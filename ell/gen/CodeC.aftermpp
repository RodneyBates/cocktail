(*
 *	ell2 - a redesign of ell
 *
 *	$RCSfile: CodeC.ESTRA,v $
 *	
 *	purpose:	generation of C code
 *
 *	$Author: grosch $
 *	$Date: 1992/10/15 18:26:55 $
 *)















TRANSFORMATION	CodeC

GLOBAL	{
FROM ArgCheck	IMPORT	DEF, IMP, LINE, SourceFileName;
FROM Checks	IMPORT	CheckWriteOpen, CheckOpenOutput;
FROM Codes	IMPORT	cNoIndex, vMaxRecSetIndex, vMaxSetIndex,
			Code, MaxCode, WriteIndex, WriteRecIndex,
			Term, GetSet, GetRecSet;
FROM DynArray	IMPORT	MakeArray, ReleaseArray;
FROM Errors	IMPORT	ERROR;
FROM IO		IMPORT	tFile, WriteS, WriteC, WriteI, WriteNl,
			WriteOpen, WriteClose;
FROM Idents	IMPORT	tIdent, WriteIdent, MaxIdent, GetString;
FROM Sets	IMPORT	tSet, MakeSet, ReleaseSet, Extract, IsEmpty, Assign,
			Union, Include, Exclude, IsElement, Minimum, Maximum;
FROM StringMem	IMPORT	WriteString;
FROM SYSTEM	IMPORT	TSIZE, ADR;
FROM System	IMPORT	OpenOutput, Write, Close;
FROM Scanner	IMPORT	NoIdent, Epsilon;
FROM Types	IMPORT	IsTerm, IsNonterm, Terminals;
FROM Strings	IMPORT	tString, Char, Length, ArrayToString, Concatenate, Append,
			StringToArray;
FROM Tree	IMPORT	ScannerName, ParserName;

IMPORT Idents;

CONST
  cBitsPerChar		= 8;
  cBitsPerLong		= 32;
  cDefinition		= '.h';
  cImplementation	= '.c';

VAR
  file		: tFile;
  SpaCo, Label	: INTEGER;
  vExport	: BOOLEAN;
  InDefault	: BOOLEAN;
  lSections	: Tree.tTree;
  PathS, String	: tString;
  PathA		: ARRAY [0..128] OF CHAR;


PROCEDURE Prefix;
  BEGIN
    IF ScannerName # Idents.NoIdent THEN
Spaces;WriteIdent (file, ScannerName);WriteS (file, '_');
    END;
  END Prefix;

PROCEDURE Spaces;
  VAR i: INTEGER;
  BEGIN FOR i := 1 TO SpaCo DO WriteS (file, '  '); END; END Spaces;

PROCEDURE CodeIsElement (index: INTEGER; set: tSet);
  VAR
    todo: tSet;
    id: tIdent;
    sl: INTEGER;
  BEGIN
    IF index = cNoIndex THEN
      MakeSet (todo, MaxIdent ());
      Assign (todo, set);
      Exclude (todo, Epsilon);
      IF NOT IsEmpty (todo) THEN
	LOOP
	  id := Extract (todo);
	  WriteS (file, '(xxToken == ');
	  WriteI (file, Code (id), 0);
	  WriteS (file, ' /* ');
	  WriteIdent (file, id);
	  WriteS (file, ' */)');
	  IF IsEmpty (todo) THEN EXIT END;
	  WriteS (file, ' || ');
	END;
      END;
      ReleaseSet (todo);
    ELSE
      sl := index DIV cBitsPerChar;
      WriteS (file, '(xxVerticalSet [xxToken');
      IF sl # 0 THEN
	WriteS (file, ' + ');
	WriteI (file, sl * (MaxCode () + 1), 0);
      END;
      WriteS (file, '] & 1 << ');
      WriteI (file, index MOD cBitsPerChar, 0);
      WriteS (file, ' /* ');
      WriteIndex (file, index);
      WriteS (file, ' */)');
    END;
  END CodeIsElement;

PROCEDURE CodeRecovery (recover, expect: INTEGER);
  BEGIN
    IF expect = cNoIndex THEN
WriteS (file, 'xxUnexpected (');WriteI (file, recover, 0);WriteS (file, ', xxGlobalRecoverySet); /* ');WriteRecIndex (file, recover);WriteS (file, ' */');WriteNl (file);
    ELSE
Spaces;WriteS (file, 'xxExpected (');WriteI (file, expect, 0);WriteS (file, ', ');WriteI (file, recover, 0);WriteS (file, ', xxGlobalRecoverySet); /* ');WriteRecIndex (file, expect);WriteS (file, ' / ');WriteRecIndex (file, recover);WriteS (file, ' */');WriteNl (file);
    END;
  END CodeRecovery;

PROCEDURE WriteLabels (set: tSet);
  VAR
    todo: tSet;
    id: tIdent;
  BEGIN
    MakeSet (todo, MaxIdent ());
    Assign (todo, set);
    WHILE NOT IsEmpty (todo) DO
      id := Extract (todo);
Spaces;WriteS (file, 'case ');
      WriteI (file, Code (id), 0);
      WriteS (file, ' /* ');
      WriteIdent (file, id);
      WriteS (file, ' */ :; ');
      WriteNl (file);
    END;
    ReleaseSet (todo);
  END WriteLabels;

VAR
  NumberArray: POINTER TO ARRAY [0..1000] OF INTEGER;
  NumberArraySize: LONGINT;
  MaxNumberArray: POINTER TO ARRAY [0..1000] OF INTEGER;
  MaxNumberArraySize: LONGINT;

PROCEDURE ClearArray (VAR a: ARRAY OF INTEGER);
  VAR id: tIdent;
  BEGIN
    FOR id := 0 TO MaxIdent () DO a [id] := 0; END;
  END ClearArray;

PROCEDURE WriteAttributes;
  VAR
    id: tIdent;
    i, max: INTEGER;
  BEGIN
    FOR id := 0 TO MaxIdent () DO
      max := MaxNumberArray^ [id];
      IF max > 0 THEN
	IF IsTerm (id) THEN
WriteS (file, '  ');
	  Prefix;
WriteS (file, 'tScanAttribute ');
	ELSE
WriteS (file, '  ');WriteIdent (file, ParserName);WriteS (file, '_tParsAttribute ');
	END;
	FOR i := 1 TO max - 1 DO
WriteIdent (file, id);WriteI (file, i, 0);WriteS (file, ', ');
	END;
WriteIdent (file, id);WriteI (file, max, 0);WriteS (file, ';');WriteNl (file);
      END;
    END;
  END WriteAttributes;

VAR Hex: ARRAY [0..15] OF CHAR;

PROCEDURE WriteRecSets;
  VAR
    value: INTEGER;
    set: tSet;
    no, bit, bitvalue: INTEGER;
    index: INTEGER;
  BEGIN
    MakeSet (set, MaxCode ());
    FOR index := 0 TO vMaxRecSetIndex DO
      GetRecSet (index, set);
      WriteS (file, '  {');
      FOR no := 0 TO MaxCode () DIV cBitsPerLong DO
	WriteS (file, ' 0x');
        FOR bit := 0 TO cBitsPerLong - 1 DO
	  IF bit MOD 4 = 0 THEN
	    value := 0;
	    bitvalue := 8;
	  END;
	  IF IsElement (no * cBitsPerLong + bit, set) THEN
	    INC (value, bitvalue);
	  END;
	  bitvalue := bitvalue DIV 2;
	  IF bit MOD 4 = 3 THEN
	    WriteC (file, Hex [value]);
	  END;
	END;
	WriteS (file, 'L,');
	IF no MOD 4 = 3 THEN WriteNl (file); END;
      END;
      WriteS (file, ' },');
      WriteNl (file);
    END;
    ReleaseSet (set);
  END WriteRecSets;

PROCEDURE WriteVerticalSet (no: INTEGER);
  VAR
    sets: ARRAY [0..cBitsPerChar-1] OF tSet;
    code, bit: INTEGER;
    index: INTEGER;
    value, bitvalue: INTEGER;
  BEGIN
    FOR bit := 0 TO cBitsPerChar - 1 DO
      MakeSet (sets [bit], MaxCode ());
      index := no * cBitsPerChar + bit;
      GetSet (index, sets [bit]);
    END;
    FOR code := 0 TO MaxCode () DO
      IF code MOD 8 = 0 THEN WriteNl (file); END;
      WriteS (file, ' 0x');
      FOR bit := cBitsPerChar - 1 TO 0 BY -1 DO 
	IF bit MOD 4 = 3 THEN
	  value := 0;
	  bitvalue := 8;
	END;
	IF IsElement (code, sets [bit]) THEN
	  INC (value, bitvalue);
	END;
	IF bit MOD 4 = 0 THEN
	  WriteC (file, Hex [value]);
	END;
	bitvalue := bitvalue DIV 2;
      END;
      WriteS (file, ',');
    END;
    WriteNl (file);
    FOR bit := 0 TO cBitsPerChar - 1 DO
      ReleaseSet (sets [bit]);
    END;
  END WriteVerticalSet;
}

BEGIN	{
  vExport := FALSE;
  SpaCo := 0;
  Label := 0;
  Hex [0] := '0';
  Hex [1] := '1';
  Hex [2] := '2';
  Hex [3] := '3';
  Hex [4] := '4';
  Hex [5] := '5';
  Hex [6] := '6';
  Hex [7] := '7';
  Hex [8] := '8';
  Hex [9] := '9';
  Hex [10] := 'A';
  Hex [11] := 'B';
  Hex [12] := 'C';
  Hex [13] := 'D';
  Hex [14] := 'E';
  Hex [15] := 'F';
}

GRAMMAR Tree

grammar		= 
| Grammar	(sections, tokens, rules)

sections	=
| Sections0	()
| Sections	(section, sections)

section		=
| Export	(codes)
| Global	(codes)
| Local		(codes)
| Begin		(codes)
| Close		(codes)

codes		=
| Codes0	()
| Codes		(code, codes)

code		=
| Code		()

tokens		=
| Tokens0	()
| Tokens	(token, tokens)

token		=
| Token		(id, number)

id		=
| Id		()

number		=
| Number	()

rules		=
| Rules0	()
| Rules		(rule, rules)

rule		=
| Rule		(id, codes, expr)

expr		=
| Option	(expr)
| Times		(expr)
| Plus		(expr)
| List		(body: expr, sep: expr)
| Action	(codes)
| Leaf		(id)

expr		->
alternative	=
| Alternative0	()
| Alternative	(expr, alternative)

expr		->
sequence	=
| Sequence0	()
| Sequence	(expr, sequence)


FUNCTION	CODE			/ grammar /

  grammar
		{
		IF DEF THEN CodeDef (grammar); END;
		IF IMP THEN CodeImp (grammar); END;
		}


/*
 *	generate definition of parser
 */

FUNCTION	CodeDef			/ grammar /

  Grammar	(sections, tokens, rules)
		{
		GetString	(ParserName, PathS);
		ArrayToString	(cDefinition, String);
		Concatenate	(PathS, String);
		Append		(PathS, 0C);
		StringToArray	(PathS, PathA);
		file := WriteOpen (PathA);
		CheckWriteOpen (file, PathA);

		IF ScannerName # Idents.NoIdent THEN
Spaces;WriteS (file, '# include "');WriteIdent (file, ScannerName);WriteS (file, '.h"');WriteNl (file);
		ELSE
Spaces;WriteS (file, '# include "Scanner.h"');WriteNl (file);
		END;
Spaces;WriteNl (file);
Spaces;WriteS (file, '# if defined __STDC__ | defined __cplusplus');WriteNl (file);
Spaces;WriteS (file, '# define ARGS(parameters)	parameters');WriteNl (file);
Spaces;WriteS (file, '# else');WriteNl (file);
Spaces;WriteS (file, '# define ARGS(parameters)	()');WriteNl (file);
Spaces;WriteS (file, '# endif');WriteNl (file);
Spaces;WriteNl (file);
		CodeExport (sections);
		IF NOT vExport THEN	(* Default EXPORT action *)
Spaces;WriteS (file, 'typedef	');
		Prefix;
WriteS (file, 'tScanAttribute ');WriteIdent (file, ParserName);WriteS (file, '_tParsAttribute;');WriteNl (file);
		END;
Spaces;WriteNl (file);
Spaces;WriteS (file, 'extern	');WriteIdent (file, ParserName);WriteS (file, '_tParsAttribute ');WriteIdent (file, ParserName);WriteS (file, '_ParsAttribute;');WriteNl (file);
Spaces;WriteS (file, 'extern	char *	');WriteIdent (file, ParserName);WriteS (file, '_TokenName [];');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'extern	int	');WriteIdent (file, ParserName);WriteS (file, '		();');WriteNl (file);
Spaces;WriteS (file, 'extern	void	Close');WriteIdent (file, ParserName);WriteS (file, '	();');WriteNl (file);
		WriteClose (file);
		}


/*
 *	generate implementation of parser
 */

FUNCTION	CodeImp			/ grammar /

  Grammar	(sections, tokens, Rules (Rule (Id (), codes, expr), rules))
		DECLARE	{ VAR
		  i	: INTEGER;
		  j	: CARDINAL;
		  set	: tSet;
		  id	: tIdent;
		  s	: tString;
		  c	: CHAR;
		}
		{
		GetString	(ParserName, PathS);
		ArrayToString	(cImplementation, String);
		Concatenate	(PathS, String);
		Append		(PathS, 0C);
		StringToArray	(PathS, PathA);
		file := WriteOpen (PathA);
		CheckWriteOpen (file, PathA);

Spaces;WriteS (file, '# include	"');WriteIdent (file, ParserName);WriteS (file, '.h"');WriteNl (file);
Spaces;WriteS (file, '# include	"Errors.h"');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, '# define	xxbool	char');WriteNl (file);
Spaces;WriteS (file, '# define	xxtrue	1');WriteNl (file);
Spaces;WriteS (file, '# define	xxfalse	0');WriteNl (file);
Spaces;WriteS (file, '# define	xxEof	0');WriteNl (file);
Spaces;WriteNl (file);
		CodeGlobal (sections);
		lSections := sections;

Spaces;WriteS (file, 'typedef struct xxsUnion {');WriteNl (file);
Spaces;WriteS (file, '	  struct xxsUnion *	xxGlobalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, '	  unsigned short	xxLocalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, '	} xxtUnion, * xxtUnionPtr;');WriteNl (file);
Spaces;WriteS (file, 'typedef	long	xxtSet [');WriteI (file, MaxCode () DIV cBitsPerLong + 1, 0);WriteS (file, '];');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteIdent (file, ParserName);WriteS (file, '_tParsAttribute	');WriteIdent (file, ParserName);WriteS (file, '_ParsAttribute;');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'static short	xxToken;');WriteNl (file);
Spaces;WriteS (file, 'static int	xxErrorCount;');WriteNl (file);
Spaces;WriteS (file, 'static xxbool	xxIsInitialized = xxfalse, xxIsRepairMode = xxfalse;');WriteNl (file);
		IF vMaxRecSetIndex = cNoIndex THEN
Spaces;WriteS (file, 'static long	xxHorizontalSet [] = { 0 };');WriteNl (file);
		ELSE
Spaces;WriteS (file, 'static long	xxHorizontalSet [] [');WriteI (file, MaxCode () DIV cBitsPerLong + 1, 0);WriteS (file, '] = {');WriteNl (file);
		WriteRecSets;
Spaces;WriteS (file, '};');WriteNl (file);
		END;
Spaces;WriteS (file, 'static unsigned char xxVerticalSet [] = {');
		FOR i := 0 TO vMaxSetIndex DIV cBitsPerChar DO
		  WriteVerticalSet (i);
		END;
WriteS (file, '};');WriteNl (file);

Spaces;WriteS (file, 'char *		');WriteIdent (file, ParserName);WriteS (file, '_TokenName [] = {');WriteNl (file);
		FOR i := 0 TO MaxCode () DO
		  id := Term (i);
		  IF id # NoIdent THEN
		    GetString (id, s);
Spaces;WriteS (file, '"');
		    c := Char (s, 1);
		    IF (c = '"') OR (c = "'") THEN
		      FOR j := 2 TO Length (s) - 1 DO
		        c := Char (s, j);
		        IF (c = '\') OR (c = '"') THEN WriteC (file, '\'); END;
		        WriteC (file, c);
		      END;
		    ELSE
		      FOR j := 1 TO Length (s) DO
		        c := Char (s, j);
		        IF (c = '\') OR (c = '"') THEN WriteC (file, '\'); END;
		        WriteC (file, c);
		      END;
		    END;
WriteS (file, '",');WriteNl (file);
		  ELSE
Spaces;WriteS (file, '0,');WriteNl (file);
		  END;
		END;
Spaces;WriteS (file, '};');WriteNl (file);
Spaces;WriteNl (file);
		CodeForward (Rules);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'static void Begin');WriteIdent (file, ParserName);WriteS (file, ' ()');WriteNl (file);
Spaces;WriteS (file, '{');WriteNl (file);
INC (SpaCo);
Spaces;WriteS (file, 'if (xxIsInitialized) return;');WriteNl (file);
		CodeBegin (sections);
DEC (SpaCo);
Spaces;WriteS (file, '}');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'void Close');WriteIdent (file, ParserName);WriteS (file, ' ()');WriteNl (file);
Spaces;WriteS (file, '{');WriteNl (file);
		CodeClose (sections);
Spaces;WriteS (file, '}');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'static xxbool xxIsElement');WriteNl (file);
Spaces;WriteS (file, '# if defined __STDC__ | defined __cplusplus');WriteNl (file);
Spaces;WriteS (file, '(xxtSet xySet, short xxElement)');WriteNl (file);
Spaces;WriteS (file, '# else');WriteNl (file);
Spaces;WriteS (file, '(xySet, xxElement) xxtSet xySet; short xxElement;');WriteNl (file);
Spaces;WriteS (file, '# endif');WriteNl (file);
Spaces;WriteS (file, '{ return xySet [xxElement / ');WriteI (file, cBitsPerLong, 0);WriteS (file, '] << xxElement % ');WriteI (file, cBitsPerLong, 0);WriteS (file, ' < 0; }');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'static void xxSkipTokens');WriteNl (file);
Spaces;WriteS (file, '# if defined __STDC__ | defined __cplusplus');WriteNl (file);
Spaces;WriteS (file, '(unsigned short xxLocalRecoverySet, xxtUnionPtr xxGlobalRecoverySet)');WriteNl (file);
Spaces;WriteS (file, '# else');WriteNl (file);
Spaces;WriteS (file, '(xxLocalRecoverySet, xxGlobalRecoverySet)');WriteNl (file);
Spaces;WriteS (file, 'unsigned short	xxLocalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, 'xxtUnionPtr	xxGlobalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, '# endif');WriteNl (file);
Spaces;WriteS (file, '{');WriteNl (file);
Spaces;WriteS (file, '  xxbool xxTokensSkipped = xxfalse;');WriteNl (file);
Spaces;WriteS (file, '  xxtSet xxRecoverySet;');WriteNl (file);
		FOR i := 0 TO MaxCode () DIV cBitsPerLong DO
Spaces;WriteS (file, '  xxRecoverySet [');WriteI (file, i, 0);WriteS (file, '] = xxHorizontalSet [xxLocalRecoverySet] [');WriteI (file, i, 0);WriteS (file, '];');WriteNl (file);
		END;
Spaces;WriteS (file, '  xxRecoverySet [0] |= (unsigned long) 0x80000000L; /* INCL (xxRecoverySet [0], xxEof); */');WriteNl (file);
Spaces;WriteS (file, '  while (xxGlobalRecoverySet != (xxtUnionPtr) 0L) {');WriteNl (file);
		FOR i := 0 TO MaxCode () DIV cBitsPerLong DO
Spaces;WriteS (file, '    xxRecoverySet [');WriteI (file, i, 0);WriteS (file, '] |= xxHorizontalSet [xxGlobalRecoverySet->xxLocalRecoverySet] [');WriteI (file, i, 0);WriteS (file, '];');WriteNl (file);
		END;
Spaces;WriteS (file, '    xxGlobalRecoverySet = xxGlobalRecoverySet->xxGlobalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, '  }');WriteNl (file);
Spaces;WriteS (file, '  while (! xxIsElement (xxRecoverySet, xxToken)) {');WriteNl (file);
Spaces;WriteS (file, '    xxToken = ');
		Prefix;
WriteS (file, 'GetToken (); xxTokensSkipped = xxtrue;');WriteNl (file);
Spaces;WriteS (file, '  }');WriteNl (file);
Spaces;WriteS (file, '  if (xxTokensSkipped) ErrorMessage (xxRestartPoint, xxInformation, ');
		Prefix;
WriteS (file, 'Attribute.Position);');WriteNl (file);
Spaces;WriteS (file, '  xxIsRepairMode = xxtrue;');WriteNl (file);
Spaces;WriteS (file, '}');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'static void xxUnexpected');WriteNl (file);
Spaces;WriteS (file, '# if defined __STDC__ | defined __cplusplus');WriteNl (file);
Spaces;WriteS (file, '(unsigned short xxLocalRecoverySet, xxtUnionPtr xxGlobalRecoverySet)');WriteNl (file);
Spaces;WriteS (file, '# else');WriteNl (file);
Spaces;WriteS (file, '(xxLocalRecoverySet, xxGlobalRecoverySet)');WriteNl (file);
Spaces;WriteS (file, 'unsigned short	xxLocalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, 'xxtUnionPtr	xxGlobalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, '# endif');WriteNl (file);
Spaces;WriteS (file, '{');WriteNl (file);
Spaces;WriteS (file, '  if (! xxIsRepairMode) {');WriteNl (file);
Spaces;WriteS (file, '    xxErrorCount ++;');WriteNl (file);
Spaces;WriteS (file, '    ErrorMessage (xxSyntaxError, xxError, ');
		Prefix;
WriteS (file, 'Attribute.Position);');WriteNl (file);
Spaces;WriteS (file, '    xxSkipTokens (xxLocalRecoverySet, xxGlobalRecoverySet);');WriteNl (file);
Spaces;WriteS (file, '  }');WriteNl (file);
Spaces;WriteS (file, '}');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'static void xxExpected');WriteNl (file);
Spaces;WriteS (file, '# if defined __STDC__ | defined __cplusplus');WriteNl (file);
Spaces;WriteS (file, '(unsigned short xxExpectedSet, unsigned short xxLocalRecoverySet, xxtUnionPtr xxGlobalRecoverySet)');WriteNl (file);
Spaces;WriteS (file, '# else');WriteNl (file);
Spaces;WriteS (file, '(xxExpectedSet, xxLocalRecoverySet, xxGlobalRecoverySet)');WriteNl (file);
Spaces;WriteS (file, 'unsigned short	xxExpectedSet, xxLocalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, 'xxtUnionPtr	xxGlobalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, '# endif');WriteNl (file);
Spaces;WriteS (file, '{');WriteNl (file);
Spaces;WriteS (file, '  if (! xxIsRepairMode) {');WriteNl (file);
Spaces;WriteS (file, '    short yxToken;');WriteNl (file);
Spaces;WriteS (file, '    int xxLength = 0;');WriteNl (file);
Spaces;WriteS (file, '    char xxContinueString [256];');WriteNl (file);
Spaces;WriteS (file, '    xxErrorCount ++;');WriteNl (file);
Spaces;WriteS (file, '    ErrorMessage (xxSyntaxError, xxError, ');
		Prefix;
WriteS (file, 'Attribute.Position);');WriteNl (file);

Spaces;WriteS (file, "    xxContinueString [0] = '\0';");WriteNl (file);

Spaces;WriteS (file, '    for (yxToken = 0; yxToken <= ');WriteI (file, MaxCode (), 0);WriteS (file, '; yxToken ++)');WriteNl (file);
Spaces;WriteS (file, '      if (xxIsElement (xxHorizontalSet [xxExpectedSet], yxToken)) {');WriteNl (file);
Spaces;WriteS (file, '	char * xxTokenString = ');WriteIdent (file, ParserName);WriteS (file, '_TokenName [yxToken];');WriteNl (file);
Spaces;WriteS (file, '	if ((xxLength += strlen (xxTokenString) + 1) >= 256) break;');WriteNl (file);
Spaces;WriteS (file, '	(void) strcat (xxContinueString, xxTokenString);');WriteNl (file);
Spaces;WriteS (file, '	(void) strcat (xxContinueString, " ");');WriteNl (file);
Spaces;WriteS (file, '      }');WriteNl (file);
Spaces;WriteS (file, '    ErrorMessageI (xxExpectedTokens, xxInformation, ');
		Prefix;
WriteS (file, 'Attribute.Position, xxString, xxContinueString);');WriteNl (file);
Spaces;WriteS (file, '    xxSkipTokens (xxLocalRecoverySet, xxGlobalRecoverySet);');WriteNl (file);
Spaces;WriteS (file, '  }');WriteNl (file);
Spaces;WriteS (file, '}');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'static void xxRecoveryLiteral');WriteNl (file);
Spaces;WriteS (file, '# if defined __STDC__ | defined __cplusplus');WriteNl (file);
Spaces;WriteS (file, '(unsigned short xxExpected, unsigned short xxLocalRecoverySet, xxtUnionPtr xxGlobalRecoverySet)');WriteNl (file);
Spaces;WriteS (file, '# else');WriteNl (file);
Spaces;WriteS (file, '(xxExpected, xxLocalRecoverySet, xxGlobalRecoverySet)');WriteNl (file);
Spaces;WriteS (file, 'unsigned short	xxExpected, xxLocalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, 'xxtUnionPtr	xxGlobalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, '# endif');WriteNl (file);
Spaces;WriteS (file, '{');WriteNl (file);
Spaces;WriteS (file, '  if (! xxIsRepairMode) {');WriteNl (file);
Spaces;WriteS (file, '    xxErrorCount ++;');WriteNl (file);
Spaces;WriteS (file, '    ErrorMessage (xxSyntaxError, xxError, ');
		Prefix;
WriteS (file, 'Attribute.Position);');WriteNl (file);
Spaces;WriteS (file, '    ErrorMessageI (xxExpectedTokens, xxInformation, ');
		Prefix;
WriteS (file, 'Attribute.Position, xxString, ');WriteIdent (file, ParserName);WriteS (file, '_TokenName [xxExpected]);');WriteNl (file);
Spaces;WriteS (file, '    xxSkipTokens (xxLocalRecoverySet, xxGlobalRecoverySet);');WriteNl (file);
Spaces;WriteS (file, '  }');WriteNl (file);
Spaces;WriteS (file, '  if (xxToken != xxExpected) {');WriteNl (file);
Spaces;WriteS (file, '    ErrorMessageI (xxTokenInserted, xxRepair, ');
		Prefix;
WriteS (file, 'Attribute.Position, xxString, ');WriteIdent (file, ParserName);WriteS (file, '_TokenName [xxExpected]);');WriteNl (file);
Spaces;WriteS (file, '  } else {');WriteNl (file);
Spaces;WriteS (file, '    if (xxToken != xxEof) xxToken = ');
		Prefix;
WriteS (file, 'GetToken ();');WriteNl (file);
Spaces;WriteS (file, '    xxIsRepairMode = xxfalse;');WriteNl (file);
Spaces;WriteS (file, '  }');WriteNl (file);
Spaces;WriteS (file, '}');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'static void xxRecoveryTerminal');WriteNl (file);
Spaces;WriteS (file, '# if defined __STDC__ | defined __cplusplus');WriteNl (file);
Spaces;WriteS (file, '(unsigned short xxExpected, unsigned short xxLocalRecoverySet,');WriteNl (file);
Spaces;WriteS (file, 'xxtUnionPtr xxGlobalRecoverySet, ');
		Prefix;
WriteS (file, 'tScanAttribute * xxRepairAttribute)');WriteNl (file);
Spaces;WriteS (file, '# else');WriteNl (file);
Spaces;WriteS (file, '(xxExpected, xxLocalRecoverySet, xxGlobalRecoverySet, xxRepairAttribute)');WriteNl (file);
Spaces;WriteS (file, 'unsigned short	xxExpected, xxLocalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, 'xxtUnionPtr	xxGlobalRecoverySet;');WriteNl (file);
		Prefix;
Spaces;WriteS (file, 'tScanAttribute	* xxRepairAttribute;');WriteNl (file);
Spaces;WriteS (file, '# endif');WriteNl (file);
Spaces;WriteS (file, '{');WriteNl (file);
Spaces;WriteS (file, '  if (! xxIsRepairMode) {');WriteNl (file);
Spaces;WriteS (file, '    xxErrorCount ++;');WriteNl (file);
Spaces;WriteS (file, '    ErrorMessage (xxSyntaxError, xxError, ');
		Prefix;
WriteS (file, 'Attribute.Position);');WriteNl (file);
Spaces;WriteS (file, '    ErrorMessageI (xxExpectedTokens, xxInformation, ');
		Prefix;
WriteS (file, 'Attribute.Position, xxString, ');WriteIdent (file, ParserName);WriteS (file, '_TokenName [xxExpected]);');WriteNl (file);
Spaces;WriteS (file, '    xxSkipTokens (xxLocalRecoverySet, xxGlobalRecoverySet);');WriteNl (file);
Spaces;WriteS (file, '  }');WriteNl (file);
Spaces;WriteS (file, '  if (xxToken != xxExpected) {');WriteNl (file);
Spaces;WriteS (file, '    ErrorMessageI (xxTokenInserted, xxRepair, ');
		Prefix;
WriteS (file, 'Attribute.Position, xxString, ');WriteIdent (file, ParserName);WriteS (file, '_TokenName [xxExpected]);');WriteNl (file);
Spaces;WriteS (file, '    ');
		Prefix;
WriteS (file, 'ErrorAttribute ((int) xxExpected, xxRepairAttribute);');WriteNl (file);
Spaces;WriteS (file, '  } else {');WriteNl (file);
Spaces;WriteS (file, '    * xxRepairAttribute = ');
		Prefix;
WriteS (file, 'Attribute;');WriteNl (file);
Spaces;WriteS (file, '    if (xxToken != xxEof) xxToken = ');
		Prefix;
WriteS (file, 'GetToken ();');WriteNl (file);
Spaces;WriteS (file, '    xxIsRepairMode = xxfalse;');WriteNl (file);
Spaces;WriteS (file, '  }');WriteNl (file);
Spaces;WriteS (file, '}');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'int ');WriteIdent (file, ParserName);WriteS (file, ' ()');WriteNl (file);
Spaces;WriteS (file, '{');WriteNl (file);
Spaces;WriteS (file, '  xxErrorCount = 0;');WriteNl (file);
Spaces;WriteS (file, '  Begin');WriteIdent (file, ParserName);WriteS (file, ' ();');WriteNl (file);
Spaces;WriteS (file, '  xxToken = ');
		Prefix;
WriteS (file, 'GetToken ();');WriteNl (file);
Spaces;WriteS (file, '  yy');WriteIdent (file, Id.ident);WriteS (file, ' (& ');WriteIdent (file, ParserName);WriteS (file, '_ParsAttribute, (xxtUnionPtr) 0L);');WriteNl (file);
Spaces;WriteS (file, '  if (xxToken != xxEof) xxRecoveryLiteral (xxEof, 0, (xxtUnionPtr) 0L);');WriteNl (file);
Spaces;WriteS (file, '  return xxErrorCount;');WriteNl (file);
Spaces;WriteS (file, '}');WriteNl (file);
Spaces;WriteNl (file);
		NumberArraySize := MaxIdent () + 1;
		MaxNumberArraySize := MaxIdent () + 1;
		MakeArray (NumberArray, NumberArraySize, TSIZE (INTEGER));
		MakeArray (MaxNumberArray, MaxNumberArraySize, TSIZE (INTEGER));
		CodeRules (Rules);
		ReleaseArray (NumberArray, NumberArraySize, TSIZE (INTEGER));
		ReleaseArray (MaxNumberArray, MaxNumberArraySize, TSIZE (INTEGER));

		WriteClose (file);
		}

  Grammar	(sections, tokens, Rules0 ())
		{
		ERROR ('CodeM2.ESTRA: no rules');
		}


/*
 *	generate forward declarations
 */

FUNCTION	CodeForward		/rules/
  
  Rules0	() {}

  Rules		(Rule (Id (), codes, expr), rules)
		{
Spaces;WriteS (file, 'static void yy');WriteIdent (file, Id.ident);WriteS (file, ' ARGS((');WriteIdent (file, ParserName);WriteS (file, '_tParsAttribute * ');WriteIdent (file, Id.ident);WriteS (file, '0, xxtUnionPtr xxGlobalRecoverySet));');WriteNl (file);
		CodeForward (rules);
		}

/*
 *	generate recursive descent procedure
 */

FUNCTION	CodeRules		/rules, expr/

  Rules0	() {}

  Rules		(Rule (Id (), codes, expr), rules)
		{
		ClearArray (MaxNumberArray^);
		SetNumbers (expr, TRUE);

Spaces;WriteS (file, 'static void yy');WriteIdent (file, Id.ident);WriteNl (file);
Spaces;WriteS (file, '# if defined __STDC__ | defined __cplusplus');WriteNl (file);
Spaces;WriteS (file, '(');WriteIdent (file, ParserName);WriteS (file, '_tParsAttribute * ');WriteIdent (file, Id.ident);WriteS (file, '0, xxtUnionPtr xxGlobalRecoverySet)');WriteNl (file);
Spaces;WriteS (file, '# else');WriteNl (file);
Spaces;WriteS (file, '(');WriteIdent (file, Id.ident);WriteS (file, '0, xxGlobalRecoverySet)');WriteNl (file);
Spaces;WriteIdent (file, ParserName);WriteS (file, '_tParsAttribute	* ');WriteIdent (file, Id.ident);WriteS (file, '0;');WriteNl (file);
Spaces;WriteS (file, 'xxtUnionPtr	xxGlobalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, '# endif');WriteNl (file);
Spaces;WriteS (file, '{');WriteNl (file);
INC (SpaCo);
		  WriteAttributes;
		  IF Rule.iscalling THEN
Spaces;WriteS (file, 'xxtUnion xxUnion;');WriteNl (file);
		  END;
		  CodeLocal (lSections);
		  CodeCodes (codes);
		  IF Rule.iscalling THEN
Spaces;WriteS (file, 'xxUnion.xxGlobalRecoverySet = xxGlobalRecoverySet;');WriteNl (file);
		  END;
		  CodeRules (expr);
DEC (SpaCo);
Spaces;WriteS (file, '}');WriteNl (file);
Spaces;WriteNl (file);
		CodeRules (rules);
		}

  Option	(expr)
		{
Spaces;WriteS (file, 'for (;;) {');WriteNl (file);
INC (SpaCo);
Spaces;WriteS (file, 'if (');
		    CodeIsElement (Option.index, expr.first);
WriteS (file, ') {');WriteNl (file);
INC (SpaCo);
		    InDefault := FALSE;
		    CodeRules (expr);
Spaces;WriteS (file, 'break;');WriteNl (file);
DEC (SpaCo);
Spaces;WriteS (file, '} else if (');
		    CodeIsElement (Option.followindex, Option.follow);
WriteS (file, ' || xxIsRepairMode) break;');WriteNl (file);
		  CodeRecovery (Option.recindex, Option.expindex);
DEC (SpaCo);
Spaces;WriteS (file, '}');WriteNl (file);
		}

  Times		(expr)
		{
Spaces;WriteS (file, 'for (;;) {');WriteNl (file);
INC (SpaCo);
Spaces;WriteS (file, 'if (');
		      CodeIsElement (Times.index, expr.first);
WriteS (file, ') {');WriteNl (file);
INC (SpaCo);
		    InDefault := FALSE;
		    CodeRules (expr);
DEC (SpaCo);
Spaces;WriteS (file, '} else if (');
		    CodeIsElement (Times.followindex, Times.follow);
WriteS (file, ' || xxIsRepairMode) break;');WriteNl (file);
Spaces;WriteS (file, 'else');WriteNl (file);
INC (SpaCo);
		    CodeRecovery (Times.recindex, Times.expindex);
DEC (SpaCo);
DEC (SpaCo);
Spaces;WriteS (file, '}');WriteNl (file);
		}

  Plus		(expr)
		{
Spaces;WriteS (file, 'for (;;) {');WriteNl (file);
INC (SpaCo);
		  CodeRules (expr);
Spaces;WriteS (file, 'if (! (');
		       CodeIsElement (Plus.index, expr.first);
WriteS (file, ')) {');WriteNl (file);
INC (SpaCo);
Spaces;WriteS (file, 'if (');
		      CodeIsElement (Plus.followindex, Plus.follow);
WriteS (file, ') break;');WriteNl (file);
		    CodeRecovery (Plus.recindex, Plus.expindex);
Spaces;WriteS (file, 'if (! (');
		      CodeIsElement (Plus.index, Plus.first);
WriteS (file, ')) break;');WriteNl (file);
DEC (SpaCo);
Spaces;WriteS (file, '}');WriteNl (file);
DEC (SpaCo);
Spaces;WriteS (file, '}');WriteNl (file);
		}

  List		(body: expr, sep: expr)
		{
Spaces;WriteS (file, 'for (;;) {');WriteNl (file);
INC (SpaCo);
		  CodeRules (body);
Spaces;WriteS (file, 'if (! (');
		    CodeIsElement (sep.index, sep.first);
WriteS (file, ')) {');WriteNl (file);
INC (SpaCo);
Spaces;WriteS (file, 'if (');
		      CodeIsElement (List.followindex, List.follow);
WriteS (file, ') break;');WriteNl (file);
		    CodeRecovery (List.recindex, List.expindex);
Spaces;WriteS (file, 'if (! (');
		      CodeIsElement (sep.index, sep.first);
WriteS (file, ' || ');
		      CodeIsElement (List.index, List.first);
WriteS (file, ')) break;');WriteNl (file);
DEC (SpaCo);
Spaces;WriteS (file, '}');WriteNl (file);
		  CodeRules (sep);
DEC (SpaCo);
Spaces;WriteS (file, '}');WriteNl (file);
		}

  Action	(Codes0 ()) {}

  Action	(codes) { CodeCodes (codes); }

  Leaf		(Id ())
		CONDITION	{ IsTerm (Id.ident) & Leaf.sure & NOT Id.isstring }
		{
		IF InDefault THEN
Spaces;WriteS (file, 'if (xxToken != ');WriteI (file, Code (Id.ident), 0);WriteS (file, ' /* ');WriteIdent (file, Id.ident);WriteS (file, ' */)');WriteNl (file);
Spaces;WriteS (file, '  xxRecoveryTerminal (');WriteI (file, Code (Id.ident), 0);WriteS (file, ', ');WriteI (file, Leaf.recindex, 0);WriteS (file, ', xxGlobalRecoverySet, & ');WriteIdent (file, Id.ident);WriteI (file, Leaf.number, 0);WriteS (file, '); /* ');WriteRecIndex (file, Leaf.recindex);WriteS (file, ' */');WriteNl (file);
Spaces;WriteS (file, 'else {');WriteNl (file);
Spaces;WriteS (file, '  ');WriteIdent (file, Id.ident);WriteI (file, Leaf.number, 0);WriteS (file, ' = ');
		  Prefix;
WriteS (file, 'Attribute;');WriteNl (file);
Spaces;WriteS (file, '  xxToken = ');
		Prefix;
WriteS (file, 'GetToken (); xxIsRepairMode = xxfalse;');WriteNl (file);
Spaces;WriteS (file, '}');WriteNl (file);
		  InDefault := FALSE;
		ELSE
Spaces;WriteIdent (file, Id.ident);WriteI (file, Leaf.number, 0);WriteS (file, ' = ');
		Prefix;
WriteS (file, 'Attribute;');WriteNl (file);
Spaces;WriteS (file, 'xxToken = ');
		Prefix;
WriteS (file, 'GetToken (); xxIsRepairMode = xxfalse;');WriteNl (file);
		END;
		}

  Leaf		(Id ())
		CONDITION	{ IsTerm (Id.ident) & Leaf.sure & Id.isstring }
		{
		IF InDefault THEN
Spaces;WriteS (file, 'if (xxToken != ');WriteI (file, Code (Id.ident), 0);WriteS (file, ' /* ');WriteIdent (file, Id.ident);WriteS (file, ' */)');WriteNl (file);
Spaces;WriteS (file, '  xxRecoveryLiteral (');WriteI (file, Code (Id.ident), 0);WriteS (file, ', ');WriteI (file, Leaf.recindex, 0);WriteS (file, ', xxGlobalRecoverySet); /* ');WriteRecIndex (file, Leaf.recindex);WriteS (file, ' */');WriteNl (file);
Spaces;WriteS (file, 'else {');WriteNl (file);
Spaces;WriteS (file, '  xxToken = ');
		Prefix;
WriteS (file, 'GetToken (); xxIsRepairMode = xxfalse;');WriteNl (file);
Spaces;WriteS (file, '}');WriteNl (file);
		  InDefault := FALSE;
		ELSE
Spaces;WriteS (file, 'xxToken = ');
		Prefix;
WriteS (file, 'GetToken (); xxIsRepairMode = xxfalse;');WriteNl (file);
		END;
		}

  Leaf		(Id ())
		CONDITION	{ IsTerm (Id.ident) & NOT Leaf.sure & NOT Id.isstring }
		{
Spaces;WriteS (file, 'if (xxToken != ');WriteI (file, Code (Id.ident), 0);WriteS (file, ' /* ');WriteIdent (file, Id.ident);WriteS (file, ' */)');WriteNl (file);
Spaces;WriteS (file, '  xxRecoveryTerminal (');WriteI (file, Code (Id.ident), 0);WriteS (file, ', ');WriteI (file, Leaf.recindex, 0);WriteS (file, ', xxGlobalRecoverySet, & ');WriteIdent (file, Id.ident);WriteI (file, Leaf.number, 0);WriteS (file, '); /* ');WriteRecIndex (file, Leaf.recindex);WriteS (file, ' */');WriteNl (file);
Spaces;WriteS (file, 'else {');WriteNl (file);
Spaces;WriteS (file, '  ');WriteIdent (file, Id.ident);WriteI (file, Leaf.number, 0);WriteS (file, ' = ');
		Prefix;
WriteS (file, 'Attribute;');WriteNl (file);
Spaces;WriteS (file, '  xxToken = ');
		Prefix;
WriteS (file, 'GetToken (); xxIsRepairMode = xxfalse;');WriteNl (file);
Spaces;WriteS (file, '}');WriteNl (file);
		}

  Leaf		(Id ())
		CONDITION	{ IsTerm (Id.ident) & NOT Leaf.sure & Id.isstring }
		{
Spaces;WriteS (file, 'if (xxToken != ');WriteI (file, Code (Id.ident), 0);WriteS (file, ' /* ');WriteIdent (file, Id.ident);WriteS (file, ' */)');WriteNl (file);
Spaces;WriteS (file, '  xxRecoveryLiteral (');WriteI (file, Code (Id.ident), 0);WriteS (file, ', ');WriteI (file, Leaf.recindex, 0);WriteS (file, ', xxGlobalRecoverySet); /* ');WriteRecIndex (file, Leaf.recindex);WriteS (file, ' */');WriteNl (file);
Spaces;WriteS (file, 'else {');WriteNl (file);
Spaces;WriteS (file, '  xxToken = ');
		Prefix;
WriteS (file, 'GetToken (); xxIsRepairMode = xxfalse;');WriteNl (file);
Spaces;WriteS (file, '}');WriteNl (file);
		}

  Leaf		(Id ())
		CONDITION	{ IsNonterm (Id.ident) }
		{
Spaces;WriteS (file, 'xxUnion.xxLocalRecoverySet = ');WriteI (file, Leaf.recindex, 0);WriteS (file, '; yy');WriteIdent (file, Id.ident);WriteS (file, ' (& ');WriteIdent (file, Id.ident);WriteI (file, Leaf.number, 0);WriteS (file, ', & xxUnion); /* ');WriteRecIndex (file, Leaf.recindex);WriteS (file, ' */');WriteNl (file);
		}

  Sequence0	() {}

  Sequence	(expr, sequence)
		{
		CodeRules (expr);
		CodeRules (sequence);
		}

  alternative	CONDITION	{ alternative.case }
		DECLARE { VAR label: INTEGER; labels: tSet; }
		{
		MakeSet (labels, MaxIdent ());
Spaces;WriteS (file, 'for (;;) {');WriteNl (file);
INC (SpaCo);
Spaces;WriteS (file, 'switch (xxToken) {');WriteNl (file);
		  INC (Label);
		  label := Label;
		  CodeAltCase (alternative, label, labels);
Spaces;WriteS (file, '}');WriteNl (file);
DEC (SpaCo);
Spaces;WriteS (file, '}');WriteNl (file);
Spaces;WriteS (file, 'xx');WriteI (file, label, 0);WriteS (file, ':;');WriteNl (file);
		ReleaseSet (labels);
		}

  alternative	CONDITION	{ NOT alternative.case }
		{
		CodeAltIf (alternative, FALSE);
		}


FUNCTION	CodeAltCase	label: INTEGER; labels: tSet ->	/ alternative /

  Alternative0	()
		DECLARE { VAR l: CARDINAL; s: tSet; }
		{
		MakeSet (s, MaxCode ());
		FOR l := Minimum (labels) TO Maximum (labels) DO
		  IF IsElement (l, labels) THEN
		    Include (s, Code (l));
		  END;
		END;
		FOR l := Minimum (s) TO Maximum (s) DO
		  IF NOT IsElement (l, s) THEN
Spaces;WriteS (file, 'case ');WriteI (file, l, 0);WriteS (file, ':;');WriteNl (file);
		  END;
		END;
Spaces;WriteS (file, 'default:');WriteNl (file);
INC (SpaCo);
Spaces;WriteS (file, 'if (xxIsRepairMode) {');WriteNl (file);
INC (SpaCo);
		    InDefault := TRUE;
		    CodeRules (Alternative0.default);
		    InDefault := FALSE;
Spaces;WriteS (file, 'goto xx');WriteI (file, label, 0);WriteS (file, ';');WriteNl (file);
DEC (SpaCo);
Spaces;WriteS (file, '}');WriteNl (file);
		  CodeRecovery (Alternative0.recindex, Alternative0.expindex);
DEC (SpaCo);
		}

  Alternative	(expr, alternative)
		{
		WriteLabels (expr.fifo);
INC (SpaCo);
		CodeRules (expr);
Spaces;WriteS (file, 'goto xx');WriteI (file, label, 0);WriteS (file, ';');WriteNl (file);
DEC (SpaCo);
		Union (labels, expr.fifo);
		CodeAltCase (alternative, label, labels);
		}


FUNCTION	CodeAltIf	started: BOOLEAN ->	/ alternative /

  Alternative0	()
		{
Spaces;WriteS (file, '} else {');WriteNl (file);
INC (SpaCo);
		  CodeRecovery (Alternative0.recindex, Alternative0.expindex);
		  InDefault := TRUE;
		  CodeRules (Alternative0.default);
		  InDefault := FALSE;
DEC (SpaCo);
Spaces;WriteS (file, '}');WriteNl (file);
		}

  Alternative	(expr, Alternative0 ())
		{
		IF NOT started THEN
Spaces;WriteS (file, 'if (');
	            CodeIsElement (Alternative.index, expr.first);
WriteS (file, ') {');WriteNl (file);
		ELSE
Spaces;WriteS (file, '} else {');WriteNl (file);
		END;
INC (SpaCo);
		CodeRules (expr);
DEC (SpaCo);
Spaces;WriteS (file, '}');WriteNl (file);
		}

  Alternative	(expr, alternative)
		{
		IF NOT started THEN
Spaces;WriteS (file, 'if (');
		ELSE
WriteS (file, '} else if (');
		END;
	        CodeIsElement (Alternative.index, expr.fifo);
WriteS (file, ') {');WriteNl (file);
INC (SpaCo);
		CodeRules (expr);
DEC (SpaCo);
		CodeAltIf (alternative, TRUE);
		}


/*
 *	set numbers for attribute access
 */

FUNCTION	SetNumbers	start: BOOLEAN	->	/expr/

Option		(expr)
		{
		IF start THEN ClearArray (NumberArray^); END;
		SetNumbers (expr, FALSE);
		}

Times		(expr)
		{
		IF start THEN ClearArray (NumberArray^); END;
		SetNumbers (expr, FALSE);
		}

Plus		(expr)
		{
		IF start THEN ClearArray (NumberArray^); END;
		SetNumbers (expr, FALSE);
		}

List		(body: expr, sep: expr)
		{
		IF start THEN ClearArray (NumberArray^); END;
		SetNumbers (body, FALSE);
		SetNumbers (sep, FALSE);
		}

Action		(codes) {}

Sequence0	() {}

Sequence	(expr, sequence)
		{
		IF start THEN ClearArray (NumberArray^); END;
		SetNumbers (expr, FALSE);
		SetNumbers (sequence, FALSE);
		}

Alternative0	() { }

Alternative	(expr, alternative)
		{
		IF start THEN ClearArray (NumberArray^); END;
		SetNumbers (expr, FALSE);
		SetNumbers (alternative, start);
		}

Leaf		(Id ())
		CONDITION	{ Id.isstring }
		{
		Leaf.number := 0;
		}

Leaf		(Id ())
		CONDITION	{ NOT Id.isstring }
		{
		IF start THEN ClearArray (NumberArray^); END;
		Leaf.number := NumberArray^ [Id.ident] + 1;
		NumberArray^ [Id.ident] := Leaf.number;
		IF Leaf.number > MaxNumberArray^ [Id.ident] THEN
		  MaxNumberArray^ [Id.ident] := Leaf.number;
		END;
		}


/*
 *		common functions
 */

FUNCTION	CodeExport		/ sections /


  Sections	(Export (codes), sections)
		{
		vExport := TRUE;
		CodeCodes (codes);
		CodeExport (sections);
		}

  Sections	(section, sections)
		CONDITION { section^.Kind # Tree.Export }
		{
		CodeExport (sections);
		}

  Sections0	() {}


FUNCTION	CodeGlobal		/ sections /


  Sections	(Global (codes), sections)
		{
		CodeCodes (codes);
		CodeGlobal (sections);
		}

  Sections	(section, sections)
		CONDITION { section^.Kind # Tree.Global }
		{
		CodeGlobal (sections);
		}

  Sections0	() {}


FUNCTION	CodeLocal		/ sections /


  Sections	(Local (codes), sections)
		{
		CodeCodes (codes);
		CodeLocal (sections);
		}

  Sections	(section, sections)
		CONDITION { section^.Kind # Tree.Local }
		{
		CodeLocal (sections);
		}

  Sections0	() {}


FUNCTION	CodeBegin		/ sections /


  Sections	(Begin (codes), sections)
		{
		CodeCodes (codes);
		CodeBegin (sections);
		}

  Sections	(section, sections)
		CONDITION { section^.Kind # Tree.Begin }
		{
		CodeBegin (sections);
		}

  Sections0	() {}


FUNCTION	CodeClose		/ sections /


  Sections	(Close (codes), sections)
		{
		CodeCodes (codes);
		CodeClose (sections);
		}

  Sections	(section, sections)
		CONDITION { section^.Kind # Tree.Close }
		{
		CodeClose (sections);
		}

  Sections0	() {}


FUNCTION	CodeCodes		/ codes /

  Codes		(Code (), codes)
		{

		IF LINE THEN
WriteS (file, '# line ');WriteI (file, Code.pos.Line, 0);WriteS (file, ' "');WriteS (file, SourceFileName);WriteS (file, '"');WriteNl (file);
		ELSE
WriteS (file, '/* line ');WriteI (file, Code.pos.Line, 0);WriteS (file, ' "');WriteS (file, SourceFileName);WriteS (file, '" */');WriteNl (file);
		END;
		WriteString (file, Code.ref);
		CodeCodes2 (codes);
WriteNl (file);

		}

  Codes0	() {}


FUNCTION	CodeCodes2		/ codes /

  Codes		(Code (), codes)
		{
		WriteString (file, Code.ref);
		CodeCodes2 (codes);
		}

  Codes0	() {}
