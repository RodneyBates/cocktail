(*
 *	"CodeC.mi"
 *	generated with estra/8906
 *	from "CodeC.aftermpp"
 *
 *	estra 
 *	was written by Bertram Vielsack in june 1989
 *
 *)

IMPLEMENTATION MODULE CodeC;

IMPORT SYSTEM, IO, Memory, System, Tree;

    (* line 28 CodeC.aftermpp *)

FROM ArgCheck	IMPORT	DEF, IMP, LINE, SourceFileName;
FROM Checks	IMPORT	CheckWriteOpen, CheckOpenOutput;
FROM Codes	IMPORT	cNoIndex, vMaxRecSetIndex, vMaxSetIndex,
			Code, MaxCode, WriteIndex, WriteRecIndex,
			Term, GetSet, GetRecSet;
FROM DynArray	IMPORT	MakeArray, ReleaseArray;
FROM Errors	IMPORT	ERROR;
FROM IO		IMPORT	tFile, WriteS, WriteC, WriteI, WriteNl,
			WriteOpen, WriteClose;
FROM Idents	IMPORT	tIdent, WriteIdent, MaxIdent, GetString;
FROM Sets	IMPORT	tSet, MakeSet, ReleaseSet, Extract, IsEmpty, Assign,
			Union, Include, Exclude, IsElement, Minimum, Maximum;
FROM StringMem	IMPORT	WriteString;
FROM SYSTEM	IMPORT	TSIZE, ADR;
FROM System	IMPORT	OpenOutput, Write, Close;
FROM Scanner	IMPORT	NoIdent, Epsilon;
FROM Types	IMPORT	IsTerm, IsNonterm, Terminals;
FROM Strings	IMPORT	tString, Char, Length, ArrayToString, Concatenate, Append,
			StringToArray;
FROM Tree	IMPORT	ScannerName, ParserName;

IMPORT Idents;

CONST
  cBitsPerChar		= 8;
  cBitsPerLong		= 32;
  cDefinition		= '.h';
  cImplementation	= '.c';

VAR
  file		: tFile;
  SpaCo, Label	: INTEGER;
  vExport	: BOOLEAN;
  InDefault	: BOOLEAN;
  lSections	: Tree.tTree;
  PathS, String	: tString;
  PathA		: ARRAY [0..128] OF CHAR;


PROCEDURE Prefix;
  BEGIN
    IF ScannerName # Idents.NoIdent THEN
Spaces;WriteIdent (file, ScannerName);WriteS (file, '_');
    END;
  END Prefix;

PROCEDURE Spaces;
  VAR i: INTEGER;
  BEGIN FOR i := 1 TO SpaCo DO WriteS (file, '  '); END; END Spaces;

PROCEDURE CodeIsElement (index: INTEGER; set: tSet);
  VAR
    todo: tSet;
    id: tIdent;
    sl: INTEGER;
  BEGIN
    IF index = cNoIndex THEN
      MakeSet (todo, MaxIdent ());
      Assign (todo, set);
      Exclude (todo, Epsilon);
      IF NOT IsEmpty (todo) THEN
	LOOP
	  id := Extract (todo);
	  WriteS (file, '(xxToken == ');
	  WriteI (file, Code (id), 0);
	  WriteS (file, ' /* ');
	  WriteIdent (file, id);
	  WriteS (file, ' */)');
	  IF IsEmpty (todo) THEN EXIT END;
	  WriteS (file, ' || ');
	END;
      END;
      ReleaseSet (todo);
    ELSE
      sl := index DIV cBitsPerChar;
      WriteS (file, '(xxVerticalSet [xxToken');
      IF sl # 0 THEN
	WriteS (file, ' + ');
	WriteI (file, sl * (MaxCode () + 1), 0);
      END;
      WriteS (file, '] & 1 << ');
      WriteI (file, index MOD cBitsPerChar, 0);
      WriteS (file, ' /* ');
      WriteIndex (file, index);
      WriteS (file, ' */)');
    END;
  END CodeIsElement;

PROCEDURE CodeRecovery (recover, expect: INTEGER);
  BEGIN
    IF expect = cNoIndex THEN
WriteS (file, 'xxUnexpected (');WriteI (file, recover, 0);WriteS (file, ', xxGlobalRecoverySet); /* ');WriteRecIndex (file, recover);WriteS (file, ' */');WriteNl (file);
    ELSE
Spaces;WriteS (file, 'xxExpected (');WriteI (file, expect, 0);WriteS (file, ', ');WriteI (file, recover, 0);WriteS (file, ', xxGlobalRecoverySet); /* ');WriteRecIndex (file, expect);WriteS (file, ' / ');WriteRecIndex (file, recover);WriteS (file, ' */');WriteNl (file);
    END;
  END CodeRecovery;

PROCEDURE WriteLabels (set: tSet);
  VAR
    todo: tSet;
    id: tIdent;
  BEGIN
    MakeSet (todo, MaxIdent ());
    Assign (todo, set);
    WHILE NOT IsEmpty (todo) DO
      id := Extract (todo);
Spaces;WriteS (file, 'case ');
      WriteI (file, Code (id), 0);
      WriteS (file, ' /* ');
      WriteIdent (file, id);
      WriteS (file, ' */ :; ');
      WriteNl (file);
    END;
    ReleaseSet (todo);
  END WriteLabels;

VAR
  NumberArray: POINTER TO ARRAY [0..1000] OF INTEGER;
  NumberArraySize: LONGINT;
  MaxNumberArray: POINTER TO ARRAY [0..1000] OF INTEGER;
  MaxNumberArraySize: LONGINT;

PROCEDURE ClearArray (VAR a: ARRAY OF INTEGER);
  VAR id: tIdent;
  BEGIN
    FOR id := 0 TO MaxIdent () DO a [id] := 0; END;
  END ClearArray;

PROCEDURE WriteAttributes;
  VAR
    id: tIdent;
    i, max: INTEGER;
  BEGIN
    FOR id := 0 TO MaxIdent () DO
      max := MaxNumberArray^ [id];
      IF max > 0 THEN
	IF IsTerm (id) THEN
WriteS (file, '  ');
	  Prefix;
WriteS (file, 'tScanAttribute ');
	ELSE
WriteS (file, '  ');WriteIdent (file, ParserName);WriteS (file, '_tParsAttribute ');
	END;
	FOR i := 1 TO max - 1 DO
WriteIdent (file, id);WriteI (file, i, 0);WriteS (file, ', ');
	END;
WriteIdent (file, id);WriteI (file, max, 0);WriteS (file, ';');WriteNl (file);
      END;
    END;
  END WriteAttributes;

VAR Hex: ARRAY [0..15] OF CHAR;

PROCEDURE WriteRecSets;
  VAR
    value: INTEGER;
    set: tSet;
    no, bit, bitvalue: INTEGER;
    index: INTEGER;
  BEGIN
    MakeSet (set, MaxCode ());
    FOR index := 0 TO vMaxRecSetIndex DO
      GetRecSet (index, set);
      WriteS (file, '  {');
      FOR no := 0 TO MaxCode () DIV cBitsPerLong DO
	WriteS (file, ' 0x');
        FOR bit := 0 TO cBitsPerLong - 1 DO
	  IF bit MOD 4 = 0 THEN
	    value := 0;
	    bitvalue := 8;
	  END;
	  IF IsElement (no * cBitsPerLong + bit, set) THEN
	    INC (value, bitvalue);
	  END;
	  bitvalue := bitvalue DIV 2;
	  IF bit MOD 4 = 3 THEN
	    WriteC (file, Hex [value]);
	  END;
	END;
	WriteS (file, 'L,');
	IF no MOD 4 = 3 THEN WriteNl (file); END;
      END;
      WriteS (file, ' },');
      WriteNl (file);
    END;
    ReleaseSet (set);
  END WriteRecSets;

PROCEDURE WriteVerticalSet (no: INTEGER);
  VAR
    sets: ARRAY [0..cBitsPerChar-1] OF tSet;
    code, bit: INTEGER;
    index: INTEGER;
    value, bitvalue: INTEGER;
  BEGIN
    FOR bit := 0 TO cBitsPerChar - 1 DO
      MakeSet (sets [bit], MaxCode ());
      index := no * cBitsPerChar + bit;
      GetSet (index, sets [bit]);
    END;
    FOR code := 0 TO MaxCode () DO
      IF code MOD 8 = 0 THEN WriteNl (file); END;
      WriteS (file, ' 0x');
      FOR bit := cBitsPerChar - 1 TO 0 BY -1 DO 
	IF bit MOD 4 = 3 THEN
	  value := 0;
	  bitvalue := 8;
	END;
	IF IsElement (code, sets [bit]) THEN
	  INC (value, bitvalue);
	END;
	IF bit MOD 4 = 0 THEN
	  WriteC (file, Hex [value]);
	END;
	bitvalue := bitvalue DIV 2;
      END;
      WriteS (file, ',');
    END;
    WriteNl (file);
    FOR bit := 0 TO cBitsPerChar - 1 DO
      ReleaseSet (sets [bit]);
    END;
  END WriteVerticalSet;


CONST
  yyInfinite = 715827882;

  yyBitsPerBitset = 32;
  yySetSize = 58;
  yyMaxIndex = 32;
  yyCombSize = 303;      
  yyStartState = 0;

  yyPoolSize = 10240;

TYPE
  yytBlockPtr = POINTER TO yytBlock;
  yytBlock =
  RECORD
    Successor: yytBlockPtr;
    Block: ARRAY [1..yyPoolSize] OF CHAR;
  END;

  yyStateType = INTEGER;
  yySetType = ARRAY [0..yySetSize DIV yyBitsPerBitset] OF BITSET;
  yySetsType = ARRAY [0..yyMaxIndex] OF yySetType;
  yyCombType = ARRAY [0..yyCombSize] OF yyStateType;

  yyPCODE = PROCEDURE (Tree.tTree);
  yyPCodeDef = PROCEDURE (Tree.tTree);
  yyPCodeImp = PROCEDURE (Tree.tTree);
  yyPCodeForward = PROCEDURE (Tree.tTree);
  yyPCodeRules = PROCEDURE (Tree.tTree);
  yyPCodeAltCase = PROCEDURE (Tree.tTree, INTEGER, tSet);
  yyPCodeAltIf = PROCEDURE (Tree.tTree, BOOLEAN);
  yyPSetNumbers = PROCEDURE (Tree.tTree, BOOLEAN);
  yyPCodeExport = PROCEDURE (Tree.tTree);
  yyPCodeGlobal = PROCEDURE (Tree.tTree);
  yyPCodeLocal = PROCEDURE (Tree.tTree);
  yyPCodeBegin = PROCEDURE (Tree.tTree);
  yyPCodeClose = PROCEDURE (Tree.tTree);
  yyPCodeCodes = PROCEDURE (Tree.tTree);
  yyPCodeCodes2 = PROCEDURE (Tree.tTree);
  
  yyInfoPtr  = POINTER TO yyInfoType;
  yyInfoType =
    RECORD
      CODE: RECORD Cost: INTEGER; Proc: yyPCODE; END;
      CodeDef: RECORD Cost: INTEGER; Proc: yyPCodeDef; END;
      CodeImp: RECORD Cost: INTEGER; Proc: yyPCodeImp; END;
      CodeForward: RECORD Cost: INTEGER; Proc: yyPCodeForward; END;
      CodeRules: RECORD Cost: INTEGER; Proc: yyPCodeRules; END;
      CodeAltCase: RECORD Cost: INTEGER; Proc: yyPCodeAltCase; END;
      CodeAltIf: RECORD Cost: INTEGER; Proc: yyPCodeAltIf; END;
      SetNumbers: RECORD Cost: INTEGER; Proc: yyPSetNumbers; END;
      CodeExport: RECORD Cost: INTEGER; Proc: yyPCodeExport; END;
      CodeGlobal: RECORD Cost: INTEGER; Proc: yyPCodeGlobal; END;
      CodeLocal: RECORD Cost: INTEGER; Proc: yyPCodeLocal; END;
      CodeBegin: RECORD Cost: INTEGER; Proc: yyPCodeBegin; END;
      CodeClose: RECORD Cost: INTEGER; Proc: yyPCodeClose; END;
      CodeCodes: RECORD Cost: INTEGER; Proc: yyPCodeCodes; END;
      CodeCodes2: RECORD Cost: INTEGER; Proc: yyPCodeCodes2; END;
    END;

VAR
  yySets: yySetsType;
  yyComb: yyCombType;
  yyInfo: yyInfoType;
  yyMatch: ARRAY [0..58] OF BOOLEAN;
  yyBlockList: yytBlockPtr;
  yyPoolFreePtr, yyPoolEndPtr: SYSTEM.ADDRESS;

PROCEDURE yyAlloc (): SYSTEM.ADDRESS;
VAR BlockPtr: yytBlockPtr;
BEGIN
  IF LONGINT (yyPoolEndPtr - yyPoolFreePtr) < SYSTEM.TSIZE (yyInfoType) THEN
    BlockPtr  := yyBlockList;
    yyBlockList  := Memory.Alloc (SYSTEM.TSIZE (yytBlock));
    yyBlockList^.Successor := BlockPtr;
    yyPoolFreePtr := SYSTEM.ADR (yyBlockList^.Block);
    yyPoolEndPtr  := yyPoolFreePtr + yyPoolSize;
  END;
  INC (yyPoolFreePtr, SYSTEM.ADDRESS (SYSTEM.TSIZE (yyInfoType)));
  RETURN yyPoolFreePtr - SYSTEM.ADDRESS (SYSTEM.TSIZE (yyInfoType));
END yyAlloc;

PROCEDURE yyReleaseHeap;
VAR BlockPtr: yytBlockPtr;
BEGIN
  WHILE yyBlockList # NIL DO
    BlockPtr:= yyBlockList;
    yyBlockList:= yyBlockList^.Successor;
    Memory.Free (SYSTEM.TSIZE (yytBlock), BlockPtr);
  END;
  yyPoolFreePtr:= NIL;
  yyPoolEndPtr:= NIL;
END yyReleaseHeap;

PROCEDURE CODE (yyt: Tree.tTree);
VAR InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyInfoPtr (yyt^.yyHead.yyEstraInfo);
  InfoPtr^.CODE.Proc (yyt);
END CODE;

PROCEDURE CodeDef (yyt: Tree.tTree);
VAR InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyInfoPtr (yyt^.yyHead.yyEstraInfo);
  InfoPtr^.CodeDef.Proc (yyt);
END CodeDef;

PROCEDURE CodeImp (yyt: Tree.tTree);
VAR InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyInfoPtr (yyt^.yyHead.yyEstraInfo);
  InfoPtr^.CodeImp.Proc (yyt);
END CodeImp;

PROCEDURE CodeForward (yyt: Tree.tTree);
VAR InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyInfoPtr (yyt^.yyHead.yyEstraInfo);
  InfoPtr^.CodeForward.Proc (yyt);
END CodeForward;

PROCEDURE CodeRules (yyt: Tree.tTree);
VAR InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyInfoPtr (yyt^.yyHead.yyEstraInfo);
  InfoPtr^.CodeRules.Proc (yyt);
END CodeRules;

PROCEDURE CodeAltCase (yyt: Tree.tTree;label:INTEGER;labels:tSet);
VAR InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyInfoPtr (yyt^.yyHead.yyEstraInfo);
  InfoPtr^.CodeAltCase.Proc (yyt, label, labels);
END CodeAltCase;

PROCEDURE CodeAltIf (yyt: Tree.tTree;started:BOOLEAN);
VAR InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyInfoPtr (yyt^.yyHead.yyEstraInfo);
  InfoPtr^.CodeAltIf.Proc (yyt, started);
END CodeAltIf;

PROCEDURE SetNumbers (yyt: Tree.tTree;start:BOOLEAN);
VAR InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyInfoPtr (yyt^.yyHead.yyEstraInfo);
  InfoPtr^.SetNumbers.Proc (yyt, start);
END SetNumbers;

PROCEDURE CodeExport (yyt: Tree.tTree);
VAR InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyInfoPtr (yyt^.yyHead.yyEstraInfo);
  InfoPtr^.CodeExport.Proc (yyt);
END CodeExport;

PROCEDURE CodeGlobal (yyt: Tree.tTree);
VAR InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyInfoPtr (yyt^.yyHead.yyEstraInfo);
  InfoPtr^.CodeGlobal.Proc (yyt);
END CodeGlobal;

PROCEDURE CodeLocal (yyt: Tree.tTree);
VAR InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyInfoPtr (yyt^.yyHead.yyEstraInfo);
  InfoPtr^.CodeLocal.Proc (yyt);
END CodeLocal;

PROCEDURE CodeBegin (yyt: Tree.tTree);
VAR InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyInfoPtr (yyt^.yyHead.yyEstraInfo);
  InfoPtr^.CodeBegin.Proc (yyt);
END CodeBegin;

PROCEDURE CodeClose (yyt: Tree.tTree);
VAR InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyInfoPtr (yyt^.yyHead.yyEstraInfo);
  InfoPtr^.CodeClose.Proc (yyt);
END CodeClose;

PROCEDURE CodeCodes (yyt: Tree.tTree);
VAR InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyInfoPtr (yyt^.yyHead.yyEstraInfo);
  InfoPtr^.CodeCodes.Proc (yyt);
END CodeCodes;

PROCEDURE CodeCodes2 (yyt: Tree.tTree);
VAR InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyInfoPtr (yyt^.yyHead.yyEstraInfo);
  InfoPtr^.CodeCodes2.Proc (yyt);
END CodeCodes2;

PROCEDURE yyECODE (yyt: Tree.tTree);
BEGIN
  IO.WriteS (IO.StdError, 'Function CODE is not defined for this tree');
  IO.WriteNl (IO.StdError); IO.CloseIO; HALT;
END yyECODE;

PROCEDURE yyECodeDef (yyt: Tree.tTree);
BEGIN
  IO.WriteS (IO.StdError, 'Function CodeDef is not defined for this tree');
  IO.WriteNl (IO.StdError); IO.CloseIO; HALT;
END yyECodeDef;

PROCEDURE yyECodeImp (yyt: Tree.tTree);
BEGIN
  IO.WriteS (IO.StdError, 'Function CodeImp is not defined for this tree');
  IO.WriteNl (IO.StdError); IO.CloseIO; HALT;
END yyECodeImp;

PROCEDURE yyECodeForward (yyt: Tree.tTree);
BEGIN
  IO.WriteS (IO.StdError, 'Function CodeForward is not defined for this tree');
  IO.WriteNl (IO.StdError); IO.CloseIO; HALT;
END yyECodeForward;

PROCEDURE yyECodeRules (yyt: Tree.tTree);
BEGIN
  IO.WriteS (IO.StdError, 'Function CodeRules is not defined for this tree');
  IO.WriteNl (IO.StdError); IO.CloseIO; HALT;
END yyECodeRules;

PROCEDURE yyECodeAltCase (yyt: Tree.tTree;label:INTEGER;labels:tSet);
BEGIN
  IO.WriteS (IO.StdError, 'Function CodeAltCase is not defined for this tree');
  IO.WriteNl (IO.StdError); IO.CloseIO; HALT;
END yyECodeAltCase;

PROCEDURE yyECodeAltIf (yyt: Tree.tTree;started:BOOLEAN);
BEGIN
  IO.WriteS (IO.StdError, 'Function CodeAltIf is not defined for this tree');
  IO.WriteNl (IO.StdError); IO.CloseIO; HALT;
END yyECodeAltIf;

PROCEDURE yyESetNumbers (yyt: Tree.tTree;start:BOOLEAN);
BEGIN
  IO.WriteS (IO.StdError, 'Function SetNumbers is not defined for this tree');
  IO.WriteNl (IO.StdError); IO.CloseIO; HALT;
END yyESetNumbers;

PROCEDURE yyECodeExport (yyt: Tree.tTree);
BEGIN
  IO.WriteS (IO.StdError, 'Function CodeExport is not defined for this tree');
  IO.WriteNl (IO.StdError); IO.CloseIO; HALT;
END yyECodeExport;

PROCEDURE yyECodeGlobal (yyt: Tree.tTree);
BEGIN
  IO.WriteS (IO.StdError, 'Function CodeGlobal is not defined for this tree');
  IO.WriteNl (IO.StdError); IO.CloseIO; HALT;
END yyECodeGlobal;

PROCEDURE yyECodeLocal (yyt: Tree.tTree);
BEGIN
  IO.WriteS (IO.StdError, 'Function CodeLocal is not defined for this tree');
  IO.WriteNl (IO.StdError); IO.CloseIO; HALT;
END yyECodeLocal;

PROCEDURE yyECodeBegin (yyt: Tree.tTree);
BEGIN
  IO.WriteS (IO.StdError, 'Function CodeBegin is not defined for this tree');
  IO.WriteNl (IO.StdError); IO.CloseIO; HALT;
END yyECodeBegin;

PROCEDURE yyECodeClose (yyt: Tree.tTree);
BEGIN
  IO.WriteS (IO.StdError, 'Function CodeClose is not defined for this tree');
  IO.WriteNl (IO.StdError); IO.CloseIO; HALT;
END yyECodeClose;

PROCEDURE yyECodeCodes (yyt: Tree.tTree);
BEGIN
  IO.WriteS (IO.StdError, 'Function CodeCodes is not defined for this tree');
  IO.WriteNl (IO.StdError); IO.CloseIO; HALT;
END yyECodeCodes;

PROCEDURE yyECodeCodes2 (yyt: Tree.tTree);
BEGIN
  IO.WriteS (IO.StdError, 'Function CodeCodes2 is not defined for this tree');
  IO.WriteNl (IO.StdError); IO.CloseIO; HALT;
END yyECodeCodes2;

PROCEDURE yyF1CODE (yyt: Tree.tTree);

BEGIN    (* line 341 CodeC.aftermpp *)

		IF DEF THEN CodeDef (yyt); END;
		IF IMP THEN CodeImp (yyt); END;
		
END yyF1CODE;

PROCEDURE yyF2CodeDef (yyt: Tree.tTree);

BEGIN    (* line 354 CodeC.aftermpp *)

		GetString	(ParserName, PathS);
		ArrayToString	(cDefinition, String);
		Concatenate	(PathS, String);
		Append		(PathS, 0C);
		StringToArray	(PathS, PathA);
		file := WriteOpen (PathA);
		CheckWriteOpen (file, PathA);

		IF ScannerName # Idents.NoIdent THEN
Spaces;WriteS (file, '# include "');WriteIdent (file, ScannerName);WriteS (file, '.h"');WriteNl (file);
		ELSE
Spaces;WriteS (file, '# include "Scanner.h"');WriteNl (file);
		END;
Spaces;WriteNl (file);
Spaces;WriteS (file, '# if defined __STDC__ | defined __cplusplus');WriteNl (file);
Spaces;WriteS (file, '# define ARGS(parameters)	parameters');WriteNl (file);
Spaces;WriteS (file, '# else');WriteNl (file);
Spaces;WriteS (file, '# define ARGS(parameters)	()');WriteNl (file);
Spaces;WriteS (file, '# endif');WriteNl (file);
Spaces;WriteNl (file);
		CodeExport (yyt^.Grammar.sections);
		IF NOT vExport THEN	(* Default EXPORT action *)
Spaces;WriteS (file, 'typedef	');
		Prefix;
WriteS (file, 'tScanAttribute ');WriteIdent (file, ParserName);WriteS (file, '_tParsAttribute;');WriteNl (file);
		END;
Spaces;WriteNl (file);
Spaces;WriteS (file, 'extern	');WriteIdent (file, ParserName);WriteS (file, '_tParsAttribute ');WriteIdent (file, ParserName);WriteS (file, '_ParsAttribute;');WriteNl (file);
Spaces;WriteS (file, 'extern	char *	');WriteIdent (file, ParserName);WriteS (file, '_TokenName [];');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'extern	int	');WriteIdent (file, ParserName);WriteS (file, '		();');WriteNl (file);
Spaces;WriteS (file, 'extern	void	Close');WriteIdent (file, ParserName);WriteS (file, '	();');WriteNl (file);
		WriteClose (file);
		
END yyF2CodeDef;

PROCEDURE yyF3CodeImp (yyt: Tree.tTree);
    (* line 398 CodeC.aftermpp *)
 VAR
		  i	: INTEGER;
		  j	: CARDINAL;
		  set	: tSet;
		  id	: tIdent;
		  s	: tString;
		  c	: CHAR;
		
BEGIN    (* line 406 CodeC.aftermpp *)

		GetString	(ParserName, PathS);
		ArrayToString	(cImplementation, String);
		Concatenate	(PathS, String);
		Append		(PathS, 0C);
		StringToArray	(PathS, PathA);
		file := WriteOpen (PathA);
		CheckWriteOpen (file, PathA);

Spaces;WriteS (file, '# include	"');WriteIdent (file, ParserName);WriteS (file, '.h"');WriteNl (file);
Spaces;WriteS (file, '# include	"Errors.h"');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, '# define	xxbool	char');WriteNl (file);
Spaces;WriteS (file, '# define	xxtrue	1');WriteNl (file);
Spaces;WriteS (file, '# define	xxfalse	0');WriteNl (file);
Spaces;WriteS (file, '# define	xxEof	0');WriteNl (file);
Spaces;WriteNl (file);
		CodeGlobal (yyt^.Grammar.sections);
		lSections := yyt^.Grammar.sections;

Spaces;WriteS (file, 'typedef struct xxsUnion {');WriteNl (file);
Spaces;WriteS (file, '	  struct xxsUnion *	xxGlobalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, '	  unsigned short	xxLocalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, '	} xxtUnion, * xxtUnionPtr;');WriteNl (file);
Spaces;WriteS (file, 'typedef	long	xxtSet [');WriteI (file, MaxCode () DIV cBitsPerLong + 1, 0);WriteS (file, '];');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteIdent (file, ParserName);WriteS (file, '_tParsAttribute	');WriteIdent (file, ParserName);WriteS (file, '_ParsAttribute;');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'static short	xxToken;');WriteNl (file);
Spaces;WriteS (file, 'static int	xxErrorCount;');WriteNl (file);
Spaces;WriteS (file, 'static xxbool	xxIsInitialized = xxfalse, xxIsRepairMode = xxfalse;');WriteNl (file);
		IF vMaxRecSetIndex = cNoIndex THEN
Spaces;WriteS (file, 'static long	xxHorizontalSet [] = { 0 };');WriteNl (file);
		ELSE
Spaces;WriteS (file, 'static long	xxHorizontalSet [] [');WriteI (file, MaxCode () DIV cBitsPerLong + 1, 0);WriteS (file, '] = {');WriteNl (file);
		WriteRecSets;
Spaces;WriteS (file, '};');WriteNl (file);
		END;
Spaces;WriteS (file, 'static unsigned char xxVerticalSet [] = {');
		FOR i := 0 TO vMaxSetIndex DIV cBitsPerChar DO
		  WriteVerticalSet (i);
		END;
WriteS (file, '};');WriteNl (file);

Spaces;WriteS (file, 'char *		');WriteIdent (file, ParserName);WriteS (file, '_TokenName [] = {');WriteNl (file);
		FOR i := 0 TO MaxCode () DO
		  id := Term (i);
		  IF id # NoIdent THEN
		    GetString (id, s);
Spaces;WriteS (file, '"');
		    c := Char (s, 1);
		    IF (c = '"') OR (c = "'") THEN
		      FOR j := 2 TO Length (s) - 1 DO
		        c := Char (s, j);
		        IF (c = '\') OR (c = '"') THEN WriteC (file, '\'); END;
		        WriteC (file, c);
		      END;
		    ELSE
		      FOR j := 1 TO Length (s) DO
		        c := Char (s, j);
		        IF (c = '\') OR (c = '"') THEN WriteC (file, '\'); END;
		        WriteC (file, c);
		      END;
		    END;
WriteS (file, '",');WriteNl (file);
		  ELSE
Spaces;WriteS (file, '0,');WriteNl (file);
		  END;
		END;
Spaces;WriteS (file, '};');WriteNl (file);
Spaces;WriteNl (file);
		CodeForward (yyt^.Grammar.rules);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'static void Begin');WriteIdent (file, ParserName);WriteS (file, ' ()');WriteNl (file);
Spaces;WriteS (file, '{');WriteNl (file);
INC (SpaCo);
Spaces;WriteS (file, 'if (xxIsInitialized) return;');WriteNl (file);
		CodeBegin (yyt^.Grammar.sections);
DEC (SpaCo);
Spaces;WriteS (file, '}');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'void Close');WriteIdent (file, ParserName);WriteS (file, ' ()');WriteNl (file);
Spaces;WriteS (file, '{');WriteNl (file);
		CodeClose (yyt^.Grammar.sections);
Spaces;WriteS (file, '}');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'static xxbool xxIsElement');WriteNl (file);
Spaces;WriteS (file, '# if defined __STDC__ | defined __cplusplus');WriteNl (file);
Spaces;WriteS (file, '(xxtSet xySet, short xxElement)');WriteNl (file);
Spaces;WriteS (file, '# else');WriteNl (file);
Spaces;WriteS (file, '(xySet, xxElement) xxtSet xySet; short xxElement;');WriteNl (file);
Spaces;WriteS (file, '# endif');WriteNl (file);
Spaces;WriteS (file, '{ return xySet [xxElement / ');WriteI (file, cBitsPerLong, 0);WriteS (file, '] << xxElement % ');WriteI (file, cBitsPerLong, 0);WriteS (file, ' < 0; }');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'static void xxSkipTokens');WriteNl (file);
Spaces;WriteS (file, '# if defined __STDC__ | defined __cplusplus');WriteNl (file);
Spaces;WriteS (file, '(unsigned short xxLocalRecoverySet, xxtUnionPtr xxGlobalRecoverySet)');WriteNl (file);
Spaces;WriteS (file, '# else');WriteNl (file);
Spaces;WriteS (file, '(xxLocalRecoverySet, xxGlobalRecoverySet)');WriteNl (file);
Spaces;WriteS (file, 'unsigned short	xxLocalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, 'xxtUnionPtr	xxGlobalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, '# endif');WriteNl (file);
Spaces;WriteS (file, '{');WriteNl (file);
Spaces;WriteS (file, '  xxbool xxTokensSkipped = xxfalse;');WriteNl (file);
Spaces;WriteS (file, '  xxtSet xxRecoverySet;');WriteNl (file);
		FOR i := 0 TO MaxCode () DIV cBitsPerLong DO
Spaces;WriteS (file, '  xxRecoverySet [');WriteI (file, i, 0);WriteS (file, '] = xxHorizontalSet [xxLocalRecoverySet] [');WriteI (file, i, 0);WriteS (file, '];');WriteNl (file);
		END;
Spaces;WriteS (file, '  xxRecoverySet [0] |= (unsigned long) 0x80000000L; /* INCL (xxRecoverySet [0], xxEof); */');WriteNl (file);
Spaces;WriteS (file, '  while (xxGlobalRecoverySet != (xxtUnionPtr) 0L) {');WriteNl (file);
		FOR i := 0 TO MaxCode () DIV cBitsPerLong DO
Spaces;WriteS (file, '    xxRecoverySet [');WriteI (file, i, 0);WriteS (file, '] |= xxHorizontalSet [xxGlobalRecoverySet->xxLocalRecoverySet] [');WriteI (file, i, 0);WriteS (file, '];');WriteNl (file);
		END;
Spaces;WriteS (file, '    xxGlobalRecoverySet = xxGlobalRecoverySet->xxGlobalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, '  }');WriteNl (file);
Spaces;WriteS (file, '  while (! xxIsElement (xxRecoverySet, xxToken)) {');WriteNl (file);
Spaces;WriteS (file, '    xxToken = ');
		Prefix;
WriteS (file, 'GetToken (); xxTokensSkipped = xxtrue;');WriteNl (file);
Spaces;WriteS (file, '  }');WriteNl (file);
Spaces;WriteS (file, '  if (xxTokensSkipped) ErrorMessage (xxRestartPoint, xxInformation, ');
		Prefix;
WriteS (file, 'Attribute.Position);');WriteNl (file);
Spaces;WriteS (file, '  xxIsRepairMode = xxtrue;');WriteNl (file);
Spaces;WriteS (file, '}');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'static void xxUnexpected');WriteNl (file);
Spaces;WriteS (file, '# if defined __STDC__ | defined __cplusplus');WriteNl (file);
Spaces;WriteS (file, '(unsigned short xxLocalRecoverySet, xxtUnionPtr xxGlobalRecoverySet)');WriteNl (file);
Spaces;WriteS (file, '# else');WriteNl (file);
Spaces;WriteS (file, '(xxLocalRecoverySet, xxGlobalRecoverySet)');WriteNl (file);
Spaces;WriteS (file, 'unsigned short	xxLocalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, 'xxtUnionPtr	xxGlobalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, '# endif');WriteNl (file);
Spaces;WriteS (file, '{');WriteNl (file);
Spaces;WriteS (file, '  if (! xxIsRepairMode) {');WriteNl (file);
Spaces;WriteS (file, '    xxErrorCount ++;');WriteNl (file);
Spaces;WriteS (file, '    ErrorMessage (xxSyntaxError, xxError, ');
		Prefix;
WriteS (file, 'Attribute.Position);');WriteNl (file);
Spaces;WriteS (file, '    xxSkipTokens (xxLocalRecoverySet, xxGlobalRecoverySet);');WriteNl (file);
Spaces;WriteS (file, '  }');WriteNl (file);
Spaces;WriteS (file, '}');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'static void xxExpected');WriteNl (file);
Spaces;WriteS (file, '# if defined __STDC__ | defined __cplusplus');WriteNl (file);
Spaces;WriteS (file, '(unsigned short xxExpectedSet, unsigned short xxLocalRecoverySet, xxtUnionPtr xxGlobalRecoverySet)');WriteNl (file);
Spaces;WriteS (file, '# else');WriteNl (file);
Spaces;WriteS (file, '(xxExpectedSet, xxLocalRecoverySet, xxGlobalRecoverySet)');WriteNl (file);
Spaces;WriteS (file, 'unsigned short	xxExpectedSet, xxLocalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, 'xxtUnionPtr	xxGlobalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, '# endif');WriteNl (file);
Spaces;WriteS (file, '{');WriteNl (file);
Spaces;WriteS (file, '  if (! xxIsRepairMode) {');WriteNl (file);
Spaces;WriteS (file, '    short yxToken;');WriteNl (file);
Spaces;WriteS (file, '    int xxLength = 0;');WriteNl (file);
Spaces;WriteS (file, '    char xxContinueString [256];');WriteNl (file);
Spaces;WriteS (file, '    xxErrorCount ++;');WriteNl (file);
Spaces;WriteS (file, '    ErrorMessage (xxSyntaxError, xxError, ');
		Prefix;
WriteS (file, 'Attribute.Position);');WriteNl (file);

Spaces;WriteS (file, "    xxContinueString [0] = '\0';");WriteNl (file);

Spaces;WriteS (file, '    for (yxToken = 0; yxToken <= ');WriteI (file, MaxCode (), 0);WriteS (file, '; yxToken ++)');WriteNl (file);
Spaces;WriteS (file, '      if (xxIsElement (xxHorizontalSet [xxExpectedSet], yxToken)) {');WriteNl (file);
Spaces;WriteS (file, '	char * xxTokenString = ');WriteIdent (file, ParserName);WriteS (file, '_TokenName [yxToken];');WriteNl (file);
Spaces;WriteS (file, '	if ((xxLength += strlen (xxTokenString) + 1) >= 256) break;');WriteNl (file);
Spaces;WriteS (file, '	(void) strcat (xxContinueString, xxTokenString);');WriteNl (file);
Spaces;WriteS (file, '	(void) strcat (xxContinueString, " ");');WriteNl (file);
Spaces;WriteS (file, '      }');WriteNl (file);
Spaces;WriteS (file, '    ErrorMessageI (xxExpectedTokens, xxInformation, ');
		Prefix;
WriteS (file, 'Attribute.Position, xxString, xxContinueString);');WriteNl (file);
Spaces;WriteS (file, '    xxSkipTokens (xxLocalRecoverySet, xxGlobalRecoverySet);');WriteNl (file);
Spaces;WriteS (file, '  }');WriteNl (file);
Spaces;WriteS (file, '}');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'static void xxRecoveryLiteral');WriteNl (file);
Spaces;WriteS (file, '# if defined __STDC__ | defined __cplusplus');WriteNl (file);
Spaces;WriteS (file, '(unsigned short xxExpected, unsigned short xxLocalRecoverySet, xxtUnionPtr xxGlobalRecoverySet)');WriteNl (file);
Spaces;WriteS (file, '# else');WriteNl (file);
Spaces;WriteS (file, '(xxExpected, xxLocalRecoverySet, xxGlobalRecoverySet)');WriteNl (file);
Spaces;WriteS (file, 'unsigned short	xxExpected, xxLocalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, 'xxtUnionPtr	xxGlobalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, '# endif');WriteNl (file);
Spaces;WriteS (file, '{');WriteNl (file);
Spaces;WriteS (file, '  if (! xxIsRepairMode) {');WriteNl (file);
Spaces;WriteS (file, '    xxErrorCount ++;');WriteNl (file);
Spaces;WriteS (file, '    ErrorMessage (xxSyntaxError, xxError, ');
		Prefix;
WriteS (file, 'Attribute.Position);');WriteNl (file);
Spaces;WriteS (file, '    ErrorMessageI (xxExpectedTokens, xxInformation, ');
		Prefix;
WriteS (file, 'Attribute.Position, xxString, ');WriteIdent (file, ParserName);WriteS (file, '_TokenName [xxExpected]);');WriteNl (file);
Spaces;WriteS (file, '    xxSkipTokens (xxLocalRecoverySet, xxGlobalRecoverySet);');WriteNl (file);
Spaces;WriteS (file, '  }');WriteNl (file);
Spaces;WriteS (file, '  if (xxToken != xxExpected) {');WriteNl (file);
Spaces;WriteS (file, '    ErrorMessageI (xxTokenInserted, xxRepair, ');
		Prefix;
WriteS (file, 'Attribute.Position, xxString, ');WriteIdent (file, ParserName);WriteS (file, '_TokenName [xxExpected]);');WriteNl (file);
Spaces;WriteS (file, '  } else {');WriteNl (file);
Spaces;WriteS (file, '    if (xxToken != xxEof) xxToken = ');
		Prefix;
WriteS (file, 'GetToken ();');WriteNl (file);
Spaces;WriteS (file, '    xxIsRepairMode = xxfalse;');WriteNl (file);
Spaces;WriteS (file, '  }');WriteNl (file);
Spaces;WriteS (file, '}');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'static void xxRecoveryTerminal');WriteNl (file);
Spaces;WriteS (file, '# if defined __STDC__ | defined __cplusplus');WriteNl (file);
Spaces;WriteS (file, '(unsigned short xxExpected, unsigned short xxLocalRecoverySet,');WriteNl (file);
Spaces;WriteS (file, 'xxtUnionPtr xxGlobalRecoverySet, ');
		Prefix;
WriteS (file, 'tScanAttribute * xxRepairAttribute)');WriteNl (file);
Spaces;WriteS (file, '# else');WriteNl (file);
Spaces;WriteS (file, '(xxExpected, xxLocalRecoverySet, xxGlobalRecoverySet, xxRepairAttribute)');WriteNl (file);
Spaces;WriteS (file, 'unsigned short	xxExpected, xxLocalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, 'xxtUnionPtr	xxGlobalRecoverySet;');WriteNl (file);
		Prefix;
Spaces;WriteS (file, 'tScanAttribute	* xxRepairAttribute;');WriteNl (file);
Spaces;WriteS (file, '# endif');WriteNl (file);
Spaces;WriteS (file, '{');WriteNl (file);
Spaces;WriteS (file, '  if (! xxIsRepairMode) {');WriteNl (file);
Spaces;WriteS (file, '    xxErrorCount ++;');WriteNl (file);
Spaces;WriteS (file, '    ErrorMessage (xxSyntaxError, xxError, ');
		Prefix;
WriteS (file, 'Attribute.Position);');WriteNl (file);
Spaces;WriteS (file, '    ErrorMessageI (xxExpectedTokens, xxInformation, ');
		Prefix;
WriteS (file, 'Attribute.Position, xxString, ');WriteIdent (file, ParserName);WriteS (file, '_TokenName [xxExpected]);');WriteNl (file);
Spaces;WriteS (file, '    xxSkipTokens (xxLocalRecoverySet, xxGlobalRecoverySet);');WriteNl (file);
Spaces;WriteS (file, '  }');WriteNl (file);
Spaces;WriteS (file, '  if (xxToken != xxExpected) {');WriteNl (file);
Spaces;WriteS (file, '    ErrorMessageI (xxTokenInserted, xxRepair, ');
		Prefix;
WriteS (file, 'Attribute.Position, xxString, ');WriteIdent (file, ParserName);WriteS (file, '_TokenName [xxExpected]);');WriteNl (file);
Spaces;WriteS (file, '    ');
		Prefix;
WriteS (file, 'ErrorAttribute ((int) xxExpected, xxRepairAttribute);');WriteNl (file);
Spaces;WriteS (file, '  } else {');WriteNl (file);
Spaces;WriteS (file, '    * xxRepairAttribute = ');
		Prefix;
WriteS (file, 'Attribute;');WriteNl (file);
Spaces;WriteS (file, '    if (xxToken != xxEof) xxToken = ');
		Prefix;
WriteS (file, 'GetToken ();');WriteNl (file);
Spaces;WriteS (file, '    xxIsRepairMode = xxfalse;');WriteNl (file);
Spaces;WriteS (file, '  }');WriteNl (file);
Spaces;WriteS (file, '}');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'int ');WriteIdent (file, ParserName);WriteS (file, ' ()');WriteNl (file);
Spaces;WriteS (file, '{');WriteNl (file);
Spaces;WriteS (file, '  xxErrorCount = 0;');WriteNl (file);
Spaces;WriteS (file, '  Begin');WriteIdent (file, ParserName);WriteS (file, ' ();');WriteNl (file);
Spaces;WriteS (file, '  xxToken = ');
		Prefix;
WriteS (file, 'GetToken ();');WriteNl (file);
Spaces;WriteS (file, '  yy');WriteIdent (file, yyt^.Grammar.rules^.Rules.rule^.Rule.id^.Id.ident);WriteS (file, ' (& ');WriteIdent (file, ParserName);WriteS (file, '_ParsAttribute, (xxtUnionPtr) 0L);');WriteNl (file);
Spaces;WriteS (file, '  if (xxToken != xxEof) xxRecoveryLiteral (xxEof, 0, (xxtUnionPtr) 0L);');WriteNl (file);
Spaces;WriteS (file, '  return xxErrorCount;');WriteNl (file);
Spaces;WriteS (file, '}');WriteNl (file);
Spaces;WriteNl (file);
		NumberArraySize := MaxIdent () + 1;
		MaxNumberArraySize := MaxIdent () + 1;
		MakeArray (NumberArray, NumberArraySize, TSIZE (INTEGER));
		MakeArray (MaxNumberArray, MaxNumberArraySize, TSIZE (INTEGER));
		CodeRules (yyt^.Grammar.rules);
		ReleaseArray (NumberArray, NumberArraySize, TSIZE (INTEGER));
		ReleaseArray (MaxNumberArray, MaxNumberArraySize, TSIZE (INTEGER));

		WriteClose (file);
		
END yyF3CodeImp;

PROCEDURE yyF4CodeImp (yyt: Tree.tTree);

BEGIN    (* line 681 CodeC.aftermpp *)

		ERROR ('CodeM2.ESTRA: no rules');
		
END yyF4CodeImp;

PROCEDURE yyF5CodeForward (yyt: Tree.tTree);

BEGIN
END yyF5CodeForward;

PROCEDURE yyF6CodeForward (yyt: Tree.tTree);

BEGIN    (* line 695 CodeC.aftermpp *)

Spaces;WriteS (file, 'static void yy');WriteIdent (file, yyt^.Rules.rule^.Rule.id^.Id.ident);WriteS (file, ' ARGS((');WriteIdent (file, ParserName);WriteS (file, '_tParsAttribute * ');WriteIdent (file, yyt^.Rules.rule^.Rule.id^.Id.ident);WriteS (file, '0, xxtUnionPtr xxGlobalRecoverySet));');WriteNl (file);
		CodeForward (yyt^.Rules.rules);
		
END yyF6CodeForward;

PROCEDURE yyF7CodeRules (yyt: Tree.tTree);

BEGIN
END yyF7CodeRules;

PROCEDURE yyF8CodeRules (yyt: Tree.tTree);

BEGIN    (* line 709 CodeC.aftermpp *)

		ClearArray (MaxNumberArray^);
		SetNumbers (yyt^.Rules.rule^.Rule.expr, TRUE);

Spaces;WriteS (file, 'static void yy');WriteIdent (file, yyt^.Rules.rule^.Rule.id^.Id.ident);WriteNl (file);
Spaces;WriteS (file, '# if defined __STDC__ | defined __cplusplus');WriteNl (file);
Spaces;WriteS (file, '(');WriteIdent (file, ParserName);WriteS (file, '_tParsAttribute * ');WriteIdent (file, yyt^.Rules.rule^.Rule.id^.Id.ident);WriteS (file, '0, xxtUnionPtr xxGlobalRecoverySet)');WriteNl (file);
Spaces;WriteS (file, '# else');WriteNl (file);
Spaces;WriteS (file, '(');WriteIdent (file, yyt^.Rules.rule^.Rule.id^.Id.ident);WriteS (file, '0, xxGlobalRecoverySet)');WriteNl (file);
Spaces;WriteIdent (file, ParserName);WriteS (file, '_tParsAttribute	* ');WriteIdent (file, yyt^.Rules.rule^.Rule.id^.Id.ident);WriteS (file, '0;');WriteNl (file);
Spaces;WriteS (file, 'xxtUnionPtr	xxGlobalRecoverySet;');WriteNl (file);
Spaces;WriteS (file, '# endif');WriteNl (file);
Spaces;WriteS (file, '{');WriteNl (file);
INC (SpaCo);
		  WriteAttributes;
		  IF yyt^.Rules.rule^.Rule.iscalling THEN
Spaces;WriteS (file, 'xxtUnion xxUnion;');WriteNl (file);
		  END;
		  CodeLocal (lSections);
		  CodeCodes (yyt^.Rules.rule^.Rule.codes);
		  IF yyt^.Rules.rule^.Rule.iscalling THEN
Spaces;WriteS (file, 'xxUnion.xxGlobalRecoverySet = xxGlobalRecoverySet;');WriteNl (file);
		  END;
		  CodeRules (yyt^.Rules.rule^.Rule.expr);
DEC (SpaCo);
Spaces;WriteS (file, '}');WriteNl (file);
Spaces;WriteNl (file);
		CodeRules (yyt^.Rules.rules);
		
END yyF8CodeRules;

PROCEDURE yyF9CodeRules (yyt: Tree.tTree);

BEGIN    (* line 740 CodeC.aftermpp *)

Spaces;WriteS (file, 'for (;;) {');WriteNl (file);
INC (SpaCo);
Spaces;WriteS (file, 'if (');
		    CodeIsElement (yyt^.Option.index, yyt^.Option.expr^.expr.first);
WriteS (file, ') {');WriteNl (file);
INC (SpaCo);
		    InDefault := FALSE;
		    CodeRules (yyt^.Option.expr);
Spaces;WriteS (file, 'break;');WriteNl (file);
DEC (SpaCo);
Spaces;WriteS (file, '} else if (');
		    CodeIsElement (yyt^.Option.followindex, yyt^.Option.follow);
WriteS (file, ' || xxIsRepairMode) break;');WriteNl (file);
		  CodeRecovery (yyt^.Option.recindex, yyt^.Option.expindex);
DEC (SpaCo);
Spaces;WriteS (file, '}');WriteNl (file);
		
END yyF9CodeRules;

PROCEDURE yyF10CodeRules (yyt: Tree.tTree);

BEGIN    (* line 760 CodeC.aftermpp *)

Spaces;WriteS (file, 'for (;;) {');WriteNl (file);
INC (SpaCo);
Spaces;WriteS (file, 'if (');
		      CodeIsElement (yyt^.Times.index, yyt^.Times.expr^.expr.first);
WriteS (file, ') {');WriteNl (file);
INC (SpaCo);
		    InDefault := FALSE;
		    CodeRules (yyt^.Times.expr);
DEC (SpaCo);
Spaces;WriteS (file, '} else if (');
		    CodeIsElement (yyt^.Times.followindex, yyt^.Times.follow);
WriteS (file, ' || xxIsRepairMode) break;');WriteNl (file);
Spaces;WriteS (file, 'else');WriteNl (file);
INC (SpaCo);
		    CodeRecovery (yyt^.Times.recindex, yyt^.Times.expindex);
DEC (SpaCo);
DEC (SpaCo);
Spaces;WriteS (file, '}');WriteNl (file);
		
END yyF10CodeRules;

PROCEDURE yyF11CodeRules (yyt: Tree.tTree);

BEGIN    (* line 782 CodeC.aftermpp *)

Spaces;WriteS (file, 'for (;;) {');WriteNl (file);
INC (SpaCo);
		  CodeRules (yyt^.Plus.expr);
Spaces;WriteS (file, 'if (! (');
		       CodeIsElement (yyt^.Plus.index, yyt^.Plus.expr^.expr.first);
WriteS (file, ')) {');WriteNl (file);
INC (SpaCo);
Spaces;WriteS (file, 'if (');
		      CodeIsElement (yyt^.Plus.followindex, yyt^.Plus.follow);
WriteS (file, ') break;');WriteNl (file);
		    CodeRecovery (yyt^.Plus.recindex, yyt^.Plus.expindex);
Spaces;WriteS (file, 'if (! (');
		      CodeIsElement (yyt^.Plus.index, yyt^.Plus.first);
WriteS (file, ')) break;');WriteNl (file);
DEC (SpaCo);
Spaces;WriteS (file, '}');WriteNl (file);
DEC (SpaCo);
Spaces;WriteS (file, '}');WriteNl (file);
		
END yyF11CodeRules;

PROCEDURE yyF12CodeRules (yyt: Tree.tTree);

BEGIN    (* line 804 CodeC.aftermpp *)

Spaces;WriteS (file, 'for (;;) {');WriteNl (file);
INC (SpaCo);
		  CodeRules (yyt^.List.body);
Spaces;WriteS (file, 'if (! (');
		    CodeIsElement (yyt^.List.sep^.expr.index, yyt^.List.sep^.expr.first);
WriteS (file, ')) {');WriteNl (file);
INC (SpaCo);
Spaces;WriteS (file, 'if (');
		      CodeIsElement (yyt^.List.followindex, yyt^.List.follow);
WriteS (file, ') break;');WriteNl (file);
		    CodeRecovery (yyt^.List.recindex, yyt^.List.expindex);
Spaces;WriteS (file, 'if (! (');
		      CodeIsElement (yyt^.List.sep^.expr.index, yyt^.List.sep^.expr.first);
WriteS (file, ' || ');
		      CodeIsElement (yyt^.List.index, yyt^.List.first);
WriteS (file, ')) break;');WriteNl (file);
DEC (SpaCo);
Spaces;WriteS (file, '}');WriteNl (file);
		  CodeRules (yyt^.List.sep);
DEC (SpaCo);
Spaces;WriteS (file, '}');WriteNl (file);
		
END yyF12CodeRules;

PROCEDURE yyF13CodeRules (yyt: Tree.tTree);

BEGIN
END yyF13CodeRules;

PROCEDURE yyF14CodeRules (yyt: Tree.tTree);

BEGIN    (* line 830 CodeC.aftermpp *)
 CodeCodes (yyt^.Action.codes); 
END yyF14CodeRules;

PROCEDURE yyF15CodeRules (yyt: Tree.tTree);

BEGIN    (* line 834 CodeC.aftermpp *)

		IF InDefault THEN
Spaces;WriteS (file, 'if (xxToken != ');WriteI (file, Code (yyt^.Leaf.id^.Id.ident), 0);WriteS (file, ' /* ');WriteIdent (file, yyt^.Leaf.id^.Id.ident);WriteS (file, ' */)');WriteNl (file);
Spaces;WriteS (file, '  xxRecoveryTerminal (');WriteI (file, Code (yyt^.Leaf.id^.Id.ident), 0);WriteS (file, ', ');WriteI (file, yyt^.Leaf.recindex, 0);WriteS (file, ', xxGlobalRecoverySet, & ');WriteIdent (file, yyt^.Leaf.id^.Id.ident);WriteI (file, yyt^.Leaf.number, 0);WriteS (file, '); /* ');WriteRecIndex (file, yyt^.Leaf.recindex);WriteS (file, ' */');WriteNl (file);
Spaces;WriteS (file, 'else {');WriteNl (file);
Spaces;WriteS (file, '  ');WriteIdent (file, yyt^.Leaf.id^.Id.ident);WriteI (file, yyt^.Leaf.number, 0);WriteS (file, ' = ');
		  Prefix;
WriteS (file, 'Attribute;');WriteNl (file);
Spaces;WriteS (file, '  xxToken = ');
		Prefix;
WriteS (file, 'GetToken (); xxIsRepairMode = xxfalse;');WriteNl (file);
Spaces;WriteS (file, '}');WriteNl (file);
		  InDefault := FALSE;
		ELSE
Spaces;WriteIdent (file, yyt^.Leaf.id^.Id.ident);WriteI (file, yyt^.Leaf.number, 0);WriteS (file, ' = ');
		Prefix;
WriteS (file, 'Attribute;');WriteNl (file);
Spaces;WriteS (file, 'xxToken = ');
		Prefix;
WriteS (file, 'GetToken (); xxIsRepairMode = xxfalse;');WriteNl (file);
		END;
		
END yyF15CodeRules;

PROCEDURE yyF16CodeRules (yyt: Tree.tTree);

BEGIN    (* line 859 CodeC.aftermpp *)

		IF InDefault THEN
Spaces;WriteS (file, 'if (xxToken != ');WriteI (file, Code (yyt^.Leaf.id^.Id.ident), 0);WriteS (file, ' /* ');WriteIdent (file, yyt^.Leaf.id^.Id.ident);WriteS (file, ' */)');WriteNl (file);
Spaces;WriteS (file, '  xxRecoveryLiteral (');WriteI (file, Code (yyt^.Leaf.id^.Id.ident), 0);WriteS (file, ', ');WriteI (file, yyt^.Leaf.recindex, 0);WriteS (file, ', xxGlobalRecoverySet); /* ');WriteRecIndex (file, yyt^.Leaf.recindex);WriteS (file, ' */');WriteNl (file);
Spaces;WriteS (file, 'else {');WriteNl (file);
Spaces;WriteS (file, '  xxToken = ');
		Prefix;
WriteS (file, 'GetToken (); xxIsRepairMode = xxfalse;');WriteNl (file);
Spaces;WriteS (file, '}');WriteNl (file);
		  InDefault := FALSE;
		ELSE
Spaces;WriteS (file, 'xxToken = ');
		Prefix;
WriteS (file, 'GetToken (); xxIsRepairMode = xxfalse;');WriteNl (file);
		END;
		
END yyF16CodeRules;

PROCEDURE yyF17CodeRules (yyt: Tree.tTree);

BEGIN    (* line 878 CodeC.aftermpp *)

Spaces;WriteS (file, 'if (xxToken != ');WriteI (file, Code (yyt^.Leaf.id^.Id.ident), 0);WriteS (file, ' /* ');WriteIdent (file, yyt^.Leaf.id^.Id.ident);WriteS (file, ' */)');WriteNl (file);
Spaces;WriteS (file, '  xxRecoveryTerminal (');WriteI (file, Code (yyt^.Leaf.id^.Id.ident), 0);WriteS (file, ', ');WriteI (file, yyt^.Leaf.recindex, 0);WriteS (file, ', xxGlobalRecoverySet, & ');WriteIdent (file, yyt^.Leaf.id^.Id.ident);WriteI (file, yyt^.Leaf.number, 0);WriteS (file, '); /* ');WriteRecIndex (file, yyt^.Leaf.recindex);WriteS (file, ' */');WriteNl (file);
Spaces;WriteS (file, 'else {');WriteNl (file);
Spaces;WriteS (file, '  ');WriteIdent (file, yyt^.Leaf.id^.Id.ident);WriteI (file, yyt^.Leaf.number, 0);WriteS (file, ' = ');
		Prefix;
WriteS (file, 'Attribute;');WriteNl (file);
Spaces;WriteS (file, '  xxToken = ');
		Prefix;
WriteS (file, 'GetToken (); xxIsRepairMode = xxfalse;');WriteNl (file);
Spaces;WriteS (file, '}');WriteNl (file);
		
END yyF17CodeRules;

PROCEDURE yyF18CodeRules (yyt: Tree.tTree);

BEGIN    (* line 893 CodeC.aftermpp *)

Spaces;WriteS (file, 'if (xxToken != ');WriteI (file, Code (yyt^.Leaf.id^.Id.ident), 0);WriteS (file, ' /* ');WriteIdent (file, yyt^.Leaf.id^.Id.ident);WriteS (file, ' */)');WriteNl (file);
Spaces;WriteS (file, '  xxRecoveryLiteral (');WriteI (file, Code (yyt^.Leaf.id^.Id.ident), 0);WriteS (file, ', ');WriteI (file, yyt^.Leaf.recindex, 0);WriteS (file, ', xxGlobalRecoverySet); /* ');WriteRecIndex (file, yyt^.Leaf.recindex);WriteS (file, ' */');WriteNl (file);
Spaces;WriteS (file, 'else {');WriteNl (file);
Spaces;WriteS (file, '  xxToken = ');
		Prefix;
WriteS (file, 'GetToken (); xxIsRepairMode = xxfalse;');WriteNl (file);
Spaces;WriteS (file, '}');WriteNl (file);
		
END yyF18CodeRules;

PROCEDURE yyF19CodeRules (yyt: Tree.tTree);

BEGIN    (* line 905 CodeC.aftermpp *)

Spaces;WriteS (file, 'xxUnion.xxLocalRecoverySet = ');WriteI (file, yyt^.Leaf.recindex, 0);WriteS (file, '; yy');WriteIdent (file, yyt^.Leaf.id^.Id.ident);WriteS (file, ' (& ');WriteIdent (file, yyt^.Leaf.id^.Id.ident);WriteI (file, yyt^.Leaf.number, 0);WriteS (file, ', & xxUnion); /* ');WriteRecIndex (file, yyt^.Leaf.recindex);WriteS (file, ' */');WriteNl (file);
		
END yyF19CodeRules;

PROCEDURE yyF20CodeRules (yyt: Tree.tTree);

BEGIN
END yyF20CodeRules;

PROCEDURE yyF21CodeRules (yyt: Tree.tTree);

BEGIN    (* line 912 CodeC.aftermpp *)

		CodeRules (yyt^.Sequence.expr);
		CodeRules (yyt^.Sequence.sequence);
		
END yyF21CodeRules;

PROCEDURE yyF22CodeRules (yyt: Tree.tTree);
    (* line 918 CodeC.aftermpp *)
 VAR label: INTEGER; labels: tSet; 
BEGIN    (* line 919 CodeC.aftermpp *)

		MakeSet (labels, MaxIdent ());
Spaces;WriteS (file, 'for (;;) {');WriteNl (file);
INC (SpaCo);
Spaces;WriteS (file, 'switch (xxToken) {');WriteNl (file);
		  INC (Label);
		  label := Label;
		  CodeAltCase (yyt, label, labels);
Spaces;WriteS (file, '}');WriteNl (file);
DEC (SpaCo);
Spaces;WriteS (file, '}');WriteNl (file);
Spaces;WriteS (file, 'xx');WriteI (file, label, 0);WriteS (file, ':;');WriteNl (file);
		ReleaseSet (labels);
		
END yyF22CodeRules;

PROCEDURE yyF23CodeRules (yyt: Tree.tTree);

BEGIN    (* line 935 CodeC.aftermpp *)

		CodeAltIf (yyt, FALSE);
		
END yyF23CodeRules;

PROCEDURE yyF24CodeAltCase (yyt: Tree.tTree;label:INTEGER;labels:tSet);
    (* line 943 CodeC.aftermpp *)
 VAR l: CARDINAL; s: tSet; 
BEGIN    (* line 944 CodeC.aftermpp *)

		MakeSet (s, MaxCode ());
		FOR l := Minimum (labels) TO Maximum (labels) DO
		  IF IsElement (l, labels) THEN
		    Include (s, Code (l));
		  END;
		END;
		FOR l := Minimum (s) TO Maximum (s) DO
		  IF NOT IsElement (l, s) THEN
Spaces;WriteS (file, 'case ');WriteI (file, l, 0);WriteS (file, ':;');WriteNl (file);
		  END;
		END;
Spaces;WriteS (file, 'default:');WriteNl (file);
INC (SpaCo);
Spaces;WriteS (file, 'if (xxIsRepairMode) {');WriteNl (file);
INC (SpaCo);
		    InDefault := TRUE;
		    CodeRules (yyt^.Alternative0.default);
		    InDefault := FALSE;
Spaces;WriteS (file, 'goto xx');WriteI (file, label, 0);WriteS (file, ';');WriteNl (file);
DEC (SpaCo);
Spaces;WriteS (file, '}');WriteNl (file);
		  CodeRecovery (yyt^.Alternative0.recindex, yyt^.Alternative0.expindex);
DEC (SpaCo);
		
END yyF24CodeAltCase;

PROCEDURE yyF25CodeAltCase (yyt: Tree.tTree;label:INTEGER;labels:tSet);

BEGIN    (* line 971 CodeC.aftermpp *)

		WriteLabels (yyt^.Alternative.expr^.expr.fifo);
INC (SpaCo);
		CodeRules (yyt^.Alternative.expr);
Spaces;WriteS (file, 'goto xx');WriteI (file, label, 0);WriteS (file, ';');WriteNl (file);
DEC (SpaCo);
		Union (labels, yyt^.Alternative.expr^.expr.fifo);
		CodeAltCase (yyt^.Alternative.alternative, label, labels);
		
END yyF25CodeAltCase;

PROCEDURE yyF26CodeAltIf (yyt: Tree.tTree;started:BOOLEAN);

BEGIN    (* line 985 CodeC.aftermpp *)

Spaces;WriteS (file, '} else {');WriteNl (file);
INC (SpaCo);
		  CodeRecovery (yyt^.Alternative0.recindex, yyt^.Alternative0.expindex);
		  InDefault := TRUE;
		  CodeRules (yyt^.Alternative0.default);
		  InDefault := FALSE;
DEC (SpaCo);
Spaces;WriteS (file, '}');WriteNl (file);
		
END yyF26CodeAltIf;

PROCEDURE yyF27CodeAltIf (yyt: Tree.tTree;started:BOOLEAN);

BEGIN    (* line 997 CodeC.aftermpp *)

		IF NOT started THEN
Spaces;WriteS (file, 'if (');
	            CodeIsElement (yyt^.Alternative.index, yyt^.Alternative.expr^.expr.first);
WriteS (file, ') {');WriteNl (file);
		ELSE
Spaces;WriteS (file, '} else {');WriteNl (file);
		END;
INC (SpaCo);
		CodeRules (yyt^.Alternative.expr);
DEC (SpaCo);
Spaces;WriteS (file, '}');WriteNl (file);
		
END yyF27CodeAltIf;

PROCEDURE yyF28CodeAltIf (yyt: Tree.tTree;started:BOOLEAN);

BEGIN    (* line 1012 CodeC.aftermpp *)

		IF NOT started THEN
Spaces;WriteS (file, 'if (');
		ELSE
WriteS (file, '} else if (');
		END;
	        CodeIsElement (yyt^.Alternative.index, yyt^.Alternative.expr^.expr.fifo);
WriteS (file, ') {');WriteNl (file);
INC (SpaCo);
		CodeRules (yyt^.Alternative.expr);
DEC (SpaCo);
		CodeAltIf (yyt^.Alternative.alternative, TRUE);
		
END yyF28CodeAltIf;

PROCEDURE yyF29SetNumbers (yyt: Tree.tTree;start:BOOLEAN);

BEGIN    (* line 1034 CodeC.aftermpp *)

		IF start THEN ClearArray (NumberArray^); END;
		SetNumbers (yyt^.Option.expr, FALSE);
		
END yyF29SetNumbers;

PROCEDURE yyF30SetNumbers (yyt: Tree.tTree;start:BOOLEAN);

BEGIN    (* line 1040 CodeC.aftermpp *)

		IF start THEN ClearArray (NumberArray^); END;
		SetNumbers (yyt^.Times.expr, FALSE);
		
END yyF30SetNumbers;

PROCEDURE yyF31SetNumbers (yyt: Tree.tTree;start:BOOLEAN);

BEGIN    (* line 1046 CodeC.aftermpp *)

		IF start THEN ClearArray (NumberArray^); END;
		SetNumbers (yyt^.Plus.expr, FALSE);
		
END yyF31SetNumbers;

PROCEDURE yyF32SetNumbers (yyt: Tree.tTree;start:BOOLEAN);

BEGIN    (* line 1052 CodeC.aftermpp *)

		IF start THEN ClearArray (NumberArray^); END;
		SetNumbers (yyt^.List.body, FALSE);
		SetNumbers (yyt^.List.sep, FALSE);
		
END yyF32SetNumbers;

PROCEDURE yyF33SetNumbers (yyt: Tree.tTree;start:BOOLEAN);

BEGIN
END yyF33SetNumbers;

PROCEDURE yyF34SetNumbers (yyt: Tree.tTree;start:BOOLEAN);

BEGIN
END yyF34SetNumbers;

PROCEDURE yyF35SetNumbers (yyt: Tree.tTree;start:BOOLEAN);

BEGIN    (* line 1063 CodeC.aftermpp *)

		IF start THEN ClearArray (NumberArray^); END;
		SetNumbers (yyt^.Sequence.expr, FALSE);
		SetNumbers (yyt^.Sequence.sequence, FALSE);
		
END yyF35SetNumbers;

PROCEDURE yyF36SetNumbers (yyt: Tree.tTree;start:BOOLEAN);

BEGIN    (* line 1069 CodeC.aftermpp *)
 
END yyF36SetNumbers;

PROCEDURE yyF37SetNumbers (yyt: Tree.tTree;start:BOOLEAN);

BEGIN    (* line 1072 CodeC.aftermpp *)

		IF start THEN ClearArray (NumberArray^); END;
		SetNumbers (yyt^.Alternative.expr, FALSE);
		SetNumbers (yyt^.Alternative.alternative, start);
		
END yyF37SetNumbers;

PROCEDURE yyF38SetNumbers (yyt: Tree.tTree;start:BOOLEAN);

BEGIN    (* line 1080 CodeC.aftermpp *)

		yyt^.Leaf.number := 0;
		
END yyF38SetNumbers;

PROCEDURE yyF39SetNumbers (yyt: Tree.tTree;start:BOOLEAN);

BEGIN    (* line 1086 CodeC.aftermpp *)

		IF start THEN ClearArray (NumberArray^); END;
		yyt^.Leaf.number := NumberArray^ [yyt^.Leaf.id^.Id.ident] + 1;
		NumberArray^ [yyt^.Leaf.id^.Id.ident] := yyt^.Leaf.number;
		IF yyt^.Leaf.number > MaxNumberArray^ [yyt^.Leaf.id^.Id.ident] THEN
		  MaxNumberArray^ [yyt^.Leaf.id^.Id.ident] := yyt^.Leaf.number;
		END;
		
END yyF39SetNumbers;

PROCEDURE yyF40CodeExport (yyt: Tree.tTree);

BEGIN    (* line 1104 CodeC.aftermpp *)

		vExport := TRUE;
		CodeCodes (yyt^.Sections.section^.Export.codes);
		CodeExport (yyt^.Sections.sections);
		
END yyF40CodeExport;

PROCEDURE yyF41CodeExport (yyt: Tree.tTree);

BEGIN    (* line 1112 CodeC.aftermpp *)

		CodeExport (yyt^.Sections.sections);
		
END yyF41CodeExport;

PROCEDURE yyF42CodeExport (yyt: Tree.tTree);

BEGIN
END yyF42CodeExport;

PROCEDURE yyF43CodeGlobal (yyt: Tree.tTree);

BEGIN    (* line 1123 CodeC.aftermpp *)

		CodeCodes (yyt^.Sections.section^.Global.codes);
		CodeGlobal (yyt^.Sections.sections);
		
END yyF43CodeGlobal;

PROCEDURE yyF44CodeGlobal (yyt: Tree.tTree);

BEGIN    (* line 1130 CodeC.aftermpp *)

		CodeGlobal (yyt^.Sections.sections);
		
END yyF44CodeGlobal;

PROCEDURE yyF45CodeGlobal (yyt: Tree.tTree);

BEGIN
END yyF45CodeGlobal;

PROCEDURE yyF46CodeLocal (yyt: Tree.tTree);

BEGIN    (* line 1141 CodeC.aftermpp *)

		CodeCodes (yyt^.Sections.section^.Local.codes);
		CodeLocal (yyt^.Sections.sections);
		
END yyF46CodeLocal;

PROCEDURE yyF47CodeLocal (yyt: Tree.tTree);

BEGIN    (* line 1148 CodeC.aftermpp *)

		CodeLocal (yyt^.Sections.sections);
		
END yyF47CodeLocal;

PROCEDURE yyF48CodeLocal (yyt: Tree.tTree);

BEGIN
END yyF48CodeLocal;

PROCEDURE yyF49CodeBegin (yyt: Tree.tTree);

BEGIN    (* line 1159 CodeC.aftermpp *)

		CodeCodes (yyt^.Sections.section^.Begin.codes);
		CodeBegin (yyt^.Sections.sections);
		
END yyF49CodeBegin;

PROCEDURE yyF50CodeBegin (yyt: Tree.tTree);

BEGIN    (* line 1166 CodeC.aftermpp *)

		CodeBegin (yyt^.Sections.sections);
		
END yyF50CodeBegin;

PROCEDURE yyF51CodeBegin (yyt: Tree.tTree);

BEGIN
END yyF51CodeBegin;

PROCEDURE yyF52CodeClose (yyt: Tree.tTree);

BEGIN    (* line 1177 CodeC.aftermpp *)

		CodeCodes (yyt^.Sections.section^.Close.codes);
		CodeClose (yyt^.Sections.sections);
		
END yyF52CodeClose;

PROCEDURE yyF53CodeClose (yyt: Tree.tTree);

BEGIN    (* line 1184 CodeC.aftermpp *)

		CodeClose (yyt^.Sections.sections);
		
END yyF53CodeClose;

PROCEDURE yyF54CodeClose (yyt: Tree.tTree);

BEGIN
END yyF54CodeClose;

PROCEDURE yyF55CodeCodes (yyt: Tree.tTree);

BEGIN    (* line 1194 CodeC.aftermpp *)


		IF LINE THEN
WriteS (file, '# line ');WriteI (file, yyt^.Codes.code^.Code.pos.Line, 0);WriteS (file, ' "');WriteS (file, SourceFileName);WriteS (file, '"');WriteNl (file);
		ELSE
WriteS (file, '/* line ');WriteI (file, yyt^.Codes.code^.Code.pos.Line, 0);WriteS (file, ' "');WriteS (file, SourceFileName);WriteS (file, '" */');WriteNl (file);
		END;
		WriteString (file, yyt^.Codes.code^.Code.ref);
		CodeCodes2 (yyt^.Codes.codes);
WriteNl (file);

		
END yyF55CodeCodes;

PROCEDURE yyF56CodeCodes (yyt: Tree.tTree);

BEGIN
END yyF56CodeCodes;

PROCEDURE yyF57CodeCodes2 (yyt: Tree.tTree);

BEGIN    (* line 1213 CodeC.aftermpp *)

		WriteString (file, yyt^.Codes.code^.Code.ref);
		CodeCodes2 (yyt^.Codes.codes);
		
END yyF57CodeCodes2;

PROCEDURE yyF58CodeCodes2 (yyt: Tree.tTree);

BEGIN
END yyF58CodeCodes2;

PROCEDURE CostCODE (yyt: Tree.tTree): INTEGER;
VAR
  InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyt^.yyHead.yyEstraInfo;
  RETURN InfoPtr^.CODE.Cost;
END CostCODE;

PROCEDURE CostCodeDef (yyt: Tree.tTree): INTEGER;
VAR
  InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyt^.yyHead.yyEstraInfo;
  RETURN InfoPtr^.CodeDef.Cost;
END CostCodeDef;

PROCEDURE CostCodeImp (yyt: Tree.tTree): INTEGER;
VAR
  InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyt^.yyHead.yyEstraInfo;
  RETURN InfoPtr^.CodeImp.Cost;
END CostCodeImp;

PROCEDURE CostCodeForward (yyt: Tree.tTree): INTEGER;
VAR
  InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyt^.yyHead.yyEstraInfo;
  RETURN InfoPtr^.CodeForward.Cost;
END CostCodeForward;

PROCEDURE CostCodeRules (yyt: Tree.tTree): INTEGER;
VAR
  InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyt^.yyHead.yyEstraInfo;
  RETURN InfoPtr^.CodeRules.Cost;
END CostCodeRules;

PROCEDURE CostCodeAltCase (yyt: Tree.tTree): INTEGER;
VAR
  InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyt^.yyHead.yyEstraInfo;
  RETURN InfoPtr^.CodeAltCase.Cost;
END CostCodeAltCase;

PROCEDURE CostCodeAltIf (yyt: Tree.tTree): INTEGER;
VAR
  InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyt^.yyHead.yyEstraInfo;
  RETURN InfoPtr^.CodeAltIf.Cost;
END CostCodeAltIf;

PROCEDURE CostSetNumbers (yyt: Tree.tTree): INTEGER;
VAR
  InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyt^.yyHead.yyEstraInfo;
  RETURN InfoPtr^.SetNumbers.Cost;
END CostSetNumbers;

PROCEDURE CostCodeExport (yyt: Tree.tTree): INTEGER;
VAR
  InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyt^.yyHead.yyEstraInfo;
  RETURN InfoPtr^.CodeExport.Cost;
END CostCodeExport;

PROCEDURE CostCodeGlobal (yyt: Tree.tTree): INTEGER;
VAR
  InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyt^.yyHead.yyEstraInfo;
  RETURN InfoPtr^.CodeGlobal.Cost;
END CostCodeGlobal;

PROCEDURE CostCodeLocal (yyt: Tree.tTree): INTEGER;
VAR
  InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyt^.yyHead.yyEstraInfo;
  RETURN InfoPtr^.CodeLocal.Cost;
END CostCodeLocal;

PROCEDURE CostCodeBegin (yyt: Tree.tTree): INTEGER;
VAR
  InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyt^.yyHead.yyEstraInfo;
  RETURN InfoPtr^.CodeBegin.Cost;
END CostCodeBegin;

PROCEDURE CostCodeClose (yyt: Tree.tTree): INTEGER;
VAR
  InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyt^.yyHead.yyEstraInfo;
  RETURN InfoPtr^.CodeClose.Cost;
END CostCodeClose;

PROCEDURE CostCodeCodes (yyt: Tree.tTree): INTEGER;
VAR
  InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyt^.yyHead.yyEstraInfo;
  RETURN InfoPtr^.CodeCodes.Cost;
END CostCodeCodes;

PROCEDURE CostCodeCodes2 (yyt: Tree.tTree): INTEGER;
VAR
  InfoPtr: yyInfoPtr;
BEGIN
  InfoPtr := yyt^.yyHead.yyEstraInfo;
  RETURN InfoPtr^.CodeCodes2.Cost;
END CostCodeCodes2;

PROCEDURE yyTraverse (yyt: Tree.tTree): yyStateType;
VAR
  state: yyStateType;
  match: POINTER TO yySetType;
  cost: INTEGER;
  info: yyInfoPtr;
  success: BOOLEAN;
  
BEGIN
  info := yyAlloc ();
  info^ := yyInfo;
  yyt^.yyHead.yyEstraInfo := info;
  
  
  CASE yyt^.Kind OF
  
  | Tree.Codes:
      state := 0;
      state := yyComb [state + yyTraverse (yyt^.Codes.code)];
      state := yyComb [state + yyTraverse (yyt^.Codes.codes)];

      cost := 1
      + CostCodeCodes2 (yyt^.Codes.codes);
      IF cost < info^.CodeCodes.Cost THEN
        info^.CodeCodes.Cost := cost;
        info^.CodeCodes.Proc := yyF55CodeCodes;
      END;
      
      cost := 1
      + CostCodeCodes2 (yyt^.Codes.codes);
      IF cost < info^.CodeCodes2.Cost THEN
        info^.CodeCodes2.Cost := cost;
        info^.CodeCodes2.Proc := yyF57CodeCodes2;
      END;
      
  | Tree.Code:
      state := 32;

  | Tree.Close:
      state := 3;
      state := yyComb [state + yyTraverse (yyt^.Close.codes)];

  | Tree.Grammar:
      state := 18;
      state := yyComb [state + yyTraverse (yyt^.Grammar.sections)];
      state := yyComb [state + yyTraverse (yyt^.Grammar.tokens)];
      state := yyComb [state + yyTraverse (yyt^.Grammar.rules)];
      match := SYSTEM.ADR (yySets [state]);
      
      yyMatch [3] := (3 IN match^[0]);
      yyMatch [4] := (4 IN match^[0]);

      cost := 1
      + CostCodeExport (yyt^.Grammar.sections);
      IF cost < info^.CodeDef.Cost THEN
        info^.CodeDef.Cost := cost;
        info^.CodeDef.Proc := yyF2CodeDef;
      END;
      
      IF yyMatch [3] THEN
        cost := 1
        + CostCodeGlobal (yyt^.Grammar.sections)
        + CostCodeBegin (yyt^.Grammar.sections)
        + CostCodeClose (yyt^.Grammar.sections)
        + CostCodeForward (yyt^.Grammar.rules)
        + CostCodeRules (yyt^.Grammar.rules);
        IF cost < info^.CodeImp.Cost THEN
          info^.CodeImp.Cost := cost;
          info^.CodeImp.Proc := yyF3CodeImp;
        END;
      END;
      
      IF yyMatch [4] THEN
        cost := 1;
        IF cost < info^.CodeImp.Cost THEN
          info^.CodeImp.Cost := cost;
          info^.CodeImp.Proc := yyF4CodeImp;
        END;
      END;
      
      cost := 1
      + CostCodeDef (yyt)
      + CostCodeImp (yyt);
      IF cost < info^.CODE.Cost THEN
        info^.CODE.Cost := cost;
        info^.CODE.Proc := yyF1CODE;
      END;
      
  | Tree.Sections0:
      state := 24;

      cost := 1;
      IF cost < info^.CodeExport.Cost THEN
        info^.CodeExport.Cost := cost;
        info^.CodeExport.Proc := yyF42CodeExport;
      END;
      
      cost := 1;
      IF cost < info^.CodeGlobal.Cost THEN
        info^.CodeGlobal.Cost := cost;
        info^.CodeGlobal.Proc := yyF45CodeGlobal;
      END;
      
      cost := 1;
      IF cost < info^.CodeLocal.Cost THEN
        info^.CodeLocal.Cost := cost;
        info^.CodeLocal.Proc := yyF48CodeLocal;
      END;
      
      cost := 1;
      IF cost < info^.CodeBegin.Cost THEN
        info^.CodeBegin.Cost := cost;
        info^.CodeBegin.Proc := yyF51CodeBegin;
      END;
      
      cost := 1;
      IF cost < info^.CodeClose.Cost THEN
        info^.CodeClose.Cost := cost;
        info^.CodeClose.Proc := yyF54CodeClose;
      END;
      
  | Tree.Sections:
      state := 17;
      state := yyComb [state + yyTraverse (yyt^.Sections.section)];
      state := yyComb [state + yyTraverse (yyt^.Sections.sections)];
      match := SYSTEM.ADR (yySets [state]);
      
      yyMatch [40] := (8 IN match^[1]);
      yyMatch [41] := TRUE & (          (* line 1111 CodeC.aftermpp *)
 yyt^.Sections.section^.Kind # Tree.Export );
      yyMatch [43] := (11 IN match^[1]);
      yyMatch [44] := TRUE & (          (* line 1129 CodeC.aftermpp *)
 yyt^.Sections.section^.Kind # Tree.Global );
      yyMatch [46] := (14 IN match^[1]);
      yyMatch [47] := TRUE & (          (* line 1147 CodeC.aftermpp *)
 yyt^.Sections.section^.Kind # Tree.Local );
      yyMatch [49] := (17 IN match^[1]);
      yyMatch [50] := TRUE & (          (* line 1165 CodeC.aftermpp *)
 yyt^.Sections.section^.Kind # Tree.Begin );
      yyMatch [52] := (20 IN match^[1]);
      yyMatch [53] := TRUE & (          (* line 1183 CodeC.aftermpp *)
 yyt^.Sections.section^.Kind # Tree.Close );

      IF yyMatch [40] THEN
        cost := 1
        + CostCodeCodes (yyt^.Sections.section^.Export.codes)
        + CostCodeExport (yyt^.Sections.sections);
        IF cost < info^.CodeExport.Cost THEN
          info^.CodeExport.Cost := cost;
          info^.CodeExport.Proc := yyF40CodeExport;
        END;
      END;
      
      IF yyMatch [41] THEN
        cost := 1
        + CostCodeExport (yyt^.Sections.sections);
        IF cost < info^.CodeExport.Cost THEN
          info^.CodeExport.Cost := cost;
          info^.CodeExport.Proc := yyF41CodeExport;
        END;
      END;
      
      IF yyMatch [43] THEN
        cost := 1
        + CostCodeCodes (yyt^.Sections.section^.Global.codes)
        + CostCodeGlobal (yyt^.Sections.sections);
        IF cost < info^.CodeGlobal.Cost THEN
          info^.CodeGlobal.Cost := cost;
          info^.CodeGlobal.Proc := yyF43CodeGlobal;
        END;
      END;
      
      IF yyMatch [44] THEN
        cost := 1
        + CostCodeGlobal (yyt^.Sections.sections);
        IF cost < info^.CodeGlobal.Cost THEN
          info^.CodeGlobal.Cost := cost;
          info^.CodeGlobal.Proc := yyF44CodeGlobal;
        END;
      END;
      
      IF yyMatch [46] THEN
        cost := 1
        + CostCodeCodes (yyt^.Sections.section^.Local.codes)
        + CostCodeLocal (yyt^.Sections.sections);
        IF cost < info^.CodeLocal.Cost THEN
          info^.CodeLocal.Cost := cost;
          info^.CodeLocal.Proc := yyF46CodeLocal;
        END;
      END;
      
      IF yyMatch [47] THEN
        cost := 1
        + CostCodeLocal (yyt^.Sections.sections);
        IF cost < info^.CodeLocal.Cost THEN
          info^.CodeLocal.Cost := cost;
          info^.CodeLocal.Proc := yyF47CodeLocal;
        END;
      END;
      
      IF yyMatch [49] THEN
        cost := 1
        + CostCodeCodes (yyt^.Sections.section^.Begin.codes)
        + CostCodeBegin (yyt^.Sections.sections);
        IF cost < info^.CodeBegin.Cost THEN
          info^.CodeBegin.Cost := cost;
          info^.CodeBegin.Proc := yyF49CodeBegin;
        END;
      END;
      
      IF yyMatch [50] THEN
        cost := 1
        + CostCodeBegin (yyt^.Sections.sections);
        IF cost < info^.CodeBegin.Cost THEN
          info^.CodeBegin.Cost := cost;
          info^.CodeBegin.Proc := yyF50CodeBegin;
        END;
      END;
      
      IF yyMatch [52] THEN
        cost := 1
        + CostCodeCodes (yyt^.Sections.section^.Close.codes)
        + CostCodeClose (yyt^.Sections.sections);
        IF cost < info^.CodeClose.Cost THEN
          info^.CodeClose.Cost := cost;
          info^.CodeClose.Proc := yyF52CodeClose;
        END;
      END;
      
      IF yyMatch [53] THEN
        cost := 1
        + CostCodeClose (yyt^.Sections.sections);
        IF cost < info^.CodeClose.Cost THEN
          info^.CodeClose.Cost := cost;
          info^.CodeClose.Proc := yyF53CodeClose;
        END;
      END;
      
  | Tree.Export:
      state := 85;
      state := yyComb [state + yyTraverse (yyt^.Export.codes)];

  | Tree.Global:
      state := 87;
      state := yyComb [state + yyTraverse (yyt^.Global.codes)];

  | Tree.Local:
      state := 89;
      state := yyComb [state + yyTraverse (yyt^.Local.codes)];

  | Tree.Begin:
      state := 97;
      state := yyComb [state + yyTraverse (yyt^.Begin.codes)];

  | Tree.Codes0:
      state := 26;

      cost := 1;
      IF cost < info^.CodeCodes.Cost THEN
        info^.CodeCodes.Cost := cost;
        info^.CodeCodes.Proc := yyF56CodeCodes;
      END;
      
      cost := 1;
      IF cost < info^.CodeCodes2.Cost THEN
        info^.CodeCodes2.Cost := cost;
        info^.CodeCodes2.Proc := yyF58CodeCodes2;
      END;
      
  | Tree.Tokens0:
      state := 32;

  | Tree.Tokens:
      state := 99;
      state := yyComb [state + yyTraverse (yyt^.Tokens.token)];
      state := yyComb [state + yyTraverse (yyt^.Tokens.tokens)];

  | Tree.Token:
      state := 99;
      state := yyComb [state + yyTraverse (yyt^.Token.id)];
      state := yyComb [state + yyTraverse (yyt^.Token.number)];

  | Tree.Id:
      state := 32;

  | Tree.Number:
      state := 32;

  | Tree.Rules0:
      state := 3;

      cost := 1;
      IF cost < info^.CodeForward.Cost THEN
        info^.CodeForward.Cost := cost;
        info^.CodeForward.Proc := yyF5CodeForward;
      END;
      
      cost := 1;
      IF cost < info^.CodeRules.Cost THEN
        info^.CodeRules.Cost := cost;
        info^.CodeRules.Proc := yyF7CodeRules;
      END;
      
  | Tree.Rules:
      state := 34;
      state := yyComb [state + yyTraverse (yyt^.Rules.rule)];
      state := yyComb [state + yyTraverse (yyt^.Rules.rules)];

      cost := 1
      + CostCodeForward (yyt^.Rules.rules);
      IF cost < info^.CodeForward.Cost THEN
        info^.CodeForward.Cost := cost;
        info^.CodeForward.Proc := yyF6CodeForward;
      END;
      
      cost := 1
      + CostCodeCodes (yyt^.Rules.rule^.Rule.codes)
      + CostSetNumbers (yyt^.Rules.rule^.Rule.expr)
      + CostCodeRules (yyt^.Rules.rule^.Rule.expr)
      + CostCodeRules (yyt^.Rules.rules);
      IF cost < info^.CodeRules.Cost THEN
        info^.CodeRules.Cost := cost;
        info^.CodeRules.Proc := yyF8CodeRules;
      END;
      
  | Tree.Rule:
      state := 35;
      state := yyComb [state + yyTraverse (yyt^.Rule.id)];
      state := yyComb [state + yyTraverse (yyt^.Rule.codes)];
      state := yyComb [state + yyTraverse (yyt^.Rule.expr)];

  | Tree.Option:
      state := 140;
      state := yyComb [state + yyTraverse (yyt^.Option.expr)];

      cost := 1
      + CostCodeRules (yyt^.Option.expr);
      IF cost < info^.CodeRules.Cost THEN
        info^.CodeRules.Cost := cost;
        info^.CodeRules.Proc := yyF9CodeRules;
      END;
      
      cost := 1
      + CostSetNumbers (yyt^.Option.expr);
      IF cost < info^.SetNumbers.Cost THEN
        info^.SetNumbers.Cost := cost;
        info^.SetNumbers.Proc := yyF29SetNumbers;
      END;
      
  | Tree.Times:
      state := 168;
      state := yyComb [state + yyTraverse (yyt^.Times.expr)];

      cost := 1
      + CostCodeRules (yyt^.Times.expr);
      IF cost < info^.CodeRules.Cost THEN
        info^.CodeRules.Cost := cost;
        info^.CodeRules.Proc := yyF10CodeRules;
      END;
      
      cost := 1
      + CostSetNumbers (yyt^.Times.expr);
      IF cost < info^.SetNumbers.Cost THEN
        info^.SetNumbers.Cost := cost;
        info^.SetNumbers.Proc := yyF30SetNumbers;
      END;
      
  | Tree.Plus:
      state := 181;
      state := yyComb [state + yyTraverse (yyt^.Plus.expr)];

      cost := 1
      + CostCodeRules (yyt^.Plus.expr);
      IF cost < info^.CodeRules.Cost THEN
        info^.CodeRules.Cost := cost;
        info^.CodeRules.Proc := yyF11CodeRules;
      END;
      
      cost := 1
      + CostSetNumbers (yyt^.Plus.expr);
      IF cost < info^.SetNumbers.Cost THEN
        info^.SetNumbers.Cost := cost;
        info^.SetNumbers.Proc := yyF31SetNumbers;
      END;
      
  | Tree.List:
      state := 209;
      state := yyComb [state + yyTraverse (yyt^.List.body)];
      state := yyComb [state + yyTraverse (yyt^.List.sep)];

      cost := 1
      + CostCodeRules (yyt^.List.body)
      + CostCodeRules (yyt^.List.sep);
      IF cost < info^.CodeRules.Cost THEN
        info^.CodeRules.Cost := cost;
        info^.CodeRules.Proc := yyF12CodeRules;
      END;
      
      cost := 1
      + CostSetNumbers (yyt^.List.body)
      + CostSetNumbers (yyt^.List.sep);
      IF cost < info^.SetNumbers.Cost THEN
        info^.SetNumbers.Cost := cost;
        info^.SetNumbers.Proc := yyF32SetNumbers;
      END;
      
  | Tree.Action:
      state := 135;
      state := yyComb [state + yyTraverse (yyt^.Action.codes)];
      match := SYSTEM.ADR (yySets [state]);
      
      yyMatch [13] := (13 IN match^[0]);

      IF yyMatch [13] THEN
        cost := 1;
        IF cost < info^.CodeRules.Cost THEN
          info^.CodeRules.Cost := cost;
          info^.CodeRules.Proc := yyF13CodeRules;
        END;
      END;
      
      cost := 1
      + CostCodeCodes (yyt^.Action.codes);
      IF cost < info^.CodeRules.Cost THEN
        info^.CodeRules.Cost := cost;
        info^.CodeRules.Proc := yyF14CodeRules;
      END;
      
      cost := 1;
      IF cost < info^.SetNumbers.Cost THEN
        info^.SetNumbers.Cost := cost;
        info^.SetNumbers.Proc := yyF33SetNumbers;
      END;
      
  | Tree.Leaf:
      state := 36;
      state := yyComb [state + yyTraverse (yyt^.Leaf.id)];
      yyMatch [15] := TRUE & (          (* line 833 CodeC.aftermpp *)
 IsTerm (yyt^.Leaf.id^.Id.ident) & yyt^.Leaf.sure & NOT yyt^.Leaf.id^.Id.isstring );
      yyMatch [16] := TRUE & (          (* line 858 CodeC.aftermpp *)
 IsTerm (yyt^.Leaf.id^.Id.ident) & yyt^.Leaf.sure & yyt^.Leaf.id^.Id.isstring );
      yyMatch [17] := TRUE & (          (* line 877 CodeC.aftermpp *)
 IsTerm (yyt^.Leaf.id^.Id.ident) & NOT yyt^.Leaf.sure & NOT yyt^.Leaf.id^.Id.isstring );
      yyMatch [18] := TRUE & (          (* line 892 CodeC.aftermpp *)
 IsTerm (yyt^.Leaf.id^.Id.ident) & NOT yyt^.Leaf.sure & yyt^.Leaf.id^.Id.isstring );
      yyMatch [19] := TRUE & (          (* line 904 CodeC.aftermpp *)
 IsNonterm (yyt^.Leaf.id^.Id.ident) );
      yyMatch [38] := TRUE & (          (* line 1079 CodeC.aftermpp *)
 yyt^.Leaf.id^.Id.isstring );
      yyMatch [39] := TRUE & (          (* line 1085 CodeC.aftermpp *)
 NOT yyt^.Leaf.id^.Id.isstring );

      IF yyMatch [15] THEN
        cost := 1;
        IF cost < info^.CodeRules.Cost THEN
          info^.CodeRules.Cost := cost;
          info^.CodeRules.Proc := yyF15CodeRules;
        END;
      END;
      
      IF yyMatch [16] THEN
        cost := 1;
        IF cost < info^.CodeRules.Cost THEN
          info^.CodeRules.Cost := cost;
          info^.CodeRules.Proc := yyF16CodeRules;
        END;
      END;
      
      IF yyMatch [17] THEN
        cost := 1;
        IF cost < info^.CodeRules.Cost THEN
          info^.CodeRules.Cost := cost;
          info^.CodeRules.Proc := yyF17CodeRules;
        END;
      END;
      
      IF yyMatch [18] THEN
        cost := 1;
        IF cost < info^.CodeRules.Cost THEN
          info^.CodeRules.Cost := cost;
          info^.CodeRules.Proc := yyF18CodeRules;
        END;
      END;
      
      IF yyMatch [19] THEN
        cost := 1;
        IF cost < info^.CodeRules.Cost THEN
          info^.CodeRules.Cost := cost;
          info^.CodeRules.Proc := yyF19CodeRules;
        END;
      END;
      
      IF yyMatch [38] THEN
        cost := 1;
        IF cost < info^.SetNumbers.Cost THEN
          info^.SetNumbers.Cost := cost;
          info^.SetNumbers.Proc := yyF38SetNumbers;
        END;
      END;
      
      IF yyMatch [39] THEN
        cost := 1;
        IF cost < info^.SetNumbers.Cost THEN
          info^.SetNumbers.Cost := cost;
          info^.SetNumbers.Proc := yyF39SetNumbers;
        END;
      END;
      
  | Tree.Alternative0:
      state := 14;
      yyMatch [22] := TRUE & (          (* line 917 CodeC.aftermpp *)
 yyt^.alternative.case );
      yyMatch [23] := TRUE & (          (* line 934 CodeC.aftermpp *)
 NOT yyt^.alternative.case );

      cost := 1;
      IF cost < info^.CodeAltCase.Cost THEN
        info^.CodeAltCase.Cost := cost;
        info^.CodeAltCase.Proc := yyF24CodeAltCase;
      END;
      
      cost := 1;
      IF cost < info^.CodeAltIf.Cost THEN
        info^.CodeAltIf.Cost := cost;
        info^.CodeAltIf.Proc := yyF26CodeAltIf;
      END;
      
      cost := 1;
      IF cost < info^.SetNumbers.Cost THEN
        info^.SetNumbers.Cost := cost;
        info^.SetNumbers.Proc := yyF36SetNumbers;
      END;
      
      REPEAT
        success := FALSE;
        IF yyMatch [22] THEN
          cost := 1
          + CostCodeAltCase (yyt);
          IF cost < info^.CodeRules.Cost THEN
            info^.CodeRules.Cost := cost;
            info^.CodeRules.Proc := yyF22CodeRules;
            success := TRUE;
          END;
        END;
        
        IF yyMatch [23] THEN
          cost := 1
          + CostCodeAltIf (yyt);
          IF cost < info^.CodeRules.Cost THEN
            info^.CodeRules.Cost := cost;
            info^.CodeRules.Proc := yyF23CodeRules;
            success := TRUE;
          END;
        END;
        
      UNTIL NOT success;
  | Tree.Alternative:
      state := 250;
      state := yyComb [state + yyTraverse (yyt^.Alternative.expr)];
      state := yyComb [state + yyTraverse (yyt^.Alternative.alternative)];
      match := SYSTEM.ADR (yySets [state]);
      
      yyMatch [22] := TRUE & (          (* line 917 CodeC.aftermpp *)
 yyt^.alternative.case );
      yyMatch [23] := TRUE & (          (* line 934 CodeC.aftermpp *)
 NOT yyt^.alternative.case );
      yyMatch [27] := (27 IN match^[0]);

      cost := 1
      + CostCodeRules (yyt^.Alternative.expr)
      + CostCodeAltCase (yyt^.Alternative.alternative);
      IF cost < info^.CodeAltCase.Cost THEN
        info^.CodeAltCase.Cost := cost;
        info^.CodeAltCase.Proc := yyF25CodeAltCase;
      END;
      
      IF yyMatch [27] THEN
        cost := 1
        + CostCodeRules (yyt^.Alternative.expr);
        IF cost < info^.CodeAltIf.Cost THEN
          info^.CodeAltIf.Cost := cost;
          info^.CodeAltIf.Proc := yyF27CodeAltIf;
        END;
      END;
      
      cost := 1
      + CostCodeRules (yyt^.Alternative.expr)
      + CostCodeAltIf (yyt^.Alternative.alternative);
      IF cost < info^.CodeAltIf.Cost THEN
        info^.CodeAltIf.Cost := cost;
        info^.CodeAltIf.Proc := yyF28CodeAltIf;
      END;
      
      cost := 1
      + CostSetNumbers (yyt^.Alternative.expr)
      + CostSetNumbers (yyt^.Alternative.alternative);
      IF cost < info^.SetNumbers.Cost THEN
        info^.SetNumbers.Cost := cost;
        info^.SetNumbers.Proc := yyF37SetNumbers;
      END;
      
      REPEAT
        success := FALSE;
        IF yyMatch [22] THEN
          cost := 1
          + CostCodeAltCase (yyt);
          IF cost < info^.CodeRules.Cost THEN
            info^.CodeRules.Cost := cost;
            info^.CodeRules.Proc := yyF22CodeRules;
            success := TRUE;
          END;
        END;
        
        IF yyMatch [23] THEN
          cost := 1
          + CostCodeAltIf (yyt);
          IF cost < info^.CodeRules.Cost THEN
            info^.CodeRules.Cost := cost;
            info^.CodeRules.Proc := yyF23CodeRules;
            success := TRUE;
          END;
        END;
        
      UNTIL NOT success;
  | Tree.Sequence0:
      state := 12;

      cost := 1;
      IF cost < info^.CodeRules.Cost THEN
        info^.CodeRules.Cost := cost;
        info^.CodeRules.Proc := yyF20CodeRules;
      END;
      
      cost := 1;
      IF cost < info^.SetNumbers.Cost THEN
        info^.SetNumbers.Cost := cost;
        info^.SetNumbers.Proc := yyF34SetNumbers;
      END;
      
  | Tree.Sequence:
      state := 264;
      state := yyComb [state + yyTraverse (yyt^.Sequence.expr)];
      state := yyComb [state + yyTraverse (yyt^.Sequence.sequence)];

      cost := 1
      + CostCodeRules (yyt^.Sequence.expr)
      + CostCodeRules (yyt^.Sequence.sequence);
      IF cost < info^.CodeRules.Cost THEN
        info^.CodeRules.Cost := cost;
        info^.CodeRules.Proc := yyF21CodeRules;
      END;
      
      cost := 1
      + CostSetNumbers (yyt^.Sequence.expr)
      + CostSetNumbers (yyt^.Sequence.sequence);
      IF cost < info^.SetNumbers.Cost THEN
        info^.SetNumbers.Cost := cost;
        info^.SetNumbers.Proc := yyF35SetNumbers;
      END;
      
  END;
  RETURN state;
END yyTraverse;

PROCEDURE yyErrorCheck (i: INTEGER; s1, s2: ARRAY OF CHAR);
BEGIN
  IF i < 0 THEN
    IO.WriteS (IO.StdError, s1);
    IO.WriteS (IO.StdError, s2);
    IO.WriteNl (IO.StdError); IO.CloseIO; HALT;
  END;
END yyErrorCheck;

PROCEDURE BeginCodeC;
VAR yyf: System.tFile; yyi: INTEGER;
BEGIN
  yyf := System.OpenInput (CodeCTabName);
  yyErrorCheck (yyf, 'cannot open ', CodeCTabName);
  yyi := System.Read (yyf, SYSTEM.ADR (yySets), SYSTEM.TSIZE (yySetsType));
  yyErrorCheck (yyi, 'cannot read ', CodeCTabName);
  yyi := System.Read (yyf, SYSTEM.ADR (yyComb), SYSTEM.TSIZE (yyCombType));
  yyErrorCheck (yyi, 'cannot read ', CodeCTabName);
  System.Close (yyf);
    (* line 254 CodeC.aftermpp *)

  vExport := FALSE;
  SpaCo := 0;
  Label := 0;
  Hex [0] := '0';
  Hex [1] := '1';
  Hex [2] := '2';
  Hex [3] := '3';
  Hex [4] := '4';
  Hex [5] := '5';
  Hex [6] := '6';
  Hex [7] := '7';
  Hex [8] := '8';
  Hex [9] := '9';
  Hex [10] := 'A';
  Hex [11] := 'B';
  Hex [12] := 'C';
  Hex [13] := 'D';
  Hex [14] := 'E';
  Hex [15] := 'F';

END BeginCodeC;

PROCEDURE DoCodeC (yyt: Tree.tTree);
VAR yystate: yyStateType;
BEGIN
  yystate := yyTraverse (yyt);
  CODE (yyt);
  yyReleaseHeap;
END DoCodeC;

PROCEDURE CloseCodeC;
BEGIN

END CloseCodeC;

BEGIN
  CodeCTabName := 'CodeC.tab';
  WITH yyInfo DO
    CODE.Cost := yyInfinite;
    CODE.Proc := yyECODE;
    CodeDef.Cost := yyInfinite;
    CodeDef.Proc := yyECodeDef;
    CodeImp.Cost := yyInfinite;
    CodeImp.Proc := yyECodeImp;
    CodeForward.Cost := yyInfinite;
    CodeForward.Proc := yyECodeForward;
    CodeRules.Cost := yyInfinite;
    CodeRules.Proc := yyECodeRules;
    CodeAltCase.Cost := yyInfinite;
    CodeAltCase.Proc := yyECodeAltCase;
    CodeAltIf.Cost := yyInfinite;
    CodeAltIf.Proc := yyECodeAltIf;
    SetNumbers.Cost := yyInfinite;
    SetNumbers.Proc := yyESetNumbers;
    CodeExport.Cost := yyInfinite;
    CodeExport.Proc := yyECodeExport;
    CodeGlobal.Cost := yyInfinite;
    CodeGlobal.Proc := yyECodeGlobal;
    CodeLocal.Cost := yyInfinite;
    CodeLocal.Proc := yyECodeLocal;
    CodeBegin.Cost := yyInfinite;
    CodeBegin.Proc := yyECodeBegin;
    CodeClose.Cost := yyInfinite;
    CodeClose.Proc := yyECodeClose;
    CodeCodes.Cost := yyInfinite;
    CodeCodes.Proc := yyECodeCodes;
    CodeCodes2.Cost := yyInfinite;
    CodeCodes2.Proc := yyECodeCodes2;
  END;
  yyBlockList:= NIL;
  yyPoolFreePtr:= NIL;
  yyPoolEndPtr:= NIL;
END CodeC.
