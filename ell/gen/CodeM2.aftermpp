(*
 *	ell2 - a redesign of ell
 *
 *	$RCSfile: CodeM2.ESTRA,v $
 *	
 *	purpose:	generation of MODULA2 code
 *
 *	$Author: grosch $
 *	$Date: 1992/10/15 18:26:55 $
 *)













TRANSFORMATION	CodeM2

GLOBAL	{
FROM ArgCheck	IMPORT	DEF, IMP, SourceFileName;
FROM Checks	IMPORT	CheckWriteOpen, CheckOpenOutput;
FROM Codes	IMPORT	cNoIndex, vMaxRecSetIndex, vMaxSetIndex, EmptyRecSetIndex,
			Code, MaxCode, WriteIndex, WriteRecIndex, GetSet, GetRecSet;
FROM DynArray	IMPORT	MakeArray, ReleaseArray;
FROM Errors	IMPORT	ERROR;
FROM IO		IMPORT	tFile, WriteS, WriteI, WriteNl, WriteOpen, WriteClose;
FROM Idents	IMPORT	tIdent, NoIdent, WriteIdent, MaxIdent, GetString;
FROM Sets	IMPORT	tSet, MakeSet, ReleaseSet, Extract, IsEmpty, Assign, IsElement, Exclude;
FROM StringMem	IMPORT	WriteString;
FROM SYSTEM	IMPORT	TSIZE, ADR;
FROM System	IMPORT	OpenOutput, Write, Close;
FROM Scanner	IMPORT	Epsilon;
FROM Types	IMPORT	IsTerm, IsNonterm, Terminals;
FROM Strings	IMPORT	tString, Char, ArrayToString, Concatenate, Append, StringToArray;
FROM Tree	IMPORT	ScannerName, ParserName;

CONST
  cBitsPerBitset	= 32;
  cDefinition		= '.md';
  cImplementation	= '.mi';
  cTable		= '.Tab';

VAR
  file		: tFile;
  SpaCo		: INTEGER;
  vExport	: BOOLEAN;
  InDefault	: BOOLEAN;
  lSections	: Tree.tTree;
  PathS, String	: tString;
  PathA		: ARRAY [0..128] OF CHAR;

PROCEDURE Prefix;
  BEGIN
    IF ScannerName # NoIdent THEN
Spaces;WriteIdent (file, ScannerName);
    ELSE
WriteS (file, 'Scanner');
    END;
  END Prefix;

PROCEDURE Spaces;
  VAR i: INTEGER;
  BEGIN FOR i := 1 TO SpaCo DO WriteS (file, '  '); END; END Spaces;

PROCEDURE CodeIsElement (index: INTEGER; set: tSet);
  VAR
    todo: tSet;
    id: tIdent;
  BEGIN
    IF index = cNoIndex THEN
      MakeSet (todo, MaxIdent ());
      Assign (todo, set);
      Exclude (todo, Epsilon);
      IF NOT IsEmpty (todo) THEN
	LOOP
	  id := Extract (todo);
	  WriteS (file, '(xxToken = ');
	  WriteI (file, Code (id), 0);
	  WriteS (file, ' (* ');
	  WriteIdent (file, id);
	  WriteS (file, ' *))');
	  IF IsEmpty (todo) THEN EXIT END;
	  WriteS (file, ' OR ');
	END;
      END;
      ReleaseSet (todo);
    ELSE
      WriteS (file, '(');
      WriteI (file, index MOD cBitsPerBitset, 0);
      WriteS (file, ' IN xxVerticalSet');
      WriteI (file, index DIV cBitsPerBitset, 0);
      WriteS (file, ' [xxToken] (* ');
      WriteIndex (file, index);
      WriteS (file, ' *))');
    END;
  END CodeIsElement;

PROCEDURE CodeRecovery (recover, expect: INTEGER);
  BEGIN
    IF expect = cNoIndex THEN
WriteS (file, 'xxUnexpected (');WriteI (file, recover, 0);WriteS (file, ', xxGlobalRecoverySet); (* ');WriteRecIndex (file, recover);WriteS (file, ' *)');WriteNl (file);
    ELSE
Spaces;WriteS (file, 'xxExpected (');WriteI (file, expect, 0);WriteS (file, ', ');WriteI (file, recover, 0);WriteS (file, ', xxGlobalRecoverySet); (* ');WriteRecIndex (file, expect);WriteS (file, ' / ');WriteRecIndex (file, recover);WriteS (file, ' *)');WriteNl (file);
    END;
  END CodeRecovery;

PROCEDURE WriteLabels (set: tSet);
  VAR
    todo: tSet;
    id: tIdent;
  BEGIN
    MakeSet (todo, MaxIdent ());
    Assign (todo, set);
    Spaces;
    WriteS (file, '| ');
    IF NOT IsEmpty (todo) THEN
      LOOP
	id := Extract (todo);
	WriteI (file, Code (id), 0);
	WriteS (file, ' (* ');
	WriteIdent (file, id);
	WriteS (file, ' *)');
	IF IsEmpty (todo) THEN EXIT END;
	WriteS (file, ', ');
      END;
    END;
    WriteS (file, ':');
    WriteNl (file);
    ReleaseSet (todo);
  END WriteLabels;

VAR
  NumberArray		: POINTER TO ARRAY [0..1000] OF INTEGER;
  NumberArraySize	: LONGINT;
  MaxNumberArray	: POINTER TO ARRAY [0..1000] OF INTEGER;
  MaxNumberArraySize	: LONGINT;

PROCEDURE ClearArray (VAR a: ARRAY OF INTEGER);
  VAR id: tIdent;
  BEGIN
    FOR id := 0 TO MaxIdent () DO a [id] := 0; END;
  END ClearArray;

PROCEDURE WriteAttributes;
  VAR
    id: tIdent;
    i, max: INTEGER;
  BEGIN
    FOR id := 0 TO MaxIdent () DO
      max := MaxNumberArray^ [id];
      IF max > 0 THEN
Spaces;
	FOR i := 1 TO max - 1 DO
WriteIdent (file, id);WriteI (file, i, 0);WriteS (file, ', ');
	END;
WriteIdent (file, id);WriteI (file, max, 0);WriteS (file, ': ');
	IF IsTerm (id) THEN
	  Prefix;
WriteS (file, '.tScanAttribute');
	ELSE
WriteS (file, 'tParsAttribute');
	END;
WriteS (file, ';');WriteNl (file);
      END;
    END;
  END WriteAttributes;

PROCEDURE WriteParsTab;
  VAR
    bitset: BITSET;
    set: tSet;
    sets: ARRAY [0..cBitsPerBitset-1] OF tSet;
    size: INTEGER;
    code,i,bit: INTEGER;
    index: INTEGER;
  BEGIN
    GetString		(ParserName, PathS);
    ArrayToString	(cTable, String);
    Concatenate		(PathS, String);
    Append		(PathS, 0C);
    StringToArray	(PathS, PathA);
    file := OpenOutput	(PathA);
    CheckOpenOutput	(file, PathA);

    MakeSet (set, MaxCode ());
    FOR index := 0 TO vMaxRecSetIndex DO
      GetRecSet (index, set);
      FOR i := 0 TO MaxCode () DIV cBitsPerBitset - 1 DO
	bitset := {};
        FOR bit := 0 TO cBitsPerBitset - 1 DO
	  IF IsElement (i * cBitsPerBitset + bit, set) THEN INCL (bitset, bit); END;
	END;
	size := Write (file, ADR (bitset), TSIZE (BITSET));
      END;
        i := MaxCode () DIV cBitsPerBitset;
	bitset := {};
        FOR bit := 0 TO MaxCode () MOD cBitsPerBitset DO
	  IF IsElement (i * cBitsPerBitset + bit, set) THEN INCL (bitset, bit); END;
	END;
	size := Write (file, ADR (bitset), TSIZE (BITSET));
    END;
    ReleaseSet (set);

    FOR bit := 0 TO cBitsPerBitset - 1 DO
      MakeSet (sets [bit], MaxCode ());
    END;
    FOR i := 0 TO vMaxSetIndex DIV cBitsPerBitset DO
      FOR bit := 0 TO cBitsPerBitset - 1 DO
	index := i * cBitsPerBitset + bit;
	IF index <= vMaxSetIndex THEN
	  GetSet (index, sets [bit]);
        END;
      END;
      FOR code := 0 TO MaxCode () DO
	bitset := {};
	FOR bit := 0 TO cBitsPerBitset - 1 DO 
	  IF IsElement (code, sets [bit]) THEN INCL (bitset, bit); END;
	END;
	size := Write (file, ADR (bitset), TSIZE (BITSET));
      END;
    END;
    FOR bit := 0 TO cBitsPerBitset - 1 DO
      ReleaseSet (sets [bit]);
    END;

    Close (file);
  END WriteParsTab;
}

BEGIN	{
  vExport := FALSE;
  SpaCo := 0;
  InDefault := FALSE;
}

GRAMMAR Tree

grammar		= 
| Grammar	(sections, tokens, rules)

sections	=
| Sections0	()
| Sections	(section, sections)

section		=
| Export	(codes)
| Global	(codes)
| Local		(codes)
| Begin		(codes)
| Close		(codes)

codes		=
| Codes0	()
| Codes		(code, codes)

code		=
| Code		()

tokens		=
| Tokens0	()
| Tokens	(token, tokens)

token		=
| Token		(id, number)

id		=
| Id		()

number		=
| Number	()

rules		=
| Rules0	()
| Rules		(rule, rules)

rule		=
| Rule		(id, codes, expr)

expr		=
| Option	(expr)
| Times		(expr)
| Plus		(expr)
| List		(body: expr, sep: expr)
| Action	(codes)
| Leaf		(id)

expr		->
alternative	=
| Alternative0	()
| Alternative	(expr, alternative)

expr		->
sequence	=
| Sequence0	()
| Sequence	(expr, sequence)


FUNCTION	CODE			/ grammar /

  grammar
		{
		IF DEF THEN
		  CodeDef (grammar);
		END;
		IF IMP THEN
		  CodeImp (grammar);
		  WriteParsTab;
		END;
		}


/*
 *	generate definition of parser
 */

FUNCTION	CodeDef			/ grammar /

  Grammar	(sections, tokens, rules)
		{
		GetString	(ParserName, PathS);
		ArrayToString	(cDefinition, String);
		Concatenate	(PathS, String);
		Append		(PathS, 0C);
		StringToArray	(PathS, PathA);
		file := WriteOpen (PathA);
		CheckWriteOpen	(file, PathA);

Spaces;WriteS (file, 'DEFINITION MODULE ');WriteIdent (file, ParserName);WriteS (file, ';');WriteNl (file);
Spaces;WriteNl (file);
		CodeExport (sections);
		IF NOT vExport THEN	(* Default EXPORT action *)
Spaces;WriteS (file, 'IMPORT ');
		Prefix;
WriteS (file, ';');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'TYPE tParsAttribute = ');
		Prefix;
WriteS (file, '.tScanAttribute;');WriteNl (file);
		END;
Spaces;WriteNl (file);
Spaces;WriteS (file, 'VAR');WriteNl (file);
Spaces;WriteS (file, '  ParsAttribute	: tParsAttribute;');WriteNl (file);
Spaces;WriteS (file, '  ParsTabName	: ARRAY [0..128] OF CHAR;');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'PROCEDURE ');WriteIdent (file, ParserName);WriteS (file, ' (): INTEGER;');WriteNl (file);
Spaces;WriteS (file, 'PROCEDURE Close');WriteIdent (file, ParserName);WriteS (file, ' ();');WriteNl (file);
Spaces;WriteS (file, 'PROCEDURE xxTokenName (Token: CARDINAL; VAR Name: ARRAY OF CHAR);');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'END ');WriteIdent (file, ParserName);WriteS (file, '.');WriteNl (file);
		WriteClose (file);
		}


/*
 *	generate implementation of parser
 */

FUNCTION	CodeImp			/ grammar /

  Grammar	(sections, tokens, Rules (Rule (Id (), codes, expr), rules))
		DECLARE	{ VAR
		  i	: INTEGER;
		  set	: tSet;
		  id	: tIdent;
		  s	: tString;
		}
		{
		GetString	(ParserName, PathS);
		ArrayToString	(cImplementation, String);
		Concatenate	(PathS, String);
		Append		(PathS, 0C);
		StringToArray	(PathS, PathA);
		file := WriteOpen (PathA);
		CheckWriteOpen	(file, PathA);

Spaces;WriteS (file, 'IMPLEMENTATION MODULE ');WriteIdent (file, ParserName);WriteS (file, ';');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'IMPORT Positions, Errors, ');
		Prefix;
WriteS (file, ', Strings, System, SYSTEM;');WriteNl (file);
Spaces;WriteNl (file);
		CodeGlobal (sections);
		lSections := sections;

Spaces;WriteS (file, 'CONST xxEof = 0;');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'TYPE');WriteNl (file);
Spaces;WriteS (file, '  xxtUnionPtr	= POINTER TO xxtUnion;');WriteNl (file);
Spaces;WriteS (file, '  xxtUnion	= RECORD GlobalRecoverySet: xxtUnionPtr; LocalRecoverySet: SHORTCARD; END;');WriteNl (file);
Spaces;WriteS (file, '  xxtSet	= ARRAY [0..');WriteI (file, MaxCode () DIV cBitsPerBitset, 0);WriteS (file, '] OF BITSET;');WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, 'VAR');WriteNl (file);
Spaces;WriteS (file, '  xxToken		: SHORTCARD;');WriteNl (file);
Spaces;WriteS (file, '  xxErrorCount		: INTEGER;');WriteNl (file);
Spaces;WriteS (file, '  xxIsInitialized	: BOOLEAN;');WriteNl (file);
Spaces;WriteS (file, '  xxIsRepairMode	: BOOLEAN;');WriteNl (file);
		IF vMaxRecSetIndex = cNoIndex THEN
Spaces;WriteS (file, '  xxHorizontalSet	: ARRAY [0..0] OF xxtSet;');WriteNl (file);
		ELSE
Spaces;WriteS (file, '  xxHorizontalSet	: ARRAY [0..');WriteI (file, vMaxRecSetIndex, 0);WriteS (file, '] OF xxtSet;');WriteNl (file);
		END;
		FOR i := 0 TO vMaxSetIndex DIV cBitsPerBitset DO
Spaces;WriteS (file, '  xxVerticalSet');WriteI (file, i, 0);WriteS (file, '	: ARRAY [0..');WriteI (file, MaxCode (), 0);WriteS (file, '] OF BITSET;');WriteNl (file);
		END;
Spaces;WriteNl (file);
Spaces;WriteS (file, 'PROCEDURE xxTokenName (Token: CARDINAL; VAR Name: ARRAY OF CHAR);');WriteNl (file);
Spaces;WriteS (file, '  PROCEDURE Copy (Source: ARRAY OF CHAR; VAR Target: ARRAY OF CHAR);');WriteNl (file);
Spaces;WriteS (file, '    VAR i, j: CARDINAL;');WriteNl (file);
Spaces;WriteS (file, '    BEGIN');WriteNl (file);
Spaces;WriteS (file, '      IF HIGH (Source) < HIGH (Target)');WriteNl (file);
Spaces;WriteS (file, '      THEN j := HIGH (Source); ELSE j := HIGH (Target); END;');WriteNl (file);
Spaces;WriteS (file, '      FOR i := 0 TO j DO Target [i] := Source [i]; END;');WriteNl (file);
Spaces;WriteS (file, '      IF HIGH (Target) > j THEN Target [j + 1] := CHR (0); END;');WriteNl (file);
Spaces;WriteS (file, '    END Copy;');WriteNl (file);
Spaces;WriteS (file, '  BEGIN');WriteNl (file);
Spaces;WriteS (file, '    CASE Token OF');WriteNl (file);
		MakeSet (set, MaxIdent ());
		Terminals (set);
		Exclude (set, Epsilon);
		WHILE NOT IsEmpty (set) DO
		  id := Extract (set);
		  GetString (id, s);
		  IF (Char (s, 1) = "'") THEN

Spaces;WriteS (file, '    | ');WriteI (file, Code (id), 0);WriteS (file, ': Copy (');WriteIdent (file, id);WriteS (file, ', Name);');WriteNl (file);

		  ELSIF (Char (s, 1) = '"') THEN
Spaces;WriteS (file, "    | ");WriteI (file, Code (id), 0);WriteS (file, ": Copy (");WriteIdent (file, id);WriteS (file, ", Name);");WriteNl (file);
		  ELSE
Spaces;WriteS (file, "    | ");WriteI (file, Code (id), 0);WriteS (file, ": Copy ('");WriteIdent (file, id);WriteS (file, "', Name);");WriteNl (file);
		  END;
		END;
		ReleaseSet (set);
Spaces;WriteS (file, "    END;");WriteNl (file);
Spaces;WriteS (file, "  END xxTokenName;");WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, "PROCEDURE ");WriteIdent (file, ParserName);WriteS (file, " (): INTEGER;");WriteNl (file);
INC (SpaCo);
Spaces;WriteS (file, "BEGIN");WriteNl (file);
INC (SpaCo);
Spaces;WriteS (file, "xxErrorCount := 0;");WriteNl (file);
Spaces;WriteS (file, "Begin");WriteIdent (file, ParserName);WriteS (file, ";");WriteNl (file);
Spaces;WriteS (file, "xxToken := ");
		Prefix;
WriteS (file, ".GetToken (); xxIsRepairMode := FALSE;");WriteNl (file);
Spaces;WriteS (file, "yy");WriteIdent (file, Id.ident);WriteS (file, " (ParsAttribute, NIL);");WriteNl (file);
Spaces;WriteS (file, "IF xxToken # xxEof THEN xxRecoveryLiteral (xxEof, ");WriteI (file, EmptyRecSetIndex, 0);WriteS (file, ", NIL); END;");WriteNl (file);
Spaces;WriteS (file, "RETURN xxErrorCount;");WriteNl (file);
DEC (SpaCo);
Spaces;WriteS (file, "END ");WriteIdent (file, ParserName);WriteS (file, ";");WriteNl (file);
DEC (SpaCo);
Spaces;WriteNl (file);
Spaces;WriteS (file, "PROCEDURE xxIsElement (VAR Set: xxtSet; Element: SHORTCARD): BOOLEAN;");WriteNl (file);
Spaces;WriteS (file, "  BEGIN");WriteNl (file);
Spaces;WriteS (file, "    RETURN Element MOD ");WriteI (file, cBitsPerBitset, 0);WriteS (file, " IN Set [Element DIV ");WriteI (file, cBitsPerBitset, 0);WriteS (file, "];");WriteNl (file);
Spaces;WriteS (file, "  END xxIsElement;");WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, "PROCEDURE xxUnexpected (LocalRecoverySet: SHORTCARD; GlobalRecoverySet: xxtUnionPtr);");WriteNl (file);
Spaces;WriteS (file, "  BEGIN");WriteNl (file);
Spaces;WriteS (file, "    IF NOT xxIsRepairMode THEN");WriteNl (file);
Spaces;WriteS (file, "      INC (xxErrorCount);");WriteNl (file);
Spaces;WriteS (file, "      Errors.ErrorMessage (Errors.SyntaxError, Errors.Error, ");
		Prefix;
WriteS (file, ".Attribute.Position);");WriteNl (file);
Spaces;WriteS (file, "      xxSkipTokens (LocalRecoverySet, GlobalRecoverySet);");WriteNl (file);
Spaces;WriteS (file, "    END;");WriteNl (file);
Spaces;WriteS (file, "  END xxUnexpected;");WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, "PROCEDURE xxExpected (ExpectedSet: SHORTCARD; LocalRecoverySet: SHORTCARD; GlobalRecoverySet: xxtUnionPtr);");WriteNl (file);
Spaces;WriteS (file, "  VAR");WriteNl (file);
Spaces;WriteS (file, "    Token		: SHORTCARD;");WriteNl (file);
Spaces;WriteS (file, "    TokenArray		: ARRAY [0..127] OF CHAR;");WriteNl (file);
Spaces;WriteS (file, "    TokenString		: Strings.tString;");WriteNl (file);
Spaces;WriteS (file, "    ContinueString	: Strings.tString;");WriteNl (file);
Spaces;WriteS (file, "  BEGIN");WriteNl (file);
Spaces;WriteS (file, "    IF NOT xxIsRepairMode THEN");WriteNl (file);
Spaces;WriteS (file, "      INC (xxErrorCount);");WriteNl (file);
Spaces;WriteS (file, "      Errors.ErrorMessage (Errors.SyntaxError, Errors.Error, ");
		Prefix;
WriteS (file, ".Attribute.Position);");WriteNl (file);
Spaces;WriteS (file, "      Strings.AssignEmpty (ContinueString);");WriteNl (file);
Spaces;WriteS (file, "      FOR Token := 0 TO ");WriteI (file, MaxCode (), 0);WriteS (file, " DO");WriteNl (file);
Spaces;WriteS (file, "        IF xxIsElement (xxHorizontalSet [ExpectedSet], Token) THEN");WriteNl (file);
Spaces;WriteS (file, "	  xxTokenName (Token, TokenArray);");WriteNl (file);
Spaces;WriteS (file, "	  Strings.ArrayToString (TokenArray, TokenString);");WriteNl (file);
Spaces;WriteS (file, "	  IF (Strings.Length (ContinueString) + Strings.Length (TokenString) + 1 <= Strings.cMaxStrLength) THEN");WriteNl (file);
Spaces;WriteS (file, "	    Strings.Concatenate (ContinueString, TokenString);");WriteNl (file);
Spaces;WriteS (file, "	    Strings.Append (ContinueString, ' ');");WriteNl (file);
Spaces;WriteS (file, "	  END;");WriteNl (file);
Spaces;WriteS (file, "        END;");WriteNl (file);
Spaces;WriteS (file, "      END;");WriteNl (file);
Spaces;WriteS (file, "      Errors.ErrorMessageI (Errors.ExpectedTokens, Errors.Information, ");
		Prefix;
WriteS (file, ".Attribute.Position, Errors.String, SYSTEM.ADR (ContinueString));");WriteNl (file);
Spaces;WriteS (file, "      xxSkipTokens (LocalRecoverySet, GlobalRecoverySet);");WriteNl (file);
Spaces;WriteS (file, "    END;");WriteNl (file);
Spaces;WriteS (file, "  END xxExpected;");WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, "PROCEDURE xxRecoveryLiteral (Expected: SHORTCARD; LocalRecoverySet: SHORTCARD; GlobalRecoverySet: xxtUnionPtr);");WriteNl (file);
Spaces;WriteS (file, "  VAR TokenString: ARRAY [0..127] OF CHAR;");WriteNl (file);
Spaces;WriteS (file, "  BEGIN");WriteNl (file);
Spaces;WriteS (file, "    IF NOT xxIsRepairMode THEN");WriteNl (file);
Spaces;WriteS (file, "      INC (xxErrorCount);");WriteNl (file);
Spaces;WriteS (file, "      Errors.ErrorMessage (Errors.SyntaxError, Errors.Error, ");
		Prefix;
WriteS (file, ".Attribute.Position);");WriteNl (file);
Spaces;WriteS (file, "      xxTokenName (Expected, TokenString);");WriteNl (file);
Spaces;WriteS (file, "      Errors.ErrorMessageI (Errors.ExpectedTokens, Errors.Information, ");
		Prefix;
WriteS (file, ".Attribute.Position, Errors.Array, SYSTEM.ADR (TokenString));");WriteNl (file);
Spaces;WriteS (file, "      xxSkipTokens (LocalRecoverySet, GlobalRecoverySet);");WriteNl (file);
Spaces;WriteS (file, "    END;");WriteNl (file);
Spaces;WriteS (file, "    IF xxToken # Expected THEN");WriteNl (file);
Spaces;WriteS (file, "      xxTokenName (Expected, TokenString);");WriteNl (file);
Spaces;WriteS (file, "      Errors.ErrorMessageI (Errors.TokenInserted, Errors.Repair, ");
		Prefix;
WriteS (file, ".Attribute.Position, Errors.Array, SYSTEM.ADR (TokenString));");WriteNl (file);
Spaces;WriteS (file, "    ELSE");WriteNl (file);
Spaces;WriteS (file, "      IF xxToken # xxEof THEN xxToken := ");
		Prefix;
WriteS (file, ".GetToken (); END;");WriteNl (file);
Spaces;WriteS (file, "      xxIsRepairMode := FALSE;");WriteNl (file);
Spaces;WriteS (file, "    END;");WriteNl (file);
Spaces;WriteS (file, "  END xxRecoveryLiteral;");WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, "PROCEDURE xxRecoveryTerminal (Expected: SHORTCARD; LocalRecoverySet: SHORTCARD; GlobalRecoverySet: xxtUnionPtr; VAR RepairAttribute: ");
		Prefix;
WriteS (file, ".tScanAttribute);");WriteNl (file);
Spaces;WriteS (file, "  VAR TokenString: ARRAY [0..127] OF CHAR;");WriteNl (file);
Spaces;WriteS (file, "  BEGIN");WriteNl (file);
Spaces;WriteS (file, "    IF NOT xxIsRepairMode THEN");WriteNl (file);
Spaces;WriteS (file, "      INC (xxErrorCount);");WriteNl (file);
Spaces;WriteS (file, "      Errors.ErrorMessage (Errors.SyntaxError, Errors.Error, ");
		Prefix;
WriteS (file, ".Attribute.Position);");WriteNl (file);
Spaces;WriteS (file, "      xxTokenName (Expected, TokenString);");WriteNl (file);
Spaces;WriteS (file, "      Errors.ErrorMessageI (Errors.ExpectedTokens, Errors.Information, ");
		Prefix;
WriteS (file, ".Attribute.Position, Errors.Array, SYSTEM.ADR (TokenString));");WriteNl (file);
Spaces;WriteS (file, "      xxSkipTokens (LocalRecoverySet, GlobalRecoverySet);");WriteNl (file);
Spaces;WriteS (file, "    END;");WriteNl (file);
Spaces;WriteS (file, "    IF xxToken # Expected THEN");WriteNl (file);
Spaces;WriteS (file, "      xxTokenName (Expected, TokenString);");WriteNl (file);
Spaces;WriteS (file, "      Errors.ErrorMessageI (Errors.TokenInserted, Errors.Repair, ");
		Prefix;
WriteS (file, ".Attribute.Position, Errors.Array, SYSTEM.ADR (TokenString));");WriteNl (file);
Spaces;WriteS (file, "      ");
		Prefix;
WriteS (file, ".ErrorAttribute (Expected, RepairAttribute);");WriteNl (file);
Spaces;WriteS (file, "    ELSE");WriteNl (file);
Spaces;WriteS (file, "      RepairAttribute := ");
		Prefix;
WriteS (file, ".Attribute;");WriteNl (file);
Spaces;WriteS (file, "      IF xxToken # xxEof THEN xxToken := ");
		Prefix;
WriteS (file, ".GetToken (); END;");WriteNl (file);
Spaces;WriteS (file, "      xxIsRepairMode := FALSE;");WriteNl (file);
Spaces;WriteS (file, "    END;");WriteNl (file);
Spaces;WriteS (file, "  END xxRecoveryTerminal;");WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, "PROCEDURE xxSkipTokens (LocalRecoverySet: SHORTCARD; GlobalRecoverySet: xxtUnionPtr);");WriteNl (file);
Spaces;WriteS (file, "  VAR RecoverySet: xxtSet;");WriteNl (file);
Spaces;WriteS (file, "      TokensSkipped: BOOLEAN;");WriteNl (file);
Spaces;WriteS (file, "  BEGIN");WriteNl (file);
Spaces;WriteS (file, "    RecoverySet := xxHorizontalSet [LocalRecoverySet];");WriteNl (file);
Spaces;WriteS (file, "    INCL (RecoverySet [0], xxEof);");WriteNl (file);
Spaces;WriteS (file, "    WHILE GlobalRecoverySet # NIL DO");WriteNl (file);
		FOR i := 0 TO MaxCode () DIV cBitsPerBitset DO
Spaces;WriteS (file, "      RecoverySet [");WriteI (file, i, 0);WriteS (file, "] := RecoverySet [");WriteI (file, i, 0);WriteS (file, "] + xxHorizontalSet [GlobalRecoverySet^.LocalRecoverySet] [");WriteI (file, i, 0);WriteS (file, "];");WriteNl (file);
		END;
Spaces;WriteS (file, "      GlobalRecoverySet := GlobalRecoverySet^.GlobalRecoverySet;");WriteNl (file);
Spaces;WriteS (file, "    END;");WriteNl (file);
Spaces;WriteS (file, "    TokensSkipped := FALSE;");WriteNl (file);
Spaces;WriteS (file, "    WHILE NOT xxIsElement (RecoverySet, xxToken) DO");WriteNl (file);
Spaces;WriteS (file, "      xxToken := ");
		Prefix;
WriteS (file, ".GetToken ();");WriteNl (file);
Spaces;WriteS (file, "      TokensSkipped := TRUE;");WriteNl (file);
Spaces;WriteS (file, "    END;");WriteNl (file);
Spaces;WriteS (file, "    IF TokensSkipped THEN");WriteNl (file);
Spaces;WriteS (file, "      Errors.ErrorMessage (Errors.RestartPoint, Errors.Information, ");
		Prefix;
WriteS (file, ".Attribute.Position);");WriteNl (file);
Spaces;WriteS (file, "    END;");WriteNl (file);
Spaces;WriteS (file, "    xxIsRepairMode := TRUE;");WriteNl (file);
Spaces;WriteS (file, "  END xxSkipTokens;");WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, "PROCEDURE Begin");WriteIdent (file, ParserName);WriteS (file, ";");WriteNl (file);
Spaces;WriteS (file, "  VAR");WriteNl (file);
Spaces;WriteS (file, "    xxTableFile: System.tFile;");WriteNl (file);
Spaces;WriteS (file, "    xxSize: CARDINAL;");WriteNl (file);
Spaces;WriteS (file, "  BEGIN");WriteNl (file);
Spaces;WriteS (file, "    IF xxIsInitialized THEN RETURN; END;");WriteNl (file);
		CodeBegin (sections);
Spaces;WriteS (file, "    xxTableFile := System.OpenInput (ParsTabName);");WriteNl (file);
Spaces;WriteS (file, "    IF xxTableFile < 0 THEN");WriteNl (file);
Spaces;WriteS (file, "      Errors.ErrorMessage (Errors.ReadParseTable, Errors.Fatal, Positions.NoPosition);");WriteNl (file);
Spaces;WriteS (file, "    END;");WriteNl (file);
		IF vMaxRecSetIndex # cNoIndex THEN
Spaces;WriteS (file, "    xxSize := System.Read (xxTableFile, SYSTEM.ADR (xxHorizontalSet), SIZE (xxHorizontalSet));");WriteNl (file);
Spaces;WriteS (file, "    IF xxSize # SIZE (xxHorizontalSet) THEN");WriteNl (file);
Spaces;WriteS (file, "      Errors.ErrorMessage (Errors.ReadParseTable, Errors.Fatal, Positions.NoPosition);");WriteNl (file);
Spaces;WriteS (file, "    END;");WriteNl (file);
		END;
		FOR i := 0 TO vMaxSetIndex DIV cBitsPerBitset DO
Spaces;WriteS (file, "    xxSize := System.Read (xxTableFile, SYSTEM.ADR (xxVerticalSet");WriteI (file, i, 0);WriteS (file, "), SIZE (xxVerticalSet");WriteI (file, i, 0);WriteS (file, "));");WriteNl (file);
Spaces;WriteS (file, "    IF xxSize # SIZE (xxVerticalSet");WriteI (file, i, 0);WriteS (file, ") THEN");WriteNl (file);
Spaces;WriteS (file, "      Errors.ErrorMessage (Errors.ReadParseTable, Errors.Fatal, Positions.NoPosition);");WriteNl (file);
Spaces;WriteS (file, "    END;");WriteNl (file);
		END;
Spaces;WriteS (file, "    System.Close (xxTableFile);");WriteNl (file);
Spaces;WriteS (file, "    xxIsInitialized := TRUE;");WriteNl (file);
Spaces;WriteS (file, "  END Begin");WriteIdent (file, ParserName);WriteS (file, ";");WriteNl (file);
Spaces;WriteNl (file);
Spaces;WriteS (file, "PROCEDURE Close");WriteIdent (file, ParserName);WriteS (file, ";");WriteNl (file);
Spaces;WriteS (file, "  BEGIN");WriteNl (file);
		CodeClose (sections);
Spaces;WriteS (file, "  END Close");WriteIdent (file, ParserName);WriteS (file, ";");WriteNl (file);
Spaces;WriteNl (file);
		NumberArraySize := MaxIdent () + 1;
		MaxNumberArraySize := MaxIdent () + 1;
		MakeArray (NumberArray, NumberArraySize, TSIZE (INTEGER));
		MakeArray (MaxNumberArray, MaxNumberArraySize, TSIZE (INTEGER));
		CodeRules (Rules);
		ReleaseArray (NumberArray, NumberArraySize, TSIZE (INTEGER));
		ReleaseArray (MaxNumberArray, MaxNumberArraySize, TSIZE (INTEGER));

Spaces;WriteS (file, "BEGIN");WriteNl (file);
Spaces;WriteS (file, "  xxIsInitialized := FALSE;");WriteNl (file);
Spaces;WriteS (file, "  ParsTabName := '");WriteIdent (file, ParserName);WriteS (file, cTable);WriteS (file, "';");WriteNl (file);
Spaces;WriteS (file, "END ");WriteIdent (file, ParserName);WriteS (file, ".");WriteNl (file);

		WriteClose (file);
		}

  Grammar	(sections, tokens, Rules0 ())
		{
		ERROR ('CodeM2.ESTRA: no rules');
		}


/*
 *	generate recursive descent procedure
 */

FUNCTION	CodeRules		/rules, expr/

  Rules0	() {}

  Rules		(Rule (Id (), codes, expr), rules)
		{
		ClearArray (MaxNumberArray^);
		SetNumbers (expr, TRUE);
Spaces;WriteS (file, "PROCEDURE yy");WriteIdent (file, Id.ident);WriteS (file, " (VAR ");WriteIdent (file, Id.ident);WriteS (file, "0: tParsAttribute; xxGlobalRecoverySet: xxtUnionPtr);");WriteNl (file);
INC (SpaCo);
Spaces;WriteS (file, "VAR");WriteNl (file);
INC (SpaCo);
		  WriteAttributes;
		  IF Rule.iscalling THEN
Spaces;WriteS (file, "xxUnion: xxtUnion;");WriteNl (file);
		  END;
		  CodeLocal (lSections);
		  CodeCodes (codes);
DEC (SpaCo);
Spaces;WriteS (file, "BEGIN");WriteNl (file);
INC (SpaCo);
		  IF Rule.iscalling THEN
Spaces;WriteS (file, "xxUnion.GlobalRecoverySet := xxGlobalRecoverySet;");WriteNl (file);
		  END;
		  CodeRules (expr);
DEC (SpaCo);
Spaces;WriteS (file, "END yy");WriteIdent (file, Id.ident);WriteS (file, ";");WriteNl (file);
DEC (SpaCo);
Spaces;WriteNl (file);
		CodeRules (rules);
		}

  Option	(expr)
		{
Spaces;WriteS (file, "LOOP");WriteNl (file);
INC (SpaCo);
Spaces;WriteS (file, "IF ");
		    CodeIsElement (Option.index, Option.first);
WriteS (file, " THEN");WriteNl (file);
INC (SpaCo);
		    InDefault := FALSE;
		    CodeRules (expr);
Spaces;WriteS (file, "EXIT;");WriteNl (file);
DEC (SpaCo);
Spaces;WriteS (file, "ELSIF ");
		    CodeIsElement (Option.followindex, Option.follow);
WriteS (file, " OR xxIsRepairMode THEN EXIT; END;");WriteNl (file);
		  CodeRecovery (Option.recindex, Option.expindex);
DEC (SpaCo);
Spaces;WriteS (file, "END;");WriteNl (file);
		}

  Times		(expr)
		{
Spaces;WriteS (file, "LOOP");WriteNl (file);
INC (SpaCo);
Spaces;WriteS (file, "IF ");
		    CodeIsElement (Times.index, Times.first);
WriteS (file, " THEN");WriteNl (file);
INC (SpaCo);
		    InDefault := FALSE;
		    CodeRules (expr);
DEC (SpaCo);
Spaces;WriteS (file, "ELSIF ");
		    CodeIsElement (Times.followindex, Times.follow);
WriteS (file, " OR xxIsRepairMode THEN EXIT;");WriteNl (file);
Spaces;WriteS (file, "ELSE");WriteNl (file);
Spaces;WriteS (file, " ");WriteNl (file);
		    CodeRecovery (Times.recindex, Times.expindex);
Spaces;WriteS (file, "END;");WriteNl (file);
DEC (SpaCo);
Spaces;WriteS (file, "END;");WriteNl (file);
		}

  Plus		(expr)
		{
Spaces;WriteS (file, "LOOP");WriteNl (file);
INC (SpaCo);
		  CodeRules (expr);
Spaces;WriteS (file, "IF NOT (");
		    CodeIsElement (Plus.index, Plus.first);
WriteS (file, ") THEN");WriteNl (file);
INC (SpaCo);
Spaces;WriteS (file, "IF ");
		      CodeIsElement (Plus.followindex, Plus.follow);
WriteS (file, " THEN EXIT; END;");WriteNl (file);
		    CodeRecovery (Plus.recindex, Plus.expindex);
Spaces;WriteS (file, "IF NOT (");
		      CodeIsElement (Plus.index, Plus.first);
WriteS (file, ") THEN EXIT; END;");WriteNl (file);
DEC (SpaCo);
Spaces;WriteS (file, "END;");WriteNl (file);
DEC (SpaCo);
Spaces;WriteS (file, "END;");WriteNl (file);
		}

  List		(body: expr, sep: expr)
		{
Spaces;WriteS (file, "LOOP");WriteNl (file);
INC (SpaCo);
		  CodeRules (body);
Spaces;WriteS (file, "IF NOT (");
		    CodeIsElement (sep.index, sep.first);
WriteS (file, ") THEN");WriteNl (file);
INC (SpaCo);
Spaces;WriteS (file, "IF ");
		      CodeIsElement (List.followindex, List.follow);
WriteS (file, " THEN EXIT; END;");WriteNl (file);
		    CodeRecovery (List.recindex, List.expindex);
Spaces;WriteS (file, "IF NOT (");
		      CodeIsElement (sep.index, sep.first);
WriteS (file, " OR ");
		      CodeIsElement (List.index, List.first);
WriteS (file, ") THEN EXIT; END;");WriteNl (file);
DEC (SpaCo);
Spaces;WriteS (file, "END;");WriteNl (file);
		  CodeRules (sep);
DEC (SpaCo);
Spaces;WriteS (file, "END;");WriteNl (file);
		}

  Action	(Codes0 ()) {}

  Action	(codes) { CodeCodes (codes); }

  Leaf		(Id ())
		CONDITION	{ IsTerm (Id.ident) & Leaf.sure & NOT Id.isstring }
		{
		IF InDefault THEN
Spaces;WriteS (file, "IF xxToken # ");WriteI (file, Code (Id.ident), 0);WriteS (file, " (* ");WriteIdent (file, Id.ident);WriteS (file, " *) THEN");WriteNl (file);
Spaces;WriteS (file, "  xxRecoveryTerminal (");WriteI (file, Code (Id.ident), 0);WriteS (file, ", ");WriteI (file, Leaf.recindex, 0);WriteS (file, ", xxGlobalRecoverySet, ");WriteIdent (file, Id.ident);WriteI (file, Leaf.number, 0);WriteS (file, "); (* ");WriteRecIndex (file, Leaf.recindex);WriteS (file, " *)");WriteNl (file);
Spaces;WriteS (file, "ELSE");WriteNl (file);
Spaces;WriteS (file, "  ");WriteIdent (file, Id.ident);WriteI (file, Leaf.number, 0);WriteS (file, " := ");
		Prefix;
WriteS (file, ".Attribute;");WriteNl (file);
Spaces;WriteS (file, "  xxToken := ");
		Prefix;
WriteS (file, ".GetToken (); xxIsRepairMode := FALSE;");WriteNl (file);
Spaces;WriteS (file, "END;");WriteNl (file);
		  InDefault := FALSE;
		ELSE
Spaces;WriteIdent (file, Id.ident);WriteI (file, Leaf.number, 0);WriteS (file, " := ");
		Prefix;
WriteS (file, ".Attribute;");WriteNl (file);
Spaces;WriteS (file, "xxToken := ");
		Prefix;
WriteS (file, ".GetToken (); xxIsRepairMode := FALSE;");WriteNl (file);
		END;
		}

  Leaf		(Id ())
		CONDITION	{ IsTerm (Id.ident) & Leaf.sure & Id.isstring }
		{
		IF InDefault THEN
Spaces;WriteS (file, "IF xxToken # ");WriteI (file, Code (Id.ident), 0);WriteS (file, " (* ");WriteIdent (file, Id.ident);WriteS (file, " *) THEN");WriteNl (file);
Spaces;WriteS (file, "  xxRecoveryLiteral (");WriteI (file, Code (Id.ident), 0);WriteS (file, ", ");WriteI (file, Leaf.recindex, 0);WriteS (file, ", xxGlobalRecoverySet); (* ");WriteRecIndex (file, Leaf.recindex);WriteS (file, " *)");WriteNl (file);
Spaces;WriteS (file, "ELSE");WriteNl (file);
Spaces;WriteS (file, "  xxToken := ");
		Prefix;
WriteS (file, ".GetToken (); xxIsRepairMode := FALSE;");WriteNl (file);
Spaces;WriteS (file, "END;");WriteNl (file);
		  InDefault := FALSE;
		ELSE
Spaces;WriteS (file, "xxToken := ");
		Prefix;
WriteS (file, ".GetToken (); xxIsRepairMode := FALSE;");WriteNl (file);
		END;
		}

  Leaf		(Id ())
		CONDITION	{ IsTerm (Id.ident) & NOT Leaf.sure & NOT Id.isstring }
		{
Spaces;WriteS (file, "IF xxToken # ");WriteI (file, Code (Id.ident), 0);WriteS (file, " (* ");WriteIdent (file, Id.ident);WriteS (file, " *) THEN");WriteNl (file);
Spaces;WriteS (file, "  xxRecoveryTerminal (");WriteI (file, Code (Id.ident), 0);WriteS (file, ", ");WriteI (file, Leaf.recindex, 0);WriteS (file, ", xxGlobalRecoverySet, ");WriteIdent (file, Id.ident);WriteI (file, Leaf.number, 0);WriteS (file, "); (* ");WriteRecIndex (file, Leaf.recindex);WriteS (file, " *)");WriteNl (file);
Spaces;WriteS (file, "ELSE");WriteNl (file);
Spaces;WriteS (file, "  ");WriteIdent (file, Id.ident);WriteI (file, Leaf.number, 0);WriteS (file, " := ");
		Prefix;
WriteS (file, ".Attribute;");WriteNl (file);
Spaces;WriteS (file, "  xxToken := ");
		Prefix;
WriteS (file, ".GetToken (); xxIsRepairMode := FALSE;");WriteNl (file);
Spaces;WriteS (file, "END;");WriteNl (file);
		}

  Leaf		(Id ())
		CONDITION	{ IsTerm (Id.ident) & NOT Leaf.sure & Id.isstring }
		{
Spaces;WriteS (file, "IF xxToken # ");WriteI (file, Code (Id.ident), 0);WriteS (file, " (* ");WriteIdent (file, Id.ident);WriteS (file, " *) THEN");WriteNl (file);
Spaces;WriteS (file, "  xxRecoveryLiteral (");WriteI (file, Code (Id.ident), 0);WriteS (file, ", ");WriteI (file, Leaf.recindex, 0);WriteS (file, ", xxGlobalRecoverySet); (* ");WriteRecIndex (file, Leaf.recindex);WriteS (file, " *)");WriteNl (file);
Spaces;WriteS (file, "ELSE");WriteNl (file);
Spaces;WriteS (file, "  xxToken := ");
		Prefix;
WriteS (file, ".GetToken (); xxIsRepairMode := FALSE;");WriteNl (file);
Spaces;WriteS (file, "END;");WriteNl (file);
		}

  Leaf		(Id ())
		CONDITION	{ IsNonterm (Id.ident) }
		{
Spaces;WriteS (file, "xxUnion.LocalRecoverySet := ");WriteI (file, Leaf.recindex, 0);WriteS (file, "; yy");WriteIdent (file, Id.ident);WriteS (file, " (");WriteIdent (file, Id.ident);WriteI (file, Leaf.number, 0);WriteS (file, ", SYSTEM.ADR (xxUnion)); (* ");WriteRecIndex (file, Leaf.recindex);WriteS (file, " *)");WriteNl (file);
		}

  Sequence0	() {}

  Sequence	(expr, sequence)
		{
		CodeRules (expr);
		CodeRules (sequence);
		}

  alternative	CONDITION	{ alternative.case }
		{
Spaces;WriteS (file, "LOOP");WriteNl (file);
INC (SpaCo);
Spaces;WriteS (file, "CASE xxToken OF");WriteNl (file);
		  CodeAltCase (alternative);
Spaces;WriteS (file, "END;");WriteNl (file);
DEC (SpaCo);
Spaces;WriteS (file, "END;");WriteNl (file);
		}

  alternative	CONDITION	{ NOT alternative.case }
		{
		CodeAltIf (alternative, FALSE);
		}


FUNCTION	CodeAltCase			/ alternative /

  Alternative0	()
		{
Spaces;WriteS (file, "ELSE");WriteNl (file);
INC (SpaCo);
Spaces;WriteS (file, "IF xxIsRepairMode THEN");WriteNl (file);
INC (SpaCo);
		    InDefault := TRUE;
		    CodeRules (Alternative0.default);
		    InDefault := FALSE;
Spaces;WriteS (file, "EXIT;");WriteNl (file);
DEC (SpaCo);
Spaces;WriteS (file, "END;");WriteNl (file);
		  CodeRecovery (Alternative0.recindex, Alternative0.expindex);
DEC (SpaCo);
		}

  Alternative	(expr, alternative)
		{
		WriteLabels (expr.fifo);
INC (SpaCo);
		CodeRules (expr);
Spaces;WriteS (file, "EXIT;");WriteNl (file);
DEC (SpaCo);
		CodeAltCase (alternative);
		}


FUNCTION	CodeAltIf	started: BOOLEAN ->	/ alternative /

  Alternative0	()
		{
Spaces;WriteS (file, "ELSE");WriteNl (file);
INC (SpaCo);
		  CodeRecovery (Alternative0.recindex, Alternative0.expindex);
		  InDefault := TRUE;
		  CodeRules (Alternative0.default);
		  InDefault := FALSE;
DEC (SpaCo);
Spaces;WriteS (file, "END;");WriteNl (file);
		}

  Alternative	(expr, Alternative0 ())
		{
		IF NOT started THEN
Spaces;WriteS (file, "IF ");
	            CodeIsElement (Alternative.index, expr.first);
WriteS (file, " THEN");WriteNl (file);
		ELSE
Spaces;WriteS (file, "ELSE ");WriteNl (file);
		END;
INC (SpaCo);
		CodeRules (expr);
DEC (SpaCo);
Spaces;WriteS (file, "END;");WriteNl (file);
		}

  Alternative	(expr, alternative)
		{
		IF NOT started THEN
Spaces;WriteS (file, "IF ");
		ELSE
WriteS (file, "ELSIF ");
		END;
	        CodeIsElement (Alternative.index, expr.fifo);
WriteS (file, " THEN");WriteNl (file);
INC (SpaCo);
		CodeRules (expr);
DEC (SpaCo);
		CodeAltIf (alternative, TRUE);
		}


/*
 *	set numbers for attribute access
 */

FUNCTION	SetNumbers	start: BOOLEAN	->	/expr/

Option		(expr)
		{
		IF start THEN ClearArray (NumberArray^); END;
		SetNumbers (expr, FALSE);
		}

Times		(expr)
		{
		IF start THEN ClearArray (NumberArray^); END;
		SetNumbers (expr, FALSE);
		}

Plus		(expr)
		{
		IF start THEN ClearArray (NumberArray^); END;
		SetNumbers (expr, FALSE);
		}

List		(body: expr, sep: expr)
		{
		IF start THEN ClearArray (NumberArray^); END;
		SetNumbers (body, FALSE);
		SetNumbers (sep, FALSE);
		}

Action		(codes) {}

Sequence0	() {}

Sequence	(expr, sequence)
		{
		IF start THEN ClearArray (NumberArray^); END;
		SetNumbers (expr, FALSE);
		SetNumbers (sequence, FALSE);
		}

Alternative0	() { }

Alternative	(expr, alternative)
		{
		IF start THEN ClearArray (NumberArray^); END;
		SetNumbers (expr, FALSE);
		SetNumbers (alternative, start);
		}

Leaf		(Id ())
		CONDITION	{ Id.isstring }
		{
		Leaf.number := 0;
		}

Leaf		(Id ())
		CONDITION	{ NOT Id.isstring }
		{
		IF start THEN ClearArray (NumberArray^); END;
		Leaf.number := NumberArray^ [Id.ident] + 1;
		NumberArray^ [Id.ident] := Leaf.number;
		IF Leaf.number > MaxNumberArray^ [Id.ident] THEN
		  MaxNumberArray^ [Id.ident] := Leaf.number;
		END;
		}


/*
 *		common functions
 */

FUNCTION	CodeExport		/ sections /


  Sections	(Export (codes), sections)
		{
		vExport := TRUE;
		CodeCodes (codes);
		CodeExport (sections);
		}

  Sections	(section, sections)
		CONDITION	{ section^.Kind # Tree.Export }
		{
		CodeExport (sections);
		}

  Sections0	() {}


FUNCTION	CodeGlobal		/ sections /


  Sections	(Global (codes), sections)
		{
		CodeCodes (codes);
		CodeGlobal (sections);
		}

  Sections	(section, sections)
		CONDITION	{ section^.Kind # Tree.Global }
		{
		CodeGlobal (sections);
		}

  Sections0	() {}


FUNCTION	CodeLocal		/ sections /


  Sections	(Local (codes), sections)
		{
		CodeCodes (codes);
		CodeLocal (sections);
		}

  Sections	(section, sections)
		CONDITION	{ section^.Kind # Tree.Local }
		{
		CodeLocal (sections);
		}

  Sections0	() {}


FUNCTION	CodeBegin		/ sections /


  Sections	(Begin (codes), sections)
		{
		CodeCodes (codes);
		CodeBegin (sections);
		}

  Sections	(section, sections)
		CONDITION	{ section^.Kind # Tree.Begin }
		{
		CodeBegin (sections);
		}

  Sections0	() {}


FUNCTION	CodeClose		/ sections /


  Sections	(Close (codes), sections)
		{
		CodeCodes (codes);
		CodeClose (sections);
		}

  Sections	(section, sections)
		CONDITION	{ section^.Kind # Tree.Close }
		{
		CodeClose (sections);
		}

  Sections0	() {}


FUNCTION	CodeCodes		/ codes /

  Codes		(Code (), codes)
		{

WriteS (file, "(* '");WriteS (file, SourceFileName);WriteS (file, "' line ");WriteI (file, Code.pos.Line, 0);WriteS (file, " *)");WriteNl (file);
		WriteString (file, Code.ref);
		CodeCodes2 (codes);
WriteNl (file);

		}

  Codes0	() {}


FUNCTION	CodeCodes2		/ codes /

  Codes		(Code (), codes)
		{
		WriteString (file, Code.ref);
		CodeCodes2 (codes);
		}

  Codes0	() {}
