(*
 *	ell2 - a redesign of ell
 *
 *	$RCSfile: SupM2.MI,v $
 *	
 *	purpose:	generate supported modules (MODULA2)
 *
 *	$Author: grosch $
 *	$Date: 1992/10/15 18:26:55 $
 *)

IMPLEMENTATION MODULE SupM2;

.. $ WriteNl (file);
.. % WriteS (file, '%');
.. n WriteI (file, %, 0);
.. i WriteIdent (file, %);
.. s WriteS (file, %);

FROM ArgCheck	IMPORT	SourceFileName;
FROM Checks	IMPORT	CheckWriteOpen;
FROM IO		IMPORT	tFile, WriteS, WriteI, WriteNl, WriteOpen, WriteClose;
FROM Idents	IMPORT	tIdent, NoIdent, WriteIdent, GetString, MakeIdent;
FROM Tree	IMPORT	ScannerName, ParserName;
FROM Strings	IMPORT	tString, Char, ArrayToString, Concatenate, Append, StringToArray;

CONST
  cErrDef = 'Errors.md';
  cErrImp = 'Errors.mi';
  cDrvImp = 'Drv.mi';
  cScaDef = '.md';
  cScaImp = '.mi';

VAR
  PathS, String	: tString;
  PathA		: ARRAY [0..128] OF CHAR;

PROCEDURE ErrM2;
  VAR file: tFile;
  BEGIN
    file := WriteOpen (cErrDef);
    CheckWriteOpen (file, cErrDef);

.	DEFINITION MODULE Errors;
.	
.	FROM SYSTEM	IMPORT ADDRESS;
.	FROM Positions	IMPORT tPosition;
.	
.	CONST
.      \   NoText		= 0	;
.      \   SyntaxError		= 1	;	(* error codes		*)
.      \   ExpectedTokens	= 2	;
.      \   RestartPoint		= 3	;
.      \   TokenInserted	= 4	;
.      \   WrongParseTable	= 5	;
.      \   OpenParseTable	= 6	;
.      \   ReadParseTable	= 7	;
.	
.      \   Fatal		= 1	;	(* error classes	*)
.      \   Restriction		= 2	;
.      \   Error		= 3	;
.      \   Warning		= 4	;
.      \   Repair		= 5	;
.      \   Note			= 6	;
.      \   Information		= 7	;
.	
.      \   None			= 0	;
.      \   Integer		= 1	;	(* info classes		*)
.      \   Short		= 2	;
.      \   Long			= 3	;
.      \   Real			= 4	;
.      \   Boolean		= 5	;
.      \   Character		= 6	;
.      \   String		= 7	;
.      \   Array		= 8	;
.      \   Set			= 9	;
.      \   Ident		= 10	;
.	
.	VAR Exit	: PROC;
.
.	PROCEDURE ErrorMessage	(ErrorCode, ErrorClass: CARDINAL; Position: tPosition);
.	PROCEDURE ErrorMessageI	(ErrorCode, ErrorClass: CARDINAL; Position: tPosition;
.      \			 InfoClass: CARDINAL; Info: ADDRESS);
.	PROCEDURE Message  (ErrorText: ARRAY OF CHAR; ErrorClass: CARDINAL; Position: tPosition);
.	PROCEDURE MessageI (ErrorText: ARRAY OF CHAR; ErrorClass: CARDINAL; Position: tPosition;
.      \			 InfoClass: CARDINAL; Info: ADDRESS);
.	
.	END Errors.

    WriteClose (file);

    file := WriteOpen (cErrImp);
    CheckWriteOpen (file, cErrImp);

.. % WriteS (file, "%");
.	IMPLEMENTATION MODULE Errors;
.
.	FROM SYSTEM	IMPORT ADDRESS;
.	FROM IO		IMPORT tFile, StdError, WriteC, WriteNl, WriteS, WriteI,
.      \		       WriteB, WriteR, CloseIO;
.	FROM Sets	IMPORT tSet, IsElement, Size;
.	FROM Idents	IMPORT tIdent, WriteIdent;
.	FROM Positions	IMPORT tPosition, WritePosition;
.
.	IMPORT System, Strings;
.
.	PROCEDURE ErrorMessage	(ErrorCode, ErrorClass: CARDINAL; Position: tPosition);
.      \   BEGIN
.      \      WriteHead	(Position, ErrorClass);
.      \      WriteCode	(ErrorCode);
.      \      WriteTail	(ErrorClass);
.      \   END ErrorMessage;
.
.	PROCEDURE ErrorMessageI	(ErrorCode, ErrorClass: CARDINAL; Position: tPosition;
.      \			 InfoClass: CARDINAL; Info: ADDRESS);
.      \   BEGIN
.      \      WriteHead	(Position, ErrorClass);
.      \      WriteCode	(ErrorCode);
.      \      WriteInfo	(InfoClass, Info);
.      \      WriteTail	(ErrorClass);
.      \   END ErrorMessageI;
.
.	PROCEDURE Message  (ErrorText: ARRAY OF CHAR; ErrorClass: CARDINAL; Position: tPosition);
.      \   BEGIN
.      \      WriteHead	(Position, ErrorClass);
.      \      WriteS	(StdError, ErrorText);
.      \      WriteTail	(ErrorClass);
.      \   END Message;
.
.	PROCEDURE MessageI (ErrorText: ARRAY OF CHAR; ErrorClass: CARDINAL; Position: tPosition;
.      \			 InfoClass: CARDINAL; Info: ADDRESS);
.      \   BEGIN
.      \      WriteHead	(Position, ErrorClass);
.      \      WriteS	(StdError, ErrorText);
.      \      WriteInfo	(InfoClass, Info);
.      \      WriteTail	(ErrorClass);
.      \   END MessageI;
.
.	PROCEDURE WriteHead (Position: tPosition; ErrorClass: CARDINAL);
.      \   BEGIN
.      \      WritePosition (StdError, Position);
.      \      WriteS	(StdError, ': ');
.      \      CASE ErrorClass OF
.      \      |  Fatal		: WriteS (StdError, 'Fatal       ');
.      \      |  Restriction	: WriteS (StdError, 'Restriction ');
.      \      |  Error		: WriteS (StdError, 'Error       ');
.      \      |  Warning	: WriteS (StdError, 'Warning     ');
.      \      |  Repair		: WriteS (StdError, 'Repair      ');
.      \      |  Note		: WriteS (StdError, 'Note        ');
.      \      |  Information	: WriteS (StdError, 'Information ');
.      \      ELSE WriteS (StdError, 'Error class: '); WriteI (StdError, ErrorClass, 0);
.      \      END;
.      \   END WriteHead;
.
.	PROCEDURE WriteTail (ErrorClass: CARDINAL);
.      \   BEGIN
.      \      WriteNl (StdError);
.      \      IF ErrorClass = Fatal THEN Exit; END;
.      \   END WriteTail;
.
.	PROCEDURE WriteCode (ErrorCode: CARDINAL);
.      \   BEGIN
.      \      CASE ErrorCode OF
.      \      |  NoText		 :
.      \      |  SyntaxError	 : WriteS (StdError, 'syntax error'		);
.      \      |  ExpectedTokens	 : WriteS (StdError, 'expected tokens'		);
.      \      |  RestartPoint	 : WriteS (StdError, 'restart point'		);
.      \      |  TokenInserted	 : WriteS (StdError, 'token inserted '		);
.      \      |  WrongParseTable : WriteS (StdError, 'parse table mismatch'	);
.      \      |  OpenParseTable	 : WriteS (StdError, 'cannot open parse table'	);
.      \      |  ReadParseTable	 : WriteS (StdError, 'cannot read parse table'	);
.      \      ELSE WriteS (StdError, ' error code: '); WriteI (StdError, ErrorCode, 0);
.      \      END;
.      \   END WriteCode;
.
.	PROCEDURE WriteInfo	(InfoClass: CARDINAL; Info: ADDRESS);
.      \   VAR
.      \      PtrToInteger	: POINTER TO INTEGER;
.      \      PtrToShort	: POINTER TO SHORTCARD;
.      \      PtrToLong		: POINTER TO LONGINT;
.      \      PtrToReal		: POINTER TO REAL;
.      \      PtrToBoolean	: POINTER TO BOOLEAN;
.      \      PtrToCharacter	: POINTER TO CHAR;
.      \      PtrToString	: POINTER TO Strings.tString;
.      \      PtrToArray	: POINTER TO ARRAY [0..1023] OF CHAR;
.      \      PtrToIdent	: POINTER TO tIdent;
.      \   BEGIN
.      \      WriteS (StdError, ': ');
.      \      CASE InfoClass OF
.      \      | Integer	: PtrToInteger	:= Info; WriteI (StdError, PtrToInteger^, 0);
.      \      | Short  	: PtrToShort	:= Info; WriteI (StdError, PtrToShort^, 0);
.      \      | Long   	: PtrToLong	:= Info; WriteI (StdError, PtrToLong^, 0);
.      \      | Real   	: PtrToReal	:= Info; WriteR (StdError, PtrToReal^, 1, 10, 1);
.      \      | Boolean	: PtrToBoolean	:= Info; WriteB (StdError, PtrToBoolean^);
.      \      | Character:PtrToCharacter:= Info; WriteC (StdError, PtrToCharacter^);
.      \      | String	: PtrToString	:= Info; Strings.WriteS (StdError, PtrToString^);
.      \      | Array	: PtrToArray	:= Info; WriteS (StdError, PtrToArray^);
.      \      | Ident	: PtrToIdent	:= Info; WriteIdent (StdError, PtrToIdent^);
.      \      ELSE
.      \      END;
.      \   END WriteInfo;
.
.	PROCEDURE yyExit;
.      \   BEGIN
.      \      CloseIO; System.Exit (1);
.      \   END yyExit;
.
.	BEGIN
.      \   Exit := yyExit;
.	END Errors.

    WriteClose (file);
  END ErrM2;
.. % WriteS (file, '%');

PROCEDURE ParM2;
  VAR file: tFile;
  BEGIN
    GetString		(ParserName, PathS);
    ArrayToString	(cDrvImp, String);
    Concatenate		(PathS, String);
    Append		(PathS, 0C);
    StringToArray	(PathS, PathA);
    file := WriteOpen	(PathA);
    CheckWriteOpen	(file, PathA);

.	MODULE {i ParserName}Drv;
.	
.	FROM {i ParserName}	IMPORT {i ParserName}, Close{i ParserName};
.	FROM IO		IMPORT CloseIO;
.	
.	BEGIN
.      \   IF {i ParserName} () = 0 THEN END;
.      \   Close{i ParserName};
.      \   CloseIO;
.	END {i ParserName}Drv.

    WriteClose (file);
  END ParM2;

PROCEDURE ScaM2;
  VAR
    file	: tFile;
    ScanName	: tIdent;
    String	: tString;
  BEGIN
    IF ScannerName = NoIdent THEN
       ArrayToString ("Scanner", String);
       ScanName := MakeIdent (String);
    ELSE
       ScanName := ScannerName;
    END;
    GetString		(ScanName, PathS);
    ArrayToString	(cScaDef, String);
    Concatenate		(PathS, String);
    Append		(PathS, 0C);
    StringToArray	(PathS, PathA);
    file := WriteOpen	(PathA);
    CheckWriteOpen	(file, PathA);

.	DEFINITION MODULE {i ScanName};
.	
.	FROM Positions	IMPORT	tPosition;
.	TYPE tScanAttribute	= RECORD Position: tPosition; END;
.	
.	VAR  Attribute		: tScanAttribute;
.	
.	PROCEDURE GetToken ()	: INTEGER;
.	PROCEDURE ErrorAttribute (Token: INTEGER; VAR Attribute: tScanAttribute);
.	
.	END {i ScanName}.

    WriteClose (file);

    GetString		(ScanName, PathS);
    ArrayToString	(cScaImp, String);
    Concatenate		(PathS, String);
    Append		(PathS, 0C);
    StringToArray	(PathS, PathA);
    file := WriteOpen	(PathA);
    CheckWriteOpen	(file, PathA);

.	IMPLEMENTATION MODULE {i ScanName};
.	
.	FROM IO		IMPORT StdInput, ReadC;
.	
.	PROCEDURE GetToken (): INTEGER;
.      \   VAR ch	: CHAR;
.      \   BEGIN
.      \      LOOP
.      \	 ch := ReadC (StdInput);
.      \         IF ch = 12C THEN
.      \	   INC (Attribute.Position.Line);
.      \	   Attribute.Position.Column := 0;
.. % WriteS (file, "%");
.      \	 ELSIF ch = ' ' THEN
.. % WriteS (file, '%');
.      \	   INC (Attribute.Position.Column);
.      \         ELSE
.      \	   INC (Attribute.Position.Column);
.      \	   EXIT;
.      \	 END;
.      \      END;
.      \      RETURN ORD (ch);
.      \   END GetToken;
.	
.	PROCEDURE ErrorAttribute (Token: INTEGER; VAR Attribute: tScanAttribute);
.      \   BEGIN
.      \   END ErrorAttribute;
.	
.	BEGIN
.      \  Attribute.Position.Line	:= 1;
.      \  Attribute.Position.Column	:= 0;
.	END {i ScanName}.
.. % WriteS (file, '%');

    WriteClose (file);
  END ScaM2;

END SupM2.
