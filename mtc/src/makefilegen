# $Id: Makefile,v 1.33 1992/11/09 11:26:10 grosch rel $

ifndef INSTALLGMD
  INSTALLGMD=/usr/local
endif
export INSTALLGMD

INSTALLBIN	= $(INSTALLGMD)/bin
INSTALLLIB	= $(INSTALLGMD)/lib
MC      = mocka_mtc

INCLUDE = .

BIN = ../../bintobuildwith
REX = $(BIN)/rex
ELL = $(BIN)/ell
CG = $(BIN)/cg
PUMA = $(BIN)/puma
PUMAFLAGS = -dibu
#PUMA = ../../puma/bin/puma

# Modula-2 source modules
#SRCM	= AssocTab.md AssocTab.mi Base.md Base.mi DefMods.md DefMods.mi \
	  Errors.md Errors.mi Source.md Source.mi Tokens.md Tokens.mi \
	  UniqueIds.md UniqueIds.mi GenIdents.md GenIdents.mi \
	  Positions.md Positions.mi Values.md Values.mi Types.md Types.mi mtc.mi

# source modules generated by tools
MODULAGENS	= Parser.md Parser.mi Scanner.md Scanner.mi \
          Tree.md Tree.mi Defs.md Defs.mi Semantics.md Semantics.mi \
          Code.md Code.mi 

OTHERGENS = Scanner.Tab Parser.Tab Tree.TS 
GENS    = $(MODULAGENS) $(OTHERGENS)

EXE     = mtc

MODULASOURCES = \
   AssocTab.md AssocTab.mi Base.md Base.mi \
   DefMods.md DefMods.mi Errors.md Errors.mi \
   GenIdents.md GenIdents.mi Positions.md Positions.mi \
   Source.md Source.mi Tokens.md Tokens.mi Trafo.md Trafo.mi \
   Types.md Types.mi UniqueIds.md UniqueIds.mi Values.md Values.mi \
   mtc.mi

OTHERSOURCES = \
   modula.rex modula.ell modula.cg code.puma defs.cg
SOURCES = $(MODULESOURCES) $(OTHERSOURCES) 


# "runtime system"
RTS	= SYSTEM_.h SYSTEM_.c Arguments.h Arguments.c

MOCKAFLAGS = -norange -noindex
MOCKALIBS = -d ../../reuse/gen 

include $(INCLUDE)/make.include

# Generated sources:

Scanner.md Scanner.mi Scanner.Tab : ../src/modula.rex
	$(REX) -d ../src/modula.rex;

Parser.md Parser.mi Parser.Tab : ../src/modula.ell
	$(ELL) -di ../src/modula.ell;

Tree.md Tree.mi : ../src/modula.cg
	$(CG) -mRdiDI0 ../src/modula.cg;

Semantics.md Semantics.mi : ../src/modula.cg
	$(CG) -DI0 ../src/modula.cg;

Defs.md Defs.mi : ../src/defs.cg
	$(CG) -mdi ../src/defs.cg;

Tree.TS : ../src/modula.cg
	echo SELECT Abstract | cat - ../src/modula.cg | $(CG) -4

Code.md Code.mi : ../src/code.puma Tree.TS ../lib/opp ../lib/opp.sed
	../lib/opp ../src/code.puma | tee code.pumain | $(PUMA) $(PUMAFLAGS)
#	Opp = output pre processor

# swap all byte pairs of the file Scanner.Tab
# reverse all BITSETs (long words) of the file Parser.Tab

bin.conv:	convert
	dd conv=swab < Scanner.Tab > .Scanner.Tab; mv .Scanner.Tab Scanner.Tab
	dd conv=swab < Parser.Tab | convert > .Parser.Tab; mv .Parser.Tab Parser.Tab

convert:	convert.o
	cc -o convert convert.o

install_mocka:

install_modula:

#install_modula:	mtc ../lib/mtc.sh $(INSTALLBIN) $(INSTALLLIB)/mtc Scanner.Tab Parser.Tab
#	if test $(INSTALLLIB) = $(INSTALLBIN); then echo error: INSTALLBIN = INSTALLLIB; false; else true; fi
#	sed 's;LIB;$(INSTALLLIB);g' < ../lib/mtc.sh > $(INSTALLBIN)/mtc
#	chmod a+rx $(INSTALLBIN)/mtc
#	install -c -s -m 755 mtc $(INSTALLLIB)/mtc
#	install -c -m 644 Scanner.Tab $(INSTALLLIB)/mtc
#	install -c -m 644 Parser.Tab $(INSTALLLIB)/mtc
#	cp $(RTS) $(INSTALLLIB)/mtc
#	cd $(INSTALLLIB)/mtc; chmod a+r $(RTS)

# installation directories

$(INSTALLBIN):
	sh -c "if test ! -d $(INSTALLBIN); then mkdir $(INSTALLBIN); else true; fi"

$(INSTALLLIB):
	sh -c "if test ! -d $(INSTALLLIB); then mkdir $(INSTALLLIB); else true; fi"

$(INSTALLLIB)/mtc:	$(INSTALLLIB)
	sh -c "if test ! -d $(INSTALLLIB)/mtc; then mkdir $(INSTALLLIB)/mtc; else true; fi"

MTC	= time mtc -tm -d../../reuse/src s.mi

test:	$(GEN) $(SRCM)
	cg -IL modula.cg;
	mv Semantics.mi s.mi
	cg -dimRDI0 modula.cg;
	make mtc
	tcsh -c "$(MTC); $(MTC); $(MTC); $(MTC)"
	wc Semantics.mi
	size Semantics.o mtc
	cg -dimRDI09 modula.cg;
	make mtc
	$(MTC)
	cg -dimRDI modula.cg;
	make mtc
	tcsh -c "$(MTC); $(MTC); $(MTC); $(MTC)"
	wc Semantics.mi
	size Semantics.o mtc
	cg -dimRDI9 modula.cg;
	make mtc
	$(MTC)
	cg -dimRDIL modula.cg;
	make mtc
	tcsh -c "$(MTC); $(MTC); $(MTC); $(MTC)"
	wc Semantics.mi
	size Semantics.o mtc
	cg -dimRDIL9 modula.cg;
	make mtc
	$(MTC)

clean:
	rm -f *.[dimor] core ERRORS LISTING convert $(GENS)

CLEAN:	clean
	rm -f mtc Scanner.Tab Parser.Tab Scanner.m? Parser.m? Tree.m? Defs.m? Semantics.m? Code.m? Tree.TS
