
(* This file was mechanically generated by puma. *)

IMPLEMENTATION MODULE Trafo;
# define yyInline
# ifdef yyInline
# define yyALLOC(tree, make, ptr, kind) \
  ptr := tree.yyPoolFreePtr; \
  IF SYSTEM.ADDRESS (ptr) >= tree.yyPoolMaxPtr THEN ptr := tree.yyAlloc (); END; \
  INC (tree.yyPoolFreePtr, tree.yyNodeSize [tree.kind]); \
  ptr^.yyHead.yyMark := 0; \
  ptr^.Kind := tree.kind;
# else
# define yyALLOC(tree, make, ptr, kind) ptr := tree.make (tree.kind);
# endif

# define yyWrite(s) IO.WriteS (yyf, s)
# define yyWriteNl IO.WriteNl (yyf)

IMPORT SYSTEM, System, IO, Tree;

# include "yyTrafo.w"

PROCEDURE yyAbort (yyFunction: ARRAY OF CHAR);
 BEGIN
  IO.WriteS (IO.StdError, 'Error: module Trafo, routine ');
  IO.WriteS (IO.StdError, yyFunction);
  IO.WriteS (IO.StdError, ' failed');
  IO.WriteNl (IO.StdError);
  Exit;
 END yyAbort;

PROCEDURE yyIsEqual (yya, yyb: ARRAY OF SYSTEM.BYTE): BOOLEAN;
 VAR yyi	: INTEGER;
 BEGIN
  FOR yyi := 0 TO INTEGER (HIGH (yya)) DO
   IF yya [yyi] # yyb [yyi] THEN RETURN FALSE; END;
  END;
  RETURN TRUE;
 END yyIsEqual;

PROCEDURE BeginTrafo;
 BEGIN

 END BeginTrafo;

PROCEDURE CloseTrafo;
 BEGIN

 END CloseTrafo;

PROCEDURE yyExit;
 BEGIN
  IO.CloseIO; System.Exit (1);
 END yyExit;

BEGIN
 yyf	:= IO.StdOutput;
 Exit	:= yyExit;
 BeginTrafo;
END Trafo.

