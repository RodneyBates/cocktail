/*
 *      M T C  -  Modula-2 to C Translator
 *      ----------------------------------
 *
 *      Purpose: Specification of code generation
 *               Generated code generator generates C-Code for an
 *               attributed structure tree
 *
 *      $Author: grosch $
 *      $Date: 1992/08/14 07:34:10 $
 *      $Revision: 1.12 $
 *
 ***/

(* RMB 10-93 Changed name of program module's translation to 'main'
       instead of BEGIN_MODULE, and generate in line in main, steps
       previously performed by SYSTEM_.main (which is removed.)
       Change the name of the initialization procedure for 
       module M from BEGIN_M to M__init.
       Change names of SYSTEM_argc to parameters_argc, resp. for argv, envp
       which are used by WRL in its module runtime (.c).
       These are for compatibility with WRL Modula-2. 
   RMB 10-93WriteSpaces (f, Indent); bug fix: was passing "\0" to open array formal when actual is 
       a VAR of type CHAR 
   RMB 10-98 Removed several backslashes which were causing the linux
       cpp to complain.  Replaced in code by 134C, 'backslash' in comments.
   RMB 10-98 Changed labels 'Else' and 'Then' to 'ElsePart' and 'ThenPart',
       since the former spellings are now recognized by puma as case-
       independent Ada operators. 
   RMB 7-99 Added lots of colons after labels, "VAR"s in local decls,
       and some "(..)"s after Label:Node
   RMB 8-99 Removed two incorrect colons on references in rule statements
       to labels. 
*)

TRAFO Code PUBLIC CodeCompUnits

EXPORT  {
CONST
  cNoOp                 =  0;           (* C operators                  *)
  cNotEqual             =  1;
  cTimes                =  2;
  cPlus                 =  3;
  cMinus                =  4;
  cDivide               =  5;
  cLess                 =  6;
  cLessEqual            =  7;
  cEqual                =  8;
  cGreater              =  9;
  cGreaterEqual         = 10;
  cAnd                  = 11;
  cIn                   = 13;
  cMod                  = 14;
  cNot                  = 15;
  cOr                   = 16;
  cUnion                = 17;
  cDifference           = 18;
  cIntersection         = 19;
  cSymDiff              = 20;
  cIsSubset1            = 21;
  cIsSubset2            = 22;

  cAssign               = 23;
  cPassValue            = 24;
  cPassAddress          = 25;
}

GLOBAL  {
FROM Base       IMPORT
  OptionIsSet   , OpenHeader    , OpenProgram;

FROM IO         IMPORT
  tFile         , WriteS        , WriteC        , WriteI        ,
  WriteN        , WriteR        , WriteCard     , WriteNl       ,
  WriteClose    ;

FROM Layout     IMPORT
  WriteSpaces   ;

FROM Strings    IMPORT
  tString       , tStringIndex  ;

FROM StringMem  IMPORT
  tStringRef    , GetString     , Length        , WriteString   ;

FROM Idents     IMPORT
  tIdent        , NoIdent       , WriteIdent    ;

FROM Tree       IMPORT
  tTree         , NoTree        ,
  Definition    , Foreign       , Program       , Implementation,
  Decimal       , Octal         , Hexadecimal   ;

FROM Defs       IMPORT
  tObject       , tObjects      , tType         , tSelectors    ,
  tCObjects     , tStrings      ,
  NoObject      , NoObjects     , NoSelectors   , NoCObjects    ,
  NoStrings     ,
  ProcABS       , ProcCAP       , ProcCHR       , ProcDEC       ,
  ProcEXCL      , ProcFLOAT     , ProcHALT      , ProcHIGH      ,
  ProcINC       , ProcINCL      , ProcMAX       , ProcMIN       ,
  ProcODD       , ProcORD       , ProcSIZE      , ProcTRUNC     ,
  ProcVAL       , ProcADR       , ProcTSIZE     , ProcTRANSFER  ,
  ProcNEWPROCESS, ProcIOTRANSFER, ProcNEW       , ProcDISPOSE   ,
  IdentSYSTEM   ,
  TypeLONGCARD  , TypeBOOLEAN   , TypeWORD      , TypeADDRESS   ,
  TypeIntCard   , TypeSTRING    , TypeStringChar, TypeVOID      ,
  TypeCHAR      , Field1        , TypeDecl1     , Const1        ,
  ShortInt      , LongInt       , ShortCard     , LongCard      ,
  Real          , LongReal      , Bool          , Char          ,
  Bitset        , Proc          , Word          , Address       ,
  IntCard       , Nil           , StringChar    , String        ,
  StdProcType1  , OpaqueType1   , Array1        , Enumeration1  ,
  Pointer1      , ProcType1     , Record1       , Set1          ,
  Subrange1     ,
  GetSelectors  , GetType       ,
  GetIndexType  , GetElemType   , GetTargetType , GetResultType ,
  GetFields     , GetLiteral    ,
  IsExported    , IsOpenArray   , IsVAR         , IsProcedure   ,
  IsOfType      , IsForward     , IsIntType     , IsOpen        ;

FROM Values     IMPORT
  tValue        , ValueToInt    , MinCharVal    , MaxCharVal    ,
  ZeroValue     , MaxShortCardVal;

FROM Types      IMPORT
  TypeSize      , GetLwb        , GetUpb        , SizeUnsignedChar,
  MaxLongInt    , Cast          ;

FROM AssocTab   IMPORT
  BeginAssocTab , PutAssoc      , GetAssoc      , CloseAssocTab ;

FROM GenIdents  IMPORT
  GenLabel      , GenWith       , GenBound      , GenReturn     ,
  GenOpaque     ;

FROM Errors     IMPORT
  CompilerError , ErrorMessageP , Restriction   , Warning       ,
  NoTRANSFER    , NoIOTRANSFER  , NoNEWPROCESS  , StructTypeReq ,
  OutOfLongRange;

IMPORT Strings, Idents, GenIdents, DynArray, Defs, Values;

CONST
  pMaxPrec              =  1;   (* C operator precedences       *)
  pCall                 =  1;
  pSubscript            =  1;
  pSelect               =  1;
  pCast                 =  2;
  pDeref                =  3;
  pAdr                  =  3;
  pNot                  =  3;
  pTimes                =  4;
  pDivide               =  4;
  pMod                  =  4;
  pPlus                 =  5;
  pMinus                =  5;
  pComparison           =  7;
  pLess                 =  7;
  pLessEqual            =  7;
  pGreater              =  7;
  pGreaterEqual         =  7;
  pEqual                =  8;
  pNotEqual             =  8;
  pIntersection         =  9;
  pSymDiff              = 10;
  pUnion                = 11;
  pAnd                  = 12;
  pOr                   = 13;
  pIn                   = 14;
  pDifference           = 14;
  pIsSubset1            = 14;
  pIsSubset2            = 14;
  pAssign               = 14;
  pPassValue            = 14;
  pPassAddress          = 14;
  pMinPrec              = 14;

CONST
  Auto                  = 1;    (* C storage classes            *)
  Static                = 2;

CONST
  Full                  = TRUE;
  NonFull               = NOT Full;
  Before                = TRUE;
  After                 = NOT Before;
  Strncpy               = TRUE;

VAR
  f             : tFile;        (* C header/source file(s)      *)
  Indent        : CARDINAL;     (* level of indentation         *)

                  (* table with precedence of C operators       *)
  Precedence    : ARRAY [cNoOp .. cPassAddress] OF SHORTCARD;


(*------- MODULE LabelStack --------------------------------------------------*)

MODULE LabelStack;

(* Stack for the administration of the labels generated for the *)
(* translation of LOOP and EXIT statements.                     *)

FROM DynArray   IMPORT
  MakeArray     , ExtendArray   , ReleaseArray  ;

FROM Idents     IMPORT
  tIdent        , NoIdent       ;

EXPORT QUALIFIED Push, Pop, Top, Begin, Close;

CONST
  Infinite      = 1048576;
  InitialSize   = 16;

VAR
  StackPtr      ,
  StackSize     : LONGINT;
  LabelStack    : POINTER TO ARRAY [0 .. Infinite] OF tIdent;

PROCEDURE Push  (Ident: tIdent);
BEGIN
  IF StackPtr = StackSize THEN
    ExtendArray (LabelStack, StackSize, SIZE (tIdent));
  END;
  LabelStack^ [StackPtr] := Ident;
  INC (StackPtr);
END Push;

PROCEDURE Pop   ();
BEGIN
  DEC (StackPtr);
END Pop;

PROCEDURE Top   (): tIdent;
BEGIN
  IF StackPtr > 0 THEN
    RETURN LabelStack^ [StackPtr - 1];
  ELSE
    RETURN NoIdent;     (* error: EXIT not in LOOP context      *)
  END;
END Top;

PROCEDURE Begin;
BEGIN
  StackSize     := InitialSize;
  StackPtr      := 0;
  MakeArray (LabelStack, StackSize, SIZE (tIdent));
END Begin;

PROCEDURE Close;
BEGIN
  ReleaseArray (LabelStack, StackSize, SIZE (tIdent));
END Close;

END LabelStack;

(*------- END LabelStack -----------------------------------------------------*)

(*------- MODULE WithStack ---------------------------------------------------*)

MODULE WithStack;

(* Stack for the administration of the pointer variables        *)
(* generated for the translation of WITH statements.            *)

FROM DynArray   IMPORT
  MakeArray     , ExtendArray   , ReleaseArray  ;

FROM Idents     IMPORT
  tIdent        , NoIdent       ;

FROM Defs       IMPORT
  tObjects      , NoObject      , Identify2     ;

EXPORT QUALIFIED Push, Pop, GetWith, Begin, Close;

CONST
  Infinite      = 1048576;
  InitialSize   = 16;

TYPE
  tStackElem    = RECORD
                    WithId      : tIdent;
                    Fields      : tObjects;
                  END;

VAR
  StackPtr      ,
  StackSize     : LONGINT;
  WithStack     : POINTER TO ARRAY [0 .. Infinite] OF tStackElem;

PROCEDURE Push  (pWithId: tIdent; pFields: tObjects);
BEGIN
  IF StackPtr = StackSize THEN
    ExtendArray (WithStack, StackSize, SIZE (tStackElem));
  END;
  WITH WithStack^ [StackPtr] DO
    WithId := pWithId;
    Fields := pFields;
  END;
  INC (StackPtr);
END Push;

PROCEDURE Pop   ();
BEGIN
  DEC (StackPtr);
END Pop;

PROCEDURE GetWith       (FieldId: tIdent): tIdent;
VAR
  StackIndex    : LONGINT;
BEGIN
  StackIndex := StackPtr - 1;
  LOOP
    WITH WithStack^ [StackIndex] DO
      IF Identify2 (FieldId, Fields) # NoObject THEN RETURN WithId; END;
    END;
    DEC (StackIndex);
  END;
END GetWith;

PROCEDURE Begin;
BEGIN
  StackSize     := InitialSize;
  StackPtr      := 0;
  MakeArray (WithStack, StackSize, SIZE (tStackElem));
END Begin;

PROCEDURE Close;
BEGIN
  ReleaseArray (WithStack, StackSize, SIZE (tStackElem));
END Close;

END WithStack;

(*------- END WithStack ------------------------------------------------------*)

(*------- MODULE ParamTable --------------------------------------------------*)

MODULE ParamTable;

(* Module for the administration of the additional parameters used to   *)
(* translate open array parameters.                                     *)

FROM Idents     IMPORT
  tIdent        , NoIdent       ;

FROM GenIdents  IMPORT
  GenParam      ;

FROM Defs       IMPORT
  tObject       ,
  tCObjects     , NoCObjects    ,
  IsVAR         ,
  LookUp        ;

EXPORT GenParams, GetParam, ValueOpens, VAROpens;

VAR
  VAROpens      ,
  ValueOpens    : tCObjects;

PROCEDURE GenParams     (OpenParams: tCObjects);
BEGIN
  WHILE OpenParams # NoCObjects DO
    OpenParams^.CObjects.CObject := GenParam ();
    OpenParams := OpenParams^.CObjects.Next;
  END;
END GenParams;

PROCEDURE GetParam      (M2Object: tObject): tIdent;
BEGIN
  IF IsVAR (M2Object) THEN
    RETURN LookUp (M2Object, VAROpens);
  ELSE
    RETURN LookUp (M2Object, ValueOpens);
  END;
END GetParam;

BEGIN
  ValueOpens    := NoCObjects;
  VAROpens      := NoCObjects;
END ParamTable;

(*------- END ParamTable -----------------------------------------------------*)

(*------- MODULE PointerTable ------------------------------------------------*)

MODULE PointerTable;

(* Module for the administration of the global and local pointer        *)
(* variables, used to translate the access to local variables of        *)
(* statically enclosing procedures                                      *) 

FROM Idents     IMPORT
  tIdent        , NoIdent       ;

FROM GenIdents  IMPORT
  GenGlobalPtr  , GenLocalPtr   ;

FROM Defs       IMPORT
  tObject       ,
  tCObjects     , NoCObjects    ,
  LookUp        ;

EXPORT 
  GenGlobalPtrs , GenLocalPtrs  , GetGlobalPtr  , GetLocalPtr   ,
  GlobalPtrs    , LocalPtrs     ;

VAR
  GlobalPtrs    ,
  LocalPtrs     : tCObjects;

PROCEDURE GenGlobalPtrs (GlobalPtrs: tCObjects);
BEGIN
  WHILE GlobalPtrs # NoCObjects DO
    WITH GlobalPtrs^.CObjects DO
      CObject := GenGlobalPtr (M2Object^.Var1.Ident);
    END;
    GlobalPtrs := GlobalPtrs^.CObjects.Next;
  END;
END GenGlobalPtrs;

PROCEDURE GenLocalPtrs  (LocalPtrs: tCObjects);
BEGIN
  WHILE LocalPtrs # NoCObjects DO
    LocalPtrs^.CObjects.CObject := GenLocalPtr ();
    LocalPtrs := LocalPtrs^.CObjects.Next;
  END;
END GenLocalPtrs;

PROCEDURE GetGlobalPtr  (M2Object: tObject): tIdent;
BEGIN
  RETURN LookUp (M2Object, GlobalPtrs);
END GetGlobalPtr;

PROCEDURE GetLocalPtr   (M2Object: tObject): tIdent;
BEGIN
  RETURN LookUp (M2Object, LocalPtrs);
END GetLocalPtr;

BEGIN
  GlobalPtrs    := NoCObjects;
  LocalPtrs     := NoCObjects;
END PointerTable;

(*------- END PointerTable ---------------------------------------------------*)

PROCEDURE OverOrUnderflow (CtrlType: tType; ToValue, ByValue: tValue): BOOLEAN;
(* Check if the translation of the Modula-2 FOR-statement               *)
(*      FOR v := a TO b BY c DO ... END;        (b = const)             *)
(* into the C for-statement                                             *)
(*      for (v = a; v <= b; v += c) { ... }     (v >= b if c < 0)       *)
(* would result in a over resp. underflow of the control variable v.    *)
(* 'CtrlType' is the type of v, 'ToValue' is the value of b, and        *)
(* 'ByValue' is the value of c.                                         *)
VAR
  MinCValue     ,
  MaxCValue     : tValue;
BEGIN
  IF ToValue.Kind = Values.NoValue THEN
    (* error: illegal limit value                               *)
    (* or                                                       *)
    (* restriction: overflow test not possible, because module  *)
    (*              Values could not evaluate b, because b      *)
    (*              contains a constant in the range            *)
    (*              MAX (INTEGER) + 1 .. MAX (CARDINAL).        *)
    (*              Assume there would be an overflow!          *)
    RETURN TRUE;
  ELSE
    IF CtrlType^.Kind = Subrange1 THEN
      CtrlType := CtrlType^.Subrange1.Type;
    END;

    CASE CtrlType^.Kind OF
    | ShortCard         ,
      ShortInt          ,
      LongCard          ,
      LongInt           ,
      Char              :
        GetLwb (CtrlType, MinCValue);
        GetUpb (CtrlType, MaxCValue);

    | Bool              ,
      Enumeration1      :
        IF TypeSize (CtrlType) = SizeUnsignedChar THEN
          MinCValue := MinCharVal;
          MaxCValue := MaxCharVal;
        ELSE
          MinCValue := ZeroValue;
          MaxCValue := MaxShortCardVal;
        END;

    ELSE
      (* error: illegal type of control variable        *)
      RETURN TRUE;
    END;

    IF ValueToInt (ByValue) >= 0 THEN
      IF CtrlType = TypeLONGCARD THEN
        RETURN FALSE;
        (* restriction: MAX (CARDINAL) is not representable as INTEGER  *)
        (*              or as tValue. But b (see above) does not        *)
        (*              contain a constant in the range                 *)
        (*              MAX (INTEGER) + 1..MAX (CARDINAL).              *)
        (*              Hence assume there would be no overflow!        *)
      END;
      RETURN ValueToInt (ToValue) > ValueToInt (MaxCValue) - ValueToInt (ByValue);
    ELSE
      RETURN ValueToInt (ToValue) < ValueToInt (MinCValue) - ValueToInt (ByValue);
    END;
  END;
END OverOrUnderflow;

(*======= code generation procedures =========================================*)

(*
 *      generate code for a string constant
 *)

PROCEDURE CodeString1   (s: tStringRef);
(* The characters '"' and backslash are escaped with a backslash. *)
(* note: within WriteS (f, ' ... '); opp will transform \\\\ to \\           *)
VAR i           : tStringIndex;
    Ch          : CHAR;
    String      : tString;
BEGIN
  GetString (s, String);
  WriteC (f, '"');
  FOR i := 1 TO Length (s) DO
    Ch := Strings.Char (String, i);
    IF (Ch = '"') OR (Ch = 134C) THEN  WriteC (f, 134C);  END; WriteC (f, Ch);
  END;
  WriteC (f, '"');
END CodeString1;

(*
 *      generate a string constant for a character constant
 *)

PROCEDURE CodeString3   (Ch: CHAR);
(* The characters '"' and backslash are escaped with a backslash. *)
(* note: within WriteS (f, ' ... '); opp will transform \\\\ to \\           *)
BEGIN
  WriteC (f, '"');
  IF (Ch < ' ') OR (Ch > '~') THEN  WriteC (f, 134C); WriteN (f, ORD (Ch), 1, 8);
  ELSIF (Ch = '"') OR (Ch = 134C) THEN  WriteC (f, 134C);  WriteC (f, Ch);
  ELSE WriteC (f, Ch);
  END;
  WriteC (f, '"');
END CodeString3;

(*
 *      generate code for a character constant
 *)

PROCEDURE CodeChar      (Ch: CHAR);
(* The characters "'" and backslash are escaped with a backslash. *)
(* Non-printable characters are written either as their C       *)
(* escape sequence (\\0, \\n, \\t, \\b, \\r, \\f) or are represented    *)
(* by their internal code written as an octal number.           *)
(* note: within WriteS (f, ' ... '); opp will transform \\\\ to \\           *)
BEGIN
  CASE Ch OF
  | "'"         :  WriteC (f, 47C);  WriteC (f, 134C);  WriteC (f, 47C);  WriteC (f, 47C); 
  | 134C         :  WriteC (f, 47C);  WriteC (f, 134C);  WriteC (f, 134C);  WriteC (f, 47C); 
  | ' ' .. '&'  ,
    '(' .. '['  ,
    ']' .. '~'  :  WriteC (f, 47C); WriteC (f, Ch); WriteC (f, 47C); 
  | 0C          :  WriteC (f, 47C);  WriteC (f, 134C); WriteC (f, '0'); WriteC (f, 47C); 
  | 10C         :  WriteC (f, 47C);  WriteC (f, 134C); WriteC (f, 'b'); WriteC (f, 47C); 
  | 11C         :  WriteC (f, 47C);  WriteC (f, 134C); WriteC (f, 't'); WriteC (f, 47C); 
  | 12C         :  WriteC (f, 47C);  WriteC (f, 134C); WriteC (f, 'n'); WriteC (f, 47C); 
  | 14C         :  WriteC (f, 47C);  WriteC (f, 134C); WriteC (f, 'f'); WriteC (f, 47C); 
  | 15C         :  WriteC (f, 47C);  WriteC (f, 134C); WriteC (f, 'r'); WriteC (f, 47C); 
  ELSE
    WriteS (f, '((CHAR)'); WriteC (f, 47C);  WriteC (f, 134C); WriteN (f, ORD (Ch), 1, 8); WriteC (f, 47C); WriteC (f, ')');
  END;
END CodeChar;

(*
 *      generate code for a value
 *)

PROCEDURE CodeValue     (Value: tValue);
VAR
  Object: tObject;
BEGIN
  CASE Value.Kind OF
  | Values.Integer      : WriteI (f, Value.IntValue, 1);
  | Values.Real         : WriteR (f, Value.RealValue, 1, 1, 1);
  | Values.Boolean      : IF Value.BoolValue THEN WriteS (f, 'TRUE'); ELSE WriteS (f, 'FALSE'); END;
  | Values.StringChar   ,
    Values.Char         : CodeChar (Value.CharValue);
  | Values.String       : CodeString1 (Value.StringValue);
  | Values.Bitset       : WriteS (f, '0X');WriteN (f, LONGCARD (Value.BitsetValue), 1, 16);WriteC (f, 'L');
  | Values.Enumeration  : Object := Value.EnumValue;
                          WriteIdent (f, Object^.EnumLiteral1.CIdent);
  | Values.NilType      : WriteS (f, 'NIL');
  ELSE
    (* error: illegal value *)
  END;
END CodeValue;

(*
 *      generate code for a type name
 *)

PROCEDURE CodeTypeName  (Type: tType);
VAR
  Object: tObject;
BEGIN
  CASE Type^.Kind OF
  | Array1      ,
    Enumeration1,
    Pointer1    ,
    ProcType1   ,
    Record1     ,
    Set1        ,
    Subrange1   ,
    OpaqueType1 :
      Object := Type^.Constructor.TypeObj;
      IF Object # NoObject THEN
        WriteIdent (f, Object^.Object.CIdent);
        RETURN;
      END;

  ELSE
  END;

  IF Type^.Kind = Subrange1 THEN
    Type := Type^.Subrange1.Type;
  END;

  CASE Type^.Kind OF
  | ShortInt    : WriteS (f, 'SHORTINT');
  | LongInt     : WriteS (f, 'LONGINT');
  | ShortCard   : WriteS (f, 'SHORTCARD');
  | LongCard    : WriteS (f, 'LONGCARD');
  | Real        : WriteS (f, 'REAL');
  | LongReal    : WriteS (f, 'LONGREAL');
  | Bool        : WriteS (f, 'BOOLEAN');
  | Char        : WriteS (f, 'CHAR');
  | Bitset      : WriteS (f, 'BITSET');
  | Proc        : WriteS (f, 'PROC');
  | Word        : WriteS (f, 'WORD');
  | Address     : WriteS (f, 'ADDRESS');
  | OpaqueType1 : WriteS (f, 'OPAQUE');
  | Array1      : WriteS (f, 'struct ');WriteIdent (f, Type^.Array1.StructId);
  | Enumeration1: IF TypeSize (Type) = SizeUnsignedChar THEN
                    WriteS (f, 'unsigned char');
                  ELSE
                    WriteS (f, 'unsigned short');
                  END;
  | Pointer1    : CodeTypeName (Type^.Pointer1.Type);
  | ProcType1   : CodeTypeName (Type^.ProcType1.Type);
  | Record1     : WriteS (f, 'struct ');WriteIdent (f, Type^.Record1.StructId);
  | Set1        : WriteS (f, 'unsigned long');
  ELSE
    (* error: illegal type name *)
  END;
END CodeTypeName;

(*
 *      generate code for the part of a declarator before the identifier
 *)

PROCEDURE CodeDeclarator1       (Type: tType);
BEGIN
  IF (Type^.Kind = Pointer1) AND (Type^.Pointer1.TypeObj = NoObject) THEN
    CodeDeclarator1 (Type^.Pointer1.Type); WriteS (f, ' *');
  ELSIF (Type^.Kind = ProcType1) AND (Type^.ProcType1.TypeObj = NoObject) THEN
    WriteS (f, ' (*');
  END;
END CodeDeclarator1;

(*
 *      generate code for the part of a declarator after the identifier
 *)

PROCEDURE CodeDeclarator2       (Type: tType);
BEGIN
  IF (Type^.Kind = Pointer1) AND (Type^.Pointer1.TypeObj = NoObject) THEN
    CodeDeclarator2 (Type^.Pointer1.Type);
  ELSIF (Type^.Kind = ProcType1) AND (Type^.ProcType1.TypeObj = NoObject) THEN
    WriteS (f, ')()');
  END;
END CodeDeclarator2;

(*
 *      generate declarations for the global/local pointer variables,
 *      which are used to translate the access to local variables of
 *      statically enclosing procedures
 *)

PROCEDURE CodePointers  (StorageClass: SHORTCARD; Pointers: tCObjects);
VAR
  Type  : tTree;
BEGIN
  WHILE Pointers # NoCObjects DO
    WITH Pointers^.CObjects DO
      Type := M2Object^.Var1.TypeTree;

      IF NOT IsOpenArray (M2Object) THEN

WriteSpaces (f, Indent);       IF StorageClass = Static THEN WriteS (f, 'static '); END;
        CodeType (Type, NonFull);
          CodeDecla (Type, Before); WriteS (f, ' *');WriteIdent (f, CObject); CodeDecla (Type, After); WriteC (f, ';'); WriteNl (f);

      ELSE

WriteSpaces (f, Indent);       IF StorageClass = Static THEN WriteS (f, 'static '); END;
        CodeType (Type^.Array.ElemType, NonFull); WriteS (f, ' *');WriteIdent (f, CObject);WriteC (f, ';'); WriteNl (f);

WriteSpaces (f, Indent);       IF StorageClass = Static THEN WriteS (f, 'static '); END;
        WriteS (f, 'LONGCARD ');WriteIdent (f, CObject);WriteS (f, '_O;'); WriteNl (f);

      END;

    END;
    Pointers := Pointers^.CObjects.Next;
  END;
END CodePointers;

(*
 *      generate code to save and reinitialize the global pointer variables,
 *      which are used to translate the access to local variables of procedure p
 *      (called upon each entry of p)
 *)

PROCEDURE CodePush      (LocalPtrs: tCObjects);
VAR GlobalPtr   : tIdent;
BEGIN
  WHILE LocalPtrs # NoCObjects DO
    WITH LocalPtrs^.CObjects DO
      GlobalPtr := GetGlobalPtr (M2Object);

WriteSpaces (f, Indent);     WriteIdent (f, CObject);WriteS (f, ' = ');WriteIdent (f, GlobalPtr);WriteC (f, ';'); WriteNl (f);

      IF IsOpenArray (M2Object) THEN

WriteSpaces (f, Indent);       WriteIdent (f, GlobalPtr);WriteS (f, ' = ');WriteIdent (f, M2Object^.Var1.CIdent);WriteC (f, ';'); WriteNl (f);

WriteSpaces (f, Indent);       WriteIdent (f, CObject);WriteS (f, '_O = ');WriteIdent (f, GlobalPtr);WriteS (f, '_O;'); WriteNl (f);
WriteSpaces (f, Indent);       WriteIdent (f, GlobalPtr);WriteS (f, '_O = ');WriteIdent (f, GetParam (M2Object));WriteC (f, ';'); WriteNl (f);

      ELSIF IsVAR (M2Object) THEN

WriteSpaces (f, Indent);       WriteIdent (f, GlobalPtr);WriteS (f, ' = ');WriteIdent (f, M2Object^.Var1.CIdent);WriteC (f, ';'); WriteNl (f);

      ELSE

WriteSpaces (f, Indent);       WriteIdent (f, GlobalPtr);WriteS (f, ' = &');WriteIdent (f, M2Object^.Var1.CIdent);WriteC (f, ';'); WriteNl (f);

      END;
    END;
    LocalPtrs := LocalPtrs^.CObjects.Next;
  END;
END CodePush;

(*
 *      generate code to restore the global pointer variables, which are
 *      used to translate the access to local variables of procedure p
 *      (called upon each exit from p)
 *)

PROCEDURE CodePop       (LocalPtrs: tCObjects);
VAR GlobalPtr   : tIdent;
BEGIN
  WHILE LocalPtrs # NoCObjects DO
    WITH LocalPtrs^.CObjects DO
      GlobalPtr := GetGlobalPtr (M2Object);

WriteSpaces (f, Indent);     WriteIdent (f, GlobalPtr);WriteS (f, ' = ');WriteIdent (f, CObject);WriteC (f, ';'); WriteNl (f);

      IF IsOpenArray (M2Object) THEN
WriteSpaces (f, Indent);       WriteIdent (f, GlobalPtr);WriteS (f, '_O = ');WriteIdent (f, CObject);WriteS (f, '_O;'); WriteNl (f);
      END;
    END;
    LocalPtrs := LocalPtrs^.CObjects.Next;
  END;
END CodePop;

(*
 *      generate code for a label range
 *)

PROCEDURE CodeLabelRange (Label1, Label2: tValue);
VAR
  IntLabel      : INTEGER;
  BoolLabel     : BOOLEAN;
  CharLabel     : CHAR;
  EnumLiterals  : tObjects;
  EnumIndex1    ,
  EnumIndex2    : SHORTCARD;
  Type          : tType;
BEGIN
  CASE Label1.Kind OF
  | Values.Integer      :
      FOR IntLabel := Label1.IntValue TO Label2.IntValue DO
WriteSpaces (f, Indent);       WriteS (f, 'case '); WriteI (f, IntLabel, 1); WriteS (f, ':;'); WriteNl (f);
      END;

  | Values.Boolean      :
      FOR BoolLabel := Label1.BoolValue TO Label2.BoolValue DO
        IF BoolLabel THEN
WriteSpaces (f, Indent);         WriteS (f, 'case TRUE:'); WriteNl (f);
        ELSE
WriteSpaces (f, Indent);         WriteS (f, 'case FALSE:'); WriteNl (f);
        END;
      END;

  | Values.Char         ,
    Values.StringChar   :
      FOR CharLabel := Label1.CharValue TO Label2.CharValue DO
WriteSpaces (f, Indent);       WriteS (f, 'case '); CodeChar (CharLabel); WriteS (f, ':;'); WriteNl (f);
      END;

  | Values.Enumeration  :
      Type              := GetType (Label1.EnumValue);
      EnumLiterals      := Type^.Enumeration1.Objects;
      EnumIndex1        := ValueToInt (Label1);
      EnumIndex2        := ValueToInt (Label2);

      WHILE EnumLiterals # NoObjects DO
        WITH EnumLiterals^.Elmt.Object^.EnumLiteral1 DO
          IF (Index >= EnumIndex1) AND
             (Index <= EnumIndex2) THEN
WriteSpaces (f, Indent);           WriteS (f, 'case '); WriteIdent (f, CIdent); WriteS (f, ':;'); WriteNl (f);
          END;
        END;

        EnumLiterals := EnumLiterals^.Elmt.Next;
      END;

  ELSE
  END;
END CodeLabelRange;

(*
 *      generate code to allocate memory for open array value parameters
 *)

PROCEDURE CodeAlloc     (ValueOpens: tCObjects);
VAR
  ArrayCnt      : CARDINAL;
BEGIN
  IF ValueOpens # NoCObjects THEN
    ArrayCnt := 0;

WriteSpaces (f, Indent);   WriteS (f, 'ALLOC_OPEN_ARRAYS(');

    LOOP
      INC (ArrayCnt);

      WITH ValueOpens^.CObjects DO
        WriteIdent (f, CObject);WriteS (f, ' * ');
          WriteS (f, 'sizeof('); CodeTypeName (GetElemType (GetType (M2Object))); WriteC (f, ')');
      END;

      ValueOpens := ValueOpens^.CObjects.Next;
      IF ValueOpens = NoObjects THEN
        EXIT;
      END;

      WriteS (f, ' + ');

    END;

    WriteS (f, ', ');WriteI (f, ArrayCnt, 1);WriteC (f, ')'); WriteNl (f);

  END;
END CodeAlloc;

(*
 *      generate code to copy an open array value parameter
 *)

PROCEDURE CodeCopy      (ValueOpens: tCObjects);
BEGIN
  WHILE ValueOpens # NoCObjects DO
    WITH ValueOpens^.CObjects DO
WriteSpaces (f, Indent);     WriteS (f, 'COPY_OPEN_ARRAY(');
        WriteIdent (f, M2Object^.Var1.CIdent);WriteS (f, ', ');
        WriteIdent (f, CObject);WriteS (f, ', ');
        CodeTypeName (GetElemType (GetType (M2Object)));
      WriteC (f, ')'); WriteNl (f);
    END;
    ValueOpens := ValueOpens^.CObjects.Next;
  END;
END CodeCopy;

(*
 *      generate code to release memory for an open array value parameter
 *)

PROCEDURE CodeFree      (ValueOpens: tCObjects);
BEGIN
  IF ValueOpens # NoCObjects THEN
WriteSpaces (f, Indent);   WriteS (f, 'FREE_OPEN_ARRAYS'); WriteNl (f);
  END;
END CodeFree;

(*
 *      generate declarations for the local array variables, which
 *      are used to translate the parameter passing of strings,
 *      if the corresponding formal parameters are no open arrays
 *)

PROCEDURE CodeStrings   (Strings: tStrings);
BEGIN
  WHILE Strings # NoStrings DO
    WITH Strings^.StringPar DO
WriteSpaces (f, Indent);     CodeTypeName (FormalType); WriteC (f, ' '); WriteIdent (f, CString); WriteC (f, ';'); WriteNl (f);
    END;
    Strings := Strings^.StringPar.Next;
  END;
END CodeStrings;

(*
 *      generate code to initialize the local array variables, which
 *      are used to translate the parameter passing of strings,
 *      if the corresponding formal parameters are no open arrays
 *)

PROCEDURE CodeStrncpy   (Strings: tStrings);
BEGIN
  WHILE Strings # NoStrings DO
    WITH Strings^.StringPar DO
WriteSpaces (f, Indent);     WriteS (f, '(void)strncpy(');
                      IF OptionIsSet ('c') THEN WriteS (f, '(char *)'); END;
                      WriteIdent (f, CString); WriteS (f, '.A, ');
                      CodeString2 (M2String, Strncpy); WriteS (f, ', ');
                      WriteS (f, 'sizeof('); WriteIdent (f, CString); WriteS (f, '.A)');
      WriteS (f, ');'); WriteNl (f);
    END;
    Strings := Strings^.StringPar.Next;
  END;
END CodeStrncpy;

(*
 *      generate code for additional record field selectors
 *)

PROCEDURE CodeSelectors (Selectors: tSelectors);
BEGIN
  IF Selectors # NoSelectors THEN
    CodeSelectors (Selectors^.Selectors.Next);
    WriteIdent (f, Selectors^.Selectors.Selector);WriteC (f, '.');
  END;
END CodeSelectors;

(*
 *      generate code for type casts
 *)

PROCEDURE CodeCast      (Type: tType);
BEGIN
  WriteC (f, '('); CodeTypeName (Type); CodeDeclarator1 (Type); CodeDeclarator2 (Type); WriteC (f, ')');
END CodeCast;

PROCEDURE CodeCastVAR   (Type: tType);
BEGIN
  WriteC (f, '('); CodeTypeName (Type); CodeDeclarator1 (Type); WriteS (f, ' *'); CodeDeclarator2 (Type); WriteC (f, ')');
END CodeCastVAR;

(*
 *      generate code for standard procedure MIN
 *)

PROCEDURE CodeMIN       (Type: tType);
VAR Object: tObject;
BEGIN
  CASE Type^.Kind OF
  | ShortInt    : WriteS (f, 'MIN_SHORTINT');
  | LongInt     : WriteS (f, 'MIN_LONGINT');
  | ShortCard   : WriteS (f, 'MIN_SHORTCARD');
  | LongCard    : WriteS (f, 'MIN_LONGCARD');
  | Real        : WriteS (f, 'MIN_REAL');
  | LongReal    : WriteS (f, 'MIN_LONGREAL');
  | Bool        : WriteS (f, 'MIN_BOOLEAN');
  | Char        : WriteS (f, 'MIN_CHAR');
  | Enumeration1: WITH Type^.Enumeration1 DO
                    Object := GetLiteral (Objects, 0);
                  END;
                  WriteIdent (f, Object^.EnumLiteral1.CIdent);
  | Subrange1   : CodeValue (Type^.Subrange1.Lwb);
                  IF IsIntType (Type) AND Cast (cPassValue, Type, TypeIntCard) THEN WriteC (f, 'L'); END;
  ELSE
  END;
END CodeMIN;

(*
 *      generate code for standard procedure MAX
 *)

PROCEDURE CodeMAX       (Type: tType);
VAR Object: tObject;
BEGIN
  CASE Type^.Kind OF
  | ShortInt    : WriteS (f, 'MAX_SHORTINT');
  | LongInt     : WriteS (f, 'MAX_LONGINT');
  | ShortCard   : WriteS (f, 'MAX_SHORTCARD');
  | LongCard    : WriteS (f, 'MAX_LONGCARD');
  | Real        : WriteS (f, 'MAX_REAL');
  | LongReal    : WriteS (f, 'MAX_LONGREAL');
  | Bool        : WriteS (f, 'MAX_BOOLEAN');
  | Char        : WriteS (f, 'MAX_CHAR');
  | Enumeration1: WITH Type^.Enumeration1 DO
                    Object := GetLiteral (Objects, MaxValue);
                  END;
                  WriteIdent (f, Object^.EnumLiteral1.CIdent);
  | Subrange1   : CodeValue (Type^.Subrange1.Upb);
                  IF IsIntType (Type) AND Cast (cPassValue, Type, TypeIntCard) THEN WriteC (f, 'L'); END;
  ELSE
  END;
END CodeMAX;
}

BEGIN   {
  Indent := 0;

  Precedence [cNoOp             ] := pMinPrec;
  Precedence [cNotEqual         ] := pNotEqual;
  Precedence [cTimes            ] := pTimes;
  Precedence [cPlus             ] := pPlus;
  Precedence [cMinus            ] := pMinus;
  Precedence [cDivide           ] := pDivide;
  Precedence [cLess             ] := pLess;
  Precedence [cLessEqual        ] := pLessEqual;
  Precedence [cEqual            ] := pEqual;
  Precedence [cGreater          ] := pGreater;
  Precedence [cGreaterEqual     ] := pGreaterEqual;
  Precedence [cAnd              ] := pAnd;
  Precedence [cIn               ] := pIn;
  Precedence [cMod              ] := pMod;
  Precedence [cNot              ] := pNot;
  Precedence [cOr               ] := pOr;
  Precedence [cUnion            ] := pUnion;
  Precedence [cDifference       ] := pDifference;
  Precedence [cIntersection     ] := pIntersection;
  Precedence [cSymDiff          ] := pSymDiff;
  Precedence [cIsSubset1        ] := pIsSubset1;
  Precedence [cIsSubset2        ] := pIsSubset2;
  Precedence [cAssign           ] := pAssign;
  Precedence [cPassValue        ] := pPassValue;
  Precedence [cPassAddress      ] := pPassAddress;

  BeginAssocTab;
  LabelStack.Begin;
  WithStack.Begin;
}

CLOSE   {
  CloseAssocTab;
  LabelStack.Close;
  WithStack.Close;
}

/*
 *      generate code for compilation units
 */

PROCEDURE CodeCompUnits ([ROOT, CompUnits])

ROOT            (CompUnits:) :-
                CodeCompUnits (CompUnits);
                .
DefMod          (_, Ident:, _, CompUnits0 (), Import:, Decls:) :-
{
                f := OpenHeader (Ident);

                WriteS (f, '#define DEFINITION_');WriteIdent (f, Ident); WriteNl (f);
                WriteNl (f);

                CodeImports (Import);
                CodeDefs1 (Decls);

/*              WriteS (f, 'extern void BEGIN_');WriteIdent (f, Ident);WriteS (f, '();'); WriteNl (f);  */
                WriteS (f, 'extern void ');WriteIdent (f, Ident);WriteS (f, '__init();'); WriteNl (f);

                WriteClose (f);
};
                .
DefMod:DefMod (_, Ident:, _, Next:CompUnit(..), Import:, Decls:) :-
{
                (* Associate the name of the definition module with     *)
                (* a pointer to its attributed structure tree (used to  *)
                (* access the import statements and the declarations    *)
                (* within the corresponding implementation module).     *)
                PutAssoc (Ident, DefMod);

                IF OptionIsSet ('i') THEN
                  f := OpenHeader (Ident);

                  WriteS (f, '#define DEFINITION_');WriteIdent (f, Ident); WriteNl (f);
                  WriteNl (f);

                  CodeImports (Import);
                  CodeDefs1 (Decls);

/*                WriteS (f, 'extern void BEGIN_');WriteIdent (f, Ident);WriteS (f, '();'); WriteNl (f); */
                  WriteS (f, 'extern void ');WriteIdent (f, Ident);WriteS (f, '__init();'); WriteNl (f);

                  WriteClose (f);
                END;

                CodeCompUnits (Next);
};
                .
ProgMod:ProgMod 
   ( Kind:, Ident:, Pos:, CompUnits0 (), Import1:Import(..)
   , Decls1:Decls(..), Stmts:) :-
                Kind = Implementation;
        VAR DefMod: tTree;
{
                f := OpenProgram (Ident);

                (* DefMod is a pointer to the attributed        *)
                (* structure tree of the corresponding          *)
                (* definition module.                           *)
                GetAssoc (Ident, DefMod);
                IF DefMod = NoTree THEN
                  CompilerError ("Code.CodeCompUnits");
                END;

                WriteS (f, '#include "SYSTEM_.h"'); WriteNl (f);
                WriteNl (f);

                CodeImports (Import1);

                WriteS (f, '#ifndef DEFINITION_');WriteIdent (f, Ident); WriteNl (f);
                WriteS (f, '#include "');WriteIdent (f, Ident);WriteS (f, '.h"'); WriteNl (f);
                WriteS (f, '#endif'); WriteNl (f);
                WriteNl (f);

                CodeDefs2 (DefMod^.DefMod.Decls);
                WriteNl (f);

                CodeDecls1 (Decls1);
                WriteNl (f);

                GenGlobalPtrs (ProgMod^.\ProgMod.GlobalPtrs);
                GlobalPtrs := ProgMod^.\ProgMod.GlobalPtrs;

                CodePointers (Static, ProgMod^.\ProgMod.GlobalPtrs);
                WriteNl (f);
                
                CodeProcs (Decls1);

/*              WriteS (f, 'void BEGIN_');WriteIdent (f, Ident);WriteS (f, '()'); WriteNl (f); */
                WriteS (f, 'void ');WriteIdent (f, Ident);WriteS (f, '__init()'); WriteNl (f);
                WriteC (f, '{'); WriteNl (f);
                WriteS (f, '  static BOOLEAN has_been_called = FALSE;'); WriteNl (f);
                WriteNl (f);

INC (Indent, 2);                 CodeStrings (ProgMod^.\ProgMod.Strings);
                   IF ProgMod^.\ProgMod.Strings # NoStrings THEN WriteNl (f); END;

                WriteS (f, '  if (!has_been_called) {'); WriteNl (f);
                WriteS (f, '    has_been_called = TRUE;'); WriteNl (f);
                WriteNl (f);

                     (* To ensure the initialization of all (global)    *)
                     (* modules, the import statements from the         *)
                     (* definition module have to be considered too     *)
INC (Indent, 2);                   CodeInits (DefMod^.DefMod.Import);
                     CodeInits (Import1);
                     CodeStrncpy (ProgMod^.\ProgMod.Strings);
                     CodeInits (Decls1);
                WriteNl (f);
                     CodeStmts (Stmts);

DEC (Indent, 4);             WriteS (f, '  }'); WriteNl (f);
                WriteC (f, '}'); WriteNl (f);

                WriteClose (f);
};
                .
ProgMod:ProgMod 
  (Kind:, Ident:, _, CompUnits0 (), Import:, Decls:, Stmts:) :-
                Kind = Program;
{
                f := OpenProgram (Ident);

                WriteS (f, '#include "SYSTEM_.h"'); WriteNl (f);
                WriteNl (f);

                CodeImports (Import);

                CodeDecls1 (Decls);
                WriteNl (f);

                GenGlobalPtrs (ProgMod^.\ProgMod.GlobalPtrs);
                GlobalPtrs := ProgMod^.\ProgMod.GlobalPtrs;

                CodePointers (Static, ProgMod^.\ProgMod.GlobalPtrs);
                WriteNl (f);
                
                CodeProcs (Decls);

                WriteS (f, 'extern int  parameters_argc;'); WriteNl (f);
                WriteS (f, 'extern char **parameters_argv;'); WriteNl (f);
                WriteS (f, 'extern char **parameters_envp;'); WriteNl (f);

                WriteS (f, '# ifdef __STDC__'); WriteNl (f);
                WriteS (f, 'void main(int argc, char *argv[], char *envp[])'); WriteNl (f);
                WriteS (f, '# else'); WriteNl (f);
                WriteS (f, 'void main(argc, argv, envp)'); WriteNl (f);
                WriteS (f, '  int argc;'); WriteNl (f);
                WriteS (f, '  char *argv[], *envp[];'); WriteNl (f);
                WriteS (f, '# endif'); WriteNl (f);
                WriteC (f, '{'); WriteNl (f);

                WriteS (f, 'parameters_argc = argc;'); WriteNl (f);
                WriteS (f, 'parameters_argv = argv;'); WriteNl (f);
                WriteS (f, 'parameters_envp = envp;'); WriteNl (f);

INC (Indent, 2);                CodeStrings (ProgMod^.\ProgMod.Strings);
                  IF ProgMod^.\ProgMod.Strings # NoStrings THEN WriteNl (f); END;

                  CodeInits (Import);
                  CodeStrncpy (ProgMod^.\ProgMod.Strings);
                  CodeInits (Decls);
                WriteNl (f);
                  CodeStmts (Stmts);
                WriteS (f, 'exit(0);'); WriteNl (f);
DEC (Indent, 2);              WriteC (f, '}'); WriteNl (f);

                WriteClose (f);
};
                .
/*
 *      generate code for (global) import statements
 */

PROCEDURE CodeImports ([Import, ImpIds])

From            (Next:, Ident:, ..) :-
                Ident # IdentSYSTEM;
                WriteS (f, '#ifndef DEFINITION_');WriteIdent (f, Ident); WriteNl (f);
                WriteS (f, '#include "');WriteIdent (f, Ident);WriteS (f, '.h"'); WriteNl (f);
                WriteS (f, '#endif'); WriteNl (f);
                WriteNl (f);
                CodeImports (Next);
                .
From            (Next:, ..) :-
                CodeImports (Next);
                .
Objects         (Next:, ImpIds:) :-
                CodeImports (ImpIds);
                CodeImports (Next);
                .
ImpIds1         (Ident:, _, Next:) :-
                Ident # IdentSYSTEM;
                WriteS (f, '#ifndef DEFINITION_');WriteIdent (f, Ident); WriteNl (f);
                WriteS (f, '#include "');WriteIdent (f, Ident);WriteS (f, '.h"'); WriteNl (f);
                WriteS (f, '#endif'); WriteNl (f);
                WriteNl (f);
                CodeImports (Next);
                .
ImpIds1         (_, _, Next:) :-
                CodeImports (Next);
                .
/*
 *      generate calls to initialization procedures for modules
 */

PROCEDURE CodeInits (t: [Import, ImpIds, Decls])

From            (Next:, Ident:, ..) :-
                Ident # IdentSYSTEM;
/*WriteSpaces (f, Indent);             WriteS (f, 'BEGIN_');WriteIdent (f, Ident);WriteS (f, '();'); WriteNl (f);*/
WriteSpaces (f, Indent);               WriteIdent (f, Ident);WriteS (f, '__init();'); WriteNl (f);
                CodeInits (Next);
                .
From            (Next:, ..) :-
                CodeInits (Next);
                .
Objects         (Next:, ImpIds:) :-
                CodeInits (ImpIds);
                CodeInits (Next);
                .
ImpIds1         (Ident:, _, Next:) :-
                Ident # IdentSYSTEM;
/*WriteSpaces (f, Indent);             WriteS (f, 'BEGIN_');WriteIdent (f, Ident);WriteS (f, '();'); WriteNl (f); */
WriteSpaces (f, Indent);               WriteIdent (f, Ident);WriteS (f, '__init();'); WriteNl (f);
                CodeInits (Next);
                .
ImpIds1         (_, _, Next:) :-
                CodeInits (Next);
                .
Module          (Next:, _, _, _, Decls:, _) :-
WriteSpaces (f, Indent);               WriteIdent (f, t^.Module.CIdent);WriteS (f, '();'); WriteNl (f);
                CodeInits (Decls);
                CodeInits (Next);
                .
Decl            (Next:) :-
                CodeInits (Next);
                .
/*
 *      generate code for the declarations of a definition module
 *      (to be included in the header file)
 */

PROCEDURE CodeDefs1 (t: [Decls])

Var             (Next:, VarIds:, Type:) :-
                CodeEnums (Type);
                WriteS (f, 'extern '); CodeType (Type, Full); WriteC (f, ' '); CodeIds (VarIds, Type); WriteC (f, ';'); WriteNl (f);
                CodeDefs1 (Next);
                .
Const           (Next:, _, StringConst (StringVal:)) :-
                Length (StringVal) > 1;
                WriteS (f, 'extern CHAR ');WriteIdent (f, t^.Const.CIdent);WriteS (f, '[];'); WriteNl (f);
                CodeDefs1 (Next);
                .
Const           (Next:, _, expr:) :-
                expr^.Expr.IsCConst;
                WriteS (f, '#define ');WriteIdent (f, t^.Const.CIdent);WriteS (f, '   '); CodeExpr (expr, pMaxPrec); WriteNl (f);
                CodeDefs1 (Next);
                .
Const           (Next:, _, Expr:) :-
                WriteS (f, '#define ');WriteIdent (f, t^.Const.CIdent);WriteS (f, '   '); CodeValue (t^.Const.Object^.Const1.Value); WriteNl (f);
                CodeDefs1 (Next);
                .
TypeDecl        (Next:, _, Type:, _) :-
                CodeEnums (Type);
                WriteS (f, 'typedef '); CodeType (Type, Full); WriteC (f, ' ');
                  CodeDecla (Type, Before); WriteIdent (f, t^.TypeDecl.CIdent); CodeDecla (Type, After); WriteC (f, ';'); WriteNl (f);
                CodeDefs1 (Next);
                .
ProcHead        (Next:, _, Formals:, ResultType:, _) :-
                WriteS (f, 'extern '); CodeType (ResultType, Full); WriteC (f, ' ');WriteIdent (f, t^.ProcHead.CIdent);
                WriteS (f, ' ARGS(('); CodeFormals3 (Formals, NoIdent); WriteS (f, '));'); WriteNl (f);
                CodeDefs1 (Next);
                .
Opaque          (Next:, _) :-
                WriteS (f, 'typedef OPAQUE ');WriteIdent (f, t^.Opaque.CIdent);WriteC (f, ';'); WriteNl (f);
                CodeDefs1 (Next);
                .
/*
 *      generate code for the declarations of a definition module
 *      (to be included in the source file)
 */

PROCEDURE CodeDefs2 (t: [Decls])

Var             (Next:, VarIds:, Type:) :-
                CodeType (Type, NonFull); WriteC (f, ' '); CodeIds (VarIds, Type); WriteC (f, ';'); WriteNl (f);
                CodeDefs2 (Next);
                .
Const           (Next:, _, StringConst (StringVal:)) :-
                Length (StringVal) > 1;
                WriteS (f, 'CHAR ');WriteIdent (f, t^.Const.CIdent);WriteS (f, ' [] = '); CodeString1 (StringVal); WriteC (f, ';'); WriteNl (f);
                CodeDefs2 (Next);
                .
Decl            (Next:) :-
                CodeDefs2 (Next);
                .
/*
 *      generate code for constant, type, and global variable
 *      declarations of an implementation or program module
 *      generate structure declarations for structured types used in
 *      local variable declarations
 *      generate forward declarations for non exported procedures
 *      of an implementation or program module
 */

PROCEDURE CodeDecls1 (t: [Decls])

Var             (Next:, VarIds:, Type:) :-
                t^.Var.IsGlobal;
                CodeEnums (Type);
                WriteS (f, 'static '); CodeType (Type, Full); WriteC (f, ' '); CodeIds (VarIds, Type); WriteC (f, ';'); WriteNl (f);
                CodeDecls1 (Next);
                .
Var             (Next:, VarIds:, Type:) :-
                NOT t^.Var.IsGlobal;
                CodeEnums (Type);
                CodeStruct (Type);
                CodeDecls1 (Next);
                .
Const           (Next:, _, StringConst (StringVal:)) :-
                Length (StringVal) > 1;
                WriteS (f, 'static CHAR ');WriteIdent (f, t^.Const.CIdent);WriteS (f, ' [] = '); CodeString1 (StringVal); WriteC (f, ';'); WriteNl (f);
                CodeDecls1 (Next);
                .
Const           (Next:, _, expr:) :-
                expr^.Expr.IsCConst;
                WriteS (f, '#define ');WriteIdent (f, t^.Const.CIdent);WriteS (f, '   '); CodeExpr (expr, pMaxPrec); WriteNl (f);
                CodeDecls1 (Next);
                .
Const           (Next:, ..) :-
                WriteS (f, '#define ');WriteIdent (f, t^.Const.CIdent);WriteS (f, '   '); CodeValue (t^.Const.Object^.Const1.Value); WriteNl (f);
                CodeDecls1 (Next);
                .
TypeDecl        (Next:, _, Type:, _) :-
                CodeEnums (Type);
                WriteS (f, 'typedef '); CodeType (Type, Full); WriteC (f, ' ');
                  CodeDecla (Type, Before); WriteIdent (f, t^.TypeDecl.CIdent); CodeDecla (Type, After); WriteC (f, ';'); WriteNl (f);
                CodeDecls1 (Next);
                .
Proc            (Next:, _, Formals:, ResultType:, Decls:, _) :-
                NOT IsExported (t^.Proc.Object);
                WriteS (f, 'static '); CodeType (ResultType, Full); WriteC (f, ' ');WriteIdent (f, t^.Proc.CIdent);
                WriteS (f, ' ARGS(('); CodeFormals3 (Formals, NoIdent); WriteS (f, '));'); WriteNl (f);
                CodeDecls1 (Decls);
                CodeDecls1 (Next);
                .
Proc            (Next:, _, _, _, Decls:, _) :-
                CodeDecls1 (Decls);
                CodeDecls1 (Next);
                .
Module          (Next:, _, _, _, Decls:, _) :-
                CodeDecls1 (Decls);
                CodeDecls1 (Next);
                .
/*
 *      generate code for type declarations
 *      ( generate a C type name)
 */

PROCEDURE CodeType (t: [Type, Fields, TagField, Variants], Full: BOOLEAN)

/* Full = FALSE: generate a declaration of the form struct Name for     */
/*               arrays and records instead of a complete structure     */
/*               declaration                                            */

Array           (_, IndexType:, ElemType:), _ :-
                IndexType^.SimpleType.Type2^.Kind = Subrange1;
        VAR Lwb: tValue, VAR LwbExpr: tTree, VAR UpbExpr: tTree;
{
                IF Full THEN
                  GetLwb (IndexType^.SimpleType.Type2, Lwb);
                  LwbExpr := IndexType^.SimpleType.Type2^.Subrange1.LwbExpr;
                  UpbExpr := IndexType^.SimpleType.Type2^.Subrange1.UpbExpr;

                  WriteS (f, 'struct ');WriteIdent (f, t^.Array.Type2^.Array1.StructId);WriteS (f, ' {'); WriteNl (f);
INC (Indent, 4);WriteSpaces (f, Indent);                  CodeType (ElemType, Full); WriteC (f, ' ');
                      CodeDecla (ElemType, Before);
                      WriteS (f, 'A[');
                       IF UpbExpr^.Expr.IsCConst THEN
                         IF ValueToInt (Lwb) # 0 THEN
                           CodeExpr (UpbExpr, pMinus + 1);
                         ELSE
                           CodeExpr (UpbExpr, pPlus + 1);
                         END;
                       ELSE
                         CodeValue (IndexType^.SimpleType.Type2^.Subrange1.Upb);
                       END;
                       IF ValueToInt (Lwb) # 0 THEN
                         WriteS (f, ' - ');
                         IF LwbExpr^.Expr.IsCConst THEN
                           CodeExpr (LwbExpr, pMinus);
                         ELSE
                           CodeValue (Lwb);
                         END;
                       END;
                       WriteS (f, ' + 1');
                      WriteC (f, ']');
                      CodeDecla (ElemType, After); WriteC (f, ';'); WriteNl (f);
DEC (Indent, 4);WriteSpaces (f, Indent);              WriteC (f, '}');
                ELSE
                  WriteS (f, 'struct ');WriteIdent (f, t^.Array.Type2^.Array1.StructId);
                END;
};
                .
Array           (_, IndexType:, ElemType:), _ :-
                IndexType^.SimpleType.Type2^.Kind = Enumeration1;
        VAR Upb: tValue;
{
                IF Full THEN
                  GetUpb (IndexType^.SimpleType.Type2, Upb);
                  WriteS (f, 'struct ');WriteIdent (f, t^.Array.Type2^.Array1.StructId);WriteS (f, ' {'); WriteNl (f);
INC (Indent, 4);WriteSpaces (f, Indent);                  CodeType (ElemType, Full); WriteC (f, ' ');
                      CodeDecla (ElemType, Before);
                      WriteS (f, 'A['); CodeValue (Upb); WriteS (f, ' + 1]');
                      CodeDecla (ElemType, After); WriteC (f, ';'); WriteNl (f);
DEC (Indent, 4);WriteSpaces (f, Indent);              WriteC (f, '}');
                ELSE
                  WriteS (f, 'struct ');WriteIdent (f, t^.Array.Type2^.Array1.StructId);
                END;
};
                .
Array           (_, IndexType:, ElemType:), _ :-
        VAR Lwb: tValue, VAR Upb: tValue;
{
                IF Full THEN
                  GetLwb (IndexType^.SimpleType.Type2, Lwb);
                  GetUpb (IndexType^.SimpleType.Type2, Upb);

                  WriteS (f, 'struct ');WriteIdent (f, t^.Array.Type2^.Array1.StructId);WriteS (f, ' {'); WriteNl (f);
INC (Indent, 4);WriteSpaces (f, Indent);                  CodeType (ElemType, Full); WriteC (f, ' ');
                      CodeDecla (ElemType, Before);
                      WriteS (f, 'A[');WriteI (f, ValueToInt (Upb) - ValueToInt (Lwb) + 1, 1);WriteC (f, ']');
                      CodeDecla (ElemType, After); WriteC (f, ';'); WriteNl (f);
DEC (Indent, 4);WriteSpaces (f, Indent);              WriteC (f, '}');
                ELSE
                  WriteS (f, 'struct ');WriteIdent (f, t^.Array.Type2^.Array1.StructId);
                END;
};
                .
Record          (Fields0 ()), _ :-
/* generate a dummy field named 'dummy' of type char, because   */
/* empty structures are not allowed in C                        */
{
                IF Full THEN
                  WriteS (f, 'struct ');WriteIdent (f, t^.Record.Type2^.Record1.StructId);WriteS (f, ' {'); WriteNl (f);
INC (Indent, 4);WriteSpaces (f, Indent);                  WriteS (f, 'char dummy;'); WriteNl (f);
DEC (Indent, 4);WriteSpaces (f, Indent);              WriteC (f, '}');
                ELSE
                  WriteS (f, 'struct ');WriteIdent (f, t^.Record.Type2^.Record1.StructId);
                END;
};
                .
Record          (fields1:Fields1(..)), _ :-
{
                IF Full THEN
                WriteS (f, 'struct ');WriteIdent (f, t^.Record.Type2^.Record1.StructId);WriteS (f, ' {'); WriteNl (f);
INC (Indent, 4);                 CodeType (fields1, Full);
DEC (Indent, 4);WriteSpaces (f, Indent);            WriteC (f, '}');
                ELSE
                  WriteS (f, 'struct ');WriteIdent (f, t^.Record.Type2^.Record1.StructId);
                END;
};
                .
SetType         (_), _ :-
                WriteS (f, 'unsigned long');
                .
Pointer         (ti:TypeId0(..)), _ :-
                (IsForward (t^.Pointer.TypePos, ti^.TypeId0.Object));
{
                CASE ti^.TypeId0.Type2^.Kind OF
                | Record1       : WriteS (f, 'struct ');WriteIdent (f, ti^.TypeId0.Type2^.Record1.StructId);
                | Array1        : WriteS (f, 'struct ');WriteIdent (f, ti^.TypeId0.Type2^.Array1.StructId);
                ELSE
                  WriteIdent (f, ti^.TypeId0.Object^.Object.CIdent);
                  ErrorMessageP (StructTypeReq, Restriction, ti^.TypeId0.Pos);
                END;
};
                .
Pointer         (TargetType:), _ :-
                CodeType (TargetType, Full);
                .
ProcType        (_, ResultType:), _ :-
                CodeType (ResultType, Full);
                .
Enumeration     (EnumIds:), _ :-
{
                IF TypeSize (t^.Enumeration.Type2) = SizeUnsignedChar THEN
                  WriteS (f, 'unsigned char');
                ELSE
                  WriteS (f, 'unsigned short');
                END;
};
                .
Subrange        (Void (), ..), _ :-
                CodeTypeName (t^.Subrange.Type2^.Subrange1.Type);
                .
Subrange        (type:TypeId(..), ..), _ :-
                WriteIdent (f, type^.TypeId.Object^.Object.CIdent);
                .
Void            (), _ :-
                WriteS (f, 'void');
                .
TypeId          (..), _ :-
                WriteIdent (f, t^.TypeId.Object^.Object.CIdent);
                .
RecordSect      (Next:, FieldIds:, Type:), _ :-
WriteSpaces (f, Indent);               CodeType (Type, Full); WriteC (f, ' '); CodeIds (FieldIds, Type); WriteC (f, ';'); WriteNl (f);
                CodeType (Next, Full);
                .
VariantSect     (Next:, TagField:, Variants0 (), Fields0 ()), _ :-
/* generate a dummy field named 'dummy' of type char, because   */
/* empty structures are not allowed in C                        */
                CodeType (TagField, Full);
WriteSpaces (f, Indent);               WriteS (f, 'union {'); WriteNl (f);
INC (Indent, 4);WriteSpaces (f, Indent);                WriteS (f, 'char dummy;'); WriteNl (f);
DEC (Indent, 4);WriteSpaces (f, Indent);            WriteS (f, '} ');WriteIdent (f, t^.VariantSect.UnionId);WriteC (f, ';'); WriteNl (f);
                CodeType (Next, Full);
                .
VariantSect     (Next:, TagField:, Variants:, Fields0 ()), _ :-
                CodeType (TagField, Full);
WriteSpaces (f, Indent);               WriteS (f, 'union {'); WriteNl (f);
INC (Indent, 4);                 CodeType (Variants, Full);
DEC (Indent, 4);WriteSpaces (f, Indent);            WriteS (f, '} ');WriteIdent (f, t^.VariantSect.UnionId);WriteC (f, ';'); WriteNl (f);
                CodeType (Next, Full);
                .
VariantSect     (Next:, TagField:, Variants:, ElsePart:), _ :-
                CodeType (TagField, Full);
WriteSpaces (f, Indent);               WriteS (f, 'union {'); WriteNl (f);
INC (Indent, 4);                 CodeType (Variants, Full);
WriteSpaces (f, Indent);                   WriteS (f, 'struct {'); WriteNl (f);
INC (Indent, 4);                     CodeType (ElsePart, Full);
DEC (Indent, 4);WriteSpaces (f, Indent);                WriteS (f, '} ');WriteIdent (f, t^.VariantSect.ElseId);WriteC (f, ';'); WriteNl (f);
DEC (Indent, 4);WriteSpaces (f, Indent);            WriteS (f, '} ');WriteIdent (f, t^.VariantSect.UnionId);WriteC (f, ';'); WriteNl (f);
                CodeType (Next, Full);
                .
TagField1       (type:, _), _ :-
WriteSpaces (f, Indent);               WriteIdent (f, type^.TypeId.Object^.Object.CIdent);WriteC (f, ' ');WriteIdent (f, t^.TagField1.CIdent);WriteC (f, ';'); WriteNl (f);
                .
Variant         (_, Fields0 (), Next:), _ :-
/* generate a dummy field named 'dummy' of type char, because   */
/* empty structures are not allowed in C                        */
WriteSpaces (f, Indent);               WriteS (f, 'struct {'); WriteNl (f);
INC (Indent, 4);WriteSpaces (f, Indent);                WriteS (f, 'char dummy;'); WriteNl (f);
DEC (Indent, 4);WriteSpaces (f, Indent);            WriteS (f, '} ');WriteIdent (f, t^.Variant.StructId);WriteC (f, ';'); WriteNl (f);
                CodeType (Next, Full);
                .
Variant         (_, fields1:Fields1(..), Next:), _ :-
WriteSpaces (f, Indent);               WriteS (f, 'struct {'); WriteNl (f);
INC (Indent, 4);                 CodeType (fields1, Full);
DEC (Indent, 4);WriteSpaces (f, Indent);            WriteS (f, '} ');WriteIdent (f, t^.Variant.StructId);WriteC (f, ';'); WriteNl (f);
                CodeType (Next, Full);
                .
/*
 *      generate code for type declarations
 *      (generate the part of a C declarator before/after the identifier)
 */

PROCEDURE CodeDecla ([Type], Before: BOOLEAN)

Pointer         (TargetType:), _ :-
                CodeDecla (TargetType, Before);
{
                IF Before THEN WriteC (f, '*'); END;
};
                .
ProcType        (FormalTypes:, _), _ :-
{
                IF Before THEN WriteS (f, '(*'); ELSE WriteS (f, ') ARGS(('); CodeFormals4 (FormalTypes); WriteS (f, '))'); END;
};
                .
/*
 *      generate code for type declarations
 *      (generate a C structure declaration)
 */

PROCEDURE CodeStruct (t: [Type])

Array           (..) :-
                CodeType (t, Full); WriteC (f, ';'); WriteNl (f);
                .
Record          (..) :-
                CodeType (t, Full); WriteC (f, ';'); WriteNl (f);
                .
Pointer         (TargetType:) :-
                CodeStruct (TargetType);
                .
/*
 *      generate code for enumeration literals
 */

PROCEDURE CodeEnums (t: [Type, Fields, Variants, EnumIds])

Array           (_, IndexType:, ElemType:) :-
                CodeEnums (IndexType);
                CodeEnums (ElemType);
                .
Record          (Fields:) :-
                CodeEnums (Fields);
                .
SetType         (BaseType:) :-
                CodeEnums (BaseType);
                .
Pointer         (TargetType:) :-
                CodeEnums (TargetType);
                .
Enumeration     (EnumIds:) :-
                CodeEnums (EnumIds);
                .
RecordSect      (Next:, _, Type:) :-
                CodeEnums (Type);
                .
VariantSect     (Next:, _, Variants:, ElsePart:) :-
                CodeEnums (Variants);
                CodeEnums (ElsePart);
                CodeEnums (Next);
                .
Variant         (_, Fields:, Next:) :-
                CodeEnums (Fields);
                CodeEnums (Next);
                .
EnumIds1        (_, Next:) :-
                WriteS (f, '#define ');WriteIdent (f, t^.EnumIds1.CIdent);WriteS (f, '        ');
                  WriteI (f, t^.EnumIds1.Object^.EnumLiteral1.Index, 1); WriteNl (f);
                CodeEnums (Next);
                .
/*
 *      generate code for variable and field identifier lists
 */

PROCEDURE CodeIds (t: [VarIds, FieldIds], Type: tTree)

/* Type: tree of the type belonging to the variables resp. fields       */

VarIds1         (_, Next:), _ :-
                CodeDecla (Type, Before); WriteIdent (f, t^.VarIds1.CIdent); CodeDecla (Type, After);
                CodeSepa (Next);
                CodeIds (Next, Type);
                .
FieldIds1       (_, Next:), _ :-
                CodeDecla (Type, Before); WriteIdent (f, t^.FieldIds1.CIdent); CodeDecla (Type, After);
                CodeSepa (Next);
                CodeIds (Next, Type);
                .
/*
 *      generate code for procedure declarations
 *      generate initialization routines for local modules
 */

PROCEDURE CodeProcs (t: [Decls])

Proc            (Next:, _, Formals:, ResultType:, Decls:, Stmts:) :-
        VAR NewLine: BOOLEAN;
{
                CodeProcs (Decls);

                GenParams (t^.Proc.VAROpens);
                GenParams (t^.Proc.ValueOpens);
                GenLocalPtrs (t^.Proc.LocalPtrs);

                VAROpens        := t^.Proc.VAROpens;
                ValueOpens      := t^.Proc.ValueOpens;
                LocalPtrs       := t^.Proc.LocalPtrs;

                IF NOT IsExported (t^.Proc.Object) THEN WriteS (f, 'static '); END;
                CodeType (ResultType, Full); WriteC (f, ' ');WriteIdent (f, t^.Proc.CIdent);WriteNl (f);
                WriteS (f, '# ifdef __STDC__'); WriteNl (f);
                WriteC (f, '('); CodeFormals3 (Formals, NoIdent); WriteC (f, ')'); WriteNl (f);
                WriteS (f, '# else'); WriteNl (f);
                WriteC (f, '('); CodeFormals1 (Formals); WriteC (f, ')'); WriteNl (f);
                CodeFormals2 (Formals, NoIdent);
                WriteS (f, '# endif'); WriteNl (f);
                WriteC (f, '{'); WriteNl (f);
                  NewLine := (t^.Proc.ValueOpens # NoCObjects) OR
                             (t^.Proc.LocalPtrs  # NoCObjects) OR
                             (t^.Proc.Strings    # NoStrings );
INC (Indent, 2);                CodeDecls2 (Decls, NewLine);
                  IF t^.Proc.ValueOpens # NoCObjects THEN
WriteSpaces (f, Indent);                   WriteS (f, 'OPEN_ARRAY_LOCALS'); WriteNl (f);
                  END;
                  CodePointers (Auto, t^.Proc.LocalPtrs);
                  CodeStrings (t^.Proc.Strings);
                  IF NewLine THEN WriteNl (f); END;

                  CodeAlloc   (t^.Proc.ValueOpens);
                  CodeCopy    (t^.Proc.ValueOpens);
                  CodePush    (t^.Proc.LocalPtrs);
                  CodeStrncpy (t^.Proc.Strings);
                  CodeInits   (Decls);

                  CodeStmts (Stmts);

                  IF GetResultType (GetType (t^.Proc.Object)) = TypeVOID THEN
                    CodePop (t^.Proc.LocalPtrs);
                    CodeFree (t^.Proc.ValueOpens);
                  ELSE
                    (* the last statement of a function must    *)
                    (* be a return statement, hence no code to  *)
                    (* release open array value parameters or   *)
                    (* to restore global pointer variables has  *)
                    (* to be generated here                     *)
                    IF OptionIsSet ('r') THEN
WriteSpaces (f, Indent);                     WriteS (f, 'ReturnError(__FILE__, __LINE__);'); WriteNl (f);
                    END;
                  END;

DEC (Indent, 2);              WriteC (f, '}'); WriteNl (f);
                WriteNl (f);

                VAROpens        := NoCObjects;
                ValueOpens      := NoCObjects;
                LocalPtrs       := NoCObjects;
};
                CodeProcs (Next);
                .
Module          (Next:, _, Import:, Export:, Decls:, Stmts:) :-
                CodeProcs (Decls);
{
                WriteS (f, 'static void ');WriteIdent (f, t^.Module.CIdent);WriteS (f, '()'); WriteNl (f);
                WriteC (f, '{'); WriteNl (f);
INC (Indent, 2);                CodeStrings (t^.Module.Strings);
                  IF t^.Module.Strings # NoStrings THEN WriteNl (f); END;

                  CodeStrncpy (t^.Module.Strings);
                  CodeStmts (Stmts);
DEC (Indent, 2);              WriteC (f, '}'); WriteNl (f);
                WriteNl (f);
};
                CodeProcs (Next);
                .
Decl            (Next:) :-
                CodeProcs (Next);
                .
/*
 *      generate code for formal parameter lists
 *      (parameter names)
 */

PROCEDURE CodeFormals1 (t: [Formals, ParIds])

Formals1        (_, ParIds:, _, Next:) :-
                CodeFormals1 (ParIds); CodeSepa (Next);
                CodeFormals1 (Next);
                .
ParIds1         (_, Next:) :-
                (IsOpenArray (t^.ParIds1.Object));
                WriteIdent (f, t^.ParIds1.CIdent);WriteS (f, ', ');
                WriteIdent (f, GetParam (t^.ParIds1.Object));
                CodeSepa (Next);
                CodeFormals1 (Next);
                .
ParIds1         (_, Next:) :-
                WriteIdent (f, t^.ParIds1.CIdent); CodeSepa (Next);
                CodeFormals1 (Next);
                .
/*
 *      generate code for formal parameter lists
 *      (parameter declarations)
 */

PROCEDURE CodeFormals2 (t: [Formals, ParIds], ElemTypeId: tIdent)

/* ElemTypeId: identifier of the element type of open array parameters  */

Formals1        (_, ParIds:, type:TypeId(..), Next:), _ :-
                WriteIdent (f, type^.TypeId.Object^.Object.CIdent);WriteC (f, ' '); CodeFormals2 (ParIds, NoIdent); WriteC (f, ';'); WriteNl (f);
                CodeFormals2 (Next, NoIdent);
                .
Formals1        (_, ParIds:, Array ({TRUE}, _, type:TypeId(..)), Next:), _ :-
                CodeFormals2 (ParIds, type^.TypeId.Object^.Object.CIdent);
                CodeFormals2 (Next, NoIdent);
                .
ParIds1         (_, Next:), _ :-
                (IsOpenArray (t^.ParIds1.Object));
                WriteIdent (f, ElemTypeId);WriteC (f, ' ');WriteIdent (f, t^.ParIds1.CIdent);WriteS (f, '[];'); WriteNl (f);
                WriteS (f, 'LONGCARD ');WriteIdent (f, GetParam (t^.ParIds1.Object));WriteC (f, ';'); WriteNl (f);
                CodeFormals2 (Next, ElemTypeId);
                .
ParIds1         (_, Next:), _ :-
                { IF IsVAR (t^.ParIds1.Object) THEN WriteC (f, '*'); END; };
                WriteIdent (f, t^.ParIds1.CIdent); CodeSepa (Next);
                CodeFormals2 (Next, NoIdent);
                .
/*
 *      generate prototypes for formal parameter lists
 *      (parameter declarations)
 */

PROCEDURE CodeFormals3 (t: [Formals, ParIds], TypeId: tIdent)

/* TypeId: identifier of the element type of open array parameters      */

Formals1        (_, ParIds:, type:TypeId(..), Next:), _ ;
Formals1        (_, ParIds:, Array ({TRUE}, _, type:TypeId(..)), Next:), _ :-
                CodeFormals3 (ParIds, type^.TypeId.Object^.Object.CIdent);
                CodeSepa (Next);
                CodeFormals3 (Next, NoIdent);
                .
ParIds1         (_, Next:), _ :-
                (IsOpenArray (t^.ParIds1.Object));
                WriteIdent (f, TypeId);WriteC (f, ' ');WriteIdent (f, t^.ParIds1.CIdent);WriteS (f, '[], ');
                WriteS (f, 'LONGCARD ');WriteIdent (f, GetParam (t^.ParIds1.Object)); CodeSepa (Next);
                CodeFormals3 (Next, TypeId);
                .
ParIds1         (_, Next:), _ :-
                WriteIdent (f, TypeId); { IF IsVAR (t^.ParIds1.Object) THEN WriteS (f, ' *'); ELSE WriteC (f, ' '); END; };
                WriteIdent (f, t^.ParIds1.CIdent); CodeSepa (Next);
                CodeFormals3 (Next, TypeId);
                .
/*
 *      generate prototypes for procedure types
 */

PROCEDURE CodeFormals4 (FormalTypes)

FormalType      (IsVAR:, Type:, Next:):-
                CodeType (Type, Full);
                { IF IsVAR THEN WriteS (f, ' *'); END; };
                CodeSepa (Next);
                CodeFormals4 (Next);
                .
/*
 *      generate code for local variable declarations
 */

PROCEDURE CodeDecls2 ([Decls] => NewLine: BOOLEAN)

/* NewLine: NewLine is set to TRUE if there are local variable  */
/*          declarations                                        */

Var             (Next:, VarIds:, Type:) => _ :-
WriteSpaces (f, Indent);               CodeType (Type, NonFull); WriteC (f, ' '); CodeIds (VarIds, Type); WriteC (f, ';'); WriteNl (f);
                NewLine := TRUE;
                { CodeDecls2 (Next, NewLine); };
                .
Module          (Next:, _, _, _, Decls:, _) => _ :-
                { CodeDecls2 (Decls, NewLine); };
                { CodeDecls2 (Next, NewLine); };
                .
Decl            (Next:) => _ :-
                { CodeDecls2 (Next, NewLine); };
                .
/*
 *      generate code for expressions, designators, and set elements
 */

PROCEDURE CodeExpr (t: [Expr, Elems], Prec: SHORTCARD)

/* The attribute Prec is the precedence of the C-operator used in the   */
/* parent expression. It is used to determine, when an expression has   */
/* to be put in parentheses to enforce the correct evaluation order in  */
/* C.                                                                   */

Binary          (_, Lop:, Rop:), _ :-
                t^.Binary.COperator IN {{cIn, cDifference, cIsSubset1, cIsSubset2}};
{
                CASE t^.Binary.COperator OF
                | cIn           : WriteS (f, 'IN');
                | cDifference   : WriteS (f, 'SET_DIFF');
                | cIsSubset1    : WriteS (f, 'SET_IS_SUBSET1');
                | cIsSubset2    : WriteS (f, 'SET_IS_SUBSET2');
                END;
};
                WriteC (f, '('); CodeExpr (Lop, pPassValue); WriteS (f, ', '); CodeExpr (Rop, pPassValue); WriteC (f, ')');
                .
Binary          (_, Lop:, Rop:), _ :-
                (t^.Binary.COperator IN {{cPlus, cMinus}}) AND
                (Lop^.Expr.Type = TypeADDRESS) AND (Rop^.Expr.Type = TypeADDRESS);
{
                IF Prec <= Precedence [t^.Binary.COperator] THEN WriteC (f, '('); END;
                CodeExpr (Lop, Precedence [t^.Binary.COperator] + 1);
                IF t^.Binary.COperator = cPlus THEN WriteS (f, ' + '); ELSE WriteS (f, ' - '); END;
                WriteS (f, '(LONGCARD)'); CodeExpr (Rop, pCast);
                IF Prec <= Precedence [t^.Binary.COperator] THEN WriteC (f, ')'); END;
};
                .
Binary          (_, Lop:, Rop:), _ :-
                (t^.Binary.COperator = cMinus) AND
                NOT (Lop^.Expr.Type = TypeADDRESS) AND (Rop^.Expr.Type = TypeADDRESS);
{
                IF Prec < pCast THEN WriteC (f, '('); END;
                WriteS (f, '(ADDRESS)('); CodeExpr (Lop, pMinus + 1); WriteS (f, ' - (LONGCARD)'); CodeExpr (Rop, pCast); WriteC (f, ')');
                IF Prec < pCast THEN WriteC (f, ')'); END;
};
                .
Binary          (_, Lop:, Rop:), _ :-
                (t^.Binary.COperator IN {{cTimes, cDivide}}) AND
                ((Lop^.Expr.Type = TypeADDRESS) OR (Rop^.Expr.Type = TypeADDRESS));
{
                IF Prec < pCast THEN WriteC (f, '('); END;
                WriteS (f, '(ADDRESS)(');
                IF Lop^.Expr.Type = TypeADDRESS THEN
                  WriteS (f, '(LONGCARD)'); CodeExpr (Lop, pCast);
                ELSE
                  CodeExpr (Lop, Precedence [t^.Binary.COperator] + 1);
                END;
                IF t^.Binary.COperator = cTimes THEN WriteS (f, ' * '); ELSE WriteS (f, ' / '); END;
                IF Rop^.Expr.Type = TypeADDRESS THEN
                  WriteS (f, '(LONGCARD)'); CodeExpr (Rop, pCast);
                ELSE
                  CodeExpr (Rop, Precedence [t^.Binary.COperator]);
                END;
                WriteC (f, ')');
                IF Prec < pCast THEN WriteC (f, ')'); END;
};
                .
Binary          (_, Lop:, Rop:), _ :-
{
                IF Prec <= Precedence [t^.Binary.COperator] THEN WriteC (f, '('); END;
                CodeExpr (Lop, Precedence [t^.Binary.COperator] + 1);
                (* Precedence [t^.Binary.COperator] + 1 to avoid        *)
                (* superfluous brackets (all binary operators   *)
                (* are left associative)                        *)
                CASE t^.Binary.COperator OF
                | cNotEqual     : WriteS (f, ' != ');
                | cTimes        : WriteS (f, ' * ');
                | cPlus         : WriteS (f, ' + ');
                | cMinus        : WriteS (f, ' - ');
                | cDivide       : WriteS (f, ' / ');
                | cLess         : WriteS (f, ' < ');
                | cLessEqual    : WriteS (f, ' <= ');
                | cEqual        : WriteS (f, ' == ');
                | cGreater      : WriteS (f, ' > ');
                | cGreaterEqual : WriteS (f, ' >= ');
                | cAnd          : WriteS (f, ' && ');
                | cMod          : WriteS (f, ' % ');
                | cOr           : WriteS (f, ' || ');
                | cUnion        : WriteS (f, ' | ');
                | cIntersection : WriteS (f, ' & ');
                | cSymDiff      : WriteS (f, ' ^ ');
                ELSE
                END;
                CodeExpr (Rop, Precedence [t^.Binary.COperator]);
                IF Prec <= Precedence [t^.Binary.COperator] THEN WriteC (f, ')'); END;
};
                .
Unary           (_, IntConst (Kind:, IntVal:, _)), _ :-
                t^.Unary.COperator = cMinus;
{
                CASE Kind OF
                | Decimal       : WriteC (f, '-');WriteCard (f, IntVal, 1);
                | Octal         : WriteS (f, '-0');WriteN (f, IntVal, 1, 8);
                | Hexadecimal   : WriteS (f, '-0X');WriteN (f, IntVal, 1, 16);
                END;
};
                .
Unary           (_, Mop:), _ :-
{
                IF Prec < Precedence [t^.Unary.COperator] THEN WriteC (f, '('); END;
                CASE t^.Unary.COperator OF
                | cMinus        : WriteC (f, '-');
                | cNot          : WriteC (f, '!');
                ELSE
                END;
                CodeExpr (Mop, Precedence [t^.Unary.COperator]);
                IF Prec < Precedence [t^.Unary.COperator] THEN WriteC (f, ')'); END;
};
                .
IntConst        (Kind:, IntVal:, Pos:), _ :-
{
                IF IntVal > MaxLongInt THEN
                  WriteS (f, '(LONGCARD)');
                  ErrorMessageP (OutOfLongRange, Warning, Pos);
                END;
                CASE Kind OF
                | Decimal       : WriteCard (f, IntVal, 1);
                | Octal         : WriteC (f, '0');WriteN (f, IntVal, 1, 8);
                | Hexadecimal   : WriteS (f, '0X');WriteN (f, IntVal, 1, 16);
                END;
};
                .
RealConst       (RealVal:), _ :-
                WriteString (f, RealVal);
                .
StringConst     (StringVal:), _ :-
                Length (StringVal) = 1;
        VAR String: tString;
                GetString (StringVal, String);
                CodeChar (Strings.Char (String, 1));
                .
StringConst     (StringVal:), _ :-
                CodeString1 (StringVal);
                .
CharConst       (CharVal:), _ :-
                CodeChar (CharVal);
                .
FuncCall        (designator:, Actuals:), _ :-
                designator^.Designator.Type^.Kind = StdProcType1;
                CodeStdProc (Actuals, designator^.Designator.Type^.StdProcType1.StdProc, NoObject);
                .
FuncCall        (qualid:Qualid(..), Actuals:), _ :-
                (IsProcedure (qualid^.Qualid.Object));
                WriteIdent (f, qualid^.Qualid.Object^.Object.CIdent); WriteC (f, '('); CodeActuals (Actuals); WriteC (f, ')');
                .
FuncCall        (qualid:Qualid(..), Actual (Expr:, Actuals0 ())), _ :-
                (IsOfType (qualid^.Qualid.Object));
{
                IF Prec < pCast THEN
                  WriteS (f, '((');WriteIdent (f, qualid^.Qualid.Object^.Object.CIdent);WriteC (f, ')'); CodeExpr (Expr, pCast); WriteC (f, ')');
                ELSE
                  WriteC (f, '(');WriteIdent (f, qualid^.Qualid.Object^.Object.CIdent);WriteC (f, ')'); CodeExpr (Expr, pCast);
                END;
};
                .
FuncCall        (Designator:, Actuals:), _ :-
                WriteS (f, '(*'); CodeExpr (Designator, pDeref); WriteC (f, ')'); WriteC (f, '('); CodeActuals (Actuals); WriteC (f, ')');
                .
Set             (_, Elems0 ()), _ :-
                WriteS (f, '0X0L');
                .
Set             (BaseType:, elems1:Elems1(..)), _ :-
{
                IF Prec <= pUnion THEN
                  WriteC (f, '('); CodeExpr (elems1, pMinPrec); WriteC (f, ')');
                ELSE
                  CodeExpr (elems1, Prec)
                END;
};
                .
BitSet          (Elems0 ()), _ :-
                WriteS (f, '0X0L');
                .
BitSet          (elems1:Elems1(..)), _ :-
{
                IF Prec <= pUnion THEN
                  WriteC (f, '('); CodeExpr (elems1, pMinPrec); WriteC (f, ')');
                ELSE
                  CodeExpr (elems1, Prec);
                END;
};
                .
Qualid0         (..), _ :-
                t^.Qualid0.IsGlobalPtr AND IsOpen (t^.Qualid0.Type);
                WriteIdent (f, GetGlobalPtr (t^.Qualid0.Object));
                .
Qualid0         (_, Ident:), _ :-
                t^.Qualid0.Object^.Kind = Field1;
                WriteIdent (f, WithStack.GetWith (Ident));
                WriteS (f, '->');
                CodeSelectors (t^.Qualid0.Object^.Field1.Selectors);
                WriteIdent (f, t^.Qualid0.Object^.Field1.CIdent);
                .
Qualid1         (_, _, qualid:), _ :-
                qualid^.Qualid.IsGlobalPtr;
                WriteIdent (f, GetGlobalPtr (qualid^.Qualid.Object));
                WriteS (f, '->');
                CodeSelectors (GetSelectors (t^.Qualid1.Object));
                WriteIdent (f, t^.Qualid1.Object^.Object.CIdent);
                .
Qualid1         (_, _, qualid:), _ :-
                (IsVAR (qualid^.Qualid.Object));
                WriteIdent (f, qualid^.Qualid.Object^.Var1.CIdent);
                WriteS (f, '->');
                CodeSelectors (GetSelectors (t^.Qualid1.Object));
                WriteIdent (f, t^.Qualid1.Object^.Object.CIdent);
                .
Qualid1         (_, _, Qualid:), _ :-
                t^.Qualid1.Object^.Kind = Field1;
                CodeExpr (Qualid, pSelect);
                WriteC (f, '.');
                CodeSelectors (t^.Qualid1.Object^.Field1.Selectors);
                WriteIdent (f, t^.Qualid1.Object^.Field1.CIdent);
                .
Qualid          (..), _ :-
                t^.Qualid.IsGlobalPtr;
{
                IF Prec < pDeref THEN
                  WriteS (f, '(*');WriteIdent (f, GetGlobalPtr (t^.Qualid.Object));WriteC (f, ')');
                ELSE
                  WriteC (f, '*');WriteIdent (f, GetGlobalPtr (t^.Qualid.Object));
                END;
};
                .
Qualid          (..), _ :-
                IsVAR (t^.Qualid.Object) AND NOT IsOpen (t^.Qualid.Type);
{
                IF Prec < pDeref THEN
                  WriteS (f, '(*');WriteIdent (f, t^.Qualid.Object^.Var1.CIdent);WriteC (f, ')');
                ELSE
                  WriteC (f, '*');WriteIdent (f, t^.Qualid.Object^.Var1.CIdent);
                END;
};
                .
Qualid          (..), _ :-
                WriteIdent (f, t^.Qualid.Object^.Object.CIdent);
                .
Subscript       (_, qualid:Qualid0 (..), Index:), _ :-
                (IsOpenArray (qualid^.Qualid0.Object));
                CodeExpr (qualid, pSubscript); WriteC (f, '['); CodeExpr (Index, pMinPrec); WriteC (f, ']');
                .
Subscript       (_, Designator1:Deref(_, Designator2:Designator(..)), Index:), _ :-
                NOT (Designator2^.Designator.Type^.Kind = OpaqueType1);
        VAR Lwb: tValue;
{
                GetLwb (GetIndexType (Designator1^.Deref.Type), Lwb);
                CodeExpr (Designator2, pSelect);
                WriteS (f, '->A[');
                IF ValueToInt (Lwb) # 0 THEN
                  CodeExpr (Index, pMinus + 1); WriteS (f, ' - '); CodeValue (Lwb);
                ELSE
                  CodeExpr (Index, pMinPrec);
                END;
                WriteC (f, ']');
};
                .
Subscript       (_, qualid:Qualid(..), Index:), _ :-
                qualid^.Qualid.IsGlobalPtr AND NOT IsOpen (qualid^.Qualid.Type);
        VAR Lwb: tValue;
{
                GetLwb (GetIndexType (qualid^.Qualid.Type), Lwb);
                WriteIdent (f, GetGlobalPtr (qualid^.Qualid.Object));
                WriteS (f, '->A[');
                IF ValueToInt (Lwb) # 0 THEN
                  CodeExpr (Index, pMinus + 1); WriteS (f, ' - '); CodeValue (Lwb);
                ELSE
                  CodeExpr (Index, pMinPrec);
                END;
                WriteC (f, ']');
};
                .
Subscript       (_, qualid:Qualid(..), Index:), _ :-
                IsVAR (qualid^.Qualid.Object) AND NOT IsOpen (qualid^.Qualid.Type);
        VAR Lwb: tValue;
{
                GetLwb (GetIndexType (qualid^.Qualid.Type), Lwb);
                WriteIdent (f, qualid^.Qualid.Object^.Var1.CIdent);
                WriteS (f, '->A[');
                IF ValueToInt (Lwb) # 0 THEN
                  CodeExpr (Index, pMinus + 1); WriteS (f, ' - '); CodeValue (Lwb);
                ELSE
                  CodeExpr (Index, pMinPrec);
                END;
                WriteC (f, ']');
};
                .
Subscript       (_, designator:, Index:), _ :-
        VAR Lwb: tValue;
{
                GetLwb (GetIndexType (designator^.Designator.Type), Lwb);
                CodeExpr (designator, pSelect);
                WriteS (f, '.A[');
                IF ValueToInt (Lwb) # 0 THEN
                  CodeExpr (Index, pMinus + 1); WriteS (f, ' - '); CodeValue (Lwb);
                ELSE
                  CodeExpr (Index, pMinPrec);
                END;
                WriteC (f, ']');
};
                .
Select          (_, Deref (_, designator:), _), _ :-
                designator^.Designator.Type^.Kind = OpaqueType1;
        VAR Object: tObject; 
                { Object := designator^.Designator.Type^.Constructor.TypeObj; };
                WriteS (f, '(('); WriteIdent (f, GenOpaque (Object^.Object.CIdent)); WriteC (f, ')');
                CodeExpr (designator, pCast);
                WriteS (f, ')->');
                CodeSelectors (GetSelectors (t^.Select.Object));
                WriteIdent (f, t^.Select.Object^.Object.CIdent);
                .
Select          (_, Deref (_, Designator:), _), _ :-
                CodeExpr (Designator, pSelect);
                WriteS (f, '->');
                CodeSelectors (GetSelectors (t^.Select.Object));
                WriteIdent (f, t^.Select.Object^.Object.CIdent);
                .
Select          (_, Designator:, _), _ :-
                CodeExpr (Designator, pSelect);
                WriteC (f, '.');
                CodeSelectors (GetSelectors (t^.Select.Object));
                WriteIdent (f, t^.Select.Object^.Object.CIdent);
                .
Deref           (_, designator:), _ :-
                designator^.Designator.Type^.Kind = OpaqueType1;
        VAR Object: tObject;
{
                Object := designator^.Designator.Type^.Constructor.TypeObj;

                IF Prec < pDeref THEN
                  WriteS (f, '(*('); WriteIdent (f, GenOpaque (Object^.Object.CIdent)); WriteC (f, ')');
                    CodeExpr (designator, pCast);
                  WriteC (f, ')');
                ELSE
                  WriteS (f, '*('); WriteIdent (f, GenOpaque (Object^.Object.CIdent)); WriteC (f, ')');
                    CodeExpr (designator, pCast);
                END;
};
                .
Deref           (_, Designator:), _ :-
{
                IF Prec < pDeref THEN
                  WriteS (f, '(*'); CodeExpr (Designator, pDeref); WriteC (f, ')');
                ELSE
                  WriteC (f, '*'); CodeExpr (Designator, pDeref);
                END;
};
                .
Elem            (Next:, SetElem:), _ :-
                WriteS (f, 'SET_ELEM('); CodeExpr (SetElem, pPassValue); WriteC (f, ')'); CodeSepa (Next);
                CodeExpr (Next, pUnion);
                .
ElemRange       (Next:, Lwb:, Upb:), _ :-
                Lwb^.Expr.IsCConst AND Upb^.Expr.IsCConst;
                WriteS (f, 'SET_cRNG('); CodeExpr (Lwb, pPassValue); WriteS (f, ', '); CodeExpr (Upb, pPassValue); WriteC (f, ')');
                CodeSepa (Next);
                CodeExpr (Next, pUnion);
                .
ElemRange       (Next:, Lwb:, Upb:), _ :-
                WriteS (f, 'SET_RANGE('); CodeExpr (Lwb, pPassValue); WriteS (f, ', '); CodeExpr (Upb, pPassValue); WriteC (f, ')');
                CodeSepa (Next);
                CodeExpr (Next, pUnion);
                .
/*
 *      generate code to determine the address of an expression
 *      (must be a variable)
 */

PROCEDURE CodeAdr (t: [Expr])

Deref           (_, Designator:) :-
                CodeExpr (Designator, pMinPrec);
                .
Qualid          (..) :-
                t^.Qualid.IsGlobalPtr;
                WriteIdent (f, GetGlobalPtr (t^.Qualid.Object));
                .
Qualid0         (..) :-
                (IsVAR (t^.Qualid0.Object));
                WriteIdent (f, t^.Qualid0.Object^.Var1.CIdent);
                .
Expr            (..) :-
                WriteC (f, '&'); CodeExpr (t, pAdr);
                .
/*
 *      generate code to pass a string as actual parameter
 */

PROCEDURE CodeString2 (t: [Expr], Strncpy: BOOLEAN)

/* Strncpy = TRUE: the string is an actual parameter of libray routine  */
/*                 strncpy                                              */

StringConst     (StringVal:), _ :-
{               IF OptionIsSet ('c') AND NOT Strncpy THEN WriteS (f, '(STRING)'); END; };
                CodeString1 (StringVal);
                .
CharConst       (CharVal:), _ :-
{               IF OptionIsSet ('c') AND NOT Strncpy THEN WriteS (f, '(STRING)'); END; };
                CodeString3 (CharVal);
                .
Qualid          (..), _ :-
                t^.Qualid.Type = TypeSTRING;
{               IF OptionIsSet ('c') AND Strncpy THEN WriteS (f, '(char *)'); END; };
                WriteIdent (f, t^.Qualid.Object^.Object.CIdent);
                .
Qualid          (..), _ :-
                t^.Qualid.Type = TypeStringChar;
{               IF OptionIsSet ('c') AND NOT Strncpy THEN WriteS (f, '(STRING)'); END; };
                CodeString3 (t^.Qualid.Object^.Const1.Value.CharValue);
                .
Qualid          (..), _ :-
                t^.Qualid.Type = TypeCHAR;
{               IF OptionIsSet ('c') AND NOT Strncpy THEN WriteS (f, '(STRING)'); END; };
                CodeString3 (t^.Qualid.Object^.Const1.Value.CharValue);
                .
/*
 *      generate code for statements
 */

PROCEDURE CodeStmts (t: [Stmts, Elsifs, Cases, Labels])

Assign          (Next:, designator:, expr:) :-
                (designator^.Designator.Type^.Kind = Array1) AND
                ((expr^.Expr.Type = TypeStringChar) OR (expr^.Expr.Type = TypeSTRING));
WriteSpaces (f, Indent);               WriteS (f, '(void)strncpy(');
{
                  IF OptionIsSet ('c') THEN WriteS (f, '(char *)'); END;
};
                  CodeExpr (designator, pSelect); WriteS (f, '.A, ');
                  CodeString2 (expr, Strncpy); WriteS (f, ', ');
                  WriteS (f, 'sizeof('); CodeExpr (designator, pSelect); WriteS (f, '.A));'); WriteNl (f);
                CodeStmts (Next);
                .
Assign          (Next:, designator:, expr:) :-
                (Cast (cAssign, designator^.Designator.Type, expr^.Expr.Type));
WriteSpaces (f, Indent);               CodeExpr (designator, pAssign); WriteS (f, ' = ');
                  CodeCast (designator^.Designator.Type); CodeExpr (expr, pCast); WriteC (f, ';'); WriteNl (f);
                CodeStmts (Next);
                .
Assign          (Next:, Designator:, Expr:) :-
WriteSpaces (f, Indent);               CodeExpr (Designator, pAssign); WriteS (f, ' = '); CodeExpr (Expr, pAssign); WriteC (f, ';'); WriteNl (f);
                CodeStmts (Next);
                .
Call            (Next:, designator:, Actuals:) :-
                designator^.Designator.Type^.Kind = StdProcType1;
        VAR StdProc: SHORTCARD;
{
                StdProc := designator^.Designator.Type^.StdProcType1.StdProc;
                CASE StdProc OF
                | ProcTRANSFER  :
                    ErrorMessageP (NoTRANSFER, Restriction, designator^.Designator.Pos);
                | ProcIOTRANSFER:
                    ErrorMessageP (NoIOTRANSFER, Restriction, designator^.Designator.Pos);
                | ProcNEWPROCESS:
                    ErrorMessageP (NoNEWPROCESS, Restriction, designator^.Designator.Pos);
                | ProcNEW       ,
                  ProcDISPOSE   :
WriteSpaces (f, Indent);                   CodeStdProc (Actuals, StdProc, t^.Call.AllocOrDealloc); WriteC (f, ';'); WriteNl (f);
                ELSE
WriteSpaces (f, Indent);                 CodeStdProc (Actuals, StdProc, NoObject); WriteC (f, ';'); WriteNl (f);
                END;
};
                CodeStmts (Next);
                .
Call            (Next:, qualid:Qualid(..), Actuals:) :-
                (IsProcedure (qualid^.Qualid.Object));
WriteSpaces (f, Indent);               WriteIdent (f, qualid^.Qualid.Object^.Object.CIdent);WriteC (f, '('); CodeActuals (Actuals); WriteS (f, ');'); WriteNl (f);
                CodeStmts (Next);
                .
Call            (Next:, Designator:, Actuals:) :-
WriteSpaces (f, Indent);               WriteS (f, '(*'); CodeExpr (Designator, pDeref); WriteC (f, ')'); WriteC (f, '('); CodeActuals (Actuals); WriteS (f, ');'); WriteNl (f);
                CodeStmts (Next);
                .
If              (Next:, Cond:, ThenPart:, Elsifs:, Stmts0 ()) :-
WriteSpaces (f, Indent);               WriteS (f, 'if ('); CodeExpr (Cond, pMinPrec); WriteS (f, ') {'); WriteNl (f);
INC (Indent, 2);                CodeStmts (ThenPart);
DEC (Indent, 2);              CodeStmts (Elsifs);
WriteSpaces (f, Indent);               WriteC (f, '}'); WriteNl (f);
                CodeStmts (Next);
                .
If              (Next:, Cond:, ThenPart:, Elsifs:, ElsePart:) :-
WriteSpaces (f, Indent);               WriteS (f, 'if ('); CodeExpr (Cond, pMinPrec); WriteS (f, ') {'); WriteNl (f);
INC (Indent, 2);                CodeStmts (ThenPart);
DEC (Indent, 2);              CodeStmts (Elsifs);
WriteSpaces (f, Indent);               WriteS (f, '} else {'); WriteNl (f);
INC (Indent, 2);                CodeStmts (ElsePart);
DEC (Indent, 2);WriteSpaces (f, Indent);             WriteC (f, '}'); WriteNl (f);
                CodeStmts (Next);
                .
Case            (Next:, Expr:, Cases:, ElsePart:, {TRUE}) :-
WriteSpaces (f, Indent);               WriteS (f, 'switch ('); CodeExpr (Expr, pMinPrec); WriteS (f, ') {'); WriteNl (f);
                CodeStmts (Cases);
WriteSpaces (f, Indent);               WriteS (f, 'default :'); WriteNl (f);
INC (Indent, 2);                CodeStmts (ElsePart);
WriteSpaces (f, Indent);                 WriteS (f, 'break;'); WriteNl (f);
DEC (Indent, 2);WriteSpaces (f, Indent);             WriteC (f, '}'); WriteNl (f);
                CodeStmts (Next);
                .
Case            (Next:, Expr:, Cases:, ElsePart:, _) :-
WriteSpaces (f, Indent);               WriteS (f, 'switch ('); CodeExpr (Expr, pMinPrec); WriteS (f, ') {'); WriteNl (f);
                CodeStmts (Cases);
{
                IF OptionIsSet ('r') THEN
WriteSpaces (f, Indent);               WriteS (f, 'default :'); WriteNl (f);
WriteSpaces (f, Indent);               WriteS (f, '  CaseError(__FILE__, __LINE__);'); WriteNl (f);
WriteSpaces (f, Indent);               WriteS (f, '  break;'); WriteNl (f);
                END;
};
WriteSpaces (f, Indent);               WriteC (f, '}'); WriteNl (f);
                CodeStmts (Next);
                .
While           (Next:, Cond:, Stmts:) :-
WriteSpaces (f, Indent);               WriteS (f, 'while ('); CodeExpr (Cond, pMinPrec); WriteS (f, ') {'); WriteNl (f);
INC (Indent, 2);                CodeStmts (Stmts);
DEC (Indent, 2);WriteSpaces (f, Indent);             WriteC (f, '}'); WriteNl (f);
                CodeStmts (Next);
                .
Repeat          (Next:, Stmts:, Cond:) :-
WriteSpaces (f, Indent);               WriteS (f, 'do {'); WriteNl (f);
INC (Indent, 2);                CodeStmts (Stmts);
DEC (Indent, 2);WriteSpaces (f, Indent);             WriteS (f, '} while (!'); CodeExpr (Cond, pNot); WriteS (f, ');'); WriteNl (f);
                CodeStmts (Next);
                .
Loop            (Next:, Stmts:) :-
                LabelStack.Push (GenLabel ());
WriteSpaces (f, Indent);               WriteS (f, 'for (;;) {'); WriteNl (f);
INC (Indent, 2);                CodeStmts (Stmts);
DEC (Indent, 2);WriteSpaces (f, Indent);             WriteS (f, '} ');WriteIdent (f, LabelStack.Top ());WriteS (f, ':;'); WriteNl (f);
                LabelStack.Pop ();
                CodeStmts (Next);
                .
For             (Next:, qualid:, From:, to:, By:, Stmts:) :-
                to^.Expr.IsCConst AND NOT OverOrUnderflow (qualid^.Qualid.Type, t^.For.ToVal, t^.For.ByVal);
WriteSpaces (f, Indent);               WriteS (f, 'for (');
                  CodeExpr (qualid, pAssign); WriteS (f, ' = '); CodeExpr (From, pAssign); WriteS (f, '; ');
                  CodeExpr (qualid, pComparison);
{
                IF ValueToInt (t^.For.ByVal) >= 0 THEN WriteS (f, ' <= '); ELSE WriteS (f, ' >= '); END;
};
                  CodeExpr (to, pComparison); WriteS (f, '; ');
                  CodeExpr (qualid, pAssign); WriteS (f, ' += '); CodeExpr (By, pAssign);
                WriteS (f, ') {'); WriteNl (f);
INC (Indent, 2);                CodeStmts (Stmts);
DEC (Indent, 2);WriteSpaces (f, Indent);             WriteC (f, '}'); WriteNl (f);
                CodeStmts (Next);
                .
For             (Next:, qualid:, From:, To:, By:, Stmts:) :-
        VAR BoundId1: tIdent, VAR BoundId2: tIdent, VAR ByValue: LONGINT;
{
                BoundId1 := GenBound ();
                BoundId2 := GenBound ();
                ByValue  := ValueToInt (t^.For.ByVal);

WriteSpaces (f, Indent);               WriteC (f, '{'); WriteNl (f);
INC (Indent, 2);WriteSpaces (f, Indent);               CodeTypeName (qualid^.Qualid.Type); WriteC (f, ' ');
                    WriteIdent (f, BoundId1); WriteS (f, ' = '); CodeExpr (From, pAssign); WriteS (f, ', ');
                    WriteIdent (f, BoundId2); WriteS (f, ' = '); CodeExpr (To, pAssign); WriteC (f, ';'); WriteNl (f);
                WriteNl (f);
WriteSpaces (f, Indent);                 WriteS (f, 'if ('); WriteIdent (f, BoundId1);
                IF ByValue >= 0 THEN WriteS (f, ' <= '); ELSE WriteS (f, ' >= '); END;
                         WriteIdent (f, BoundId2);
                  WriteC (f, ')'); WriteNl (f);
INC (Indent, 2);WriteSpaces (f, Indent);                 WriteS (f, 'for (');
                        CodeExpr (qualid, pAssign);
                          WriteS (f, ' = '); WriteIdent (f, BoundId1);
                IF ByValue >= 2 THEN
                        WriteS (f, ', '); WriteIdent (f, BoundId2);WriteS (f, ' = ');
                          WriteS (f, 'FOR_LIMIT_UP(');
                            WriteIdent (f, BoundId2); WriteS (f, ', ');
                            CodeExpr (By, pPassValue); WriteS (f, ', ');
                            CodeMIN (qualid^.Qualid.Type);
                          WriteC (f, ')');
                ELSIF ByValue <= -2 THEN
                        WriteS (f, ', '); WriteIdent (f, BoundId2);WriteS (f, ' = ');
                          WriteS (f, 'FOR_LIMIT_DOWN(');
                            WriteIdent (f, BoundId2); WriteS (f, ', ');
                            CodeExpr (By, pPassValue); WriteS (f, ', ');
                            CodeMAX (qualid^.Qualid.Type);
                          WriteC (f, ')');
                END;
                          WriteS (f, ';; ');
                        CodeExpr (qualid, pAssign);
                          WriteS (f, ' += '); CodeExpr (By, pAssign);
                        WriteS (f, ') {'); WriteNl (f);
INC (Indent, 2);                  CodeStmts (Stmts);
WriteSpaces (f, Indent);                   WriteS (f, 'if ('); CodeExpr (qualid, pComparison);
                IF ByValue >= 0 THEN WriteS (f, ' >= '); ELSE WriteS (f, ' <= '); END;
                           WriteIdent (f, BoundId2);
                    WriteS (f, ') break;'); WriteNl (f);
DEC (Indent, 2);WriteSpaces (f, Indent);               WriteC (f, '}'); WriteNl (f);
DEC (Indent, 4);WriteSpaces (f, Indent);            WriteC (f, '}'); WriteNl (f);
};
                CodeStmts (Next);
                .
With            (Next:, deref:Deref (_, designator:), Stmts:) :-
                designator^.Designator.Type^.Kind = OpaqueType1;
        VAR WithId: tIdent, VAR Object: tObject;
{
                WithId := GenWith ();
                Object := designator^.Designator.Type^.Constructor.TypeObj;
};
WriteSpaces (f, Indent);               WriteC (f, '{'); WriteNl (f);
INC (Indent, 2);WriteSpaces (f, Indent);               WriteS (f, 'register '); CodeTypeName (deref^.Deref.Type);
                     WriteS (f, ' *');WriteIdent (f, WithId);WriteS (f, ' = ');
                       WriteC (f, '('); WriteIdent (f, GenOpaque (Object^.Object.CIdent)); WriteC (f, ')');
                         CodeExpr (designator, pCast); WriteC (f, ';'); WriteNl (f);
                WriteNl (f);
                  WithStack.Push (WithId, GetFields (deref^.Deref.Type));
                  CodeStmts (Stmts);
                  WithStack.Pop ();
DEC (Indent, 2);WriteSpaces (f, Indent);             WriteC (f, '}'); WriteNl (f);
                CodeStmts (Next);
                .
With            (Next:, designator:, Stmts:) :-
        VAR WithId: tIdent;
{
                WithId := GenWith ();
};
WriteSpaces (f, Indent);               WriteC (f, '{'); WriteNl (f);
INC (Indent, 2);WriteSpaces (f, Indent);               WriteS (f, 'register '); CodeTypeName (designator^.Designator.Type);
                     WriteS (f, ' *');WriteIdent (f, WithId);WriteS (f, ' = '); CodeAdr (designator); WriteC (f, ';'); WriteNl (f);
                WriteNl (f);
                  WithStack.Push (WithId, GetFields (designator^.Designator.Type));
                  CodeStmts (Stmts);
                  WithStack.Pop ();
DEC (Indent, 2);WriteSpaces (f, Indent);             WriteC (f, '}'); WriteNl (f);
                CodeStmts (Next);
                .
Exit            (Next:) :-
WriteSpaces (f, Indent);               WriteS (f, 'goto ');WriteIdent (f, LabelStack.Top ());WriteC (f, ';'); WriteNl (f);
                CodeStmts (Next);
                .
Return1         (Next:) :-
                CodePop  (LocalPtrs);
                CodeFree (ValueOpens);
WriteSpaces (f, Indent);               WriteS (f, 'return;'); WriteNl (f);
                CodeStmts (Next);
                .
Return2         (Next:, expr:) :-
        VAR ReturnId: tIdent;
{
                IF ((ValueOpens # NoCObjects) OR (LocalPtrs # NoCObjects)) AND
                     t^.Return2.OpenAccessOrCall THEN
                  ReturnId := GenReturn ();
WriteSpaces (f, Indent);                 WriteC (f, '{'); WriteNl (f);
INC (Indent, 2);WriteSpaces (f, Indent);                 CodeTypeName (t^.Return2.ResultType); WriteC (f, ' ');WriteIdent (f, ReturnId);WriteS (f, ' = ');
                  IF Cast (cAssign, t^.Return2.ResultType, expr^.Expr.Type) THEN
                    CodeCast (t^.Return2.ResultType); CodeExpr (expr, pCast); WriteC (f, ';'); WriteNl (f);
                  ELSE
                    CodeExpr (expr, pMinPrec); WriteC (f, ';'); WriteNl (f);
                  END;
                  WriteNl (f);
                    CodePop  (LocalPtrs);
                    CodeFree (ValueOpens);
WriteSpaces (f, Indent);                   WriteS (f, 'return ');WriteIdent (f, ReturnId);WriteC (f, ';'); WriteNl (f);
DEC (Indent, 2);WriteSpaces (f, Indent);               WriteC (f, '}'); WriteNl (f);
                ELSE
                  CodePop  (LocalPtrs);
                  CodeFree (ValueOpens);
WriteSpaces (f, Indent);                 WriteS (f, 'return ');
                  IF Cast (cAssign, t^.Return2.ResultType, expr^.Expr.Type) THEN
                    CodeCast (t^.Return2.ResultType); CodeExpr (expr, pCast);
                  ELSE
                    CodeExpr (expr, pMinPrec);
                  END;
                  WriteC (f, ';'); WriteNl (f);
                END;
};
                CodeStmts (Next);
                .
Elsifs1         (Cond:, Stmts:, Next:) :-
WriteSpaces (f, Indent);               WriteS (f, '} else if ('); CodeExpr (Cond, pMinPrec); WriteS (f, ') {'); WriteNl (f);
INC (Indent, 2);                CodeStmts (Stmts);
DEC (Indent, 2);
                CodeStmts (Next);
                .
Cases1          (Labels:, Stmts:, Next:) :-
                CodeStmts (Labels);
INC (Indent, 2);              CodeStmts (Stmts);
WriteSpaces (f, Indent);               WriteS (f, 'break;'); WriteNl (f);
DEC (Indent, 2);
                CodeStmts (Next);
                .
Label           (Next:, expr:) :-
                expr^.Expr.IsCConst;
WriteSpaces (f, Indent);               WriteS (f, 'case '); CodeExpr (expr, pMinPrec); WriteS (f, ':;'); WriteNl (f);
                CodeStmts (Next);
                .
Label           (Next:, Expr:) :-
WriteSpaces (f, Indent);               WriteS (f, 'case '); CodeValue (t^.Label.LabelVal); WriteS (f, ':;'); WriteNl (f);
                CodeStmts (Next);
                .
LabelRange      (Next:, Lwb:, Upb:) :-
                CodeLabelRange (t^.LabelRange.LwbVal, t^.LabelRange.UpbVal);
                CodeStmts (Next);
                .
/*
 *      generate code for standard procedures
 */

PROCEDURE CodeStdProc ([Actuals], StdProc: SHORTCARD, AllocOrDealloc: tObject)

/* AllocOrDealloc: object description of procedure ALLOCATE resp.       */
/*                 DEALLOCATE used for substitution of standard         */
/*                 procedure NEW resp. DISPOSE.                         */


Actuals0        (), .. :-
{
                IF StdProc = ProcHALT THEN WriteS (f, 'exit(1)'); END;
};
                .
Actual          (qualid:Qualid0(..), Actuals0 ()), .. :-
                (IsOpenArray (qualid^.Qualid0.Object));
{
                IF StdProc = ProcHIGH THEN

                  IF qualid^.Qualid0.IsGlobalPtr THEN
                    WriteC (f, '(');WriteIdent (f, GetGlobalPtr (qualid^.Qualid0.Object));WriteS (f, '_O - 1)');
                  ELSE
                    WriteC (f, '(');WriteIdent (f, GetParam (qualid^.Qualid0.Object));WriteS (f, ' - 1)');
                  END;

                ELSIF StdProc = ProcADR THEN

                    WriteS (f, 'ADR1('); CodeExpr (qualid, pPassValue); WriteC (f, ')');

                ELSIF StdProc = ProcSIZE THEN

                  WriteS (f, '(sizeof('); CodeTypeName (qualid^.Qualid0.Type^.Array1.ElemType); WriteS (f, ') * ');
                  IF qualid^.Qualid0.IsGlobalPtr THEN
                    WriteIdent (f, GetGlobalPtr (qualid^.Qualid0.Object));WriteS (f, '_O');
                  ELSE
                    WriteIdent (f, GetParam (qualid^.Qualid0.Object));
                  END;
                  WriteC (f, ')');

                END;
};
                .
Actual          (expr:, Actuals0 ()), .. :-
        VAR Upb: tValue, VAR Object: tObject, VAR Type: tType;
{
                IF StdProc = ProcHIGH THEN

                    Type := GetIndexType (expr^.Expr.Type);
                    GetUpb (Type, Upb);
                    CodeValue (Upb);
                    IF IsIntType (Type) AND Cast (cPassValue, Type, TypeIntCard) THEN
                      WriteC (f, 'L');
                    END;

                ELSIF StdProc = ProcMIN THEN

                  CodeMIN (expr^.Expr.Type);

                ELSIF StdProc = ProcMAX THEN

                  CodeMAX (expr^.Expr.Type);

                ELSIF StdProc = ProcADR THEN

                  WriteS (f, 'ADR('); CodeExpr (expr, pPassValue); WriteC (f, ')');

                ELSIF (StdProc = ProcSIZE) OR (StdProc = ProcTSIZE) THEN

                  WriteS (f, 'sizeof('); CodeExpr (expr, pPassValue); WriteC (f, ')');

                ELSIF StdProc = ProcABS THEN

                  IF expr^.Expr.IsCConst THEN
                    WriteS (f, 'ABS');
                  ELSE
                    Type := expr^.Expr.Type;
                    IF Type^.Kind = Subrange1 THEN
                      Type := Type^.Subrange1.Type;
                    END;

                    CASE Type^.Kind OF
                    | ShortInt  : WriteS (f, 'ABSSI');
                    | LongInt   : WriteS (f, 'ABSLI');
                    | IntCard   : WriteS (f, 'ABS');
                    | ShortCard : WriteS (f, 'ABSSC');
                    | LongCard  : WriteS (f, 'ABSLC');
                    | Real      : WriteS (f, 'ABSR');
                    | LongReal  : WriteS (f, 'ABSLR');
                    ELSE
                    END;
                  END;

                  WriteC (f, '('); CodeExpr (expr, pPassValue); WriteC (f, ')');

                ELSIF (StdProc = ProcNEW) OR (StdProc = ProcDISPOSE) THEN

                  WriteIdent (f, AllocOrDealloc^.Object.CIdent); WriteC (f, '(');
                    IF Cast (cPassAddress, TypeADDRESS, expr^.Expr.Type) THEN
                      WriteS (f, '(ADDRESS *)');
                    END;
                    CodeAdr (expr); WriteS (f, ', ');

                    IF OptionIsSet ('c') THEN WriteS (f, '(LONGCARD)'); END;
                    WriteS (f, 'sizeof('); CodeTypeName (GetTargetType (expr^.Expr.Type)); WriteC (f, ')');
                  WriteC (f, ')');
                        
                ELSE

                  CASE StdProc OF
                  | ProcCAP     : WriteS (f, 'CAP');
                  | ProcCHR     : WriteS (f, 'CHR');
                  | ProcDEC     : WriteS (f, 'DEC');
                  | ProcFLOAT   : WriteS (f, 'FLOAT');
                  | ProcINC     : WriteS (f, 'INC');
                  | ProcODD     : WriteS (f, 'ODD');
                  | ProcORD     : WriteS (f, 'ORD');
                  | ProcTRUNC   : WriteS (f, 'TRUNC');
                  ELSE
                  END;
                  WriteC (f, '('); CodeExpr (expr, pPassValue); WriteC (f, ')');

                END;
};
                .
Actual          (Actual1:, Actual (Actual2:, Actuals0 ())), .. :-
{
                IF (StdProc = ProcDEC) OR (StdProc = ProcINC) THEN

                  CASE StdProc OF
                  | ProcDEC     : WriteS (f, 'DEC1');
                  | ProcINC     : WriteS (f, 'INC1');
                  END;
                  WriteC (f, '('); CodeExpr (Actual1, pPassValue); WriteS (f, ', ');
                  IF Actual2^.Expr.Type = TypeADDRESS THEN
                    WriteS (f, '(LONGCARD)'); CodeExpr (Actual2, pCast);
                  ELSE
                    CodeExpr (Actual2, pPassValue);
                  END;
                  WriteC (f, ')');

                ELSE

                  CASE StdProc OF
                  | ProcEXCL    : WriteS (f, 'EXCL');
                  | ProcINCL    : WriteS (f, 'INCL');
                  | ProcVAL     : WriteS (f, 'VAL');
                  ELSE
                  END;
                  WriteC (f, '('); CodeExpr (Actual1, pPassValue); WriteS (f, ', ');
                      CodeExpr (Actual2, pPassValue); WriteC (f, ')');

                END;
};
                .
/*
 *      generate code for actual parameter lists
 */

PROCEDURE CodeActuals (t: [Actuals])

/* the basic assumption for the code generated to pass an actual        */
/* parameter if the corresponding formal parameter is of type           */
/* ARRAY OF WORD is that sizeof(WORD) = sizeof(CHAR) = 1                */

Actual          (expr:, Next:) :-
                ((expr^.Expr.Type = TypeSTRING) OR (expr^.Expr.Type = TypeStringChar)) AND
                (t^.Actual.Formal^.Kind = Array1) AND NOT IsOpen (t^.Actual.Formal);
                WriteIdent (f, t^.Actual.String); CodeSepa (Next);
                CodeActuals (Next);
                .
Actual          (qualid:Qualid0(..), Next:) :-
                IsOpen (t^.Actual.Formal) AND IsOpenArray (qualid^.Qualid0.Object);
{
                CodeExpr (qualid, pPassValue); WriteS (f, ', ');
                IF qualid^.Qualid0.IsGlobalPtr THEN
                  WriteIdent (f, GetGlobalPtr (qualid^.Qualid0.Object));WriteS (f, '_O');
                ELSE
                  WriteIdent (f, GetParam (qualid^.Qualid0.Object));
                END;
                IF t^.Actual.Formal^.Array1.ElemType = TypeWORD THEN
                  WriteS (f, ' * sizeof('); CodeTypeName (qualid^.Qualid0.Type^.Array1.ElemType); WriteC (f, ')');
                END;
                CodeSepa (Next);
};
                CodeActuals (Next);
                .
Actual          (expr:StringConst (StringVal:), Next:) :-
                (IsOpen (t^.Actual.Formal));
                CodeString2 (expr, NOT Strncpy); WriteS (f, ', ');
        VAR length: CARDINAL;
                length := Length (StringVal);
              { IF length = 0 THEN length := 1; END; };
                WriteI (f, length, 1);WriteC (f, 'L');
                CodeSepa (Next);
                CodeActuals (Next);
                .
Actual          (expr:CharConst (CharVal:), Next:) :-
                (IsOpen (t^.Actual.Formal));
                CodeString2 (expr, NOT Strncpy); WriteS (f, ', 1L');
                CodeSepa (Next);
                CodeActuals (Next);
                .
Actual          (qualid:Qualid(..), Next:) :-
                IsOpen (t^.Actual.Formal) AND (qualid^.Qualid.Type = TypeSTRING);
                CodeString2 (qualid, NOT Strncpy); WriteS (f, ', ');
        VAR length: CARDINAL;
                length := Length (qualid^.Qualid.Object^.Const1.Value.StringValue);
              { IF length = 0 THEN length := 1; END; };
                WriteI (f, length, 1);WriteC (f, 'L');
                CodeSepa (Next);
                CodeActuals (Next);
                .
Actual          (qualid:Qualid(..), Next:) :-
                IsOpen (t^.Actual.Formal) AND (qualid^.Qualid.Type = TypeStringChar);
                CodeString2 (qualid, NOT Strncpy); WriteS (f, ', 1L');
                CodeSepa (Next);
                CodeActuals (Next);
                .
Actual          (qualid:Qualid(..), Next:) :-
                IsOpen (t^.Actual.Formal) AND (qualid^.Qualid.Type = TypeCHAR)
                AND (qualid^.Qualid.Object^.Kind = Const1);
                /* RMB bug fix: was passing "\0" when actual is a VAR of type CHAR */
                CodeString2 (qualid, NOT Strncpy); WriteS (f, ', 1L');
                CodeSepa (Next);
                CodeActuals (Next);
                .
Actual          (Designator:, Next:) :-
                IsOpen (t^.Actual.Formal) AND (t^.Actual.Formal^.Array1.ElemType = TypeWORD);
{
                IF OptionIsSet ('c') THEN WriteS (f, '(WORD *)'); END;
                CodeAdr (Designator); WriteS (f, ', ');
                IF OptionIsSet ('c') THEN WriteS (f, '(LONGCARD)'); END;
                WriteS (f, 'sizeof('); CodeExpr (Designator, pPassValue); WriteC (f, ')');
                CodeSepa (Next);
};
                CodeActuals (Next);
                .
Actual          (designator:, Next:) :-
                IsOpen (t^.Actual.Formal) AND (designator^.Designator.Type^.Kind = Array1);
        VAR Upb: tValue, VAR Lwb: tValue, VAR IndexType: tType;
{
                IndexType := designator^.Designator.Type^.Array1.IndexType;
                GetLwb (IndexType, Lwb);
                GetUpb (IndexType, Upb);
                CodeExpr (designator, pSelect); WriteS (f, '.A, ');
                WriteI (f, ValueToInt (Upb) - ValueToInt (Lwb) + 1, 1);WriteC (f, 'L'); CodeSepa (Next);
};
                CodeActuals (Next);
                .
Actual          (expr:, Next:) :-
                t^.Actual.IsVAR;
{
                IF Cast (cPassAddress, t^.Actual.Formal, expr^.Expr.Type) THEN
                  CodeCastVAR (t^.Actual.Formal); CodeAdr (expr);
                ELSE
                  CodeAdr (expr);
                END;
                CodeSepa (Next);
};
                CodeActuals (Next);
                .
Actual          (expr:IntConst(..), Next:) :-
{
                CodeExpr (expr, pPassValue);
                IF Cast (cPassValue, t^.Actual.Formal, TypeIntCard) THEN WriteC (f, 'L'); END;
                CodeSepa (Next);
};
                CodeActuals (Next);
                .
Actual          (expr:Unary (_, IntConst (..)), Next:) :-
                expr^.Unary.COperator = cMinus;
{
                CodeExpr (expr, pPassValue);
                IF Cast (cPassValue, t^.Actual.Formal, TypeIntCard) THEN WriteC (f, 'L'); END;
                CodeSepa (Next);
};
                CodeActuals (Next);
                .
Actual          ( expr : Binary ( .. ) , Next : ) :-
                expr^.Binary.Type = TypeBOOLEAN;
{
                IF OptionIsSet ('c') THEN
                  WriteS (f, '(BOOLEAN)'); CodeExpr (expr, pCast);
                ELSE
                  CodeExpr (expr, pPassValue);
                END;
                CodeSepa (Next);
};
                CodeActuals (Next);
                .
Actual          ( expr : Unary ( .. ) , Next : ) :-
                expr^.Unary.Type = TypeBOOLEAN;
{
                IF OptionIsSet ('c') THEN
                  WriteS (f, '(BOOLEAN)'); CodeExpr (expr, pCast);
                ELSE
                  CodeExpr (expr, pPassValue);
                END;
                CodeSepa (Next);
};
                CodeActuals (Next);
                .
Actual          ( expr : , Next : ) :-
{
                IF Cast (cPassValue, t^.Actual.Formal, expr^.Expr.Type) THEN
                  CodeCast (t^.Actual.Formal); CodeExpr (expr, pCast);
                ELSE
                  CodeExpr (expr, pPassValue);
                END;
                CodeSepa (Next);
};
                CodeActuals (Next);
                .
/*
 *      generate an optional list separator
 */

PROCEDURE CodeSepa ([VarIds, ParIds, FieldIds, Elems, Formals, Actuals, FormalTypes])

VarIds1         (..) ;
ParIds1         (..) ;
FieldIds1       (..) ;
Formals1        (..) ;
FormalType      (..) ;
Actual          (..) :- WriteS (f, ', '); .
Elems1          (..) :- WriteS (f, ' | '); .
