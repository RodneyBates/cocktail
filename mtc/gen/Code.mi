
(* This file was mechanically generated by puma. *)

IMPLEMENTATION MODULE Code;








IMPORT SYSTEM, System, IO, Tree;
(* line 68 "" *)

FROM Base       IMPORT
  OptionIsSet   , OpenHeader    , OpenProgram;

FROM IO         IMPORT
  tFile         , WriteS        , WriteC        , WriteI        ,
  WriteN        , WriteR        , WriteCard     , WriteNl       ,
  WriteClose    ;

FROM Layout     IMPORT
  WriteSpaces   ;

FROM Strings    IMPORT
  tString       , tStringIndex  ;

FROM StringMem  IMPORT
  tStringRef    , GetString     , Length        , WriteString   ;

FROM Idents     IMPORT
  tIdent        , NoIdent       , WriteIdent    ;

FROM Tree       IMPORT
  tTree         , NoTree        ,
  Definition    , Foreign       , Program       , Implementation,
  Decimal       , Octal         , Hexadecimal   ;

FROM Defs       IMPORT
  tObject       , tObjects      , tType         , tSelectors    ,
  tCObjects     , tStrings      ,
  NoObject      , NoObjects     , NoSelectors   , NoCObjects    ,
  NoStrings     ,
  ProcABS       , ProcCAP       , ProcCHR       , ProcDEC       ,
  ProcEXCL      , ProcFLOAT     , ProcHALT      , ProcHIGH      ,
  ProcINC       , ProcINCL      , ProcMAX       , ProcMIN       ,
  ProcODD       , ProcORD       , ProcSIZE      , ProcTRUNC     ,
  ProcVAL       , ProcADR       , ProcTSIZE     , ProcTRANSFER  ,
  ProcNEWPROCESS, ProcIOTRANSFER, ProcNEW       , ProcDISPOSE   ,
  IdentSYSTEM   ,
  TypeLONGCARD  , TypeBOOLEAN   , TypeWORD      , TypeADDRESS   ,
  TypeIntCard   , TypeSTRING    , TypeStringChar, TypeVOID      ,
  TypeCHAR      , Field1        , TypeDecl1     , Const1        ,
  ShortInt      , LongInt       , ShortCard     , LongCard      ,
  Real          , LongReal      , Bool          , Char          ,
  Bitset        , Proc          , Word          , Address       ,
  IntCard       , Nil           , StringChar    , String        ,
  StdProcType1  , OpaqueType1   , Array1        , Enumeration1  ,
  Pointer1      , ProcType1     , Record1       , Set1          ,
  Subrange1     ,
  GetSelectors  , GetType       ,
  GetIndexType  , GetElemType   , GetTargetType , GetResultType ,
  GetFields     , GetLiteral    ,
  IsExported    , IsOpenArray   , IsVAR         , IsProcedure   ,
  IsOfType      , IsForward     , IsIntType     , IsOpen        ;

FROM Values     IMPORT
  tValue        , ValueToInt    , MinCharVal    , MaxCharVal    ,
  ZeroValue     , MaxShortCardVal;

FROM Types      IMPORT
  TypeSize      , GetLwb        , GetUpb        , SizeUnsignedChar,
  MaxLongInt    , Cast          ;

FROM AssocTab   IMPORT
  BeginAssocTab , PutAssoc      , GetAssoc      , CloseAssocTab ;

FROM GenIdents  IMPORT
  GenLabel      , GenWith       , GenBound      , GenReturn     ,
  GenOpaque     ;

FROM Errors     IMPORT
  CompilerError , ErrorMessageP , Restriction   , Warning       ,
  NoTRANSFER    , NoIOTRANSFER  , NoNEWPROCESS  , StructTypeReq ,
  OutOfLongRange;

IMPORT Strings, Idents, GenIdents, DynArray, Defs, Values;

CONST
  pMaxPrec              =  1;   (* C operator precedences       *)
  pCall                 =  1;
  pSubscript            =  1;
  pSelect               =  1;
  pCast                 =  2;
  pDeref                =  3;
  pAdr                  =  3;
  pNot                  =  3;
  pTimes                =  4;
  pDivide               =  4;
  pMod                  =  4;
  pPlus                 =  5;
  pMinus                =  5;
  pComparison           =  7;
  pLess                 =  7;
  pLessEqual            =  7;
  pGreater              =  7;
  pGreaterEqual         =  7;
  pEqual                =  8;
  pNotEqual             =  8;
  pIntersection         =  9;
  pSymDiff              = 10;
  pUnion                = 11;
  pAnd                  = 12;
  pOr                   = 13;
  pIn                   = 14;
  pDifference           = 14;
  pIsSubset1            = 14;
  pIsSubset2            = 14;
  pAssign               = 14;
  pPassValue            = 14;
  pPassAddress          = 14;
  pMinPrec              = 14;

CONST
  Auto                  = 1;    (* C storage classes            *)
  Static                = 2;

CONST
  Full                  = TRUE;
  NonFull               = NOT Full;
  Before                = TRUE;
  After                 = NOT Before;
  Strncpy               = TRUE;

VAR
  f             : tFile;        (* C header/source file(s)      *)
  Indent        : CARDINAL;     (* level of indentation         *)

                  (* table with precedence of C operators       *)
  Precedence    : ARRAY [cNoOp .. cPassAddress] OF SHORTCARD;


(*------- MODULE LabelStack --------------------------------------------------*)

MODULE LabelStack;

(* Stack for the administration of the labels generated for the *)
(* translation of LOOP and EXIT statements.                     *)

FROM DynArray   IMPORT
  MakeArray     , ExtendArray   , ReleaseArray  ;

FROM Idents     IMPORT
  tIdent        , NoIdent       ;

EXPORT QUALIFIED Push, Pop, Top, Begin, Close;

CONST
  Infinite      = 1048576;
  InitialSize   = 16;

VAR
  StackPtr      ,
  StackSize     : LONGINT;
  LabelStack    : POINTER TO ARRAY [0 .. Infinite] OF tIdent;

PROCEDURE Push  (Ident: tIdent);
BEGIN
  IF StackPtr = StackSize THEN
    ExtendArray (LabelStack, StackSize, SIZE (tIdent));
  END;
  LabelStack^ [StackPtr] := Ident;
  INC (StackPtr);
END Push;

PROCEDURE Pop   ();
BEGIN
  DEC (StackPtr);
END Pop;

PROCEDURE Top   (): tIdent;
BEGIN
  IF StackPtr > 0 THEN
    RETURN LabelStack^ [StackPtr - 1];
  ELSE
    RETURN NoIdent;     (* error: EXIT not in LOOP context      *)
  END;
END Top;

PROCEDURE Begin;
BEGIN
  StackSize     := InitialSize;
  StackPtr      := 0;
  MakeArray (LabelStack, StackSize, SIZE (tIdent));
END Begin;

PROCEDURE Close;
BEGIN
  ReleaseArray (LabelStack, StackSize, SIZE (tIdent));
END Close;

END LabelStack;

(*------- END LabelStack -----------------------------------------------------*)

(*------- MODULE WithStack ---------------------------------------------------*)

MODULE WithStack;

(* Stack for the administration of the pointer variables        *)
(* generated for the translation of WITH statements.            *)

FROM DynArray   IMPORT
  MakeArray     , ExtendArray   , ReleaseArray  ;

FROM Idents     IMPORT
  tIdent        , NoIdent       ;

FROM Defs       IMPORT
  tObjects      , NoObject      , Identify2     ;

EXPORT QUALIFIED Push, Pop, GetWith, Begin, Close;

CONST
  Infinite      = 1048576;
  InitialSize   = 16;

TYPE
  tStackElem    = RECORD
                    WithId      : tIdent;
                    Fields      : tObjects;
                  END;

VAR
  StackPtr      ,
  StackSize     : LONGINT;
  WithStack     : POINTER TO ARRAY [0 .. Infinite] OF tStackElem;

PROCEDURE Push  (pWithId: tIdent; pFields: tObjects);
BEGIN
  IF StackPtr = StackSize THEN
    ExtendArray (WithStack, StackSize, SIZE (tStackElem));
  END;
  WITH WithStack^ [StackPtr] DO
    WithId := pWithId;
    Fields := pFields;
  END;
  INC (StackPtr);
END Push;

PROCEDURE Pop   ();
BEGIN
  DEC (StackPtr);
END Pop;

PROCEDURE GetWith       (FieldId: tIdent): tIdent;
VAR
  StackIndex    : LONGINT;
BEGIN
  StackIndex := StackPtr - 1;
  LOOP
    WITH WithStack^ [StackIndex] DO
      IF Identify2 (FieldId, Fields) # NoObject THEN RETURN WithId; END;
    END;
    DEC (StackIndex);
  END;
END GetWith;

PROCEDURE Begin;
BEGIN
  StackSize     := InitialSize;
  StackPtr      := 0;
  MakeArray (WithStack, StackSize, SIZE (tStackElem));
END Begin;

PROCEDURE Close;
BEGIN
  ReleaseArray (WithStack, StackSize, SIZE (tStackElem));
END Close;

END WithStack;

(*------- END WithStack ------------------------------------------------------*)

(*------- MODULE ParamTable --------------------------------------------------*)

MODULE ParamTable;

(* Module for the administration of the additional parameters used to   *)
(* translate open array parameters.                                     *)

FROM Idents     IMPORT
  tIdent        , NoIdent       ;

FROM GenIdents  IMPORT
  GenParam      ;

FROM Defs       IMPORT
  tObject       ,
  tCObjects     , NoCObjects    ,
  IsVAR         ,
  LookUp        ;

EXPORT GenParams, GetParam, ValueOpens, VAROpens;

VAR
  VAROpens      ,
  ValueOpens    : tCObjects;

PROCEDURE GenParams     (OpenParams: tCObjects);
BEGIN
  WHILE OpenParams # NoCObjects DO
    OpenParams^.CObjects.CObject := GenParam ();
    OpenParams := OpenParams^.CObjects.Next;
  END;
END GenParams;

PROCEDURE GetParam      (M2Object: tObject): tIdent;
BEGIN
  IF IsVAR (M2Object) THEN
    RETURN LookUp (M2Object, VAROpens);
  ELSE
    RETURN LookUp (M2Object, ValueOpens);
  END;
END GetParam;

BEGIN
  ValueOpens    := NoCObjects;
  VAROpens      := NoCObjects;
END ParamTable;

(*------- END ParamTable -----------------------------------------------------*)

(*------- MODULE PointerTable ------------------------------------------------*)

MODULE PointerTable;

(* Module for the administration of the global and local pointer        *)
(* variables, used to translate the access to local variables of        *)
(* statically enclosing procedures                                      *) 

FROM Idents     IMPORT
  tIdent        , NoIdent       ;

FROM GenIdents  IMPORT
  GenGlobalPtr  , GenLocalPtr   ;

FROM Defs       IMPORT
  tObject       ,
  tCObjects     , NoCObjects    ,
  LookUp        ;

EXPORT 
  GenGlobalPtrs , GenLocalPtrs  , GetGlobalPtr  , GetLocalPtr   ,
  GlobalPtrs    , LocalPtrs     ;

VAR
  GlobalPtrs    ,
  LocalPtrs     : tCObjects;

PROCEDURE GenGlobalPtrs (GlobalPtrs: tCObjects);
BEGIN
  WHILE GlobalPtrs # NoCObjects DO
    WITH GlobalPtrs^.CObjects DO
      CObject := GenGlobalPtr (M2Object^.Var1.Ident);
    END;
    GlobalPtrs := GlobalPtrs^.CObjects.Next;
  END;
END GenGlobalPtrs;

PROCEDURE GenLocalPtrs  (LocalPtrs: tCObjects);
BEGIN
  WHILE LocalPtrs # NoCObjects DO
    LocalPtrs^.CObjects.CObject := GenLocalPtr ();
    LocalPtrs := LocalPtrs^.CObjects.Next;
  END;
END GenLocalPtrs;

PROCEDURE GetGlobalPtr  (M2Object: tObject): tIdent;
BEGIN
  RETURN LookUp (M2Object, GlobalPtrs);
END GetGlobalPtr;

PROCEDURE GetLocalPtr   (M2Object: tObject): tIdent;
BEGIN
  RETURN LookUp (M2Object, LocalPtrs);
END GetLocalPtr;

BEGIN
  GlobalPtrs    := NoCObjects;
  LocalPtrs     := NoCObjects;
END PointerTable;

(*------- END PointerTable ---------------------------------------------------*)

PROCEDURE OverOrUnderflow (CtrlType: tType; ToValue, ByValue: tValue): BOOLEAN;
(* Check if the translation of the Modula-2 FOR-statement               *)
(*      FOR v := a TO b BY c DO ... END;        (b = const)             *)
(* into the C for-statement                                             *)
(*      for (v = a; v <= b; v += c) { ... }     (v >= b if c < 0)       *)
(* would result in a over resp. underflow of the control variable v.    *)
(* 'CtrlType' is the type of v, 'ToValue' is the value of b, and        *)
(* 'ByValue' is the value of c.                                         *)
VAR
  MinCValue     ,
  MaxCValue     : tValue;
BEGIN
  IF ToValue.Kind = Values.NoValue THEN
    (* error: illegal limit value                               *)
    (* or                                                       *)
    (* restriction: overflow test not possible, because module  *)
    (*              Values could not evaluate b, because b      *)
    (*              contains a constant in the range            *)
    (*              MAX (INTEGER) + 1 .. MAX (CARDINAL).        *)
    (*              Assume there would be an overflow!          *)
    RETURN TRUE;
  ELSE
    IF CtrlType^.Kind = Subrange1 THEN
      CtrlType := CtrlType^.Subrange1.Type;
    END;

    CASE CtrlType^.Kind OF
    | ShortCard         ,
      ShortInt          ,
      LongCard          ,
      LongInt           ,
      Char              :
        GetLwb (CtrlType, MinCValue);
        GetUpb (CtrlType, MaxCValue);

    | Bool              ,
      Enumeration1      :
        IF TypeSize (CtrlType) = SizeUnsignedChar THEN
          MinCValue := MinCharVal;
          MaxCValue := MaxCharVal;
        ELSE
          MinCValue := ZeroValue;
          MaxCValue := MaxShortCardVal;
        END;

    ELSE
      (* error: illegal type of control variable        *)
      RETURN TRUE;
    END;

    IF ValueToInt (ByValue) >= 0 THEN
      IF CtrlType = TypeLONGCARD THEN
        RETURN FALSE;
        (* restriction: MAX (CARDINAL) is not representable as INTEGER  *)
        (*              or as tValue. But b (see above) does not        *)
        (*              contain a constant in the range                 *)
        (*              MAX (INTEGER) + 1..MAX (CARDINAL).              *)
        (*              Hence assume there would be no overflow!        *)
      END;
      RETURN ValueToInt (ToValue) > ValueToInt (MaxCValue) - ValueToInt (ByValue);
    ELSE
      RETURN ValueToInt (ToValue) < ValueToInt (MinCValue) - ValueToInt (ByValue);
    END;
  END;
END OverOrUnderflow;

(*======= code generation procedures =========================================*)

(*
 *      generate code for a string constant
 *)

PROCEDURE CodeString1   (s: tStringRef);
(* The characters '"' and backslash are escaped with a backslash. *)
(* note: within WriteS (f, ' ... '); opp will transform \\\\ to \\           *)
VAR i           : tStringIndex;
    Ch          : CHAR;
    String      : tString;
BEGIN
  GetString (s, String);
  WriteC (f, '"');
  FOR i := 1 TO Length (s) DO
    Ch := Strings.Char (String, i);
    IF (Ch = '"') OR (Ch = 134C) THEN  WriteC (f, 134C);  END; WriteC (f, Ch);
  END;
  WriteC (f, '"');
END CodeString1;

(*
 *      generate a string constant for a character constant
 *)

PROCEDURE CodeString3   (Ch: CHAR);
(* The characters '"' and backslash are escaped with a backslash. *)
(* note: within WriteS (f, ' ... '); opp will transform \\\\ to \\           *)
BEGIN
  WriteC (f, '"');
  IF (Ch < ' ') OR (Ch > '~') THEN  WriteC (f, 134C); WriteN (f, ORD (Ch), 1, 8);
  ELSIF (Ch = '"') OR (Ch = 134C) THEN  WriteC (f, 134C);  WriteC (f, Ch);
  ELSE WriteC (f, Ch);
  END;
  WriteC (f, '"');
END CodeString3;

(*
 *      generate code for a character constant
 *)

PROCEDURE CodeChar      (Ch: CHAR);
(* The characters "'" and backslash are escaped with a backslash. *)
(* Non-printable characters are written either as their C       *)
(* escape sequence (\\0, \\n, \\t, \\b, \\r, \\f) or are represented    *)
(* by their internal code written as an octal number.           *)
(* note: within WriteS (f, ' ... '); opp will transform \\\\ to \\           *)
BEGIN
  CASE Ch OF
  | "'"         :  WriteC (f, 47C);  WriteC (f, 134C);  WriteC (f, 47C);  WriteC (f, 47C); 
  | 134C         :  WriteC (f, 47C);  WriteC (f, 134C);  WriteC (f, 134C);  WriteC (f, 47C); 
  | ' ' .. '&'  ,
    '(' .. '['  ,
    ']' .. '~'  :  WriteC (f, 47C); WriteC (f, Ch); WriteC (f, 47C); 
  | 0C          :  WriteC (f, 47C);  WriteC (f, 134C); WriteC (f, '0'); WriteC (f, 47C); 
  | 10C         :  WriteC (f, 47C);  WriteC (f, 134C); WriteC (f, 'b'); WriteC (f, 47C); 
  | 11C         :  WriteC (f, 47C);  WriteC (f, 134C); WriteC (f, 't'); WriteC (f, 47C); 
  | 12C         :  WriteC (f, 47C);  WriteC (f, 134C); WriteC (f, 'n'); WriteC (f, 47C); 
  | 14C         :  WriteC (f, 47C);  WriteC (f, 134C); WriteC (f, 'f'); WriteC (f, 47C); 
  | 15C         :  WriteC (f, 47C);  WriteC (f, 134C); WriteC (f, 'r'); WriteC (f, 47C); 
  ELSE
    WriteS (f, '((CHAR)'); WriteC (f, 47C);  WriteC (f, 134C); WriteN (f, ORD (Ch), 1, 8); WriteC (f, 47C); WriteC (f, ')');
  END;
END CodeChar;

(*
 *      generate code for a value
 *)

PROCEDURE CodeValue     (Value: tValue);
VAR
  Object: tObject;
BEGIN
  CASE Value.Kind OF
  | Values.Integer      : WriteI (f, Value.IntValue, 1);
  | Values.Real         : WriteR (f, Value.RealValue, 1, 1, 1);
  | Values.Boolean      : IF Value.BoolValue THEN WriteS (f, 'TRUE'); ELSE WriteS (f, 'FALSE'); END;
  | Values.StringChar   ,
    Values.Char         : CodeChar (Value.CharValue);
  | Values.String       : CodeString1 (Value.StringValue);
  | Values.Bitset       : WriteS (f, '0X');WriteN (f, LONGCARD (Value.BitsetValue), 1, 16);WriteC (f, 'L');
  | Values.Enumeration  : Object := Value.EnumValue;
                          WriteIdent (f, Object^.EnumLiteral1.CIdent);
  | Values.NilType      : WriteS (f, 'NIL');
  ELSE
    (* error: illegal value *)
  END;
END CodeValue;

(*
 *      generate code for a type name
 *)

PROCEDURE CodeTypeName  (Type: tType);
VAR
  Object: tObject;
BEGIN
  CASE Type^.Kind OF
  | Array1      ,
    Enumeration1,
    Pointer1    ,
    ProcType1   ,
    Record1     ,
    Set1        ,
    Subrange1   ,
    OpaqueType1 :
      Object := Type^.Constructor.TypeObj;
      IF Object # NoObject THEN
        WriteIdent (f, Object^.Object.CIdent);
        RETURN;
      END;

  ELSE
  END;

  IF Type^.Kind = Subrange1 THEN
    Type := Type^.Subrange1.Type;
  END;

  CASE Type^.Kind OF
  | ShortInt    : WriteS (f, 'SHORTINT');
  | LongInt     : WriteS (f, 'LONGINT');
  | ShortCard   : WriteS (f, 'SHORTCARD');
  | LongCard    : WriteS (f, 'LONGCARD');
  | Real        : WriteS (f, 'REAL');
  | LongReal    : WriteS (f, 'LONGREAL');
  | Bool        : WriteS (f, 'BOOLEAN');
  | Char        : WriteS (f, 'CHAR');
  | Bitset      : WriteS (f, 'BITSET');
  | Proc        : WriteS (f, 'PROC');
  | Word        : WriteS (f, 'WORD');
  | Address     : WriteS (f, 'ADDRESS');
  | OpaqueType1 : WriteS (f, 'OPAQUE');
  | Array1      : WriteS (f, 'struct ');WriteIdent (f, Type^.Array1.StructId);
  | Enumeration1: IF TypeSize (Type) = SizeUnsignedChar THEN
                    WriteS (f, 'unsigned char');
                  ELSE
                    WriteS (f, 'unsigned short');
                  END;
  | Pointer1    : CodeTypeName (Type^.Pointer1.Type);
  | ProcType1   : CodeTypeName (Type^.ProcType1.Type);
  | Record1     : WriteS (f, 'struct ');WriteIdent (f, Type^.Record1.StructId);
  | Set1        : WriteS (f, 'unsigned long');
  ELSE
    (* error: illegal type name *)
  END;
END CodeTypeName;

(*
 *      generate code for the part of a declarator before the identifier
 *)

PROCEDURE CodeDeclarator1       (Type: tType);
BEGIN
  IF (Type^.Kind = Pointer1) AND (Type^.Pointer1.TypeObj = NoObject) THEN
    CodeDeclarator1 (Type^.Pointer1.Type); WriteS (f, ' *');
  ELSIF (Type^.Kind = ProcType1) AND (Type^.ProcType1.TypeObj = NoObject) THEN
    WriteS (f, ' (*');
  END;
END CodeDeclarator1;

(*
 *      generate code for the part of a declarator after the identifier
 *)

PROCEDURE CodeDeclarator2       (Type: tType);
BEGIN
  IF (Type^.Kind = Pointer1) AND (Type^.Pointer1.TypeObj = NoObject) THEN
    CodeDeclarator2 (Type^.Pointer1.Type);
  ELSIF (Type^.Kind = ProcType1) AND (Type^.ProcType1.TypeObj = NoObject) THEN
    WriteS (f, ')()');
  END;
END CodeDeclarator2;

(*
 *      generate declarations for the global/local pointer variables,
 *      which are used to translate the access to local variables of
 *      statically enclosing procedures
 *)

PROCEDURE CodePointers  (StorageClass: SHORTCARD; Pointers: tCObjects);
VAR
  Type  : tTree;
BEGIN
  WHILE Pointers # NoCObjects DO
    WITH Pointers^.CObjects DO
      Type := M2Object^.Var1.TypeTree;

      IF NOT IsOpenArray (M2Object) THEN

WriteSpaces (f, Indent);       IF StorageClass = Static THEN WriteS (f, 'static '); END;
        CodeType (Type, NonFull);
          CodeDecla (Type, Before); WriteS (f, ' *');WriteIdent (f, CObject); CodeDecla (Type, After); WriteC (f, ';'); WriteNl (f);

      ELSE

WriteSpaces (f, Indent);       IF StorageClass = Static THEN WriteS (f, 'static '); END;
        CodeType (Type^.Array.ElemType, NonFull); WriteS (f, ' *');WriteIdent (f, CObject);WriteC (f, ';'); WriteNl (f);

WriteSpaces (f, Indent);       IF StorageClass = Static THEN WriteS (f, 'static '); END;
        WriteS (f, 'LONGCARD ');WriteIdent (f, CObject);WriteS (f, '_O;'); WriteNl (f);

      END;

    END;
    Pointers := Pointers^.CObjects.Next;
  END;
END CodePointers;

(*
 *      generate code to save and reinitialize the global pointer variables,
 *      which are used to translate the access to local variables of procedure p
 *      (called upon each entry of p)
 *)

PROCEDURE CodePush      (LocalPtrs: tCObjects);
VAR GlobalPtr   : tIdent;
BEGIN
  WHILE LocalPtrs # NoCObjects DO
    WITH LocalPtrs^.CObjects DO
      GlobalPtr := GetGlobalPtr (M2Object);

WriteSpaces (f, Indent);     WriteIdent (f, CObject);WriteS (f, ' = ');WriteIdent (f, GlobalPtr);WriteC (f, ';'); WriteNl (f);

      IF IsOpenArray (M2Object) THEN

WriteSpaces (f, Indent);       WriteIdent (f, GlobalPtr);WriteS (f, ' = ');WriteIdent (f, M2Object^.Var1.CIdent);WriteC (f, ';'); WriteNl (f);

WriteSpaces (f, Indent);       WriteIdent (f, CObject);WriteS (f, '_O = ');WriteIdent (f, GlobalPtr);WriteS (f, '_O;'); WriteNl (f);
WriteSpaces (f, Indent);       WriteIdent (f, GlobalPtr);WriteS (f, '_O = ');WriteIdent (f, GetParam (M2Object));WriteC (f, ';'); WriteNl (f);

      ELSIF IsVAR (M2Object) THEN

WriteSpaces (f, Indent);       WriteIdent (f, GlobalPtr);WriteS (f, ' = ');WriteIdent (f, M2Object^.Var1.CIdent);WriteC (f, ';'); WriteNl (f);

      ELSE

WriteSpaces (f, Indent);       WriteIdent (f, GlobalPtr);WriteS (f, ' = &');WriteIdent (f, M2Object^.Var1.CIdent);WriteC (f, ';'); WriteNl (f);

      END;
    END;
    LocalPtrs := LocalPtrs^.CObjects.Next;
  END;
END CodePush;

(*
 *      generate code to restore the global pointer variables, which are
 *      used to translate the access to local variables of procedure p
 *      (called upon each exit from p)
 *)

PROCEDURE CodePop       (LocalPtrs: tCObjects);
VAR GlobalPtr   : tIdent;
BEGIN
  WHILE LocalPtrs # NoCObjects DO
    WITH LocalPtrs^.CObjects DO
      GlobalPtr := GetGlobalPtr (M2Object);

WriteSpaces (f, Indent);     WriteIdent (f, GlobalPtr);WriteS (f, ' = ');WriteIdent (f, CObject);WriteC (f, ';'); WriteNl (f);

      IF IsOpenArray (M2Object) THEN
WriteSpaces (f, Indent);       WriteIdent (f, GlobalPtr);WriteS (f, '_O = ');WriteIdent (f, CObject);WriteS (f, '_O;'); WriteNl (f);
      END;
    END;
    LocalPtrs := LocalPtrs^.CObjects.Next;
  END;
END CodePop;

(*
 *      generate code for a label range
 *)

PROCEDURE CodeLabelRange (Label1, Label2: tValue);
VAR
  IntLabel      : INTEGER;
  BoolLabel     : BOOLEAN;
  CharLabel     : CHAR;
  EnumLiterals  : tObjects;
  EnumIndex1    ,
  EnumIndex2    : SHORTCARD;
  Type          : tType;
BEGIN
  CASE Label1.Kind OF
  | Values.Integer      :
      FOR IntLabel := Label1.IntValue TO Label2.IntValue DO
WriteSpaces (f, Indent);       WriteS (f, 'case '); WriteI (f, IntLabel, 1); WriteS (f, ':;'); WriteNl (f);
      END;

  | Values.Boolean      :
      FOR BoolLabel := Label1.BoolValue TO Label2.BoolValue DO
        IF BoolLabel THEN
WriteSpaces (f, Indent);         WriteS (f, 'case TRUE:'); WriteNl (f);
        ELSE
WriteSpaces (f, Indent);         WriteS (f, 'case FALSE:'); WriteNl (f);
        END;
      END;

  | Values.Char         ,
    Values.StringChar   :
      FOR CharLabel := Label1.CharValue TO Label2.CharValue DO
WriteSpaces (f, Indent);       WriteS (f, 'case '); CodeChar (CharLabel); WriteS (f, ':;'); WriteNl (f);
      END;

  | Values.Enumeration  :
      Type              := GetType (Label1.EnumValue);
      EnumLiterals      := Type^.Enumeration1.Objects;
      EnumIndex1        := ValueToInt (Label1);
      EnumIndex2        := ValueToInt (Label2);

      WHILE EnumLiterals # NoObjects DO
        WITH EnumLiterals^.Elmt.Object^.EnumLiteral1 DO
          IF (Index >= EnumIndex1) AND
             (Index <= EnumIndex2) THEN
WriteSpaces (f, Indent);           WriteS (f, 'case '); WriteIdent (f, CIdent); WriteS (f, ':;'); WriteNl (f);
          END;
        END;

        EnumLiterals := EnumLiterals^.Elmt.Next;
      END;

  ELSE
  END;
END CodeLabelRange;

(*
 *      generate code to allocate memory for open array value parameters
 *)

PROCEDURE CodeAlloc     (ValueOpens: tCObjects);
VAR
  ArrayCnt      : CARDINAL;
BEGIN
  IF ValueOpens # NoCObjects THEN
    ArrayCnt := 0;

WriteSpaces (f, Indent);   WriteS (f, 'ALLOC_OPEN_ARRAYS(');

    LOOP
      INC (ArrayCnt);

      WITH ValueOpens^.CObjects DO
        WriteIdent (f, CObject);WriteS (f, ' * ');
          WriteS (f, 'sizeof('); CodeTypeName (GetElemType (GetType (M2Object))); WriteC (f, ')');
      END;

      ValueOpens := ValueOpens^.CObjects.Next;
      IF ValueOpens = NoObjects THEN
        EXIT;
      END;

      WriteS (f, ' + ');

    END;

    WriteS (f, ', ');WriteI (f, ArrayCnt, 1);WriteC (f, ')'); WriteNl (f);

  END;
END CodeAlloc;

(*
 *      generate code to copy an open array value parameter
 *)

PROCEDURE CodeCopy      (ValueOpens: tCObjects);
BEGIN
  WHILE ValueOpens # NoCObjects DO
    WITH ValueOpens^.CObjects DO
WriteSpaces (f, Indent);     WriteS (f, 'COPY_OPEN_ARRAY(');
        WriteIdent (f, M2Object^.Var1.CIdent);WriteS (f, ', ');
        WriteIdent (f, CObject);WriteS (f, ', ');
        CodeTypeName (GetElemType (GetType (M2Object)));
      WriteC (f, ')'); WriteNl (f);
    END;
    ValueOpens := ValueOpens^.CObjects.Next;
  END;
END CodeCopy;

(*
 *      generate code to release memory for an open array value parameter
 *)

PROCEDURE CodeFree      (ValueOpens: tCObjects);
BEGIN
  IF ValueOpens # NoCObjects THEN
WriteSpaces (f, Indent);   WriteS (f, 'FREE_OPEN_ARRAYS'); WriteNl (f);
  END;
END CodeFree;

(*
 *      generate declarations for the local array variables, which
 *      are used to translate the parameter passing of strings,
 *      if the corresponding formal parameters are no open arrays
 *)

PROCEDURE CodeStrings   (Strings: tStrings);
BEGIN
  WHILE Strings # NoStrings DO
    WITH Strings^.StringPar DO
WriteSpaces (f, Indent);     CodeTypeName (FormalType); WriteC (f, ' '); WriteIdent (f, CString); WriteC (f, ';'); WriteNl (f);
    END;
    Strings := Strings^.StringPar.Next;
  END;
END CodeStrings;

(*
 *      generate code to initialize the local array variables, which
 *      are used to translate the parameter passing of strings,
 *      if the corresponding formal parameters are no open arrays
 *)

PROCEDURE CodeStrncpy   (Strings: tStrings);
BEGIN
  WHILE Strings # NoStrings DO
    WITH Strings^.StringPar DO
WriteSpaces (f, Indent);     WriteS (f, '(void)strncpy(');
                      IF OptionIsSet ('c') THEN WriteS (f, '(char *)'); END;
                      WriteIdent (f, CString); WriteS (f, '.A, ');
                      CodeString2 (M2String, Strncpy); WriteS (f, ', ');
                      WriteS (f, 'sizeof('); WriteIdent (f, CString); WriteS (f, '.A)');
      WriteS (f, ');'); WriteNl (f);
    END;
    Strings := Strings^.StringPar.Next;
  END;
END CodeStrncpy;

(*
 *      generate code for additional record field selectors
 *)

PROCEDURE CodeSelectors (Selectors: tSelectors);
BEGIN
  IF Selectors # NoSelectors THEN
    CodeSelectors (Selectors^.Selectors.Next);
    WriteIdent (f, Selectors^.Selectors.Selector);WriteC (f, '.');
  END;
END CodeSelectors;

(*
 *      generate code for type casts
 *)

PROCEDURE CodeCast      (Type: tType);
BEGIN
  WriteC (f, '('); CodeTypeName (Type); CodeDeclarator1 (Type); CodeDeclarator2 (Type); WriteC (f, ')');
END CodeCast;

PROCEDURE CodeCastVAR   (Type: tType);
BEGIN
  WriteC (f, '('); CodeTypeName (Type); CodeDeclarator1 (Type); WriteS (f, ' *'); CodeDeclarator2 (Type); WriteC (f, ')');
END CodeCastVAR;

(*
 *      generate code for standard procedure MIN
 *)

PROCEDURE CodeMIN       (Type: tType);
VAR Object: tObject;
BEGIN
  CASE Type^.Kind OF
  | ShortInt    : WriteS (f, 'MIN_SHORTINT');
  | LongInt     : WriteS (f, 'MIN_LONGINT');
  | ShortCard   : WriteS (f, 'MIN_SHORTCARD');
  | LongCard    : WriteS (f, 'MIN_LONGCARD');
  | Real        : WriteS (f, 'MIN_REAL');
  | LongReal    : WriteS (f, 'MIN_LONGREAL');
  | Bool        : WriteS (f, 'MIN_BOOLEAN');
  | Char        : WriteS (f, 'MIN_CHAR');
  | Enumeration1: WITH Type^.Enumeration1 DO
                    Object := GetLiteral (Objects, 0);
                  END;
                  WriteIdent (f, Object^.EnumLiteral1.CIdent);
  | Subrange1   : CodeValue (Type^.Subrange1.Lwb);
                  IF IsIntType (Type) AND Cast (cPassValue, Type, TypeIntCard) THEN WriteC (f, 'L'); END;
  ELSE
  END;
END CodeMIN;

(*
 *      generate code for standard procedure MAX
 *)

PROCEDURE CodeMAX       (Type: tType);
VAR Object: tObject;
BEGIN
  CASE Type^.Kind OF
  | ShortInt    : WriteS (f, 'MAX_SHORTINT');
  | LongInt     : WriteS (f, 'MAX_LONGINT');
  | ShortCard   : WriteS (f, 'MAX_SHORTCARD');
  | LongCard    : WriteS (f, 'MAX_LONGCARD');
  | Real        : WriteS (f, 'MAX_REAL');
  | LongReal    : WriteS (f, 'MAX_LONGREAL');
  | Bool        : WriteS (f, 'MAX_BOOLEAN');
  | Char        : WriteS (f, 'MAX_CHAR');
  | Enumeration1: WITH Type^.Enumeration1 DO
                    Object := GetLiteral (Objects, MaxValue);
                  END;
                  WriteIdent (f, Object^.EnumLiteral1.CIdent);
  | Subrange1   : CodeValue (Type^.Subrange1.Upb);
                  IF IsIntType (Type) AND Cast (cPassValue, Type, TypeIntCard) THEN WriteC (f, 'L'); END;
  ELSE
  END;
END CodeMAX;














































































PROCEDURE yyAbort (yyFunction: ARRAY OF CHAR);
 BEGIN
  IO.WriteS (IO.StdError, 'Error: module Code, routine ');
  IO.WriteS (IO.StdError, yyFunction);
  IO.WriteS (IO.StdError, ' failed');
  IO.WriteNl (IO.StdError);
  Exit;
 END yyAbort;

PROCEDURE yyIsEqual (yya, yyb: ARRAY OF SYSTEM.BYTE): BOOLEAN;
 VAR yyi       : INTEGER;
 BEGIN
  FOR yyi := 0 TO INTEGER (HIGH (yya)) DO
   IF yya [yyi] # yyb [yyi] THEN RETURN FALSE; END;
  END;
  RETURN TRUE;
 END yyIsEqual;

PROCEDURE CodeCompUnits (yyP1: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 4: yyR4: RECORD
  DefMod: tTree;
  END;
 END; END;
 BEGIN
(* line 1068 "" *)
   LOOP
      IF (yyP1^.Kind # Tree.ROOT) THEN EXIT; END;
(* line 1069 "" *)
      CodeCompUnits (yyP1^.ROOT.CompUnits);
      RETURN;
   END (* LOOP *) ;

(* line 1071 "" *)
   LOOP
      IF (yyP1^.Kind # Tree.DefMod) THEN EXIT; END;
      IF (yyP1^.DefMod.Next^.Kind # Tree.CompUnits0) THEN EXIT; END;
(* line 1072 "" *)
      
                f := OpenHeader (yyP1^.DefMod.Ident);

                WriteS (f, '#define DEFINITION_');WriteIdent (f, yyP1^.DefMod.Ident); WriteNl (f);
                WriteNl (f);

                CodeImports (yyP1^.DefMod.Import);
                CodeDefs1 (yyP1^.DefMod.Decls);


                WriteS (f, 'extern void ');WriteIdent (f, yyP1^.DefMod.Ident);WriteS (f, '__init();'); WriteNl (f);

                WriteClose (f);
;
      RETURN;
   END (* LOOP *) ;

(* line 1087 "" *)
   LOOP
      IF (yyP1^.Kind # Tree.DefMod) THEN EXIT; END;
      IF NOT Tree.IsType (yyP1^.DefMod.Next, Tree.CompUnit) THEN EXIT; END;
(* line 1088 "" *)
      
                
                
                
                
                PutAssoc (yyP1^.DefMod.Ident, yyP1);

                IF OptionIsSet ('i') THEN
                  f := OpenHeader (yyP1^.DefMod.Ident);

                  WriteS (f, '#define DEFINITION_');WriteIdent (f, yyP1^.DefMod.Ident); WriteNl (f);
                  WriteNl (f);

                  CodeImports (yyP1^.DefMod.Import);
                  CodeDefs1 (yyP1^.DefMod.Decls);


                  WriteS (f, 'extern void ');WriteIdent (f, yyP1^.DefMod.Ident);WriteS (f, '__init();'); WriteNl (f);

                  WriteClose (f);
                END;

                CodeCompUnits (yyP1^.DefMod.Next);
;
      RETURN;
   END (* LOOP *) ;

(* line 1113 "" *)
    WITH yyTempo.yyR4 DO   LOOP
      IF (yyP1^.Kind # Tree.ProgMod) THEN EXIT; END;
      IF (yyP1^.ProgMod.Next^.Kind # Tree.CompUnits0) THEN EXIT; END;
(* line 1116 "" *)
      IF NOT (yyP1^.ProgMod.Kind = Implementation) THEN EXIT; END;
(* line 1117 "" *)
      ;
(* line 1118 "" *)
      
                f := OpenProgram (yyP1^.ProgMod.Ident);

                
                
                
                GetAssoc (yyP1^.ProgMod.Ident, DefMod);
                IF DefMod = NoTree THEN
                  CompilerError ("Code.CodeCompUnits");
                END;

                WriteS (f, '#include "SYSTEM_.h"'); WriteNl (f);
                WriteNl (f);

                CodeImports (yyP1^.ProgMod.Import);

                WriteS (f, '#ifndef DEFINITION_');WriteIdent (f, yyP1^.ProgMod.Ident); WriteNl (f);
                WriteS (f, '#include "');WriteIdent (f, yyP1^.ProgMod.Ident);WriteS (f, '.h"'); WriteNl (f);
                WriteS (f, '#endif'); WriteNl (f);
                WriteNl (f);

                CodeDefs2 (DefMod^.DefMod.Decls);
                WriteNl (f);

                CodeDecls1 (yyP1^.ProgMod.Decls);
                WriteNl (f);

                GenGlobalPtrs (yyP1^.ProgMod.GlobalPtrs);
                GlobalPtrs := yyP1^.ProgMod.GlobalPtrs;

                CodePointers (Static, yyP1^.ProgMod.GlobalPtrs);
                WriteNl (f);
                
                CodeProcs (yyP1^.ProgMod.Decls);


                WriteS (f, 'void ');WriteIdent (f, yyP1^.ProgMod.Ident);WriteS (f, '__init()'); WriteNl (f);
                WriteC (f, '{'); WriteNl (f);
                WriteS (f, '  static BOOLEAN has_been_called = FALSE;'); WriteNl (f);
                WriteNl (f);

INC (Indent, 2);                 CodeStrings (yyP1^.ProgMod.Strings);
                   IF yyP1^.ProgMod.Strings # NoStrings THEN WriteNl (f); END;

                WriteS (f, '  if (!has_been_called) {'); WriteNl (f);
                WriteS (f, '    has_been_called = TRUE;'); WriteNl (f);
                WriteNl (f);

                     
                     
                     
INC (Indent, 2);                   CodeInits (DefMod^.DefMod.Import);
                     CodeInits (yyP1^.ProgMod.Import);
                     CodeStrncpy (yyP1^.ProgMod.Strings);
                     CodeInits (yyP1^.ProgMod.Decls);
                WriteNl (f);
                     CodeStmts (yyP1^.ProgMod.Stmts);

DEC (Indent, 4);             WriteS (f, '  }'); WriteNl (f);
                WriteC (f, '}'); WriteNl (f);

                WriteClose (f);
;
      RETURN;
   END (* LOOP *) ;
    END (* WITH yyTempo.yyR ... *) ;

(* line 1182 "" *)
   LOOP
      IF (yyP1^.Kind # Tree.ProgMod) THEN EXIT; END;
      IF (yyP1^.ProgMod.Next^.Kind # Tree.CompUnits0) THEN EXIT; END;
(* line 1184 "" *)
      IF NOT (yyP1^.ProgMod.Kind = Program) THEN EXIT; END;
(* line 1185 "" *)
      
                f := OpenProgram (yyP1^.ProgMod.Ident);

                WriteS (f, '#include "SYSTEM_.h"'); WriteNl (f);
                WriteNl (f);

                CodeImports (yyP1^.ProgMod.Import);

                CodeDecls1 (yyP1^.ProgMod.Decls);
                WriteNl (f);

                GenGlobalPtrs (yyP1^.ProgMod.GlobalPtrs);
                GlobalPtrs := yyP1^.ProgMod.GlobalPtrs;

                CodePointers (Static, yyP1^.ProgMod.GlobalPtrs);
                WriteNl (f);
                
                CodeProcs (yyP1^.ProgMod.Decls);

                WriteS (f, 'extern int  parameters_argc;'); WriteNl (f);
                WriteS (f, 'extern char **parameters_argv;'); WriteNl (f);
                WriteS (f, 'extern char **parameters_envp;'); WriteNl (f);

                WriteS (f, '# ifdef __STDC__'); WriteNl (f);
                WriteS (f, 'void main(int argc, char *argv[], char *envp[])'); WriteNl (f);
                WriteS (f, '# else'); WriteNl (f);
                WriteS (f, 'void main(argc, argv, envp)'); WriteNl (f);
                WriteS (f, '  int argc;'); WriteNl (f);
                WriteS (f, '  char *argv[], *envp[];'); WriteNl (f);
                WriteS (f, '# endif'); WriteNl (f);
                WriteC (f, '{'); WriteNl (f);

                WriteS (f, 'parameters_argc = argc;'); WriteNl (f);
                WriteS (f, 'parameters_argv = argv;'); WriteNl (f);
                WriteS (f, 'parameters_envp = envp;'); WriteNl (f);

INC (Indent, 2);                CodeStrings (yyP1^.ProgMod.Strings);
                  IF yyP1^.ProgMod.Strings # NoStrings THEN WriteNl (f); END;

                  CodeInits (yyP1^.ProgMod.Import);
                  CodeStrncpy (yyP1^.ProgMod.Strings);
                  CodeInits (yyP1^.ProgMod.Decls);
                WriteNl (f);
                  CodeStmts (yyP1^.ProgMod.Stmts);
                WriteS (f, 'exit(0);'); WriteNl (f);
DEC (Indent, 2);              WriteC (f, '}'); WriteNl (f);

                WriteClose (f);
;
      RETURN;
   END (* LOOP *) ;

 END CodeCompUnits;

PROCEDURE CodeImports (yyP2: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
(* line 1241 "" *)
   LOOP
      IF (yyP2^.Kind # Tree.From) THEN EXIT; END;
(* line 1242 "" *)
      IF NOT (yyP2^.From.Ident # IdentSYSTEM) THEN EXIT; END;
(* line 1243 "" *)
      WriteS (f, '#ifndef DEFINITION_');
(* line 1243 "" *)
      WriteIdent (f, yyP2^.From.Ident);
(* line 1243 "" *)
      WriteNl (f);
(* line 1244 "" *)
      WriteS (f, '#include "');
(* line 1244 "" *)
      WriteIdent (f, yyP2^.From.Ident);
(* line 1244 "" *)
      WriteS (f, '.h"');
(* line 1244 "" *)
      WriteNl (f);
(* line 1245 "" *)
      WriteS (f, '#endif');
(* line 1245 "" *)
      WriteNl (f);
(* line 1246 "" *)
      WriteNl (f);
(* line 1247 "" *)
      CodeImports (yyP2^.From.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1249 "" *)
   LOOP
      IF (yyP2^.Kind # Tree.From) THEN EXIT; END;
(* line 1250 "" *)
      CodeImports (yyP2^.From.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1252 "" *)
   LOOP
      IF (yyP2^.Kind # Tree.Objects) THEN EXIT; END;
(* line 1253 "" *)
      CodeImports (yyP2^.Objects.ImpIds);
(* line 1254 "" *)
      CodeImports (yyP2^.Objects.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1256 "" *)
   LOOP
      IF (yyP2^.Kind # Tree.ImpIds1) THEN EXIT; END;
(* line 1257 "" *)
      IF NOT (yyP2^.ImpIds1.Ident # IdentSYSTEM) THEN EXIT; END;
(* line 1258 "" *)
      WriteS (f, '#ifndef DEFINITION_');
(* line 1258 "" *)
      WriteIdent (f, yyP2^.ImpIds1.Ident);
(* line 1258 "" *)
      WriteNl (f);
(* line 1259 "" *)
      WriteS (f, '#include "');
(* line 1259 "" *)
      WriteIdent (f, yyP2^.ImpIds1.Ident);
(* line 1259 "" *)
      WriteS (f, '.h"');
(* line 1259 "" *)
      WriteNl (f);
(* line 1260 "" *)
      WriteS (f, '#endif');
(* line 1260 "" *)
      WriteNl (f);
(* line 1261 "" *)
      WriteNl (f);
(* line 1262 "" *)
      CodeImports (yyP2^.ImpIds1.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1264 "" *)
   LOOP
      IF (yyP2^.Kind # Tree.ImpIds1) THEN EXIT; END;
(* line 1265 "" *)
      CodeImports (yyP2^.ImpIds1.Next);
      RETURN;
   END (* LOOP *) ;

 END CodeImports;

PROCEDURE CodeInits (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
(* line 1273 "" *)
   LOOP
      IF (t^.Kind # Tree.From) THEN EXIT; END;
(* line 1274 "" *)
      IF NOT (t^.From.Ident # IdentSYSTEM) THEN EXIT; END;
(* line 1276 "" *)
      WriteSpaces (f, Indent);
(* line 1276 "" *)
      WriteIdent (f, t^.From.Ident);
(* line 1276 "" *)
      WriteS (f, '__init();');
(* line 1276 "" *)
      WriteNl (f);
(* line 1277 "" *)
      CodeInits (t^.From.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1279 "" *)
   LOOP
      IF (t^.Kind # Tree.From) THEN EXIT; END;
(* line 1280 "" *)
      CodeInits (t^.From.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1282 "" *)
   LOOP
      IF (t^.Kind # Tree.Objects) THEN EXIT; END;
(* line 1283 "" *)
      CodeInits (t^.Objects.ImpIds);
(* line 1284 "" *)
      CodeInits (t^.Objects.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1286 "" *)
   LOOP
      IF (t^.Kind # Tree.ImpIds1) THEN EXIT; END;
(* line 1287 "" *)
      IF NOT (t^.ImpIds1.Ident # IdentSYSTEM) THEN EXIT; END;
(* line 1289 "" *)
      WriteSpaces (f, Indent);
(* line 1289 "" *)
      WriteIdent (f, t^.ImpIds1.Ident);
(* line 1289 "" *)
      WriteS (f, '__init();');
(* line 1289 "" *)
      WriteNl (f);
(* line 1290 "" *)
      CodeInits (t^.ImpIds1.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1292 "" *)
   LOOP
      IF (t^.Kind # Tree.ImpIds1) THEN EXIT; END;
(* line 1293 "" *)
      CodeInits (t^.ImpIds1.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1295 "" *)
   LOOP
      IF (t^.Kind # Tree.Module) THEN EXIT; END;
(* line 1296 "" *)
      WriteSpaces (f, Indent);
(* line 1296 "" *)
      WriteIdent (f, t ^ . Module . CIdent);
(* line 1296 "" *)
      WriteS (f, '();');
(* line 1296 "" *)
      WriteNl (f);
(* line 1297 "" *)
      CodeInits (t^.Module.Decls);
(* line 1298 "" *)
      CodeInits (t^.Module.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1300 "" *)
   LOOP
      IF NOT Tree.IsType (t, Tree.Decl) THEN EXIT; END;
(* line 1301 "" *)
      CodeInits (t^.Decl.Next);
      RETURN;
   END (* LOOP *) ;

 END CodeInits;

PROCEDURE CodeDefs1 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
(* line 1310 "" *)
   LOOP
      IF (t^.Kind # Tree.Var) THEN EXIT; END;
(* line 1311 "" *)
      CodeEnums (t^.Var.Type);
(* line 1312 "" *)
      WriteS (f, 'extern ');
(* line 1312 "" *)
      CodeType (t^.Var.Type, Full);
(* line 1312 "" *)
      WriteC (f, ' ');
(* line 1312 "" *)
      CodeIds (t^.Var.VarIds, t^.Var.Type);
(* line 1312 "" *)
      WriteC (f, ';');
(* line 1312 "" *)
      WriteNl (f);
(* line 1313 "" *)
      CodeDefs1 (t^.Var.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1315 "" *)
   LOOP
      IF (t^.Kind # Tree.Const) THEN EXIT; END;
      IF (t^.Const.Expr^.Kind # Tree.StringConst) THEN EXIT; END;
(* line 1316 "" *)
      IF NOT (Length (t^.Const.Expr^.StringConst.StringVal) > 1) THEN EXIT; END;
(* line 1317 "" *)
      WriteS (f, 'extern CHAR ');
(* line 1317 "" *)
      WriteIdent (f, t ^ . Const . CIdent);
(* line 1317 "" *)
      WriteS (f, '[];');
(* line 1317 "" *)
      WriteNl (f);
(* line 1318 "" *)
      CodeDefs1 (t^.Const.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1320 "" *)
   LOOP
      IF (t^.Kind # Tree.Const) THEN EXIT; END;
(* line 1321 "" *)
      IF NOT (t^.Const.Expr ^ . Expr . IsCConst) THEN EXIT; END;
(* line 1322 "" *)
      WriteS (f, '#define ');
(* line 1322 "" *)
      WriteIdent (f, t ^ . Const . CIdent);
(* line 1322 "" *)
      WriteS (f, '   ');
(* line 1322 "" *)
      CodeExpr (t^.Const.Expr, pMaxPrec);
(* line 1322 "" *)
      WriteNl (f);
(* line 1323 "" *)
      CodeDefs1 (t^.Const.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1325 "" *)
   LOOP
      IF (t^.Kind # Tree.Const) THEN EXIT; END;
(* line 1326 "" *)
      WriteS (f, '#define ');
(* line 1326 "" *)
      WriteIdent (f, t ^ . Const . CIdent);
(* line 1326 "" *)
      WriteS (f, '   ');
(* line 1326 "" *)
      CodeValue (t ^ . Const . Object ^ . Const1 . Value);
(* line 1326 "" *)
      WriteNl (f);
(* line 1327 "" *)
      CodeDefs1 (t^.Const.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1329 "" *)
   LOOP
      IF (t^.Kind # Tree.TypeDecl) THEN EXIT; END;
(* line 1330 "" *)
      CodeEnums (t^.TypeDecl.Type);
(* line 1331 "" *)
      WriteS (f, 'typedef ');
(* line 1331 "" *)
      CodeType (t^.TypeDecl.Type, Full);
(* line 1331 "" *)
      WriteC (f, ' ');
(* line 1332 "" *)
      CodeDecla (t^.TypeDecl.Type, Before);
(* line 1332 "" *)
      WriteIdent (f, t ^ . TypeDecl . CIdent);
(* line 1332 "" *)
      CodeDecla (t^.TypeDecl.Type, After);
(* line 1332 "" *)
      WriteC (f, ';');
(* line 1332 "" *)
      WriteNl (f);
(* line 1333 "" *)
      CodeDefs1 (t^.TypeDecl.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1335 "" *)
   LOOP
      IF (t^.Kind # Tree.ProcHead) THEN EXIT; END;
(* line 1336 "" *)
      WriteS (f, 'extern ');
(* line 1336 "" *)
      CodeType (t^.ProcHead.ResultType, Full);
(* line 1336 "" *)
      WriteC (f, ' ');
(* line 1336 "" *)
      WriteIdent (f, t ^ . ProcHead . CIdent);
(* line 1337 "" *)
      WriteS (f, ' ARGS((');
(* line 1337 "" *)
      CodeFormals3 (t^.ProcHead.Formals, NoIdent);
(* line 1337 "" *)
      WriteS (f, '));');
(* line 1337 "" *)
      WriteNl (f);
(* line 1338 "" *)
      CodeDefs1 (t^.ProcHead.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1340 "" *)
   LOOP
      IF (t^.Kind # Tree.Opaque) THEN EXIT; END;
(* line 1341 "" *)
      WriteS (f, 'typedef OPAQUE ');
(* line 1341 "" *)
      WriteIdent (f, t ^ . Opaque . CIdent);
(* line 1341 "" *)
      WriteC (f, ';');
(* line 1341 "" *)
      WriteNl (f);
(* line 1342 "" *)
      CodeDefs1 (t^.Opaque.Next);
      RETURN;
   END (* LOOP *) ;

 END CodeDefs1;

PROCEDURE CodeDefs2 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
(* line 1351 "" *)
   LOOP
      IF (t^.Kind # Tree.Var) THEN EXIT; END;
(* line 1352 "" *)
      CodeType (t^.Var.Type, NonFull);
(* line 1352 "" *)
      WriteC (f, ' ');
(* line 1352 "" *)
      CodeIds (t^.Var.VarIds, t^.Var.Type);
(* line 1352 "" *)
      WriteC (f, ';');
(* line 1352 "" *)
      WriteNl (f);
(* line 1353 "" *)
      CodeDefs2 (t^.Var.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1355 "" *)
   LOOP
      IF (t^.Kind # Tree.Const) THEN EXIT; END;
      IF (t^.Const.Expr^.Kind # Tree.StringConst) THEN EXIT; END;
(* line 1356 "" *)
      IF NOT (Length (t^.Const.Expr^.StringConst.StringVal) > 1) THEN EXIT; END;
(* line 1357 "" *)
      WriteS (f, 'CHAR ');
(* line 1357 "" *)
      WriteIdent (f, t ^ . Const . CIdent);
(* line 1357 "" *)
      WriteS (f, ' [] = ');
(* line 1357 "" *)
      CodeString1 (t^.Const.Expr^.StringConst.StringVal);
(* line 1357 "" *)
      WriteC (f, ';');
(* line 1357 "" *)
      WriteNl (f);
(* line 1358 "" *)
      CodeDefs2 (t^.Const.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1360 "" *)
   LOOP
      IF NOT Tree.IsType (t, Tree.Decl) THEN EXIT; END;
(* line 1361 "" *)
      CodeDefs2 (t^.Decl.Next);
      RETURN;
   END (* LOOP *) ;

 END CodeDefs2;

PROCEDURE CodeDecls1 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
(* line 1374 "" *)
   LOOP
      IF (t^.Kind # Tree.Var) THEN EXIT; END;
(* line 1375 "" *)
      IF NOT (t ^ . Var . IsGlobal) THEN EXIT; END;
(* line 1376 "" *)
      CodeEnums (t^.Var.Type);
(* line 1377 "" *)
      WriteS (f, 'static ');
(* line 1377 "" *)
      CodeType (t^.Var.Type, Full);
(* line 1377 "" *)
      WriteC (f, ' ');
(* line 1377 "" *)
      CodeIds (t^.Var.VarIds, t^.Var.Type);
(* line 1377 "" *)
      WriteC (f, ';');
(* line 1377 "" *)
      WriteNl (f);
(* line 1378 "" *)
      CodeDecls1 (t^.Var.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1380 "" *)
   LOOP
      IF (t^.Kind # Tree.Var) THEN EXIT; END;
(* line 1381 "" *)
      IF NOT (NOT t ^ . Var . IsGlobal) THEN EXIT; END;
(* line 1382 "" *)
      CodeEnums (t^.Var.Type);
(* line 1383 "" *)
      CodeStruct (t^.Var.Type);
(* line 1384 "" *)
      CodeDecls1 (t^.Var.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1386 "" *)
   LOOP
      IF (t^.Kind # Tree.Const) THEN EXIT; END;
      IF (t^.Const.Expr^.Kind # Tree.StringConst) THEN EXIT; END;
(* line 1387 "" *)
      IF NOT (Length (t^.Const.Expr^.StringConst.StringVal) > 1) THEN EXIT; END;
(* line 1388 "" *)
      WriteS (f, 'static CHAR ');
(* line 1388 "" *)
      WriteIdent (f, t ^ . Const . CIdent);
(* line 1388 "" *)
      WriteS (f, ' [] = ');
(* line 1388 "" *)
      CodeString1 (t^.Const.Expr^.StringConst.StringVal);
(* line 1388 "" *)
      WriteC (f, ';');
(* line 1388 "" *)
      WriteNl (f);
(* line 1389 "" *)
      CodeDecls1 (t^.Const.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1391 "" *)
   LOOP
      IF (t^.Kind # Tree.Const) THEN EXIT; END;
(* line 1392 "" *)
      IF NOT (t^.Const.Expr ^ . Expr . IsCConst) THEN EXIT; END;
(* line 1393 "" *)
      WriteS (f, '#define ');
(* line 1393 "" *)
      WriteIdent (f, t ^ . Const . CIdent);
(* line 1393 "" *)
      WriteS (f, '   ');
(* line 1393 "" *)
      CodeExpr (t^.Const.Expr, pMaxPrec);
(* line 1393 "" *)
      WriteNl (f);
(* line 1394 "" *)
      CodeDecls1 (t^.Const.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1396 "" *)
   LOOP
      IF (t^.Kind # Tree.Const) THEN EXIT; END;
(* line 1397 "" *)
      WriteS (f, '#define ');
(* line 1397 "" *)
      WriteIdent (f, t ^ . Const . CIdent);
(* line 1397 "" *)
      WriteS (f, '   ');
(* line 1397 "" *)
      CodeValue (t ^ . Const . Object ^ . Const1 . Value);
(* line 1397 "" *)
      WriteNl (f);
(* line 1398 "" *)
      CodeDecls1 (t^.Const.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1400 "" *)
   LOOP
      IF (t^.Kind # Tree.TypeDecl) THEN EXIT; END;
(* line 1401 "" *)
      CodeEnums (t^.TypeDecl.Type);
(* line 1402 "" *)
      WriteS (f, 'typedef ');
(* line 1402 "" *)
      CodeType (t^.TypeDecl.Type, Full);
(* line 1402 "" *)
      WriteC (f, ' ');
(* line 1403 "" *)
      CodeDecla (t^.TypeDecl.Type, Before);
(* line 1403 "" *)
      WriteIdent (f, t ^ . TypeDecl . CIdent);
(* line 1403 "" *)
      CodeDecla (t^.TypeDecl.Type, After);
(* line 1403 "" *)
      WriteC (f, ';');
(* line 1403 "" *)
      WriteNl (f);
(* line 1404 "" *)
      CodeDecls1 (t^.TypeDecl.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1406 "" *)
   LOOP
      IF (t^.Kind # Tree.Proc) THEN EXIT; END;
(* line 1407 "" *)
      IF NOT (NOT IsExported (t ^ . Proc . Object)) THEN EXIT; END;
(* line 1408 "" *)
      WriteS (f, 'static ');
(* line 1408 "" *)
      CodeType (t^.Proc.ResultType, Full);
(* line 1408 "" *)
      WriteC (f, ' ');
(* line 1408 "" *)
      WriteIdent (f, t ^ . Proc . CIdent);
(* line 1409 "" *)
      WriteS (f, ' ARGS((');
(* line 1409 "" *)
      CodeFormals3 (t^.Proc.Formals, NoIdent);
(* line 1409 "" *)
      WriteS (f, '));');
(* line 1409 "" *)
      WriteNl (f);
(* line 1410 "" *)
      CodeDecls1 (t^.Proc.Decls);
(* line 1411 "" *)
      CodeDecls1 (t^.Proc.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1413 "" *)
   LOOP
      IF (t^.Kind # Tree.Proc) THEN EXIT; END;
(* line 1414 "" *)
      CodeDecls1 (t^.Proc.Decls);
(* line 1415 "" *)
      CodeDecls1 (t^.Proc.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1417 "" *)
   LOOP
      IF (t^.Kind # Tree.Module) THEN EXIT; END;
(* line 1418 "" *)
      CodeDecls1 (t^.Module.Decls);
(* line 1419 "" *)
      CodeDecls1 (t^.Module.Next);
      RETURN;
   END (* LOOP *) ;

 END CodeDecls1;

PROCEDURE CodeType (t: Tree.tTree; Full: BOOLEAN);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 1: yyR1: RECORD
  Lwb: tValue;
  LwbExpr: tTree;
  UpbExpr: tTree;
  END;
 | 2: yyR2: RECORD
  Upb: tValue;
  END;
 | 3: yyR3: RECORD
  Lwb: tValue;
  Upb: tValue;
  END;
 END; END;
 BEGIN
(* line 1432 "" *)
    WITH yyTempo.yyR1 DO   LOOP
      IF (t^.Kind # Tree.Array) THEN EXIT; END;
(* line 1433 "" *)
      IF NOT (t^.Array.IndexType ^ . SimpleType . Type2 ^ . Kind = Subrange1) THEN EXIT; END;
(* line 1434 "" *)
      ;
(* line 1435 "" *)
      
                IF Full THEN
                  GetLwb (t^.Array.IndexType^.SimpleType.Type2, Lwb);
                  LwbExpr := t^.Array.IndexType^.SimpleType.Type2^.Subrange1.LwbExpr;
                  UpbExpr := t^.Array.IndexType^.SimpleType.Type2^.Subrange1.UpbExpr;

                  WriteS (f, 'struct ');WriteIdent (f, t^.Array.Type2^.Array1.StructId);WriteS (f, ' {'); WriteNl (f);
INC (Indent, 4);WriteSpaces (f, Indent);                  CodeType (t^.Array.ElemType, Full); WriteC (f, ' ');
                      CodeDecla (t^.Array.ElemType, Before);
                      WriteS (f, 'A[');
                       IF UpbExpr^.Expr.IsCConst THEN
                         IF ValueToInt (Lwb) # 0 THEN
                           CodeExpr (UpbExpr, pMinus + 1);
                         ELSE
                           CodeExpr (UpbExpr, pPlus + 1);
                         END;
                       ELSE
                         CodeValue (t^.Array.IndexType^.SimpleType.Type2^.Subrange1.Upb);
                       END;
                       IF ValueToInt (Lwb) # 0 THEN
                         WriteS (f, ' - ');
                         IF LwbExpr^.Expr.IsCConst THEN
                           CodeExpr (LwbExpr, pMinus);
                         ELSE
                           CodeValue (Lwb);
                         END;
                       END;
                       WriteS (f, ' + 1');
                      WriteC (f, ']');
                      CodeDecla (t^.Array.ElemType, After); WriteC (f, ';'); WriteNl (f);
DEC (Indent, 4);WriteSpaces (f, Indent);              WriteC (f, '}');
                ELSE
                  WriteS (f, 'struct ');WriteIdent (f, t^.Array.Type2^.Array1.StructId);
                END;
;
      RETURN;
   END (* LOOP *) ;
    END (* WITH yyTempo.yyR ... *) ;

(* line 1471 "" *)
    WITH yyTempo.yyR2 DO   LOOP
      IF (t^.Kind # Tree.Array) THEN EXIT; END;
(* line 1472 "" *)
      IF NOT (t^.Array.IndexType ^ . SimpleType . Type2 ^ . Kind = Enumeration1) THEN EXIT; END;
(* line 1473 "" *)
      ;
(* line 1474 "" *)
      
                IF Full THEN
                  GetUpb (t^.Array.IndexType^.SimpleType.Type2, Upb);
                  WriteS (f, 'struct ');WriteIdent (f, t^.Array.Type2^.Array1.StructId);WriteS (f, ' {'); WriteNl (f);
INC (Indent, 4);WriteSpaces (f, Indent);                  CodeType (t^.Array.ElemType, Full); WriteC (f, ' ');
                      CodeDecla (t^.Array.ElemType, Before);
                      WriteS (f, 'A['); CodeValue (Upb); WriteS (f, ' + 1]');
                      CodeDecla (t^.Array.ElemType, After); WriteC (f, ';'); WriteNl (f);
DEC (Indent, 4);WriteSpaces (f, Indent);              WriteC (f, '}');
                ELSE
                  WriteS (f, 'struct ');WriteIdent (f, t^.Array.Type2^.Array1.StructId);
                END;
;
      RETURN;
   END (* LOOP *) ;
    END (* WITH yyTempo.yyR ... *) ;

(* line 1488 "" *)
    WITH yyTempo.yyR3 DO   LOOP
      IF (t^.Kind # Tree.Array) THEN EXIT; END;
(* line 1489 "" *)
      ;
(* line 1490 "" *)
      
                IF Full THEN
                  GetLwb (t^.Array.IndexType^.SimpleType.Type2, Lwb);
                  GetUpb (t^.Array.IndexType^.SimpleType.Type2, Upb);

                  WriteS (f, 'struct ');WriteIdent (f, t^.Array.Type2^.Array1.StructId);WriteS (f, ' {'); WriteNl (f);
INC (Indent, 4);WriteSpaces (f, Indent);                  CodeType (t^.Array.ElemType, Full); WriteC (f, ' ');
                      CodeDecla (t^.Array.ElemType, Before);
                      WriteS (f, 'A[');WriteI (f, ValueToInt (Upb) - ValueToInt (Lwb) + 1, 1);WriteC (f, ']');
                      CodeDecla (t^.Array.ElemType, After); WriteC (f, ';'); WriteNl (f);
DEC (Indent, 4);WriteSpaces (f, Indent);              WriteC (f, '}');
                ELSE
                  WriteS (f, 'struct ');WriteIdent (f, t^.Array.Type2^.Array1.StructId);
                END;
;
      RETURN;
   END (* LOOP *) ;
    END (* WITH yyTempo.yyR ... *) ;

(* line 1506 "" *)
   LOOP
      IF (t^.Kind # Tree.Record) THEN EXIT; END;
      IF (t^.Record.Fields^.Kind # Tree.Fields0) THEN EXIT; END;
(* line 1509 "" *)
      
                IF Full THEN
                  WriteS (f, 'struct ');WriteIdent (f, t^.Record.Type2^.Record1.StructId);WriteS (f, ' {'); WriteNl (f);
INC (Indent, 4);WriteSpaces (f, Indent);                  WriteS (f, 'char dummy;'); WriteNl (f);
DEC (Indent, 4);WriteSpaces (f, Indent);              WriteC (f, '}');
                ELSE
                  WriteS (f, 'struct ');WriteIdent (f, t^.Record.Type2^.Record1.StructId);
                END;
;
      RETURN;
   END (* LOOP *) ;

(* line 1519 "" *)
   LOOP
      IF (t^.Kind # Tree.Record) THEN EXIT; END;
      IF NOT Tree.IsType (t^.Record.Fields, Tree.Fields1) THEN EXIT; END;
(* line 1520 "" *)
      
                IF Full THEN
                WriteS (f, 'struct ');WriteIdent (f, t^.Record.Type2^.Record1.StructId);WriteS (f, ' {'); WriteNl (f);
INC (Indent, 4);                 CodeType (t^.Record.Fields, Full);
DEC (Indent, 4);WriteSpaces (f, Indent);            WriteC (f, '}');
                ELSE
                  WriteS (f, 'struct ');WriteIdent (f, t^.Record.Type2^.Record1.StructId);
                END;
;
      RETURN;
   END (* LOOP *) ;

(* line 1530 "" *)
   LOOP
      IF (t^.Kind # Tree.SetType) THEN EXIT; END;
(* line 1531 "" *)
      WriteS (f, 'unsigned long');
      RETURN;
   END (* LOOP *) ;

(* line 1533 "" *)
   LOOP
      IF (t^.Kind # Tree.Pointer) THEN EXIT; END;
      IF (t^.Pointer.TargetType^.Kind # Tree.TypeId0) THEN EXIT; END;
(* line 1534 "" *)
      IF NOT ((IsForward (t ^ . Pointer . TypePos, t^.Pointer.TargetType ^ . TypeId0 . Object))) THEN EXIT; END;
(* line 1535 "" *)
      
                CASE t^.Pointer.TargetType^.TypeId0.Type2^.Kind OF
                | Record1       : WriteS (f, 'struct ');WriteIdent (f, t^.Pointer.TargetType^.TypeId0.Type2^.Record1.StructId);
                | Array1        : WriteS (f, 'struct ');WriteIdent (f, t^.Pointer.TargetType^.TypeId0.Type2^.Array1.StructId);
                ELSE
                  WriteIdent (f, t^.Pointer.TargetType^.TypeId0.Object^.Object.CIdent);
                  ErrorMessageP (StructTypeReq, Restriction, t^.Pointer.TargetType^.TypeId0.Pos);
                END;
;
      RETURN;
   END (* LOOP *) ;

(* line 1545 "" *)
   LOOP
      IF (t^.Kind # Tree.Pointer) THEN EXIT; END;
(* line 1546 "" *)
      CodeType (t^.Pointer.TargetType, Full);
      RETURN;
   END (* LOOP *) ;

(* line 1548 "" *)
   LOOP
      IF (t^.Kind # Tree.ProcType) THEN EXIT; END;
(* line 1549 "" *)
      CodeType (t^.ProcType.ResultType, Full);
      RETURN;
   END (* LOOP *) ;

(* line 1551 "" *)
   LOOP
      IF (t^.Kind # Tree.Enumeration) THEN EXIT; END;
(* line 1552 "" *)
      
                IF TypeSize (t^.Enumeration.Type2) = SizeUnsignedChar THEN
                  WriteS (f, 'unsigned char');
                ELSE
                  WriteS (f, 'unsigned short');
                END;
;
      RETURN;
   END (* LOOP *) ;

(* line 1560 "" *)
   LOOP
      IF (t^.Kind # Tree.Subrange) THEN EXIT; END;
      IF (t^.Subrange.BaseType^.Kind # Tree.Void) THEN EXIT; END;
(* line 1561 "" *)
      CodeTypeName (t ^ . Subrange . Type2 ^ . Subrange1 . Type);
      RETURN;
   END (* LOOP *) ;

(* line 1563 "" *)
   LOOP
      IF (t^.Kind # Tree.Subrange) THEN EXIT; END;
      IF NOT Tree.IsType (t^.Subrange.BaseType, Tree.TypeId) THEN EXIT; END;
(* line 1564 "" *)
      WriteIdent (f, t^.Subrange.BaseType ^ . TypeId . Object ^ . Object . CIdent);
      RETURN;
   END (* LOOP *) ;

(* line 1566 "" *)
   LOOP
      IF (t^.Kind # Tree.Void) THEN EXIT; END;
(* line 1567 "" *)
      WriteS (f, 'void');
      RETURN;
   END (* LOOP *) ;

(* line 1569 "" *)
   LOOP
      IF NOT Tree.IsType (t, Tree.TypeId) THEN EXIT; END;
(* line 1570 "" *)
      WriteIdent (f, t ^ . TypeId . Object ^ . Object . CIdent);
      RETURN;
   END (* LOOP *) ;

(* line 1572 "" *)
   LOOP
      IF (t^.Kind # Tree.RecordSect) THEN EXIT; END;
(* line 1573 "" *)
      WriteSpaces (f, Indent);
(* line 1573 "" *)
      CodeType (t^.RecordSect.Type, Full);
(* line 1573 "" *)
      WriteC (f, ' ');
(* line 1573 "" *)
      CodeIds (t^.RecordSect.FieldIds, t^.RecordSect.Type);
(* line 1573 "" *)
      WriteC (f, ';');
(* line 1573 "" *)
      WriteNl (f);
(* line 1574 "" *)
      CodeType (t^.RecordSect.Next, Full);
      RETURN;
   END (* LOOP *) ;

(* line 1576 "" *)
   LOOP
      IF (t^.Kind # Tree.VariantSect) THEN EXIT; END;
      IF (t^.VariantSect.Variants^.Kind # Tree.Variants0) THEN EXIT; END;
      IF (t^.VariantSect.Else^.Kind # Tree.Fields0) THEN EXIT; END;
(* line 1579 "" *)
      CodeType (t^.VariantSect.TagField, Full);
(* line 1580 "" *)
      WriteSpaces (f, Indent);
(* line 1580 "" *)
      WriteS (f, 'union {');
(* line 1580 "" *)
      WriteNl (f);
(* line 1581 "" *)
      INC (Indent, 4);
(* line 1581 "" *)
      WriteSpaces (f, Indent);
(* line 1581 "" *)
      WriteS (f, 'char dummy;');
(* line 1581 "" *)
      WriteNl (f);
(* line 1582 "" *)
      DEC (Indent, 4);
(* line 1582 "" *)
      WriteSpaces (f, Indent);
(* line 1582 "" *)
      WriteS (f, '} ');
(* line 1582 "" *)
      WriteIdent (f, t ^ . VariantSect . UnionId);
(* line 1582 "" *)
      WriteC (f, ';');
(* line 1582 "" *)
      WriteNl (f);
(* line 1583 "" *)
      CodeType (t^.VariantSect.Next, Full);
      RETURN;
   END (* LOOP *) ;

(* line 1585 "" *)
   LOOP
      IF (t^.Kind # Tree.VariantSect) THEN EXIT; END;
      IF (t^.VariantSect.Else^.Kind # Tree.Fields0) THEN EXIT; END;
(* line 1586 "" *)
      CodeType (t^.VariantSect.TagField, Full);
(* line 1587 "" *)
      WriteSpaces (f, Indent);
(* line 1587 "" *)
      WriteS (f, 'union {');
(* line 1587 "" *)
      WriteNl (f);
(* line 1588 "" *)
      INC (Indent, 4);
(* line 1588 "" *)
      CodeType (t^.VariantSect.Variants, Full);
(* line 1589 "" *)
      DEC (Indent, 4);
(* line 1589 "" *)
      WriteSpaces (f, Indent);
(* line 1589 "" *)
      WriteS (f, '} ');
(* line 1589 "" *)
      WriteIdent (f, t ^ . VariantSect . UnionId);
(* line 1589 "" *)
      WriteC (f, ';');
(* line 1589 "" *)
      WriteNl (f);
(* line 1590 "" *)
      CodeType (t^.VariantSect.Next, Full);
      RETURN;
   END (* LOOP *) ;

(* line 1592 "" *)
   LOOP
      IF (t^.Kind # Tree.VariantSect) THEN EXIT; END;
(* line 1593 "" *)
      CodeType (t^.VariantSect.TagField, Full);
(* line 1594 "" *)
      WriteSpaces (f, Indent);
(* line 1594 "" *)
      WriteS (f, 'union {');
(* line 1594 "" *)
      WriteNl (f);
(* line 1595 "" *)
      INC (Indent, 4);
(* line 1595 "" *)
      CodeType (t^.VariantSect.Variants, Full);
(* line 1596 "" *)
      WriteSpaces (f, Indent);
(* line 1596 "" *)
      WriteS (f, 'struct {');
(* line 1596 "" *)
      WriteNl (f);
(* line 1597 "" *)
      INC (Indent, 4);
(* line 1597 "" *)
      CodeType (t^.VariantSect.Else, Full);
(* line 1598 "" *)
      DEC (Indent, 4);
(* line 1598 "" *)
      WriteSpaces (f, Indent);
(* line 1598 "" *)
      WriteS (f, '} ');
(* line 1598 "" *)
      WriteIdent (f, t ^ . VariantSect . ElseId);
(* line 1598 "" *)
      WriteC (f, ';');
(* line 1598 "" *)
      WriteNl (f);
(* line 1599 "" *)
      DEC (Indent, 4);
(* line 1599 "" *)
      WriteSpaces (f, Indent);
(* line 1599 "" *)
      WriteS (f, '} ');
(* line 1599 "" *)
      WriteIdent (f, t ^ . VariantSect . UnionId);
(* line 1599 "" *)
      WriteC (f, ';');
(* line 1599 "" *)
      WriteNl (f);
(* line 1600 "" *)
      CodeType (t^.VariantSect.Next, Full);
      RETURN;
   END (* LOOP *) ;

(* line 1602 "" *)
   LOOP
      IF (t^.Kind # Tree.TagField1) THEN EXIT; END;
(* line 1603 "" *)
      WriteSpaces (f, Indent);
(* line 1603 "" *)
      WriteIdent (f, t^.TagField1.Type ^ . TypeId . Object ^ . Object . CIdent);
(* line 1603 "" *)
      WriteC (f, ' ');
(* line 1603 "" *)
      WriteIdent (f, t ^ . TagField1 . CIdent);
(* line 1603 "" *)
      WriteC (f, ';');
(* line 1603 "" *)
      WriteNl (f);
      RETURN;
   END (* LOOP *) ;

(* line 1605 "" *)
   LOOP
      IF (t^.Kind # Tree.Variant) THEN EXIT; END;
      IF (t^.Variant.Variant^.Kind # Tree.Fields0) THEN EXIT; END;
(* line 1608 "" *)
      WriteSpaces (f, Indent);
(* line 1608 "" *)
      WriteS (f, 'struct {');
(* line 1608 "" *)
      WriteNl (f);
(* line 1609 "" *)
      INC (Indent, 4);
(* line 1609 "" *)
      WriteSpaces (f, Indent);
(* line 1609 "" *)
      WriteS (f, 'char dummy;');
(* line 1609 "" *)
      WriteNl (f);
(* line 1610 "" *)
      DEC (Indent, 4);
(* line 1610 "" *)
      WriteSpaces (f, Indent);
(* line 1610 "" *)
      WriteS (f, '} ');
(* line 1610 "" *)
      WriteIdent (f, t ^ . Variant . StructId);
(* line 1610 "" *)
      WriteC (f, ';');
(* line 1610 "" *)
      WriteNl (f);
(* line 1611 "" *)
      CodeType (t^.Variant.Next, Full);
      RETURN;
   END (* LOOP *) ;

(* line 1613 "" *)
   LOOP
      IF (t^.Kind # Tree.Variant) THEN EXIT; END;
      IF NOT Tree.IsType (t^.Variant.Variant, Tree.Fields1) THEN EXIT; END;
(* line 1614 "" *)
      WriteSpaces (f, Indent);
(* line 1614 "" *)
      WriteS (f, 'struct {');
(* line 1614 "" *)
      WriteNl (f);
(* line 1615 "" *)
      INC (Indent, 4);
(* line 1615 "" *)
      CodeType (t^.Variant.Variant, Full);
(* line 1616 "" *)
      DEC (Indent, 4);
(* line 1616 "" *)
      WriteSpaces (f, Indent);
(* line 1616 "" *)
      WriteS (f, '} ');
(* line 1616 "" *)
      WriteIdent (f, t ^ . Variant . StructId);
(* line 1616 "" *)
      WriteC (f, ';');
(* line 1616 "" *)
      WriteNl (f);
(* line 1617 "" *)
      CodeType (t^.Variant.Next, Full);
      RETURN;
   END (* LOOP *) ;

 END CodeType;

PROCEDURE CodeDecla (yyP3: Tree.tTree; Before: BOOLEAN);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
(* line 1626 "" *)
   LOOP
      IF (yyP3^.Kind # Tree.Pointer) THEN EXIT; END;
(* line 1627 "" *)
      CodeDecla (yyP3^.Pointer.TargetType, Before);
(* line 1628 "" *)
      
                IF Before THEN WriteC (f, '*'); END;
;
      RETURN;
   END (* LOOP *) ;

(* line 1632 "" *)
   LOOP
      IF (yyP3^.Kind # Tree.ProcType) THEN EXIT; END;
(* line 1633 "" *)
      
                IF Before THEN WriteS (f, '(*'); ELSE WriteS (f, ') ARGS(('); CodeFormals4 (yyP3^.ProcType.FormalTypes); WriteS (f, '))'); END;
;
      RETURN;
   END (* LOOP *) ;

 END CodeDecla;

PROCEDURE CodeStruct (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
(* line 1644 "" *)
   LOOP
      IF (t^.Kind # Tree.Array) THEN EXIT; END;
(* line 1645 "" *)
      CodeType (t, Full);
(* line 1645 "" *)
      WriteC (f, ';');
(* line 1645 "" *)
      WriteNl (f);
      RETURN;
   END (* LOOP *) ;

(* line 1647 "" *)
   LOOP
      IF (t^.Kind # Tree.Record) THEN EXIT; END;
(* line 1648 "" *)
      CodeType (t, Full);
(* line 1648 "" *)
      WriteC (f, ';');
(* line 1648 "" *)
      WriteNl (f);
      RETURN;
   END (* LOOP *) ;

(* line 1650 "" *)
   LOOP
      IF (t^.Kind # Tree.Pointer) THEN EXIT; END;
(* line 1651 "" *)
      CodeStruct (t^.Pointer.TargetType);
      RETURN;
   END (* LOOP *) ;

 END CodeStruct;

PROCEDURE CodeEnums (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
(* line 1659 "" *)
   LOOP
      IF (t^.Kind # Tree.Array) THEN EXIT; END;
(* line 1660 "" *)
      CodeEnums (t^.Array.IndexType);
(* line 1661 "" *)
      CodeEnums (t^.Array.ElemType);
      RETURN;
   END (* LOOP *) ;

(* line 1663 "" *)
   LOOP
      IF (t^.Kind # Tree.Record) THEN EXIT; END;
(* line 1664 "" *)
      CodeEnums (t^.Record.Fields);
      RETURN;
   END (* LOOP *) ;

(* line 1666 "" *)
   LOOP
      IF (t^.Kind # Tree.SetType) THEN EXIT; END;
(* line 1667 "" *)
      CodeEnums (t^.SetType.BaseType);
      RETURN;
   END (* LOOP *) ;

(* line 1669 "" *)
   LOOP
      IF (t^.Kind # Tree.Pointer) THEN EXIT; END;
(* line 1670 "" *)
      CodeEnums (t^.Pointer.TargetType);
      RETURN;
   END (* LOOP *) ;

(* line 1672 "" *)
   LOOP
      IF (t^.Kind # Tree.Enumeration) THEN EXIT; END;
(* line 1673 "" *)
      CodeEnums (t^.Enumeration.EnumIds);
      RETURN;
   END (* LOOP *) ;

(* line 1675 "" *)
   LOOP
      IF (t^.Kind # Tree.RecordSect) THEN EXIT; END;
(* line 1676 "" *)
      CodeEnums (t^.RecordSect.Type);
      RETURN;
   END (* LOOP *) ;

(* line 1678 "" *)
   LOOP
      IF (t^.Kind # Tree.VariantSect) THEN EXIT; END;
(* line 1679 "" *)
      CodeEnums (t^.VariantSect.Variants);
(* line 1680 "" *)
      CodeEnums (t^.VariantSect.Else);
(* line 1681 "" *)
      CodeEnums (t^.VariantSect.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1683 "" *)
   LOOP
      IF (t^.Kind # Tree.Variant) THEN EXIT; END;
(* line 1684 "" *)
      CodeEnums (t^.Variant.Variant);
(* line 1685 "" *)
      CodeEnums (t^.Variant.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1687 "" *)
   LOOP
      IF (t^.Kind # Tree.EnumIds1) THEN EXIT; END;
(* line 1688 "" *)
      WriteS (f, '#define ');
(* line 1688 "" *)
      WriteIdent (f, t ^ . EnumIds1 . CIdent);
(* line 1688 "" *)
      WriteS (f, '        ');
(* line 1689 "" *)
      WriteI (f, t ^ . EnumIds1 . Object ^ . EnumLiteral1 . Index, 1);
(* line 1689 "" *)
      WriteNl (f);
(* line 1690 "" *)
      CodeEnums (t^.EnumIds1.Next);
      RETURN;
   END (* LOOP *) ;

 END CodeEnums;

PROCEDURE CodeIds (t: Tree.tTree; Type: tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
(* line 1700 "" *)
   LOOP
      IF (t^.Kind # Tree.VarIds1) THEN EXIT; END;
(* line 1701 "" *)
      CodeDecla (Type, Before);
(* line 1701 "" *)
      WriteIdent (f, t ^ . VarIds1 . CIdent);
(* line 1701 "" *)
      CodeDecla (Type, After);
(* line 1702 "" *)
      CodeSepa (t^.VarIds1.Next);
(* line 1703 "" *)
      CodeIds (t^.VarIds1.Next, Type);
      RETURN;
   END (* LOOP *) ;

(* line 1705 "" *)
   LOOP
      IF (t^.Kind # Tree.FieldIds1) THEN EXIT; END;
(* line 1706 "" *)
      CodeDecla (Type, Before);
(* line 1706 "" *)
      WriteIdent (f, t ^ . FieldIds1 . CIdent);
(* line 1706 "" *)
      CodeDecla (Type, After);
(* line 1707 "" *)
      CodeSepa (t^.FieldIds1.Next);
(* line 1708 "" *)
      CodeIds (t^.FieldIds1.Next, Type);
      RETURN;
   END (* LOOP *) ;

 END CodeIds;

PROCEDURE CodeProcs (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 1: yyR1: RECORD
  NewLine: BOOLEAN;
  END;
 END; END;
 BEGIN
(* line 1717 "" *)
    WITH yyTempo.yyR1 DO   LOOP
      IF (t^.Kind # Tree.Proc) THEN EXIT; END;
(* line 1718 "" *)
      ;
(* line 1719 "" *)
      
                CodeProcs (t^.Proc.Decls);

                GenParams (t^.Proc.VAROpens);
                GenParams (t^.Proc.ValueOpens);
                GenLocalPtrs (t^.Proc.LocalPtrs);

                VAROpens        := t^.Proc.VAROpens;
                ValueOpens      := t^.Proc.ValueOpens;
                LocalPtrs       := t^.Proc.LocalPtrs;

                IF NOT IsExported (t^.Proc.Object) THEN WriteS (f, 'static '); END;
                CodeType (t^.Proc.ResultType, Full); WriteC (f, ' ');WriteIdent (f, t^.Proc.CIdent);WriteNl (f);
                WriteS (f, '# ifdef __STDC__'); WriteNl (f);
                WriteC (f, '('); CodeFormals3 (t^.Proc.Formals, NoIdent); WriteC (f, ')'); WriteNl (f);
                WriteS (f, '# else'); WriteNl (f);
                WriteC (f, '('); CodeFormals1 (t^.Proc.Formals); WriteC (f, ')'); WriteNl (f);
                CodeFormals2 (t^.Proc.Formals, NoIdent);
                WriteS (f, '# endif'); WriteNl (f);
                WriteC (f, '{'); WriteNl (f);
                  NewLine := (t^.Proc.ValueOpens # NoCObjects) OR
                             (t^.Proc.LocalPtrs  # NoCObjects) OR
                             (t^.Proc.Strings    # NoStrings );
INC (Indent, 2);                CodeDecls2 (t^.Proc.Decls, NewLine);
                  IF t^.Proc.ValueOpens # NoCObjects THEN
WriteSpaces (f, Indent);                   WriteS (f, 'OPEN_ARRAY_LOCALS'); WriteNl (f);
                  END;
                  CodePointers (Auto, t^.Proc.LocalPtrs);
                  CodeStrings (t^.Proc.Strings);
                  IF NewLine THEN WriteNl (f); END;

                  CodeAlloc   (t^.Proc.ValueOpens);
                  CodeCopy    (t^.Proc.ValueOpens);
                  CodePush    (t^.Proc.LocalPtrs);
                  CodeStrncpy (t^.Proc.Strings);
                  CodeInits   (t^.Proc.Decls);

                  CodeStmts (t^.Proc.Stmts);

                  IF GetResultType (GetType (t^.Proc.Object)) = TypeVOID THEN
                    CodePop (t^.Proc.LocalPtrs);
                    CodeFree (t^.Proc.ValueOpens);
                  ELSE
                    
                    
                    
                    
                    
                    IF OptionIsSet ('r') THEN
WriteSpaces (f, Indent);                     WriteS (f, 'ReturnError(__FILE__, __LINE__);'); WriteNl (f);
                    END;
                  END;

DEC (Indent, 2);              WriteC (f, '}'); WriteNl (f);
                WriteNl (f);

                VAROpens        := NoCObjects;
                ValueOpens      := NoCObjects;
                LocalPtrs       := NoCObjects;
;
(* line 1779 "" *)
      CodeProcs (t^.Proc.Next);
      RETURN;
   END (* LOOP *) ;
    END (* WITH yyTempo.yyR ... *) ;

(* line 1781 "" *)
   LOOP
      IF (t^.Kind # Tree.Module) THEN EXIT; END;
(* line 1782 "" *)
      CodeProcs (t^.Module.Decls);
(* line 1783 "" *)
      
                WriteS (f, 'static void ');WriteIdent (f, t^.Module.CIdent);WriteS (f, '()'); WriteNl (f);
                WriteC (f, '{'); WriteNl (f);
INC (Indent, 2);                CodeStrings (t^.Module.Strings);
                  IF t^.Module.Strings # NoStrings THEN WriteNl (f); END;

                  CodeStrncpy (t^.Module.Strings);
                  CodeStmts (t^.Module.Stmts);
DEC (Indent, 2);              WriteC (f, '}'); WriteNl (f);
                WriteNl (f);
;
(* line 1794 "" *)
      CodeProcs (t^.Module.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1796 "" *)
   LOOP
      IF NOT Tree.IsType (t, Tree.Decl) THEN EXIT; END;
(* line 1797 "" *)
      CodeProcs (t^.Decl.Next);
      RETURN;
   END (* LOOP *) ;

 END CodeProcs;

PROCEDURE CodeFormals1 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
(* line 1806 "" *)
   LOOP
      IF (t^.Kind # Tree.Formals1) THEN EXIT; END;
(* line 1807 "" *)
      CodeFormals1 (t^.Formals1.ParIds);
(* line 1807 "" *)
      CodeSepa (t^.Formals1.Next);
(* line 1808 "" *)
      CodeFormals1 (t^.Formals1.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1810 "" *)
   LOOP
      IF (t^.Kind # Tree.ParIds1) THEN EXIT; END;
(* line 1811 "" *)
      IF NOT ((IsOpenArray (t ^ . ParIds1 . Object))) THEN EXIT; END;
(* line 1812 "" *)
      WriteIdent (f, t ^ . ParIds1 . CIdent);
(* line 1812 "" *)
      WriteS (f, ', ');
(* line 1813 "" *)
      WriteIdent (f, GetParam (t ^ . ParIds1 . Object));
(* line 1814 "" *)
      CodeSepa (t^.ParIds1.Next);
(* line 1815 "" *)
      CodeFormals1 (t^.ParIds1.Next);
      RETURN;
   END (* LOOP *) ;

(* line 1817 "" *)
   LOOP
      IF (t^.Kind # Tree.ParIds1) THEN EXIT; END;
(* line 1818 "" *)
      WriteIdent (f, t ^ . ParIds1 . CIdent);
(* line 1818 "" *)
      CodeSepa (t^.ParIds1.Next);
(* line 1819 "" *)
      CodeFormals1 (t^.ParIds1.Next);
      RETURN;
   END (* LOOP *) ;

 END CodeFormals1;

PROCEDURE CodeFormals2 (t: Tree.tTree; ElemTypeId: tIdent);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
(* line 1830 "" *)
   LOOP
      IF (t^.Kind # Tree.Formals1) THEN EXIT; END;
      IF NOT Tree.IsType (t^.Formals1.Type, Tree.TypeId) THEN EXIT; END;
(* line 1831 "" *)
      WriteIdent (f, t^.Formals1.Type ^ . TypeId . Object ^ . Object . CIdent);
(* line 1831 "" *)
      WriteC (f, ' ');
(* line 1831 "" *)
      CodeFormals2 (t^.Formals1.ParIds, NoIdent);
(* line 1831 "" *)
      WriteC (f, ';');
(* line 1831 "" *)
      WriteNl (f);
(* line 1832 "" *)
      CodeFormals2 (t^.Formals1.Next, NoIdent);
      RETURN;
   END (* LOOP *) ;

(* line 1834 "" *)
   LOOP
      IF (t^.Kind # Tree.Formals1) THEN EXIT; END;
      IF (t^.Formals1.Type^.Kind # Tree.Array) THEN EXIT; END;
      IF NOT ( t^.Formals1.Type^.Array.IsOpen  =   TRUE  ) THEN EXIT; END;
      IF NOT Tree.IsType (t^.Formals1.Type^.Array.ElemType, Tree.TypeId) THEN EXIT; END;
(* line 1835 "" *)
      CodeFormals2 (t^.Formals1.ParIds, t^.Formals1.Type^.Array.ElemType ^ . TypeId . Object ^ . Object . CIdent);
(* line 1836 "" *)
      CodeFormals2 (t^.Formals1.Next, NoIdent);
      RETURN;
   END (* LOOP *) ;

(* line 1838 "" *)
   LOOP
      IF (t^.Kind # Tree.ParIds1) THEN EXIT; END;
(* line 1839 "" *)
      IF NOT ((IsOpenArray (t ^ . ParIds1 . Object))) THEN EXIT; END;
(* line 1840 "" *)
      WriteIdent (f, ElemTypeId);
(* line 1840 "" *)
      WriteC (f, ' ');
(* line 1840 "" *)
      WriteIdent (f, t ^ . ParIds1 . CIdent);
(* line 1840 "" *)
      WriteS (f, '[];');
(* line 1840 "" *)
      WriteNl (f);
(* line 1841 "" *)
      WriteS (f, 'LONGCARD ');
(* line 1841 "" *)
      WriteIdent (f, GetParam (t ^ . ParIds1 . Object));
(* line 1841 "" *)
      WriteC (f, ';');
(* line 1841 "" *)
      WriteNl (f);
(* line 1842 "" *)
      CodeFormals2 (t^.ParIds1.Next, ElemTypeId);
      RETURN;
   END (* LOOP *) ;

(* line 1844 "" *)
   LOOP
      IF (t^.Kind # Tree.ParIds1) THEN EXIT; END;
(* line 1845 "" *)
       IF IsVAR (t^.ParIds1.Object) THEN WriteC (f, '*'); END; ;
(* line 1846 "" *)
      WriteIdent (f, t ^ . ParIds1 . CIdent);
(* line 1846 "" *)
      CodeSepa (t^.ParIds1.Next);
(* line 1847 "" *)
      CodeFormals2 (t^.ParIds1.Next, NoIdent);
      RETURN;
   END (* LOOP *) ;

 END CodeFormals2;

PROCEDURE CodeFormals3 (t: Tree.tTree; TypeId: tIdent);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
(* line 1858 "" *)
   LOOP
      IF (t^.Kind # Tree.Formals1) THEN EXIT; END;
      IF NOT Tree.IsType (t^.Formals1.Type, Tree.TypeId) THEN EXIT; END;
(* line 1860 "" *)
      CodeFormals3 (t^.Formals1.ParIds, t^.Formals1.Type ^ . TypeId . Object ^ . Object . CIdent);
(* line 1861 "" *)
      CodeSepa (t^.Formals1.Next);
(* line 1862 "" *)
      CodeFormals3 (t^.Formals1.Next, NoIdent);
      RETURN;
   END (* LOOP *) ;

(* line 1858 "" *)
   LOOP
      IF (t^.Kind # Tree.Formals1) THEN EXIT; END;
      IF (t^.Formals1.Type^.Kind # Tree.Array) THEN EXIT; END;
      IF NOT ( t^.Formals1.Type^.Array.IsOpen  =   TRUE  ) THEN EXIT; END;
      IF NOT Tree.IsType (t^.Formals1.Type^.Array.ElemType, Tree.TypeId) THEN EXIT; END;
(* line 1860 "" *)
      CodeFormals3 (t^.Formals1.ParIds, t^.Formals1.Type^.Array.ElemType ^ . TypeId . Object ^ . Object . CIdent);
(* line 1861 "" *)
      CodeSepa (t^.Formals1.Next);
(* line 1862 "" *)
      CodeFormals3 (t^.Formals1.Next, NoIdent);
      RETURN;
   END (* LOOP *) ;

(* line 1864 "" *)
   LOOP
      IF (t^.Kind # Tree.ParIds1) THEN EXIT; END;
(* line 1865 "" *)
      IF NOT ((IsOpenArray (t ^ . ParIds1 . Object))) THEN EXIT; END;
(* line 1866 "" *)
      WriteIdent (f, TypeId);
(* line 1866 "" *)
      WriteC (f, ' ');
(* line 1866 "" *)
      WriteIdent (f, t ^ . ParIds1 . CIdent);
(* line 1866 "" *)
      WriteS (f, '[], ');
(* line 1867 "" *)
      WriteS (f, 'LONGCARD ');
(* line 1867 "" *)
      WriteIdent (f, GetParam (t ^ . ParIds1 . Object));
(* line 1867 "" *)
      CodeSepa (t^.ParIds1.Next);
(* line 1868 "" *)
      CodeFormals3 (t^.ParIds1.Next, TypeId);
      RETURN;
   END (* LOOP *) ;

(* line 1870 "" *)
   LOOP
      IF (t^.Kind # Tree.ParIds1) THEN EXIT; END;
(* line 1871 "" *)
      WriteIdent (f, TypeId);
(* line 1871 "" *)
       IF IsVAR (t^.ParIds1.Object) THEN WriteS (f, ' *'); ELSE WriteC (f, ' '); END; ;
(* line 1872 "" *)
      WriteIdent (f, t ^ . ParIds1 . CIdent);
(* line 1872 "" *)
      CodeSepa (t^.ParIds1.Next);
(* line 1873 "" *)
      CodeFormals3 (t^.ParIds1.Next, TypeId);
      RETURN;
   END (* LOOP *) ;

 END CodeFormals3;

PROCEDURE CodeFormals4 (yyP4: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
(* line 1881 "" *)
   LOOP
      IF (yyP4^.Kind # Tree.FormalType) THEN EXIT; END;
(* line 1882 "" *)
      CodeType (yyP4^.FormalType.Type, Full);
(* line 1883 "" *)
       IF yyP4^.FormalType.IsVAR THEN WriteS (f, ' *'); END; ;
(* line 1884 "" *)
      CodeSepa (yyP4^.FormalType.Next);
(* line 1885 "" *)
      CodeFormals4 (yyP4^.FormalType.Next);
      RETURN;
   END (* LOOP *) ;

 END CodeFormals4;

PROCEDURE CodeDecls2 (yyP5: Tree.tTree; VAR NewLine: BOOLEAN);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
(* line 1896 "" *)
   LOOP
      IF (yyP5^.Kind # Tree.Var) THEN EXIT; END;
(* line 1897 "" *)
      WriteSpaces (f, Indent);
(* line 1897 "" *)
      CodeType (yyP5^.Var.Type, NonFull);
(* line 1897 "" *)
      WriteC (f, ' ');
(* line 1897 "" *)
      CodeIds (yyP5^.Var.VarIds, yyP5^.Var.Type);
(* line 1897 "" *)
      WriteC (f, ';');
(* line 1897 "" *)
      WriteNl (f);
(* line 1898 "" *)
      NewLine := TRUE;
(* line 1899 "" *)
       CodeDecls2 (yyP5^.Var.Next, NewLine); ;
       
      RETURN;
   END (* LOOP *) ;

(* line 1901 "" *)
   LOOP
      IF (yyP5^.Kind # Tree.Module) THEN EXIT; END;
(* line 1902 "" *)
       CodeDecls2 (yyP5^.Module.Decls, NewLine); ;
(* line 1903 "" *)
       CodeDecls2 (yyP5^.Module.Next, NewLine); ;
       
      RETURN;
   END (* LOOP *) ;

(* line 1905 "" *)
   LOOP
      IF NOT Tree.IsType (yyP5, Tree.Decl) THEN EXIT; END;
(* line 1906 "" *)
       CodeDecls2 (yyP5^.Decl.Next, NewLine); ;
       
      RETURN;
   END (* LOOP *) ;

 END CodeDecls2;

PROCEDURE CodeExpr (t: Tree.tTree; Prec: SHORTCARD);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 10: yyR10: RECORD
  String: tString;
  END;
 | 30: yyR30: RECORD
  Lwb: tValue;
  END;
 | 31: yyR31: RECORD
  Lwb: tValue;
  END;
 | 32: yyR32: RECORD
  Lwb: tValue;
  END;
 | 33: yyR33: RECORD
  Lwb: tValue;
  END;
 | 34: yyR34: RECORD
  Object: tObject;
  END;
 | 37: yyR37: RECORD
  Object: tObject;
  END;
 END; END;
 BEGIN
(* line 1919 "" *)
   LOOP
      IF (t^.Kind # Tree.Binary) THEN EXIT; END;
(* line 1920 "" *)
      IF NOT (t ^ . Binary . COperator IN {cIn, cDifference, cIsSubset1, cIsSubset2}) THEN EXIT; END;
(* line 1921 "" *)
      
                CASE t^.Binary.COperator OF
                | cIn           : WriteS (f, 'IN');
                | cDifference   : WriteS (f, 'SET_DIFF');
                | cIsSubset1    : WriteS (f, 'SET_IS_SUBSET1');
                | cIsSubset2    : WriteS (f, 'SET_IS_SUBSET2');
                END;
;
(* line 1929 "" *)
      WriteC (f, '(');
(* line 1929 "" *)
      CodeExpr (t^.Binary.Lop, pPassValue);
(* line 1929 "" *)
      WriteS (f, ', ');
(* line 1929 "" *)
      CodeExpr (t^.Binary.Rop, pPassValue);
(* line 1929 "" *)
      WriteC (f, ')');
      RETURN;
   END (* LOOP *) ;

(* line 1931 "" *)
   LOOP
      IF (t^.Kind # Tree.Binary) THEN EXIT; END;
(* line 1933 "" *)
      IF NOT ((t ^ . Binary . COperator IN {cPlus, cMinus}) AND (t^.Binary.Lop ^ . Expr . Type = TypeADDRESS) AND (t^.Binary.Rop ^ . Expr . Type = TypeADDRESS)) THEN EXIT; END;
(* line 1934 "" *)
      
                IF Prec <= Precedence [t^.Binary.COperator] THEN WriteC (f, '('); END;
                CodeExpr (t^.Binary.Lop, Precedence [t^.Binary.COperator] + 1);
                IF t^.Binary.COperator = cPlus THEN WriteS (f, ' + '); ELSE WriteS (f, ' - '); END;
                WriteS (f, '(LONGCARD)'); CodeExpr (t^.Binary.Rop, pCast);
                IF Prec <= Precedence [t^.Binary.COperator] THEN WriteC (f, ')'); END;
;
      RETURN;
   END (* LOOP *) ;

(* line 1942 "" *)
   LOOP
      IF (t^.Kind # Tree.Binary) THEN EXIT; END;
(* line 1944 "" *)
      IF NOT ((t ^ . Binary . COperator = cMinus) AND NOT (t^.Binary.Lop ^ . Expr . Type = TypeADDRESS) AND (t^.Binary.Rop ^ . Expr . Type = TypeADDRESS)) THEN EXIT; END;
(* line 1945 "" *)
      
                IF Prec < pCast THEN WriteC (f, '('); END;
                WriteS (f, '(ADDRESS)('); CodeExpr (t^.Binary.Lop, pMinus + 1); WriteS (f, ' - (LONGCARD)'); CodeExpr (t^.Binary.Rop, pCast); WriteC (f, ')');
                IF Prec < pCast THEN WriteC (f, ')'); END;
;
      RETURN;
   END (* LOOP *) ;

(* line 1951 "" *)
   LOOP
      IF (t^.Kind # Tree.Binary) THEN EXIT; END;
(* line 1952 "" *)
      IF NOT ((t ^ . Binary . COperator IN {cTimes, cDivide}) AND ((t^.Binary.Lop ^ . Expr . Type = TypeADDRESS) OR (t^.Binary.Rop ^ . Expr . Type = TypeADDRESS))) THEN EXIT; END;
(* line 1954 "" *)
      
                IF Prec < pCast THEN WriteC (f, '('); END;
                WriteS (f, '(ADDRESS)(');
                IF t^.Binary.Lop^.Expr.Type = TypeADDRESS THEN
                  WriteS (f, '(LONGCARD)'); CodeExpr (t^.Binary.Lop, pCast);
                ELSE
                  CodeExpr (t^.Binary.Lop, Precedence [t^.Binary.COperator] + 1);
                END;
                IF t^.Binary.COperator = cTimes THEN WriteS (f, ' * '); ELSE WriteS (f, ' / '); END;
                IF t^.Binary.Rop^.Expr.Type = TypeADDRESS THEN
                  WriteS (f, '(LONGCARD)'); CodeExpr (t^.Binary.Rop, pCast);
                ELSE
                  CodeExpr (t^.Binary.Rop, Precedence [t^.Binary.COperator]);
                END;
                WriteC (f, ')');
                IF Prec < pCast THEN WriteC (f, ')'); END;
;
      RETURN;
   END (* LOOP *) ;

(* line 1972 "" *)
   LOOP
      IF (t^.Kind # Tree.Binary) THEN EXIT; END;
(* line 1973 "" *)
      
                IF Prec <= Precedence [t^.Binary.COperator] THEN WriteC (f, '('); END;
                CodeExpr (t^.Binary.Lop, Precedence [t^.Binary.COperator] + 1);
                
                
                
                CASE t^.Binary.COperator OF
                | cNotEqual     : WriteS (f, ' != ');
                | cTimes        : WriteS (f, ' * ');
                | cPlus         : WriteS (f, ' + ');
                | cMinus        : WriteS (f, ' - ');
                | cDivide       : WriteS (f, ' / ');
                | cLess         : WriteS (f, ' < ');
                | cLessEqual    : WriteS (f, ' <= ');
                | cEqual        : WriteS (f, ' == ');
                | cGreater      : WriteS (f, ' > ');
                | cGreaterEqual : WriteS (f, ' >= ');
                | cAnd          : WriteS (f, ' && ');
                | cMod          : WriteS (f, ' % ');
                | cOr           : WriteS (f, ' || ');
                | cUnion        : WriteS (f, ' | ');
                | cIntersection : WriteS (f, ' & ');
                | cSymDiff      : WriteS (f, ' ^ ');
                ELSE
                END;
                CodeExpr (t^.Binary.Rop, Precedence [t^.Binary.COperator]);
                IF Prec <= Precedence [t^.Binary.COperator] THEN WriteC (f, ')'); END;
;
      RETURN;
   END (* LOOP *) ;

(* line 2002 "" *)
   LOOP
      IF (t^.Kind # Tree.Unary) THEN EXIT; END;
      IF (t^.Unary.Mop^.Kind # Tree.IntConst) THEN EXIT; END;
(* line 2003 "" *)
      IF NOT (t ^ . Unary . COperator = cMinus) THEN EXIT; END;
(* line 2004 "" *)
      
                CASE t^.Unary.Mop^.IntConst.Kind OF
                | Decimal       : WriteC (f, '-');WriteCard (f, t^.Unary.Mop^.IntConst.IntVal, 1);
                | Octal         : WriteS (f, '-0');WriteN (f, t^.Unary.Mop^.IntConst.IntVal, 1, 8);
                | Hexadecimal   : WriteS (f, '-0X');WriteN (f, t^.Unary.Mop^.IntConst.IntVal, 1, 16);
                END;
;
      RETURN;
   END (* LOOP *) ;

(* line 2012 "" *)
   LOOP
      IF (t^.Kind # Tree.Unary) THEN EXIT; END;
(* line 2013 "" *)
      
                IF Prec < Precedence [t^.Unary.COperator] THEN WriteC (f, '('); END;
                CASE t^.Unary.COperator OF
                | cMinus        : WriteC (f, '-');
                | cNot          : WriteC (f, '!');
                ELSE
                END;
                CodeExpr (t^.Unary.Mop, Precedence [t^.Unary.COperator]);
                IF Prec < Precedence [t^.Unary.COperator] THEN WriteC (f, ')'); END;
;
      RETURN;
   END (* LOOP *) ;

(* line 2024 "" *)
   LOOP
      IF (t^.Kind # Tree.IntConst) THEN EXIT; END;
(* line 2025 "" *)
      
                IF t^.IntConst.IntVal > MaxLongInt THEN
                  WriteS (f, '(LONGCARD)');
                  ErrorMessageP (OutOfLongRange, Warning, t^.IntConst.Pos);
                END;
                CASE t^.IntConst.Kind OF
                | Decimal       : WriteCard (f, t^.IntConst.IntVal, 1);
                | Octal         : WriteC (f, '0');WriteN (f, t^.IntConst.IntVal, 1, 8);
                | Hexadecimal   : WriteS (f, '0X');WriteN (f, t^.IntConst.IntVal, 1, 16);
                END;
;
      RETURN;
   END (* LOOP *) ;

(* line 2037 "" *)
   LOOP
      IF (t^.Kind # Tree.RealConst) THEN EXIT; END;
(* line 2038 "" *)
      WriteString (f, t^.RealConst.RealVal);
      RETURN;
   END (* LOOP *) ;

(* line 2040 "" *)
    WITH yyTempo.yyR10 DO   LOOP
      IF (t^.Kind # Tree.StringConst) THEN EXIT; END;
(* line 2041 "" *)
      IF NOT (Length (t^.StringConst.StringVal) = 1) THEN EXIT; END;
(* line 2042 "" *)
      ;
(* line 2043 "" *)
      GetString (t^.StringConst.StringVal, String);
(* line 2044 "" *)
      CodeChar (Strings . Char (String, 1));
      RETURN;
   END (* LOOP *) ;
    END (* WITH yyTempo.yyR ... *) ;

(* line 2046 "" *)
   LOOP
      IF (t^.Kind # Tree.StringConst) THEN EXIT; END;
(* line 2047 "" *)
      CodeString1 (t^.StringConst.StringVal);
      RETURN;
   END (* LOOP *) ;

(* line 2049 "" *)
   LOOP
      IF (t^.Kind # Tree.CharConst) THEN EXIT; END;
(* line 2050 "" *)
      CodeChar (t^.CharConst.CharVal);
      RETURN;
   END (* LOOP *) ;

(* line 2052 "" *)
   LOOP
      IF (t^.Kind # Tree.FuncCall) THEN EXIT; END;
(* line 2053 "" *)
      IF NOT (t^.FuncCall.Designator ^ . Designator . Type ^ . Kind = StdProcType1) THEN EXIT; END;
(* line 2054 "" *)
      CodeStdProc (t^.FuncCall.Actuals, t^.FuncCall.Designator ^ . Designator . Type ^ . StdProcType1 . StdProc, NoObject);
      RETURN;
   END (* LOOP *) ;

(* line 2056 "" *)
   LOOP
      IF (t^.Kind # Tree.FuncCall) THEN EXIT; END;
      IF NOT Tree.IsType (t^.FuncCall.Designator, Tree.Qualid) THEN EXIT; END;
(* line 2057 "" *)
      IF NOT ((IsProcedure (t^.FuncCall.Designator ^ . Qualid . Object))) THEN EXIT; END;
(* line 2058 "" *)
      WriteIdent (f, t^.FuncCall.Designator ^ . Qualid . Object ^ . Object . CIdent);
(* line 2058 "" *)
      WriteC (f, '(');
(* line 2058 "" *)
      CodeActuals (t^.FuncCall.Actuals);
(* line 2058 "" *)
      WriteC (f, ')');
      RETURN;
   END (* LOOP *) ;

(* line 2060 "" *)
   LOOP
      IF (t^.Kind # Tree.FuncCall) THEN EXIT; END;
      IF NOT Tree.IsType (t^.FuncCall.Designator, Tree.Qualid) THEN EXIT; END;
      IF (t^.FuncCall.Actuals^.Kind # Tree.Actual) THEN EXIT; END;
      IF (t^.FuncCall.Actuals^.Actual.Next^.Kind # Tree.Actuals0) THEN EXIT; END;
(* line 2061 "" *)
      IF NOT ((IsOfType (t^.FuncCall.Designator ^ . Qualid . Object))) THEN EXIT; END;
(* line 2062 "" *)
      
                IF Prec < pCast THEN
                  WriteS (f, '((');WriteIdent (f, t^.FuncCall.Designator^.Qualid.Object^.Object.CIdent);WriteC (f, ')'); CodeExpr (t^.FuncCall.Actuals^.Actual.Expr, pCast); WriteC (f, ')');
                ELSE
                  WriteC (f, '(');WriteIdent (f, t^.FuncCall.Designator^.Qualid.Object^.Object.CIdent);WriteC (f, ')'); CodeExpr (t^.FuncCall.Actuals^.Actual.Expr, pCast);
                END;
;
      RETURN;
   END (* LOOP *) ;

(* line 2070 "" *)
   LOOP
      IF (t^.Kind # Tree.FuncCall) THEN EXIT; END;
(* line 2071 "" *)
      WriteS (f, '(*');
(* line 2071 "" *)
      CodeExpr (t^.FuncCall.Designator, pDeref);
(* line 2071 "" *)
      WriteC (f, ')');
(* line 2071 "" *)
      WriteC (f, '(');
(* line 2071 "" *)
      CodeActuals (t^.FuncCall.Actuals);
(* line 2071 "" *)
      WriteC (f, ')');
      RETURN;
   END (* LOOP *) ;

(* line 2073 "" *)
   LOOP
      IF (t^.Kind # Tree.Set) THEN EXIT; END;
      IF (t^.Set.Elems^.Kind # Tree.Elems0) THEN EXIT; END;
(* line 2074 "" *)
      WriteS (f, '0X0L');
      RETURN;
   END (* LOOP *) ;

(* line 2076 "" *)
   LOOP
      IF (t^.Kind # Tree.Set) THEN EXIT; END;
      IF NOT Tree.IsType (t^.Set.Elems, Tree.Elems1) THEN EXIT; END;
(* line 2077 "" *)
      
                IF Prec <= pUnion THEN
                  WriteC (f, '('); CodeExpr (t^.Set.Elems, pMinPrec); WriteC (f, ')');
                ELSE
                  CodeExpr (t^.Set.Elems, Prec)
                END;
;
      RETURN;
   END (* LOOP *) ;

(* line 2085 "" *)
   LOOP
      IF (t^.Kind # Tree.BitSet) THEN EXIT; END;
      IF (t^.BitSet.Elems^.Kind # Tree.Elems0) THEN EXIT; END;
(* line 2086 "" *)
      WriteS (f, '0X0L');
      RETURN;
   END (* LOOP *) ;

(* line 2088 "" *)
   LOOP
      IF (t^.Kind # Tree.BitSet) THEN EXIT; END;
      IF NOT Tree.IsType (t^.BitSet.Elems, Tree.Elems1) THEN EXIT; END;
(* line 2089 "" *)
      
                IF Prec <= pUnion THEN
                  WriteC (f, '('); CodeExpr (t^.BitSet.Elems, pMinPrec); WriteC (f, ')');
                ELSE
                  CodeExpr (t^.BitSet.Elems, Prec);
                END;
;
      RETURN;
   END (* LOOP *) ;

(* line 2097 "" *)
   LOOP
      IF (t^.Kind # Tree.Qualid0) THEN EXIT; END;
(* line 2098 "" *)
      IF NOT (t ^ . Qualid0 . IsGlobalPtr AND IsOpen (t ^ . Qualid0 . Type)) THEN EXIT; END;
(* line 2099 "" *)
      WriteIdent (f, GetGlobalPtr (t ^ . Qualid0 . Object));
      RETURN;
   END (* LOOP *) ;

(* line 2101 "" *)
   LOOP
      IF (t^.Kind # Tree.Qualid0) THEN EXIT; END;
(* line 2102 "" *)
      IF NOT (t ^ . Qualid0 . Object ^ . Kind = Field1) THEN EXIT; END;
(* line 2103 "" *)
      WriteIdent (f, WithStack . GetWith (t^.Qualid0.Ident));
(* line 2104 "" *)
      WriteS (f, '->');
(* line 2105 "" *)
      CodeSelectors (t ^ . Qualid0 . Object ^ . Field1 . Selectors);
(* line 2106 "" *)
      WriteIdent (f, t ^ . Qualid0 . Object ^ . Field1 . CIdent);
      RETURN;
   END (* LOOP *) ;

(* line 2108 "" *)
   LOOP
      IF (t^.Kind # Tree.Qualid1) THEN EXIT; END;
(* line 2109 "" *)
      IF NOT (t^.Qualid1.Qualid ^ . Qualid . IsGlobalPtr) THEN EXIT; END;
(* line 2110 "" *)
      WriteIdent (f, GetGlobalPtr (t^.Qualid1.Qualid ^ . Qualid . Object));
(* line 2111 "" *)
      WriteS (f, '->');
(* line 2112 "" *)
      CodeSelectors (GetSelectors (t ^ . Qualid1 . Object));
(* line 2113 "" *)
      WriteIdent (f, t ^ . Qualid1 . Object ^ . Object . CIdent);
      RETURN;
   END (* LOOP *) ;

(* line 2115 "" *)
   LOOP
      IF (t^.Kind # Tree.Qualid1) THEN EXIT; END;
(* line 2116 "" *)
      IF NOT ((IsVAR (t^.Qualid1.Qualid ^ . Qualid . Object))) THEN EXIT; END;
(* line 2117 "" *)
      WriteIdent (f, t^.Qualid1.Qualid ^ . Qualid . Object ^ . Var1 . CIdent);
(* line 2118 "" *)
      WriteS (f, '->');
(* line 2119 "" *)
      CodeSelectors (GetSelectors (t ^ . Qualid1 . Object));
(* line 2120 "" *)
      WriteIdent (f, t ^ . Qualid1 . Object ^ . Object . CIdent);
      RETURN;
   END (* LOOP *) ;

(* line 2122 "" *)
   LOOP
      IF (t^.Kind # Tree.Qualid1) THEN EXIT; END;
(* line 2123 "" *)
      IF NOT (t ^ . Qualid1 . Object ^ . Kind = Field1) THEN EXIT; END;
(* line 2124 "" *)
      CodeExpr (t^.Qualid1.Qualid, pSelect);
(* line 2125 "" *)
      WriteC (f, '.');
(* line 2126 "" *)
      CodeSelectors (t ^ . Qualid1 . Object ^ . Field1 . Selectors);
(* line 2127 "" *)
      WriteIdent (f, t ^ . Qualid1 . Object ^ . Field1 . CIdent);
      RETURN;
   END (* LOOP *) ;

(* line 2129 "" *)
   LOOP
      IF NOT Tree.IsType (t, Tree.Qualid) THEN EXIT; END;
(* line 2130 "" *)
      IF NOT (t ^ . Qualid . IsGlobalPtr) THEN EXIT; END;
(* line 2131 "" *)
      
                IF Prec < pDeref THEN
                  WriteS (f, '(*');WriteIdent (f, GetGlobalPtr (t^.Qualid.Object));WriteC (f, ')');
                ELSE
                  WriteC (f, '*');WriteIdent (f, GetGlobalPtr (t^.Qualid.Object));
                END;
;
      RETURN;
   END (* LOOP *) ;

(* line 2139 "" *)
   LOOP
      IF NOT Tree.IsType (t, Tree.Qualid) THEN EXIT; END;
(* line 2140 "" *)
      IF NOT (IsVAR (t ^ . Qualid . Object) AND NOT IsOpen (t ^ . Qualid . Type)) THEN EXIT; END;
(* line 2141 "" *)
      
                IF Prec < pDeref THEN
                  WriteS (f, '(*');WriteIdent (f, t^.Qualid.Object^.Var1.CIdent);WriteC (f, ')');
                ELSE
                  WriteC (f, '*');WriteIdent (f, t^.Qualid.Object^.Var1.CIdent);
                END;
;
      RETURN;
   END (* LOOP *) ;

(* line 2149 "" *)
   LOOP
      IF NOT Tree.IsType (t, Tree.Qualid) THEN EXIT; END;
(* line 2150 "" *)
      WriteIdent (f, t ^ . Qualid . Object ^ . Object . CIdent);
      RETURN;
   END (* LOOP *) ;

(* line 2152 "" *)
   LOOP
      IF (t^.Kind # Tree.Subscript) THEN EXIT; END;
      IF (t^.Subscript.Designator^.Kind # Tree.Qualid0) THEN EXIT; END;
(* line 2153 "" *)
      IF NOT ((IsOpenArray (t^.Subscript.Designator ^ . Qualid0 . Object))) THEN EXIT; END;
(* line 2154 "" *)
      CodeExpr (t^.Subscript.Designator, pSubscript);
(* line 2154 "" *)
      WriteC (f, '[');
(* line 2154 "" *)
      CodeExpr (t^.Subscript.Index, pMinPrec);
(* line 2154 "" *)
      WriteC (f, ']');
      RETURN;
   END (* LOOP *) ;

(* line 2156 "" *)
    WITH yyTempo.yyR30 DO   LOOP
      IF (t^.Kind # Tree.Subscript) THEN EXIT; END;
      IF (t^.Subscript.Designator^.Kind # Tree.Deref) THEN EXIT; END;
(* line 2157 "" *)
      IF NOT (NOT (t^.Subscript.Designator^.Deref.Designator ^ . Designator . Type ^ . Kind = OpaqueType1)) THEN EXIT; END;
(* line 2158 "" *)
      ;
(* line 2159 "" *)
      
                GetLwb (GetIndexType (t^.Subscript.Designator^.Deref.Type), Lwb);
                CodeExpr (t^.Subscript.Designator^.Deref.Designator, pSelect);
                WriteS (f, '->A[');
                IF ValueToInt (Lwb) # 0 THEN
                  CodeExpr (t^.Subscript.Index, pMinus + 1); WriteS (f, ' - '); CodeValue (Lwb);
                ELSE
                  CodeExpr (t^.Subscript.Index, pMinPrec);
                END;
                WriteC (f, ']');
;
      RETURN;
   END (* LOOP *) ;
    END (* WITH yyTempo.yyR ... *) ;

(* line 2171 "" *)
    WITH yyTempo.yyR31 DO   LOOP
      IF (t^.Kind # Tree.Subscript) THEN EXIT; END;
      IF NOT Tree.IsType (t^.Subscript.Designator, Tree.Qualid) THEN EXIT; END;
(* line 2172 "" *)
      IF NOT (t^.Subscript.Designator ^ . Qualid . IsGlobalPtr AND NOT IsOpen (t^.Subscript.Designator ^ . Qualid . Type)) THEN EXIT; END;
(* line 2173 "" *)
      ;
(* line 2174 "" *)
      
                GetLwb (GetIndexType (t^.Subscript.Designator^.Qualid.Type), Lwb);
                WriteIdent (f, GetGlobalPtr (t^.Subscript.Designator^.Qualid.Object));
                WriteS (f, '->A[');
                IF ValueToInt (Lwb) # 0 THEN
                  CodeExpr (t^.Subscript.Index, pMinus + 1); WriteS (f, ' - '); CodeValue (Lwb);
                ELSE
                  CodeExpr (t^.Subscript.Index, pMinPrec);
                END;
                WriteC (f, ']');
;
      RETURN;
   END (* LOOP *) ;
    END (* WITH yyTempo.yyR ... *) ;

(* line 2186 "" *)
    WITH yyTempo.yyR32 DO   LOOP
      IF (t^.Kind # Tree.Subscript) THEN EXIT; END;
      IF NOT Tree.IsType (t^.Subscript.Designator, Tree.Qualid) THEN EXIT; END;
(* line 2187 "" *)
      IF NOT (IsVAR (t^.Subscript.Designator ^ . Qualid . Object) AND NOT IsOpen (t^.Subscript.Designator ^ . Qualid . Type)) THEN EXIT; END;
(* line 2188 "" *)
      ;
(* line 2189 "" *)
      
                GetLwb (GetIndexType (t^.Subscript.Designator^.Qualid.Type), Lwb);
                WriteIdent (f, t^.Subscript.Designator^.Qualid.Object^.Var1.CIdent);
                WriteS (f, '->A[');
                IF ValueToInt (Lwb) # 0 THEN
                  CodeExpr (t^.Subscript.Index, pMinus + 1); WriteS (f, ' - '); CodeValue (Lwb);
                ELSE
                  CodeExpr (t^.Subscript.Index, pMinPrec);
                END;
                WriteC (f, ']');
;
      RETURN;
   END (* LOOP *) ;
    END (* WITH yyTempo.yyR ... *) ;

(* line 2201 "" *)
    WITH yyTempo.yyR33 DO   LOOP
      IF (t^.Kind # Tree.Subscript) THEN EXIT; END;
(* line 2202 "" *)
      ;
(* line 2203 "" *)
      
                GetLwb (GetIndexType (t^.Subscript.Designator^.Designator.Type), Lwb);
                CodeExpr (t^.Subscript.Designator, pSelect);
                WriteS (f, '.A[');
                IF ValueToInt (Lwb) # 0 THEN
                  CodeExpr (t^.Subscript.Index, pMinus + 1); WriteS (f, ' - '); CodeValue (Lwb);
                ELSE
                  CodeExpr (t^.Subscript.Index, pMinPrec);
                END;
                WriteC (f, ']');
;
      RETURN;
   END (* LOOP *) ;
    END (* WITH yyTempo.yyR ... *) ;

(* line 2215 "" *)
    WITH yyTempo.yyR34 DO   LOOP
      IF (t^.Kind # Tree.Select) THEN EXIT; END;
      IF (t^.Select.Designator^.Kind # Tree.Deref) THEN EXIT; END;
(* line 2216 "" *)
      IF NOT (t^.Select.Designator^.Deref.Designator ^ . Designator . Type ^ . Kind = OpaqueType1) THEN EXIT; END;
(* line 2217 "" *)
      ;
(* line 2218 "" *)
       Object := t^.Select.Designator^.Deref.Designator^.Designator.Type^.Constructor.TypeObj; ;
(* line 2219 "" *)
      WriteS (f, '((');
(* line 2219 "" *)
      WriteIdent (f, GenOpaque (Object ^ . Object . CIdent));
(* line 2219 "" *)
      WriteC (f, ')');
(* line 2220 "" *)
      CodeExpr (t^.Select.Designator^.Deref.Designator, pCast);
(* line 2221 "" *)
      WriteS (f, ')->');
(* line 2222 "" *)
      CodeSelectors (GetSelectors (t ^ . Select . Object));
(* line 2223 "" *)
      WriteIdent (f, t ^ . Select . Object ^ . Object . CIdent);
      RETURN;
   END (* LOOP *) ;
    END (* WITH yyTempo.yyR ... *) ;

(* line 2225 "" *)
   LOOP
      IF (t^.Kind # Tree.Select) THEN EXIT; END;
      IF (t^.Select.Designator^.Kind # Tree.Deref) THEN EXIT; END;
(* line 2226 "" *)
      CodeExpr (t^.Select.Designator^.Deref.Designator, pSelect);
(* line 2227 "" *)
      WriteS (f, '->');
(* line 2228 "" *)
      CodeSelectors (GetSelectors (t ^ . Select . Object));
(* line 2229 "" *)
      WriteIdent (f, t ^ . Select . Object ^ . Object . CIdent);
      RETURN;
   END (* LOOP *) ;

(* line 2231 "" *)
   LOOP
      IF (t^.Kind # Tree.Select) THEN EXIT; END;
(* line 2232 "" *)
      CodeExpr (t^.Select.Designator, pSelect);
(* line 2233 "" *)
      WriteC (f, '.');
(* line 2234 "" *)
      CodeSelectors (GetSelectors (t ^ . Select . Object));
(* line 2235 "" *)
      WriteIdent (f, t ^ . Select . Object ^ . Object . CIdent);
      RETURN;
   END (* LOOP *) ;

(* line 2237 "" *)
    WITH yyTempo.yyR37 DO   LOOP
      IF (t^.Kind # Tree.Deref) THEN EXIT; END;
(* line 2238 "" *)
      IF NOT (t^.Deref.Designator ^ . Designator . Type ^ . Kind = OpaqueType1) THEN EXIT; END;
(* line 2239 "" *)
      ;
(* line 2240 "" *)
      
                Object := t^.Deref.Designator^.Designator.Type^.Constructor.TypeObj;

                IF Prec < pDeref THEN
                  WriteS (f, '(*('); WriteIdent (f, GenOpaque (Object^.Object.CIdent)); WriteC (f, ')');
                    CodeExpr (t^.Deref.Designator, pCast);
                  WriteC (f, ')');
                ELSE
                  WriteS (f, '*('); WriteIdent (f, GenOpaque (Object^.Object.CIdent)); WriteC (f, ')');
                    CodeExpr (t^.Deref.Designator, pCast);
                END;
;
      RETURN;
   END (* LOOP *) ;
    END (* WITH yyTempo.yyR ... *) ;

(* line 2253 "" *)
   LOOP
      IF (t^.Kind # Tree.Deref) THEN EXIT; END;
(* line 2254 "" *)
      
                IF Prec < pDeref THEN
                  WriteS (f, '(*'); CodeExpr (t^.Deref.Designator, pDeref); WriteC (f, ')');
                ELSE
                  WriteC (f, '*'); CodeExpr (t^.Deref.Designator, pDeref);
                END;
;
      RETURN;
   END (* LOOP *) ;

(* line 2262 "" *)
   LOOP
      IF (t^.Kind # Tree.Elem) THEN EXIT; END;
(* line 2263 "" *)
      WriteS (f, 'SET_ELEM(');
(* line 2263 "" *)
      CodeExpr (t^.Elem.Elem, pPassValue);
(* line 2263 "" *)
      WriteC (f, ')');
(* line 2263 "" *)
      CodeSepa (t^.Elem.Next);
(* line 2264 "" *)
      CodeExpr (t^.Elem.Next, pUnion);
      RETURN;
   END (* LOOP *) ;

(* line 2266 "" *)
   LOOP
      IF (t^.Kind # Tree.ElemRange) THEN EXIT; END;
(* line 2267 "" *)
      IF NOT (t^.ElemRange.Lwb ^ . Expr . IsCConst AND t^.ElemRange.Upb ^ . Expr . IsCConst) THEN EXIT; END;
(* line 2268 "" *)
      WriteS (f, 'SET_cRNG(');
(* line 2268 "" *)
      CodeExpr (t^.ElemRange.Lwb, pPassValue);
(* line 2268 "" *)
      WriteS (f, ', ');
(* line 2268 "" *)
      CodeExpr (t^.ElemRange.Upb, pPassValue);
(* line 2268 "" *)
      WriteC (f, ')');
(* line 2269 "" *)
      CodeSepa (t^.ElemRange.Next);
(* line 2270 "" *)
      CodeExpr (t^.ElemRange.Next, pUnion);
      RETURN;
   END (* LOOP *) ;

(* line 2272 "" *)
   LOOP
      IF (t^.Kind # Tree.ElemRange) THEN EXIT; END;
(* line 2273 "" *)
      WriteS (f, 'SET_RANGE(');
(* line 2273 "" *)
      CodeExpr (t^.ElemRange.Lwb, pPassValue);
(* line 2273 "" *)
      WriteS (f, ', ');
(* line 2273 "" *)
      CodeExpr (t^.ElemRange.Upb, pPassValue);
(* line 2273 "" *)
      WriteC (f, ')');
(* line 2274 "" *)
      CodeSepa (t^.ElemRange.Next);
(* line 2275 "" *)
      CodeExpr (t^.ElemRange.Next, pUnion);
      RETURN;
   END (* LOOP *) ;

 END CodeExpr;

PROCEDURE CodeAdr (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
(* line 2284 "" *)
   LOOP
      IF (t^.Kind # Tree.Deref) THEN EXIT; END;
(* line 2285 "" *)
      CodeExpr (t^.Deref.Designator, pMinPrec);
      RETURN;
   END (* LOOP *) ;

(* line 2287 "" *)
   LOOP
      IF NOT Tree.IsType (t, Tree.Qualid) THEN EXIT; END;
(* line 2288 "" *)
      IF NOT (t ^ . Qualid . IsGlobalPtr) THEN EXIT; END;
(* line 2289 "" *)
      WriteIdent (f, GetGlobalPtr (t ^ . Qualid . Object));
      RETURN;
   END (* LOOP *) ;

(* line 2291 "" *)
   LOOP
      IF (t^.Kind # Tree.Qualid0) THEN EXIT; END;
(* line 2292 "" *)
      IF NOT ((IsVAR (t ^ . Qualid0 . Object))) THEN EXIT; END;
(* line 2293 "" *)
      WriteIdent (f, t ^ . Qualid0 . Object ^ . Var1 . CIdent);
      RETURN;
   END (* LOOP *) ;

(* line 2295 "" *)
   LOOP
(* line 2296 "" *)
      WriteC (f, '&');
(* line 2296 "" *)
      CodeExpr (t, pAdr);
      RETURN;
   END (* LOOP *) ;

 END CodeAdr;

PROCEDURE CodeString2 (t: Tree.tTree; Strncpy: BOOLEAN);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
(* line 2307 "" *)
   LOOP
      IF (t^.Kind # Tree.StringConst) THEN EXIT; END;
(* line 2308 "" *)
                     IF OptionIsSet ('c') AND NOT Strncpy THEN WriteS (f, '(STRING)'); END; ;
(* line 2309 "" *)
      CodeString1 (t^.StringConst.StringVal);
      RETURN;
   END (* LOOP *) ;

(* line 2311 "" *)
   LOOP
      IF (t^.Kind # Tree.CharConst) THEN EXIT; END;
(* line 2312 "" *)
                     IF OptionIsSet ('c') AND NOT Strncpy THEN WriteS (f, '(STRING)'); END; ;
(* line 2313 "" *)
      CodeString3 (t^.CharConst.CharVal);
      RETURN;
   END (* LOOP *) ;

(* line 2315 "" *)
   LOOP
      IF NOT Tree.IsType (t, Tree.Qualid) THEN EXIT; END;
(* line 2316 "" *)
      IF NOT (t ^ . Qualid . Type = TypeSTRING) THEN EXIT; END;
(* line 2317 "" *)
                     IF OptionIsSet ('c') AND Strncpy THEN WriteS (f, '(char *)'); END; ;
(* line 2318 "" *)
      WriteIdent (f, t ^ . Qualid . Object ^ . Object . CIdent);
      RETURN;
   END (* LOOP *) ;

(* line 2320 "" *)
   LOOP
      IF NOT Tree.IsType (t, Tree.Qualid) THEN EXIT; END;
(* line 2321 "" *)
      IF NOT (t ^ . Qualid . Type = TypeStringChar) THEN EXIT; END;
(* line 2322 "" *)
                     IF OptionIsSet ('c') AND NOT Strncpy THEN WriteS (f, '(STRING)'); END; ;
(* line 2323 "" *)
      CodeString3 (t ^ . Qualid . Object ^ . Const1 . Value . CharValue);
      RETURN;
   END (* LOOP *) ;

(* line 2325 "" *)
   LOOP
      IF NOT Tree.IsType (t, Tree.Qualid) THEN EXIT; END;
(* line 2326 "" *)
      IF NOT (t ^ . Qualid . Type = TypeCHAR) THEN EXIT; END;
(* line 2327 "" *)
                     IF OptionIsSet ('c') AND NOT Strncpy THEN WriteS (f, '(STRING)'); END; ;
(* line 2328 "" *)
      CodeString3 (t ^ . Qualid . Object ^ . Const1 . Value . CharValue);
      RETURN;
   END (* LOOP *) ;

 END CodeString2;

PROCEDURE CodeStmts (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 4: yyR4: RECORD
  StdProc: SHORTCARD;
  END;
 | 15: yyR15: RECORD
  BoundId1: tIdent;
  BoundId2: tIdent;
  ByValue: LONGINT;
  END;
 | 16: yyR16: RECORD
  WithId: tIdent;
  Object: tObject;
  END;
 | 17: yyR17: RECORD
  WithId: tIdent;
  END;
 | 20: yyR20: RECORD
  ReturnId: tIdent;
  END;
 END; END;
 BEGIN
(* line 2336 "" *)
   LOOP
      IF (t^.Kind # Tree.Assign) THEN EXIT; END;
(* line 2337 "" *)
      IF NOT ((t^.Assign.Designator ^ . Designator . Type ^ . Kind = Array1) AND ((t^.Assign.Expr ^ . Expr . Type = TypeStringChar) OR (t^.Assign.Expr ^ . Expr . Type = TypeSTRING))) THEN EXIT; END;
(* line 2339 "" *)
      WriteSpaces (f, Indent);
(* line 2339 "" *)
      WriteS (f, '(void)strncpy(');
(* line 2340 "" *)
      
                  IF OptionIsSet ('c') THEN WriteS (f, '(char *)'); END;
;
(* line 2343 "" *)
      CodeExpr (t^.Assign.Designator, pSelect);
(* line 2343 "" *)
      WriteS (f, '.A, ');
(* line 2344 "" *)
      CodeString2 (t^.Assign.Expr, Strncpy);
(* line 2344 "" *)
      WriteS (f, ', ');
(* line 2345 "" *)
      WriteS (f, 'sizeof(');
(* line 2345 "" *)
      CodeExpr (t^.Assign.Designator, pSelect);
(* line 2345 "" *)
      WriteS (f, '.A));');
(* line 2345 "" *)
      WriteNl (f);
(* line 2346 "" *)
      CodeStmts (t^.Assign.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2348 "" *)
   LOOP
      IF (t^.Kind # Tree.Assign) THEN EXIT; END;
(* line 2349 "" *)
      IF NOT ((Cast (cAssign, t^.Assign.Designator ^ . Designator . Type, t^.Assign.Expr ^ . Expr . Type))) THEN EXIT; END;
(* line 2350 "" *)
      WriteSpaces (f, Indent);
(* line 2350 "" *)
      CodeExpr (t^.Assign.Designator, pAssign);
(* line 2350 "" *)
      WriteS (f, ' = ');
(* line 2351 "" *)
      CodeCast (t^.Assign.Designator ^ . Designator . Type);
(* line 2351 "" *)
      CodeExpr (t^.Assign.Expr, pCast);
(* line 2351 "" *)
      WriteC (f, ';');
(* line 2351 "" *)
      WriteNl (f);
(* line 2352 "" *)
      CodeStmts (t^.Assign.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2354 "" *)
   LOOP
      IF (t^.Kind # Tree.Assign) THEN EXIT; END;
(* line 2355 "" *)
      WriteSpaces (f, Indent);
(* line 2355 "" *)
      CodeExpr (t^.Assign.Designator, pAssign);
(* line 2355 "" *)
      WriteS (f, ' = ');
(* line 2355 "" *)
      CodeExpr (t^.Assign.Expr, pAssign);
(* line 2355 "" *)
      WriteC (f, ';');
(* line 2355 "" *)
      WriteNl (f);
(* line 2356 "" *)
      CodeStmts (t^.Assign.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2358 "" *)
    WITH yyTempo.yyR4 DO   LOOP
      IF (t^.Kind # Tree.Call) THEN EXIT; END;
(* line 2359 "" *)
      IF NOT (t^.Call.Designator ^ . Designator . Type ^ . Kind = StdProcType1) THEN EXIT; END;
(* line 2360 "" *)
      ;
(* line 2361 "" *)
      
                StdProc := t^.Call.Designator^.Designator.Type^.StdProcType1.StdProc;
                CASE StdProc OF
                | ProcTRANSFER  :
                    ErrorMessageP (NoTRANSFER, Restriction, t^.Call.Designator^.Designator.Pos);
                | ProcIOTRANSFER:
                    ErrorMessageP (NoIOTRANSFER, Restriction, t^.Call.Designator^.Designator.Pos);
                | ProcNEWPROCESS:
                    ErrorMessageP (NoNEWPROCESS, Restriction, t^.Call.Designator^.Designator.Pos);
                | ProcNEW       ,
                  ProcDISPOSE   :
WriteSpaces (f, Indent);                   CodeStdProc (t^.Call.Actuals, StdProc, t^.Call.AllocOrDealloc); WriteC (f, ';'); WriteNl (f);
                ELSE
WriteSpaces (f, Indent);                 CodeStdProc (t^.Call.Actuals, StdProc, NoObject); WriteC (f, ';'); WriteNl (f);
                END;
;
(* line 2377 "" *)
      CodeStmts (t^.Call.Next);
      RETURN;
   END (* LOOP *) ;
    END (* WITH yyTempo.yyR ... *) ;

(* line 2379 "" *)
   LOOP
      IF (t^.Kind # Tree.Call) THEN EXIT; END;
      IF NOT Tree.IsType (t^.Call.Designator, Tree.Qualid) THEN EXIT; END;
(* line 2380 "" *)
      IF NOT ((IsProcedure (t^.Call.Designator ^ . Qualid . Object))) THEN EXIT; END;
(* line 2381 "" *)
      WriteSpaces (f, Indent);
(* line 2381 "" *)
      WriteIdent (f, t^.Call.Designator ^ . Qualid . Object ^ . Object . CIdent);
(* line 2381 "" *)
      WriteC (f, '(');
(* line 2381 "" *)
      CodeActuals (t^.Call.Actuals);
(* line 2381 "" *)
      WriteS (f, ');');
(* line 2381 "" *)
      WriteNl (f);
(* line 2382 "" *)
      CodeStmts (t^.Call.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2384 "" *)
   LOOP
      IF (t^.Kind # Tree.Call) THEN EXIT; END;
(* line 2385 "" *)
      WriteSpaces (f, Indent);
(* line 2385 "" *)
      WriteS (f, '(*');
(* line 2385 "" *)
      CodeExpr (t^.Call.Designator, pDeref);
(* line 2385 "" *)
      WriteC (f, ')');
(* line 2385 "" *)
      WriteC (f, '(');
(* line 2385 "" *)
      CodeActuals (t^.Call.Actuals);
(* line 2385 "" *)
      WriteS (f, ');');
(* line 2385 "" *)
      WriteNl (f);
(* line 2386 "" *)
      CodeStmts (t^.Call.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2388 "" *)
   LOOP
      IF (t^.Kind # Tree.If) THEN EXIT; END;
      IF (t^.If.Else^.Kind # Tree.Stmts0) THEN EXIT; END;
(* line 2389 "" *)
      WriteSpaces (f, Indent);
(* line 2389 "" *)
      WriteS (f, 'if (');
(* line 2389 "" *)
      CodeExpr (t^.If.Cond, pMinPrec);
(* line 2389 "" *)
      WriteS (f, ') {');
(* line 2389 "" *)
      WriteNl (f);
(* line 2390 "" *)
      INC (Indent, 2);
(* line 2390 "" *)
      CodeStmts (t^.If.Then);
(* line 2391 "" *)
      DEC (Indent, 2);
(* line 2391 "" *)
      CodeStmts (t^.If.Elsifs);
(* line 2392 "" *)
      WriteSpaces (f, Indent);
(* line 2392 "" *)
      WriteC (f, '}');
(* line 2392 "" *)
      WriteNl (f);
(* line 2393 "" *)
      CodeStmts (t^.If.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2395 "" *)
   LOOP
      IF (t^.Kind # Tree.If) THEN EXIT; END;
(* line 2396 "" *)
      WriteSpaces (f, Indent);
(* line 2396 "" *)
      WriteS (f, 'if (');
(* line 2396 "" *)
      CodeExpr (t^.If.Cond, pMinPrec);
(* line 2396 "" *)
      WriteS (f, ') {');
(* line 2396 "" *)
      WriteNl (f);
(* line 2397 "" *)
      INC (Indent, 2);
(* line 2397 "" *)
      CodeStmts (t^.If.Then);
(* line 2398 "" *)
      DEC (Indent, 2);
(* line 2398 "" *)
      CodeStmts (t^.If.Elsifs);
(* line 2399 "" *)
      WriteSpaces (f, Indent);
(* line 2399 "" *)
      WriteS (f, '} else {');
(* line 2399 "" *)
      WriteNl (f);
(* line 2400 "" *)
      INC (Indent, 2);
(* line 2400 "" *)
      CodeStmts (t^.If.Else);
(* line 2401 "" *)
      DEC (Indent, 2);
(* line 2401 "" *)
      WriteSpaces (f, Indent);
(* line 2401 "" *)
      WriteC (f, '}');
(* line 2401 "" *)
      WriteNl (f);
(* line 2402 "" *)
      CodeStmts (t^.If.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2404 "" *)
   LOOP
      IF (t^.Kind # Tree.Case) THEN EXIT; END;
      IF NOT ( t^.Case.Default  =   TRUE  ) THEN EXIT; END;
(* line 2405 "" *)
      WriteSpaces (f, Indent);
(* line 2405 "" *)
      WriteS (f, 'switch (');
(* line 2405 "" *)
      CodeExpr (t^.Case.Expr, pMinPrec);
(* line 2405 "" *)
      WriteS (f, ') {');
(* line 2405 "" *)
      WriteNl (f);
(* line 2406 "" *)
      CodeStmts (t^.Case.Cases);
(* line 2407 "" *)
      WriteSpaces (f, Indent);
(* line 2407 "" *)
      WriteS (f, 'default :');
(* line 2407 "" *)
      WriteNl (f);
(* line 2408 "" *)
      INC (Indent, 2);
(* line 2408 "" *)
      CodeStmts (t^.Case.Else);
(* line 2409 "" *)
      WriteSpaces (f, Indent);
(* line 2409 "" *)
      WriteS (f, 'break;');
(* line 2409 "" *)
      WriteNl (f);
(* line 2410 "" *)
      DEC (Indent, 2);
(* line 2410 "" *)
      WriteSpaces (f, Indent);
(* line 2410 "" *)
      WriteC (f, '}');
(* line 2410 "" *)
      WriteNl (f);
(* line 2411 "" *)
      CodeStmts (t^.Case.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2413 "" *)
   LOOP
      IF (t^.Kind # Tree.Case) THEN EXIT; END;
(* line 2414 "" *)
      WriteSpaces (f, Indent);
(* line 2414 "" *)
      WriteS (f, 'switch (');
(* line 2414 "" *)
      CodeExpr (t^.Case.Expr, pMinPrec);
(* line 2414 "" *)
      WriteS (f, ') {');
(* line 2414 "" *)
      WriteNl (f);
(* line 2415 "" *)
      CodeStmts (t^.Case.Cases);
(* line 2416 "" *)
      
                IF OptionIsSet ('r') THEN
WriteSpaces (f, Indent);               WriteS (f, 'default :'); WriteNl (f);
WriteSpaces (f, Indent);               WriteS (f, '  CaseError(__FILE__, __LINE__);'); WriteNl (f);
WriteSpaces (f, Indent);               WriteS (f, '  break;'); WriteNl (f);
                END;
;
(* line 2423 "" *)
      WriteSpaces (f, Indent);
(* line 2423 "" *)
      WriteC (f, '}');
(* line 2423 "" *)
      WriteNl (f);
(* line 2424 "" *)
      CodeStmts (t^.Case.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2426 "" *)
   LOOP
      IF (t^.Kind # Tree.While) THEN EXIT; END;
(* line 2427 "" *)
      WriteSpaces (f, Indent);
(* line 2427 "" *)
      WriteS (f, 'while (');
(* line 2427 "" *)
      CodeExpr (t^.While.Cond, pMinPrec);
(* line 2427 "" *)
      WriteS (f, ') {');
(* line 2427 "" *)
      WriteNl (f);
(* line 2428 "" *)
      INC (Indent, 2);
(* line 2428 "" *)
      CodeStmts (t^.While.Stmts);
(* line 2429 "" *)
      DEC (Indent, 2);
(* line 2429 "" *)
      WriteSpaces (f, Indent);
(* line 2429 "" *)
      WriteC (f, '}');
(* line 2429 "" *)
      WriteNl (f);
(* line 2430 "" *)
      CodeStmts (t^.While.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2432 "" *)
   LOOP
      IF (t^.Kind # Tree.Repeat) THEN EXIT; END;
(* line 2433 "" *)
      WriteSpaces (f, Indent);
(* line 2433 "" *)
      WriteS (f, 'do {');
(* line 2433 "" *)
      WriteNl (f);
(* line 2434 "" *)
      INC (Indent, 2);
(* line 2434 "" *)
      CodeStmts (t^.Repeat.Stmts);
(* line 2435 "" *)
      DEC (Indent, 2);
(* line 2435 "" *)
      WriteSpaces (f, Indent);
(* line 2435 "" *)
      WriteS (f, '} while (!');
(* line 2435 "" *)
      CodeExpr (t^.Repeat.Cond, pNot);
(* line 2435 "" *)
      WriteS (f, ');');
(* line 2435 "" *)
      WriteNl (f);
(* line 2436 "" *)
      CodeStmts (t^.Repeat.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2438 "" *)
   LOOP
      IF (t^.Kind # Tree.Loop) THEN EXIT; END;
(* line 2439 "" *)
      LabelStack . Push (GenLabel ());
(* line 2440 "" *)
      WriteSpaces (f, Indent);
(* line 2440 "" *)
      WriteS (f, 'for (;;) {');
(* line 2440 "" *)
      WriteNl (f);
(* line 2441 "" *)
      INC (Indent, 2);
(* line 2441 "" *)
      CodeStmts (t^.Loop.Stmts);
(* line 2442 "" *)
      DEC (Indent, 2);
(* line 2442 "" *)
      WriteSpaces (f, Indent);
(* line 2442 "" *)
      WriteS (f, '} ');
(* line 2442 "" *)
      WriteIdent (f, LabelStack . Top ());
(* line 2442 "" *)
      WriteS (f, ':;');
(* line 2442 "" *)
      WriteNl (f);
(* line 2443 "" *)
      LabelStack . Pop ();
(* line 2444 "" *)
      CodeStmts (t^.Loop.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2446 "" *)
   LOOP
      IF (t^.Kind # Tree.For) THEN EXIT; END;
(* line 2447 "" *)
      IF NOT (t^.For.To ^ . Expr . IsCConst AND NOT OverOrUnderflow (t^.For.Qualid ^ . Qualid . Type, t ^ . For . ToVal, t ^ . For . ByVal)) THEN EXIT; END;
(* line 2448 "" *)
      WriteSpaces (f, Indent);
(* line 2448 "" *)
      WriteS (f, 'for (');
(* line 2449 "" *)
      CodeExpr (t^.For.Qualid, pAssign);
(* line 2449 "" *)
      WriteS (f, ' = ');
(* line 2449 "" *)
      CodeExpr (t^.For.From, pAssign);
(* line 2449 "" *)
      WriteS (f, '; ');
(* line 2450 "" *)
      CodeExpr (t^.For.Qualid, pComparison);
(* line 2451 "" *)
      
                IF ValueToInt (t^.For.ByVal) >= 0 THEN WriteS (f, ' <= '); ELSE WriteS (f, ' >= '); END;
;
(* line 2454 "" *)
      CodeExpr (t^.For.To, pComparison);
(* line 2454 "" *)
      WriteS (f, '; ');
(* line 2455 "" *)
      CodeExpr (t^.For.Qualid, pAssign);
(* line 2455 "" *)
      WriteS (f, ' += ');
(* line 2455 "" *)
      CodeExpr (t^.For.By, pAssign);
(* line 2456 "" *)
      WriteS (f, ') {');
(* line 2456 "" *)
      WriteNl (f);
(* line 2457 "" *)
      INC (Indent, 2);
(* line 2457 "" *)
      CodeStmts (t^.For.Stmts);
(* line 2458 "" *)
      DEC (Indent, 2);
(* line 2458 "" *)
      WriteSpaces (f, Indent);
(* line 2458 "" *)
      WriteC (f, '}');
(* line 2458 "" *)
      WriteNl (f);
(* line 2459 "" *)
      CodeStmts (t^.For.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2461 "" *)
    WITH yyTempo.yyR15 DO   LOOP
      IF (t^.Kind # Tree.For) THEN EXIT; END;
(* line 2462 "" *)
      ;
(* line 2463 "" *)
      
                BoundId1 := GenBound ();
                BoundId2 := GenBound ();
                ByValue  := ValueToInt (t^.For.ByVal);

WriteSpaces (f, Indent);               WriteC (f, '{'); WriteNl (f);
INC (Indent, 2);WriteSpaces (f, Indent);               CodeTypeName (t^.For.Qualid^.Qualid.Type); WriteC (f, ' ');
                    WriteIdent (f, BoundId1); WriteS (f, ' = '); CodeExpr (t^.For.From, pAssign); WriteS (f, ', ');
                    WriteIdent (f, BoundId2); WriteS (f, ' = '); CodeExpr (t^.For.To, pAssign); WriteC (f, ';'); WriteNl (f);
                WriteNl (f);
WriteSpaces (f, Indent);                 WriteS (f, 'if ('); WriteIdent (f, BoundId1);
                IF ByValue >= 0 THEN WriteS (f, ' <= '); ELSE WriteS (f, ' >= '); END;
                         WriteIdent (f, BoundId2);
                  WriteC (f, ')'); WriteNl (f);
INC (Indent, 2);WriteSpaces (f, Indent);                 WriteS (f, 'for (');
                        CodeExpr (t^.For.Qualid, pAssign);
                          WriteS (f, ' = '); WriteIdent (f, BoundId1);
                IF ByValue >= 2 THEN
                        WriteS (f, ', '); WriteIdent (f, BoundId2);WriteS (f, ' = ');
                          WriteS (f, 'FOR_LIMIT_UP(');
                            WriteIdent (f, BoundId2); WriteS (f, ', ');
                            CodeExpr (t^.For.By, pPassValue); WriteS (f, ', ');
                            CodeMIN (t^.For.Qualid^.Qualid.Type);
                          WriteC (f, ')');
                ELSIF ByValue <= -2 THEN
                        WriteS (f, ', '); WriteIdent (f, BoundId2);WriteS (f, ' = ');
                          WriteS (f, 'FOR_LIMIT_DOWN(');
                            WriteIdent (f, BoundId2); WriteS (f, ', ');
                            CodeExpr (t^.For.By, pPassValue); WriteS (f, ', ');
                            CodeMAX (t^.For.Qualid^.Qualid.Type);
                          WriteC (f, ')');
                END;
                          WriteS (f, ';; ');
                        CodeExpr (t^.For.Qualid, pAssign);
                          WriteS (f, ' += '); CodeExpr (t^.For.By, pAssign);
                        WriteS (f, ') {'); WriteNl (f);
INC (Indent, 2);                  CodeStmts (t^.For.Stmts);
WriteSpaces (f, Indent);                   WriteS (f, 'if ('); CodeExpr (t^.For.Qualid, pComparison);
                IF ByValue >= 0 THEN WriteS (f, ' >= '); ELSE WriteS (f, ' <= '); END;
                           WriteIdent (f, BoundId2);
                    WriteS (f, ') break;'); WriteNl (f);
DEC (Indent, 2);WriteSpaces (f, Indent);               WriteC (f, '}'); WriteNl (f);
DEC (Indent, 4);WriteSpaces (f, Indent);            WriteC (f, '}'); WriteNl (f);
;
(* line 2507 "" *)
      CodeStmts (t^.For.Next);
      RETURN;
   END (* LOOP *) ;
    END (* WITH yyTempo.yyR ... *) ;

(* line 2509 "" *)
    WITH yyTempo.yyR16 DO   LOOP
      IF (t^.Kind # Tree.With) THEN EXIT; END;
      IF (t^.With.Designator^.Kind # Tree.Deref) THEN EXIT; END;
(* line 2510 "" *)
      IF NOT (t^.With.Designator^.Deref.Designator ^ . Designator . Type ^ . Kind = OpaqueType1) THEN EXIT; END;
(* line 2511 "" *)
      ;
(* line 2512 "" *)
      
                WithId := GenWith ();
                Object := t^.With.Designator^.Deref.Designator^.Designator.Type^.Constructor.TypeObj;
;
(* line 2516 "" *)
      WriteSpaces (f, Indent);
(* line 2516 "" *)
      WriteC (f, '{');
(* line 2516 "" *)
      WriteNl (f);
(* line 2517 "" *)
      INC (Indent, 2);
(* line 2517 "" *)
      WriteSpaces (f, Indent);
(* line 2517 "" *)
      WriteS (f, 'register ');
(* line 2517 "" *)
      CodeTypeName (t^.With.Designator ^ . Deref . Type);
(* line 2518 "" *)
      WriteS (f, ' *');
(* line 2518 "" *)
      WriteIdent (f, WithId);
(* line 2518 "" *)
      WriteS (f, ' = ');
(* line 2519 "" *)
      WriteC (f, '(');
(* line 2519 "" *)
      WriteIdent (f, GenOpaque (Object ^ . Object . CIdent));
(* line 2519 "" *)
      WriteC (f, ')');
(* line 2520 "" *)
      CodeExpr (t^.With.Designator^.Deref.Designator, pCast);
(* line 2520 "" *)
      WriteC (f, ';');
(* line 2520 "" *)
      WriteNl (f);
(* line 2521 "" *)
      WriteNl (f);
(* line 2522 "" *)
      WithStack . Push (WithId, GetFields (t^.With.Designator ^ . Deref . Type));
(* line 2523 "" *)
      CodeStmts (t^.With.Stmts);
(* line 2524 "" *)
      WithStack . Pop ();
(* line 2525 "" *)
      DEC (Indent, 2);
(* line 2525 "" *)
      WriteSpaces (f, Indent);
(* line 2525 "" *)
      WriteC (f, '}');
(* line 2525 "" *)
      WriteNl (f);
(* line 2526 "" *)
      CodeStmts (t^.With.Next);
      RETURN;
   END (* LOOP *) ;
    END (* WITH yyTempo.yyR ... *) ;

(* line 2528 "" *)
    WITH yyTempo.yyR17 DO   LOOP
      IF (t^.Kind # Tree.With) THEN EXIT; END;
(* line 2529 "" *)
      ;
(* line 2530 "" *)
      
                WithId := GenWith ();
;
(* line 2533 "" *)
      WriteSpaces (f, Indent);
(* line 2533 "" *)
      WriteC (f, '{');
(* line 2533 "" *)
      WriteNl (f);
(* line 2534 "" *)
      INC (Indent, 2);
(* line 2534 "" *)
      WriteSpaces (f, Indent);
(* line 2534 "" *)
      WriteS (f, 'register ');
(* line 2534 "" *)
      CodeTypeName (t^.With.Designator ^ . Designator . Type);
(* line 2535 "" *)
      WriteS (f, ' *');
(* line 2535 "" *)
      WriteIdent (f, WithId);
(* line 2535 "" *)
      WriteS (f, ' = ');
(* line 2535 "" *)
      CodeAdr (t^.With.Designator);
(* line 2535 "" *)
      WriteC (f, ';');
(* line 2535 "" *)
      WriteNl (f);
(* line 2536 "" *)
      WriteNl (f);
(* line 2537 "" *)
      WithStack . Push (WithId, GetFields (t^.With.Designator ^ . Designator . Type));
(* line 2538 "" *)
      CodeStmts (t^.With.Stmts);
(* line 2539 "" *)
      WithStack . Pop ();
(* line 2540 "" *)
      DEC (Indent, 2);
(* line 2540 "" *)
      WriteSpaces (f, Indent);
(* line 2540 "" *)
      WriteC (f, '}');
(* line 2540 "" *)
      WriteNl (f);
(* line 2541 "" *)
      CodeStmts (t^.With.Next);
      RETURN;
   END (* LOOP *) ;
    END (* WITH yyTempo.yyR ... *) ;

(* line 2543 "" *)
   LOOP
      IF (t^.Kind # Tree.Exit) THEN EXIT; END;
(* line 2544 "" *)
      WriteSpaces (f, Indent);
(* line 2544 "" *)
      WriteS (f, 'goto ');
(* line 2544 "" *)
      WriteIdent (f, LabelStack . Top ());
(* line 2544 "" *)
      WriteC (f, ';');
(* line 2544 "" *)
      WriteNl (f);
(* line 2545 "" *)
      CodeStmts (t^.Exit.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2547 "" *)
   LOOP
      IF (t^.Kind # Tree.Return1) THEN EXIT; END;
(* line 2548 "" *)
      CodePop (LocalPtrs);
(* line 2549 "" *)
      CodeFree (ValueOpens);
(* line 2550 "" *)
      WriteSpaces (f, Indent);
(* line 2550 "" *)
      WriteS (f, 'return;');
(* line 2550 "" *)
      WriteNl (f);
(* line 2551 "" *)
      CodeStmts (t^.Return1.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2553 "" *)
    WITH yyTempo.yyR20 DO   LOOP
      IF (t^.Kind # Tree.Return2) THEN EXIT; END;
(* line 2554 "" *)
      ;
(* line 2555 "" *)
      
                IF ((ValueOpens # NoCObjects) OR (LocalPtrs # NoCObjects)) AND
                     t^.Return2.OpenAccessOrCall THEN
                  ReturnId := GenReturn ();
WriteSpaces (f, Indent);                 WriteC (f, '{'); WriteNl (f);
INC (Indent, 2);WriteSpaces (f, Indent);                 CodeTypeName (t^.Return2.ResultType); WriteC (f, ' ');WriteIdent (f, ReturnId);WriteS (f, ' = ');
                  IF Cast (cAssign, t^.Return2.ResultType, t^.Return2.Result^.Expr.Type) THEN
                    CodeCast (t^.Return2.ResultType); CodeExpr (t^.Return2.Result, pCast); WriteC (f, ';'); WriteNl (f);
                  ELSE
                    CodeExpr (t^.Return2.Result, pMinPrec); WriteC (f, ';'); WriteNl (f);
                  END;
                  WriteNl (f);
                    CodePop  (LocalPtrs);
                    CodeFree (ValueOpens);
WriteSpaces (f, Indent);                   WriteS (f, 'return ');WriteIdent (f, ReturnId);WriteC (f, ';'); WriteNl (f);
DEC (Indent, 2);WriteSpaces (f, Indent);               WriteC (f, '}'); WriteNl (f);
                ELSE
                  CodePop  (LocalPtrs);
                  CodeFree (ValueOpens);
WriteSpaces (f, Indent);                 WriteS (f, 'return ');
                  IF Cast (cAssign, t^.Return2.ResultType, t^.Return2.Result^.Expr.Type) THEN
                    CodeCast (t^.Return2.ResultType); CodeExpr (t^.Return2.Result, pCast);
                  ELSE
                    CodeExpr (t^.Return2.Result, pMinPrec);
                  END;
                  WriteC (f, ';'); WriteNl (f);
                END;
;
(* line 2583 "" *)
      CodeStmts (t^.Return2.Next);
      RETURN;
   END (* LOOP *) ;
    END (* WITH yyTempo.yyR ... *) ;

(* line 2585 "" *)
   LOOP
      IF (t^.Kind # Tree.Elsifs1) THEN EXIT; END;
(* line 2586 "" *)
      WriteSpaces (f, Indent);
(* line 2586 "" *)
      WriteS (f, '} else if (');
(* line 2586 "" *)
      CodeExpr (t^.Elsifs1.Cond, pMinPrec);
(* line 2586 "" *)
      WriteS (f, ') {');
(* line 2586 "" *)
      WriteNl (f);
(* line 2587 "" *)
      INC (Indent, 2);
(* line 2587 "" *)
      CodeStmts (t^.Elsifs1.Stmts);
(* line 2588 "" *)
      DEC (Indent, 2);
(* line 2589 "" *)
      CodeStmts (t^.Elsifs1.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2591 "" *)
   LOOP
      IF (t^.Kind # Tree.Cases1) THEN EXIT; END;
(* line 2592 "" *)
      CodeStmts (t^.Cases1.Labels);
(* line 2593 "" *)
      INC (Indent, 2);
(* line 2593 "" *)
      CodeStmts (t^.Cases1.Stmts);
(* line 2594 "" *)
      WriteSpaces (f, Indent);
(* line 2594 "" *)
      WriteS (f, 'break;');
(* line 2594 "" *)
      WriteNl (f);
(* line 2595 "" *)
      DEC (Indent, 2);
(* line 2596 "" *)
      CodeStmts (t^.Cases1.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2598 "" *)
   LOOP
      IF (t^.Kind # Tree.Label) THEN EXIT; END;
(* line 2599 "" *)
      IF NOT (t^.Label.Label ^ . Expr . IsCConst) THEN EXIT; END;
(* line 2600 "" *)
      WriteSpaces (f, Indent);
(* line 2600 "" *)
      WriteS (f, 'case ');
(* line 2600 "" *)
      CodeExpr (t^.Label.Label, pMinPrec);
(* line 2600 "" *)
      WriteS (f, ':;');
(* line 2600 "" *)
      WriteNl (f);
(* line 2601 "" *)
      CodeStmts (t^.Label.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2603 "" *)
   LOOP
      IF (t^.Kind # Tree.Label) THEN EXIT; END;
(* line 2604 "" *)
      WriteSpaces (f, Indent);
(* line 2604 "" *)
      WriteS (f, 'case ');
(* line 2604 "" *)
      CodeValue (t ^ . Label . LabelVal);
(* line 2604 "" *)
      WriteS (f, ':;');
(* line 2604 "" *)
      WriteNl (f);
(* line 2605 "" *)
      CodeStmts (t^.Label.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2607 "" *)
   LOOP
      IF (t^.Kind # Tree.LabelRange) THEN EXIT; END;
(* line 2608 "" *)
      CodeLabelRange (t ^ . LabelRange . LwbVal, t ^ . LabelRange . UpbVal);
(* line 2609 "" *)
      CodeStmts (t^.LabelRange.Next);
      RETURN;
   END (* LOOP *) ;

 END CodeStmts;

PROCEDURE CodeStdProc (yyP6: Tree.tTree; StdProc: SHORTCARD; AllocOrDealloc: tObject);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 3: yyR3: RECORD
  Upb: tValue;
  Object: tObject;
  Type: tType;
  END;
 END; END;
 BEGIN
(* line 2622 "" *)
   LOOP
      IF (yyP6^.Kind # Tree.Actuals0) THEN EXIT; END;
(* line 2623 "" *)
      
                IF StdProc = ProcHALT THEN WriteS (f, 'exit(1)'); END;
;
      RETURN;
   END (* LOOP *) ;

(* line 2627 "" *)
   LOOP
      IF (yyP6^.Kind # Tree.Actual) THEN EXIT; END;
      IF (yyP6^.Actual.Expr^.Kind # Tree.Qualid0) THEN EXIT; END;
      IF (yyP6^.Actual.Next^.Kind # Tree.Actuals0) THEN EXIT; END;
(* line 2628 "" *)
      IF NOT ((IsOpenArray (yyP6^.Actual.Expr ^ . Qualid0 . Object))) THEN EXIT; END;
(* line 2629 "" *)
      
                IF StdProc = ProcHIGH THEN

                  IF yyP6^.Actual.Expr^.Qualid0.IsGlobalPtr THEN
                    WriteC (f, '(');WriteIdent (f, GetGlobalPtr (yyP6^.Actual.Expr^.Qualid0.Object));WriteS (f, '_O - 1)');
                  ELSE
                    WriteC (f, '(');WriteIdent (f, GetParam (yyP6^.Actual.Expr^.Qualid0.Object));WriteS (f, ' - 1)');
                  END;

                ELSIF StdProc = ProcADR THEN

                    WriteS (f, 'ADR1('); CodeExpr (yyP6^.Actual.Expr, pPassValue); WriteC (f, ')');

                ELSIF StdProc = ProcSIZE THEN

                  WriteS (f, '(sizeof('); CodeTypeName (yyP6^.Actual.Expr^.Qualid0.Type^.Array1.ElemType); WriteS (f, ') * ');
                  IF yyP6^.Actual.Expr^.Qualid0.IsGlobalPtr THEN
                    WriteIdent (f, GetGlobalPtr (yyP6^.Actual.Expr^.Qualid0.Object));WriteS (f, '_O');
                  ELSE
                    WriteIdent (f, GetParam (yyP6^.Actual.Expr^.Qualid0.Object));
                  END;
                  WriteC (f, ')');

                END;
;
      RETURN;
   END (* LOOP *) ;

(* line 2655 "" *)
    WITH yyTempo.yyR3 DO   LOOP
      IF (yyP6^.Kind # Tree.Actual) THEN EXIT; END;
      IF (yyP6^.Actual.Next^.Kind # Tree.Actuals0) THEN EXIT; END;
(* line 2656 "" *)
      ;
(* line 2657 "" *)
      
                IF StdProc = ProcHIGH THEN

                    Type := GetIndexType (yyP6^.Actual.Expr^.Expr.Type);
                    GetUpb (Type, Upb);
                    CodeValue (Upb);
                    IF IsIntType (Type) AND Cast (cPassValue, Type, TypeIntCard) THEN
                      WriteC (f, 'L');
                    END;

                ELSIF StdProc = ProcMIN THEN

                  CodeMIN (yyP6^.Actual.Expr^.Expr.Type);

                ELSIF StdProc = ProcMAX THEN

                  CodeMAX (yyP6^.Actual.Expr^.Expr.Type);

                ELSIF StdProc = ProcADR THEN

                  WriteS (f, 'ADR('); CodeExpr (yyP6^.Actual.Expr, pPassValue); WriteC (f, ')');

                ELSIF (StdProc = ProcSIZE) OR (StdProc = ProcTSIZE) THEN

                  WriteS (f, 'sizeof('); CodeExpr (yyP6^.Actual.Expr, pPassValue); WriteC (f, ')');

                ELSIF StdProc = ProcABS THEN

                  IF yyP6^.Actual.Expr^.Expr.IsCConst THEN
                    WriteS (f, 'ABS');
                  ELSE
                    Type := yyP6^.Actual.Expr^.Expr.Type;
                    IF Type^.Kind = Subrange1 THEN
                      Type := Type^.Subrange1.Type;
                    END;

                    CASE Type^.Kind OF
                    | ShortInt  : WriteS (f, 'ABSSI');
                    | LongInt   : WriteS (f, 'ABSLI');
                    | IntCard   : WriteS (f, 'ABS');
                    | ShortCard : WriteS (f, 'ABSSC');
                    | LongCard  : WriteS (f, 'ABSLC');
                    | Real      : WriteS (f, 'ABSR');
                    | LongReal  : WriteS (f, 'ABSLR');
                    ELSE
                    END;
                  END;

                  WriteC (f, '('); CodeExpr (yyP6^.Actual.Expr, pPassValue); WriteC (f, ')');

                ELSIF (StdProc = ProcNEW) OR (StdProc = ProcDISPOSE) THEN

                  WriteIdent (f, AllocOrDealloc^.Object.CIdent); WriteC (f, '(');
                    IF Cast (cPassAddress, TypeADDRESS, yyP6^.Actual.Expr^.Expr.Type) THEN
                      WriteS (f, '(ADDRESS *)');
                    END;
                    CodeAdr (yyP6^.Actual.Expr); WriteS (f, ', ');

                    IF OptionIsSet ('c') THEN WriteS (f, '(LONGCARD)'); END;
                    WriteS (f, 'sizeof('); CodeTypeName (GetTargetType (yyP6^.Actual.Expr^.Expr.Type)); WriteC (f, ')');
                  WriteC (f, ')');
                        
                ELSE

                  CASE StdProc OF
                  | ProcCAP     : WriteS (f, 'CAP');
                  | ProcCHR     : WriteS (f, 'CHR');
                  | ProcDEC     : WriteS (f, 'DEC');
                  | ProcFLOAT   : WriteS (f, 'FLOAT');
                  | ProcINC     : WriteS (f, 'INC');
                  | ProcODD     : WriteS (f, 'ODD');
                  | ProcORD     : WriteS (f, 'ORD');
                  | ProcTRUNC   : WriteS (f, 'TRUNC');
                  ELSE
                  END;
                  WriteC (f, '('); CodeExpr (yyP6^.Actual.Expr, pPassValue); WriteC (f, ')');

                END;
;
      RETURN;
   END (* LOOP *) ;
    END (* WITH yyTempo.yyR ... *) ;

(* line 2737 "" *)
   LOOP
      IF (yyP6^.Kind # Tree.Actual) THEN EXIT; END;
      IF (yyP6^.Actual.Next^.Kind # Tree.Actual) THEN EXIT; END;
      IF (yyP6^.Actual.Next^.Actual.Next^.Kind # Tree.Actuals0) THEN EXIT; END;
(* line 2738 "" *)
      
                IF (StdProc = ProcDEC) OR (StdProc = ProcINC) THEN

                  CASE StdProc OF
                  | ProcDEC     : WriteS (f, 'DEC1');
                  | ProcINC     : WriteS (f, 'INC1');
                  END;
                  WriteC (f, '('); CodeExpr (yyP6^.Actual.Expr, pPassValue); WriteS (f, ', ');
                  IF yyP6^.Actual.Next^.Actual.Expr^.Expr.Type = TypeADDRESS THEN
                    WriteS (f, '(LONGCARD)'); CodeExpr (yyP6^.Actual.Next^.Actual.Expr, pCast);
                  ELSE
                    CodeExpr (yyP6^.Actual.Next^.Actual.Expr, pPassValue);
                  END;
                  WriteC (f, ')');

                ELSE

                  CASE StdProc OF
                  | ProcEXCL    : WriteS (f, 'EXCL');
                  | ProcINCL    : WriteS (f, 'INCL');
                  | ProcVAL     : WriteS (f, 'VAL');
                  ELSE
                  END;
                  WriteC (f, '('); CodeExpr (yyP6^.Actual.Expr, pPassValue); WriteS (f, ', ');
                      CodeExpr (yyP6^.Actual.Next^.Actual.Expr, pPassValue); WriteC (f, ')');

                END;
;
      RETURN;
   END (* LOOP *) ;

 END CodeStdProc;

PROCEDURE CodeActuals (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 3: yyR3: RECORD
  length: CARDINAL;
  END;
 | 5: yyR5: RECORD
  length: CARDINAL;
  END;
 | 9: yyR9: RECORD
  Upb: tValue;
  Lwb: tValue;
  IndexType: tType;
  END;
 END; END;
 BEGIN
(* line 2777 "" *)
   LOOP
      IF (t^.Kind # Tree.Actual) THEN EXIT; END;
(* line 2779 "" *)
      IF NOT (((t^.Actual.Expr ^ . Expr . Type = TypeSTRING) OR (t^.Actual.Expr ^ . Expr . Type = TypeStringChar)) AND (t ^ . Actual . Formal ^ . Kind = Array1) AND NOT IsOpen (t ^ . Actual . Formal)) THEN EXIT; END;
(* line 2780 "" *)
      WriteIdent (f, t ^ . Actual . String);
(* line 2780 "" *)
      CodeSepa (t^.Actual.Next);
(* line 2781 "" *)
      CodeActuals (t^.Actual.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2783 "" *)
   LOOP
      IF (t^.Kind # Tree.Actual) THEN EXIT; END;
      IF (t^.Actual.Expr^.Kind # Tree.Qualid0) THEN EXIT; END;
(* line 2784 "" *)
      IF NOT (IsOpen (t ^ . Actual . Formal) AND IsOpenArray (t^.Actual.Expr ^ . Qualid0 . Object)) THEN EXIT; END;
(* line 2785 "" *)
      
                CodeExpr (t^.Actual.Expr, pPassValue); WriteS (f, ', ');
                IF t^.Actual.Expr^.Qualid0.IsGlobalPtr THEN
                  WriteIdent (f, GetGlobalPtr (t^.Actual.Expr^.Qualid0.Object));WriteS (f, '_O');
                ELSE
                  WriteIdent (f, GetParam (t^.Actual.Expr^.Qualid0.Object));
                END;
                IF t^.Actual.Formal^.Array1.ElemType = TypeWORD THEN
                  WriteS (f, ' * sizeof('); CodeTypeName (t^.Actual.Expr^.Qualid0.Type^.Array1.ElemType); WriteC (f, ')');
                END;
                CodeSepa (t^.Actual.Next);
;
(* line 2797 "" *)
      CodeActuals (t^.Actual.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2799 "" *)
    WITH yyTempo.yyR3 DO   LOOP
      IF (t^.Kind # Tree.Actual) THEN EXIT; END;
      IF (t^.Actual.Expr^.Kind # Tree.StringConst) THEN EXIT; END;
(* line 2800 "" *)
      IF NOT ((IsOpen (t ^ . Actual . Formal))) THEN EXIT; END;
(* line 2801 "" *)
      CodeString2 (t^.Actual.Expr, NOT Strncpy);
(* line 2801 "" *)
      WriteS (f, ', ');
(* line 2802 "" *)
      ;
(* line 2803 "" *)
      length := Length (t^.Actual.Expr^.StringConst.StringVal);
(* line 2804 "" *)
       IF length = 0 THEN length := 1; END; ;
(* line 2805 "" *)
      WriteI (f, length, 1);
(* line 2805 "" *)
      WriteC (f, 'L');
(* line 2806 "" *)
      CodeSepa (t^.Actual.Next);
(* line 2807 "" *)
      CodeActuals (t^.Actual.Next);
      RETURN;
   END (* LOOP *) ;
    END (* WITH yyTempo.yyR ... *) ;

(* line 2809 "" *)
   LOOP
      IF (t^.Kind # Tree.Actual) THEN EXIT; END;
      IF (t^.Actual.Expr^.Kind # Tree.CharConst) THEN EXIT; END;
(* line 2810 "" *)
      IF NOT ((IsOpen (t ^ . Actual . Formal))) THEN EXIT; END;
(* line 2811 "" *)
      CodeString2 (t^.Actual.Expr, NOT Strncpy);
(* line 2811 "" *)
      WriteS (f, ', 1L');
(* line 2812 "" *)
      CodeSepa (t^.Actual.Next);
(* line 2813 "" *)
      CodeActuals (t^.Actual.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2815 "" *)
    WITH yyTempo.yyR5 DO   LOOP
      IF (t^.Kind # Tree.Actual) THEN EXIT; END;
      IF NOT Tree.IsType (t^.Actual.Expr, Tree.Qualid) THEN EXIT; END;
(* line 2816 "" *)
      IF NOT (IsOpen (t ^ . Actual . Formal) AND (t^.Actual.Expr ^ . Qualid . Type = TypeSTRING)) THEN EXIT; END;
(* line 2817 "" *)
      CodeString2 (t^.Actual.Expr, NOT Strncpy);
(* line 2817 "" *)
      WriteS (f, ', ');
(* line 2818 "" *)
      ;
(* line 2819 "" *)
      length := Length (t^.Actual.Expr ^ . Qualid . Object ^ . Const1 . Value . StringValue);
(* line 2820 "" *)
       IF length = 0 THEN length := 1; END; ;
(* line 2821 "" *)
      WriteI (f, length, 1);
(* line 2821 "" *)
      WriteC (f, 'L');
(* line 2822 "" *)
      CodeSepa (t^.Actual.Next);
(* line 2823 "" *)
      CodeActuals (t^.Actual.Next);
      RETURN;
   END (* LOOP *) ;
    END (* WITH yyTempo.yyR ... *) ;

(* line 2825 "" *)
   LOOP
      IF (t^.Kind # Tree.Actual) THEN EXIT; END;
      IF NOT Tree.IsType (t^.Actual.Expr, Tree.Qualid) THEN EXIT; END;
(* line 2826 "" *)
      IF NOT (IsOpen (t ^ . Actual . Formal) AND (t^.Actual.Expr ^ . Qualid . Type = TypeStringChar)) THEN EXIT; END;
(* line 2827 "" *)
      CodeString2 (t^.Actual.Expr, NOT Strncpy);
(* line 2827 "" *)
      WriteS (f, ', 1L');
(* line 2828 "" *)
      CodeSepa (t^.Actual.Next);
(* line 2829 "" *)
      CodeActuals (t^.Actual.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2831 "" *)
   LOOP
      IF (t^.Kind # Tree.Actual) THEN EXIT; END;
      IF NOT Tree.IsType (t^.Actual.Expr, Tree.Qualid) THEN EXIT; END;
(* line 2833 "" *)
      IF NOT (IsOpen (t ^ . Actual . Formal) AND (t^.Actual.Expr ^ . Qualid . Type = TypeCHAR) AND (t^.Actual.Expr ^ . Qualid . Object ^ . Kind = Const1)) THEN EXIT; END;
(* line 2835 "" *)
      CodeString2 (t^.Actual.Expr, NOT Strncpy);
(* line 2835 "" *)
      WriteS (f, ', 1L');
(* line 2836 "" *)
      CodeSepa (t^.Actual.Next);
(* line 2837 "" *)
      CodeActuals (t^.Actual.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2839 "" *)
   LOOP
      IF (t^.Kind # Tree.Actual) THEN EXIT; END;
(* line 2840 "" *)
      IF NOT (IsOpen (t ^ . Actual . Formal) AND (t ^ . Actual . Formal ^ . Array1 . ElemType = TypeWORD)) THEN EXIT; END;
(* line 2841 "" *)
      
                IF OptionIsSet ('c') THEN WriteS (f, '(WORD *)'); END;
                CodeAdr (t^.Actual.Expr); WriteS (f, ', ');
                IF OptionIsSet ('c') THEN WriteS (f, '(LONGCARD)'); END;
                WriteS (f, 'sizeof('); CodeExpr (t^.Actual.Expr, pPassValue); WriteC (f, ')');
                CodeSepa (t^.Actual.Next);
;
(* line 2848 "" *)
      CodeActuals (t^.Actual.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2850 "" *)
    WITH yyTempo.yyR9 DO   LOOP
      IF (t^.Kind # Tree.Actual) THEN EXIT; END;
(* line 2851 "" *)
      IF NOT (IsOpen (t ^ . Actual . Formal) AND (t^.Actual.Expr ^ . Designator . Type ^ . Kind = Array1)) THEN EXIT; END;
(* line 2852 "" *)
      ;
(* line 2853 "" *)
      
                IndexType := t^.Actual.Expr^.Designator.Type^.Array1.IndexType;
                GetLwb (IndexType, Lwb);
                GetUpb (IndexType, Upb);
                CodeExpr (t^.Actual.Expr, pSelect); WriteS (f, '.A, ');
                WriteI (f, ValueToInt (Upb) - ValueToInt (Lwb) + 1, 1);WriteC (f, 'L'); CodeSepa (t^.Actual.Next);
;
(* line 2860 "" *)
      CodeActuals (t^.Actual.Next);
      RETURN;
   END (* LOOP *) ;
    END (* WITH yyTempo.yyR ... *) ;

(* line 2862 "" *)
   LOOP
      IF (t^.Kind # Tree.Actual) THEN EXIT; END;
(* line 2863 "" *)
      IF NOT (t ^ . Actual . IsVAR) THEN EXIT; END;
(* line 2864 "" *)
      
                IF Cast (cPassAddress, t^.Actual.Formal, t^.Actual.Expr^.Expr.Type) THEN
                  CodeCastVAR (t^.Actual.Formal); CodeAdr (t^.Actual.Expr);
                ELSE
                  CodeAdr (t^.Actual.Expr);
                END;
                CodeSepa (t^.Actual.Next);
;
(* line 2872 "" *)
      CodeActuals (t^.Actual.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2874 "" *)
   LOOP
      IF (t^.Kind # Tree.Actual) THEN EXIT; END;
      IF (t^.Actual.Expr^.Kind # Tree.IntConst) THEN EXIT; END;
(* line 2875 "" *)
      
                CodeExpr (t^.Actual.Expr, pPassValue);
                IF Cast (cPassValue, t^.Actual.Formal, TypeIntCard) THEN WriteC (f, 'L'); END;
                CodeSepa (t^.Actual.Next);
;
(* line 2880 "" *)
      CodeActuals (t^.Actual.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2882 "" *)
   LOOP
      IF (t^.Kind # Tree.Actual) THEN EXIT; END;
      IF (t^.Actual.Expr^.Kind # Tree.Unary) THEN EXIT; END;
      IF (t^.Actual.Expr^.Unary.Mop^.Kind # Tree.IntConst) THEN EXIT; END;
(* line 2883 "" *)
      IF NOT (t^.Actual.Expr ^ . Unary . COperator = cMinus) THEN EXIT; END;
(* line 2884 "" *)
      
                CodeExpr (t^.Actual.Expr, pPassValue);
                IF Cast (cPassValue, t^.Actual.Formal, TypeIntCard) THEN WriteC (f, 'L'); END;
                CodeSepa (t^.Actual.Next);
;
(* line 2889 "" *)
      CodeActuals (t^.Actual.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2891 "" *)
   LOOP
      IF (t^.Kind # Tree.Actual) THEN EXIT; END;
      IF (t^.Actual.Expr^.Kind # Tree.Binary) THEN EXIT; END;
(* line 2892 "" *)
      IF NOT (t^.Actual.Expr ^ . Binary . Type = TypeBOOLEAN) THEN EXIT; END;
(* line 2893 "" *)
      
                IF OptionIsSet ('c') THEN
                  WriteS (f, '(BOOLEAN)'); CodeExpr (t^.Actual.Expr, pCast);
                ELSE
                  CodeExpr (t^.Actual.Expr, pPassValue);
                END;
                CodeSepa (t^.Actual.Next);
;
(* line 2901 "" *)
      CodeActuals (t^.Actual.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2903 "" *)
   LOOP
      IF (t^.Kind # Tree.Actual) THEN EXIT; END;
      IF (t^.Actual.Expr^.Kind # Tree.Unary) THEN EXIT; END;
(* line 2904 "" *)
      IF NOT (t^.Actual.Expr ^ . Unary . Type = TypeBOOLEAN) THEN EXIT; END;
(* line 2905 "" *)
      
                IF OptionIsSet ('c') THEN
                  WriteS (f, '(BOOLEAN)'); CodeExpr (t^.Actual.Expr, pCast);
                ELSE
                  CodeExpr (t^.Actual.Expr, pPassValue);
                END;
                CodeSepa (t^.Actual.Next);
;
(* line 2913 "" *)
      CodeActuals (t^.Actual.Next);
      RETURN;
   END (* LOOP *) ;

(* line 2915 "" *)
   LOOP
      IF (t^.Kind # Tree.Actual) THEN EXIT; END;
(* line 2916 "" *)
      
                IF Cast (cPassValue, t^.Actual.Formal, t^.Actual.Expr^.Expr.Type) THEN
                  CodeCast (t^.Actual.Formal); CodeExpr (t^.Actual.Expr, pCast);
                ELSE
                  CodeExpr (t^.Actual.Expr, pPassValue);
                END;
                CodeSepa (t^.Actual.Next);
;
(* line 2924 "" *)
      CodeActuals (t^.Actual.Next);
      RETURN;
   END (* LOOP *) ;

 END CodeActuals;

PROCEDURE CodeSepa (yyP7: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
(* line 2932 "" *)
   LOOP
      IF (yyP7^.Kind # Tree.VarIds1) THEN EXIT; END;
(* line 2937 "" *)
      WriteS (f, ', ');
      RETURN;
   END (* LOOP *) ;

(* line 2932 "" *)
   LOOP
      IF (yyP7^.Kind # Tree.ParIds1) THEN EXIT; END;
(* line 2937 "" *)
      WriteS (f, ', ');
      RETURN;
   END (* LOOP *) ;

(* line 2932 "" *)
   LOOP
      IF (yyP7^.Kind # Tree.FieldIds1) THEN EXIT; END;
(* line 2937 "" *)
      WriteS (f, ', ');
      RETURN;
   END (* LOOP *) ;

(* line 2932 "" *)
   LOOP
      IF (yyP7^.Kind # Tree.Formals1) THEN EXIT; END;
(* line 2937 "" *)
      WriteS (f, ', ');
      RETURN;
   END (* LOOP *) ;

(* line 2932 "" *)
   LOOP
      IF (yyP7^.Kind # Tree.FormalType) THEN EXIT; END;
(* line 2937 "" *)
      WriteS (f, ', ');
      RETURN;
   END (* LOOP *) ;

(* line 2932 "" *)
   LOOP
      IF (yyP7^.Kind # Tree.Actual) THEN EXIT; END;
(* line 2937 "" *)
      WriteS (f, ', ');
      RETURN;
   END (* LOOP *) ;

(* line 2938 "" *)
   LOOP
      IF NOT Tree.IsType (yyP7, Tree.Elems1) THEN EXIT; END;
(* line 2938 "" *)
      WriteS (f, ' | ');
      RETURN;
   END (* LOOP *) ;

 END CodeSepa;

PROCEDURE BeginCode;
 BEGIN
(* line 1022 "" *)

  Indent := 0;

  Precedence [cNoOp             ] := pMinPrec;
  Precedence [cNotEqual         ] := pNotEqual;
  Precedence [cTimes            ] := pTimes;
  Precedence [cPlus             ] := pPlus;
  Precedence [cMinus            ] := pMinus;
  Precedence [cDivide           ] := pDivide;
  Precedence [cLess             ] := pLess;
  Precedence [cLessEqual        ] := pLessEqual;
  Precedence [cEqual            ] := pEqual;
  Precedence [cGreater          ] := pGreater;
  Precedence [cGreaterEqual     ] := pGreaterEqual;
  Precedence [cAnd              ] := pAnd;
  Precedence [cIn               ] := pIn;
  Precedence [cMod              ] := pMod;
  Precedence [cNot              ] := pNot;
  Precedence [cOr               ] := pOr;
  Precedence [cUnion            ] := pUnion;
  Precedence [cDifference       ] := pDifference;
  Precedence [cIntersection     ] := pIntersection;
  Precedence [cSymDiff          ] := pSymDiff;
  Precedence [cIsSubset1        ] := pIsSubset1;
  Precedence [cIsSubset2        ] := pIsSubset2;
  Precedence [cAssign           ] := pAssign;
  Precedence [cPassValue        ] := pPassValue;
  Precedence [cPassAddress      ] := pPassAddress;

  BeginAssocTab;
  LabelStack.Begin;
  WithStack.Begin;


 END BeginCode;

PROCEDURE CloseCode;
 BEGIN
(* line 1056 "" *)

  CloseAssocTab;
  LabelStack.Close;
  WithStack.Close;


 END CloseCode;

PROCEDURE yyExit;
 BEGIN
  IO.CloseIO; System.Exit (1);
 END yyExit;

BEGIN
 yyf   := IO.StdOutput;
 Exit  := yyExit;
 BeginCode;
END Code.

