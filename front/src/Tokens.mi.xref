     1 (* handle token section *)
     2 
     3 (* $Id: Tokens.mi,v 2.2 1992/08/07 15:13:51 grosch rel $ *)
     4 
     5 (* $Log: Tokens.mi,v $
c    6  * Revision 2.2  1992/08/07  15:13:51  grosch
c    7  * allow several scanner and parsers; extend module Errors
c    8  *
c    9  * Revision 2.1  1991/11/21  14:47:50  grosch
c   10  * new version of RCS on SPARC
c   11  *
c   12  * Revision 2.0  91/03/08  18:26:43  grosch
c   13  * turned tables into initialized arrays (in C)
c   14  * moved mapping tokens -> strings from Errors to Parser
c   15  * changed interface for source position
c   16  * 
c   17  * Revision 1.1  90/06/11  18:45:48  grosch
c   18  * layout improvements
c   19  * 
c   20  * Revision 1.0  88/10/04  14:27:26  vielsack
c   21  * Initial revision
c   22  * 
c   23  *)
    24 
    25 IMPLEMENTATION MODULE Tokens;                                                 *     *
    26 
    27 FROM Lists      IMPORT MakeList, tList;                                       *     *     *
    28 FROM Strings    IMPORT tString, ArrayToString;                                *     *     *
    29 FROM StringMem  IMPORT tStringRef;                                            *     *
    30 FROM TokenTab   IMPORT Vocabulary,PosType;                                    *     *     *
    31 FROM Memory     IMPORT Alloc;                                                 *     *
    32 FROM Idents     IMPORT tIdent;                                                *     *
    33 FROM SYSTEM     IMPORT ADR, TSIZE;                                            *     *     *
    34 FROM TokenTab   IMPORT Terminal, MakeDefTerm,MakeTerm,CompleteDefTerm,TokenError;        30     *     *     *     *     *
    35 FROM Errors     IMPORT eFatal, eError, eIdent, eString, eInternal, ErrorMessageI;         *     *     *     *     *     *
                                                                                     *
    36 FROM Positions  IMPORT NoPosition;                                            *     *
    37 
    38   CONST
    39     eTokenDeclTwice     = 30;                                                 *
    40     eCodeExists         = 31;                                                 *
    41 
    42   TYPE
    43     Declarations = POINTER TO Declaration;                                    *     *
    44 
    45     Declaration = RECORD                                                      *
    46         Token     : tIdent;                                                   *    32
    47         TokenPos  : PosType;                                                  *    30
    48         CASE HasCoding : BOOLEAN OF                                           *     *
    49           TRUE:                                                               *
    50             EQUALPos  : PosType;                                              *    30
    51             NumberPos : PosType;                                              *    30
    52         END;
    53         Comment   : tList;                                                    *    27
    54         CommPos   : PosType;                                                  *    30
    55         Next      : Declarations;                                             *    43
    56       END;
    57 
    58   VAR
    59     TokensVars :                                                              *
    60       RECORD
    61         GlobalComment: tList;                                                 *    27
    62         GlobalCommPos: PosType;                                               *    30
    63         TOKENPos     : PosType;                                               *    30
    64         TOKENComment : tList;                                                 *    27
    65         TOKENCommPos : PosType;                                               *    30
    66       END;
    67     
    68     StartDecl : Declarations;                                                 *    43
    69     RDecl : Declarations;                                                     *    43
    70     WDecl : Declarations;                                                     *    43
    71     ReadyForReading : BOOLEAN;                                                *     *
    72 
    73   PROCEDURE  MakeGlobalHeader                                                 *
    74     ( GlobalComment : tList;                                                 61    27
    75       GlobalCommPos : PosType);                                              62    30
    76   
    77   BEGIN
    78     TokensVars.GlobalComment := GlobalComment;                               59    74    74
    79     TokensVars.GlobalCommPos := GlobalCommPos;                               59    75    75
    80   END MakeGlobalHeader;                                                      73
    81 
    82 
    83   PROCEDURE  MakeTokensHeader                                                 *
    84     ( TOKENPos      : PosType;                                               63    30
    85       TOKENComment  : tList;                                                 64    27
    86       TOKENCommPos  : PosType);                                              65    30
    87   
    88   (* Speichert globale Informationen ueber den zu TOKEN gehoerigen
c   89      Abschnitt *)
    90 
    91   BEGIN
    92     TokensVars.TOKENPos      := TOKENPos;                                    59    84    84
    93     TokensVars.TOKENComment  := TOKENComment;                                59    85    85
    94     TokensVars.TOKENCommPos  := TOKENCommPos;                                59    86    86
    95   END MakeTokensHeader;                                                      83
    96 
    97 
    98   PROCEDURE MakeDeclaration                                                   *
    99     (Token      : tIdent;                                                    46    32
   100      TokenPos   : PosType;                                                   47    30
   101      HasCoding  : BOOLEAN;                                                   48     *
   102      EQUALPos   : PosType;                                                    *    30
   103      Number     : Terminal;                                                   *    34
   104      NumberPos  : PosType;                                                   51    30
   105      Comment    : tList;                                                     53    27
   106      CommPos    : PosType);                                                  54    30
   107   
   108   (* Fuege neue Deklaration ein *)
   109 
   110   VAR HDecl : Declarations;                                                   *    43
   111       Error : TokenError;                                                     *    34
   112 
   113   BEGIN
   114     IF ReadyForReading THEN                                                  71
   115       ERROR ('MakeDeclaration: do not write');                                *
   116     END;
   117     HDecl := Alloc(TSIZE(Declaration));                                     110    31    33    45
   118     IF HDecl = NIL THEN                                                     110     *
   119       ERROR ('MakeDeclaration: Heap overflow');                               *
   120     END;
   121     HDecl^.Token       := Token;                                            110    99    99
   122     HDecl^.TokenPos    := TokenPos;                                         110   100   100
   123     HDecl^.HasCoding   := HasCoding;                                        110   101   101
   124     HDecl^.Next        := NIL;                                              110    55     *
   125     IF HasCoding THEN                                                       101
   126       MakeTerm(Token,Number,Error,TokenPos);                                 34    99   103   111   100
   127       IF Error = SymbolExists THEN                                          111     *
   128         ErrorMessageI (eTokenDeclTwice,eError,TokenPos,eIdent, ADR (Token));       35    39    35   100    35    33    99
   129         RETURN;
   130       ELSIF Error = CodeExists THEN                                         111     *
   131         ErrorMessageI (eCodeExists,eError,TokenPos,eIdent,ADR(Token));       35    40    35   100    35    33    99
   132         RETURN;
   133       END;
   134       HDecl^.EQUALPos  := EQUALPos;                                         110   102   102
   135       HDecl^.NumberPos := NumberPos;                                        110   104   104
   136     ELSE
   137       MakeDefTerm(Token,Error,TokenPos);                                     34    99   111   100
   138       IF Error = SymbolExists THEN                                          111     *
   139         ErrorMessageI(eTokenDeclTwice,eError,TokenPos,eIdent,ADR(Token));    35    39    35   100    35    33    99
   140         RETURN;
   141       END;
   142     END;
   143     HDecl^.Comment     := Comment;                                          110   105   105
   144     HDecl^.CommPos     := CommPos;                                          110   106   106
   145     IF WDecl = NIL THEN                                                      70     *
   146       (* Einfuegen des ersten Elementes *)
   147       StartDecl := HDecl;                                                    68   110
   148     ELSE
   149       WDecl^.Next := HDecl;                                                  70    55   110
   150     END;
   151     WDecl := HDecl;                                                          70   110
   152   END MakeDeclaration;                                                       98
   153 
   154 
   155   PROCEDURE CompleteDeclarations;                                             *
   156 
   157   VAR Error : TokenError;                                                   111    34
   158 
   159   BEGIN
   160     RDecl := StartDecl;                                                      69    68
   161     WHILE RDecl <> NIL DO                                                    69     *
   162       IF NOT RDecl^.HasCoding THEN                                           69   101
   163         CompleteDefTerm(RDecl^.Token,Error);                                 34    69    99   157
   164         IF Error = NotExists THEN                                           157     *
   165           ERROR ('CompleteDeclarations: token does not exists');              *
   166         ELSIF Error = CodeExists THEN                                       157     *
   167           ERROR ('CompleteDeclarations: token already complete');             *
   168         ELSIF Error = NotTerm  THEN                                         157     *
   169           ERROR ('CompleteDeclarations: token is nonterminal');               *
   170         END;
   171       END;
   172       RDecl := RDecl^.Next;                                                  69    69    55
   173     END;
   174     RDecl := StartDecl;                                                      69    68
   175     ReadyForReading := TRUE;                                                 71     *
   176   END CompleteDeclarations;                                                 155
   177 
   178 
   179   PROCEDURE  GetGlobalHeader                                                  *
   180     (VAR GlobalComment : tList;                                              74    27
   181      VAR GlobalCommPos : PosType);                                           75    30
   182 
   183   (* liest die mit MakeGlobalHeader abgelegte Information *)
   184 
   185   BEGIN
   186     GlobalComment := TokensVars.GlobalComment;                              180    59   180
   187     GlobalCommPos := TokensVars.GlobalCommPos;                              181    59   181
   188   END GetGlobalHeader;                                                      179
   189 
   190 
   191   PROCEDURE  GetTokensHeader                                                  *
   192     (VAR TOKENPos      : PosType;                                            84    30
   193      VAR TOKENComment  : tList;                                              85    27
   194      VAR TOKENCommPos  : PosType);                                           86    30
   195 
   196   (* liest die mit MakeTokensHeader abgelegte Information *)
   197 
   198   BEGIN
   199     TOKENPos      := TokensVars.TOKENPos;                                   192    59   192
   200     TOKENComment  := TokensVars.TOKENComment;                               193    59   193
   201     TOKENCommPos  := TokensVars.TOKENCommPos;                               194    59   194
   202   END GetTokensHeader;                                                      191
   203 
   204    
   205   PROCEDURE GetDeclaration                                                    *
   206     (VAR Token      : tIdent;                                                99    32
   207      VAR TokenPos   : PosType;                                              100    30
   208      VAR HasCoding  : BOOLEAN;                                              101     *
   209      VAR EQUALPos   : PosType;                                              102    30
   210      VAR NumberPos  : PosType;                                              104    30
   211      VAR Comment    : tList;                                                105    27
   212      VAR CommPos    : PosType) : BOOLEAN ;                                  106    30     *
   213   
   214   (* liefert die naechste Deklaration, falls vorhanden. Ansonsten wird
c  215      FALSE zurueckgegeben.  *)
   216 
   217   BEGIN
   218     IF NOT ReadyForReading THEN                                              71
   219       ERROR ('GetDeclaration: do not read');                                  *
   220     END;
   221     IF RDecl = NIL THEN                                                      69     *
   222       RETURN FALSE;                                                           *
   223     ELSE
   224       Token       := RDecl^.Token;                                          206    69   206
   225       TokenPos    := RDecl^.TokenPos;                                       207    69   207
   226       HasCoding   := RDecl^.HasCoding;                                      208    69   208
   227       IF HasCoding THEN                                                     208
   228         EQUALPos  := RDecl^.EQUALPos;                                       209    69   209
   229         NumberPos := RDecl^.NumberPos;                                      210    69   210
   230       ELSE
   231         EQUALPos.Line    := 0;                                              209     *
   232         EQUALPos.Column  := 0;                                              209     *
   233         NumberPos.Line   := 0;                                              210     *
   234         NumberPos.Column := 0;                                              210     *
   235       END;
   236       Comment := RDecl^.Comment;                                            211    69   211
   237       CommPos := RDecl^.CommPos;                                            212    69   212
   238       RDecl   := RDecl^.Next;                                                69    69    55
   239       RETURN TRUE;                                                            *
   240     END;
   241   END GetDeclaration;                                                       205
   242 
   243   PROCEDURE ERROR (a: ARRAY OF CHAR);                                         *     *     *
   244   VAR s: tString;                                                             *    28
   245   BEGIN
   246     ArrayToString (a, s);                                                    28   243   244
   247     ErrorMessageI (eInternal, eFatal, NoPosition, eString, ADR (s));         35    35    35    36    35    33   244
   248   END ERROR;                                                                243
   249 
   250 BEGIN
   251   StartDecl := NIL;  (* Anker fuer Declaration *)                            68     *
   252   WDecl     := NIL;  (* Schreibzeiger *)                                     70     *
   253   RDecl     := NIL;  (* Lesezeiger    *)                                     69     *
   254   ReadyForReading := FALSE;                                                  71     *
   255   WITH TokensVars DO                                                         59
   256     MakeList (GlobalComment);                                                27   180
   257     GlobalCommPos.Line := 0;                                                181     *
   258     GlobalCommPos.Column := 0;                                              181     *
   259     MakeList (TOKENComment);                                                 27   193
   260     TOKENCommPos.Line := 0;                                                 194     *
   261     TOKENCommPos.Column := 0;                                               194     *
   262   END;
   263 END Tokens.                                                                  25
Cross reference: * is declaration, = is assignment

-A-
 a                              243*  246 
 ADR                             33*  128   131   139   247 
 Alloc                           31*  117 
 ArrayToString                   28*  246 

-B-
 BOOLEAN                         48    71   101   208   212 

-C-
 CHAR                           243 
 CodeExists                     130   166 
 Column                         232=  234=  258=  261=
 Comment                         53*  105*  143=  143   211*  236=  236 
 CommPos                         54*  106*  144=  144   212*  237=  237 
 CompleteDeclarations           155*  176 
 CompleteDefTerm                 34*  163 

-D-
 Declaration                     43    45*  117 
 Declarations                    43*   55    68    69    70   110 

-E-
 eCodeExists                     40*  131 
 eError                          35*  128   131   139 
 eFatal                          35*  247 
 eIdent                          35*  128   131   139 
 eInternal                       35*  247 
 EQUALPos                        50   102*  134=  134   209*  228=  228   231=  232=
 ERROR                          115   119   165   167   169   219   243*  248 
 Error                          111*  126   127   130   137   138   157*  163   164   166   168 
 ErrorMessageI                   35*  128   131   139   247 
 Errors                          35*
 eString                         35*  247 
 eTokenDeclTwice                 39*  128   139 

-F-
 FALSE                          222   254 

-G-
 GetDeclaration                 205*  241 
 GetGlobalHeader                179*  188 
 GetTokensHeader                191*  202 
 GlobalComment                   61*   74*   78=   78   180*  186=  186   256 
 GlobalCommPos                   62*   75*   79=   79   181*  187=  187   257=  258=

-H-
 HasCoding                       48*  101*  123=  123   125   162   208*  226=  226   227 
 HDecl                          110*  117=  118   121=  122=  123=  124=  134=  135=  143=  144=  147   149   151 

-I-
 Idents                          32*
 IMPLEMENTATION                  25*

-L-
 Line                           231=  233=  257=  260=
 Lists                           27*

-M-
 MakeDeclaration                 98*  152 
 MakeDefTerm                     34*  137 
 MakeGlobalHeader                73*   80 
 MakeList                        27*  256   259 
 MakeTerm                        34*  126 
 MakeTokensHeader                83*   95 
 Memory                          31*

-N-
 Next                            55*  124=  149=  172   238 
 NIL                            118   124   145   161   221   251   252   253 
 NoPosition                      36*  247 
 NotExists                      164 
 NotTerm                        168 
 Number                         103*  126 
 NumberPos                       51*  104*  135=  135   210*  229=  229   233=  234=

-P-
 Positions                       36*
 PosType                         30*   47    50    51    54    62    63    65    75    84    86   100   102   104   106   181   192 
                                194   207   209   210   212 

-R-
 RDecl                           69*  160=  161   162   163   172=  172   174=  221   224   225   226   228   229   236   237   238=
                                238   253=
 ReadyForReading                 71*  114   175=  218   254=

-S-
 s                              244*  246   247 
 StartDecl                       68*  147=  160   174   251=
 StringMem                       29*
 Strings                         28*
 SymbolExists                   127   138 
 SYSTEM                          33*

-T-
 Terminal                        34*  103 
 tIdent                          32*   46    99   206 
 tList                           27*   53    61    64    74    85   105   180   193   211 
 Token                           46*   99*  121=  121   126   128   131   137   139   163   206*  224=  224 
 TOKENComment                    64*   85*   93=   93   193*  200=  200   259 
 TOKENCommPos                    65*   86*   94=   94   194*  201=  201   260=  261=
 TokenError                      34*  111   157 
 TOKENPos                        63*   84*   92=   92   192*  199=  199 
 TokenPos                        47*  100*  122=  122   126   128   131   137   139   207*  225=  225 
 Tokens                          25*  263 
 TokensVars                      59*   78=   79=   92=   93=   94=  186   187   199   200   201   255 
 TokenTab                        30*   34*
 TRUE                            49   175   239 
 TSIZE                           33*  117 
 tString                         28*  244 
 tStringRef                      29*

-V-
 Vocabulary                      30*

-W-
 WDecl                           70*  145   149=  151=  252=

end cross reference, 359 occurrences of 80 identifiers.
