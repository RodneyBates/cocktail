(* $Id: Parser.mi,v 2.8 1992/08/12 06:54:05 grosch rel $ *)
(* Skeleton parser for Cocktail lalr. *)
(* Modified Rodney M. Bates. Various times. *)

 UNSAFE MODULE Parser;

FROM SYSTEM IMPORT SHORTCARD;
IMPORT Word, SYSTEM, Scanner, Positions, Strings, DynArray, Sets, System;
IMPORT FrontErrors AS Errors 

(* line 2 "/tmp/lalr1305" *)
(* line 26 ../src/input.lalr *)

FROM Actions	IMPORT PutAction, PutComment, tActionMode, ScannerName, ParserName;
FROM Errors	IMPORT eError, eInteger, ErrorMessageI;
FROM Lists	IMPORT Append, IsEmpty, Head, Tail, MakeList, tList;
FROM Oper	IMPORT OperKind, MakePriority, CompletePriority, MakeOperator, MakeOperHeader;
FROM Scanner	IMPORT GetToken, tScanAttribute, Attribute, ErrorAttribute;
FROM Positions	IMPORT NoPosition;
FROM Strings	IMPORT AssignEmpty, tString, ArrayToString;
FROM StringMem	IMPORT PutString, tStringRef;
FROM Idents	IMPORT NoIdent, MakeIdent;

FROM TokenTab	IMPORT Terminal;
FROM Tokens	IMPORT MakeGlobalHeader, MakeTokensHeader, MakeDeclaration, CompleteDeclarations;
FROM Rules	IMPORT MakeRulesHeader, MakeLeafNode, MakeActionNode, MakeUnaryNode,
			MakeBracketNode, MakeBinaryNode, MakePrioAlternativeNode,
			MakeRule, Operation, NoExpression;

CONST
  cEol = '\012';	(* eol character *)
  eNumToBig = 9;

TYPE tParsAttribute = RECORD Scan: tScanAttribute; END;

VAR
  String		,
  EndOfLineString	: tString;
  EndOfLine		: ADDRESS;


CONST
   yyInitStackSize      = 100;
   yyNoState            = 0;

   yyFirstTerminal		= 0;
   yyLastTerminal		= 30;
   yyFirstSymbol		= 0;
   yyLastSymbol		= 62;
   yyTableMax		= 222;
   yyNTableMax		= 131;
   yyFirstReadState		= 1;
   yyLastReadState		= 62;
   yyFirstReadTermState		= 63;
   yyLastReadTermState		= 78;
   yyLastReadNontermState		= 96;
   yyFirstReduceState		= 97;
   yyLastReduceState		= 159;
   yyStartState		= 1;
   yyStopState		= 97;

   yyFirstFinalState    = yyFirstReadTermState;
   yyLastState          = yyLastReduceState;

TYPE
   yyTableElmt          = SHORTCARD;
   yyTCombRange         = yyTableElmt [0 .. yyTableMax];
   yyNCombRange         = yyTableElmt [yyLastTerminal + 1 .. yyNTableMax];
   yyStateRange         = yyTableElmt [0 .. yyLastState];
   yyReadRange          = yyTableElmt [yyFirstReadState .. yyLastReadState];
   yyReadReduceRange    = yyTableElmt 
                            [yyFirstReadTermState ..yyLastReadNontermState];
   yyReduceRange        = yyTableElmt [yyFirstReduceState .. yyLastReduceState];
   yySymbolRange        = yyTableElmt [yyFirstSymbol .. yyLastSymbol];
   yyTCombType          = RECORD Check, Next: yyStateRange; END;
   yyNCombType          = yyStateRange;
   yyTCombTypePtr       = UNTRACED BRANDED REF  yyTCombType;
   yyNCombTypePtr       = UNTRACED BRANDED REF  yyNCombType;
   yyStackPtrType       = yyTableElmt [ FIRST(yyTableElmt) .. LAST (yyTableElmt) ];
   yyStackType          = UNTRACED BRANDED REF  ARRAY yyStackPtrType OF yyStateRange;
   yyAttributeStackType = UNTRACED BRANDED REF  ARRAY yyStackPtrType OF tParsAttribute;

VAR
   yyTBasePtr           : ARRAY yyTableElmt [0 .. yyLastReadState] 
                          OF yyTCombTypePtr;
   yyNBasePtr           : ARRAY yyTableElmt [0 .. yyLastReadState]      
                          OF yyNCombTypePtr;
   yyDefault            : ARRAY yyTableElmt [0 .. yyLastReadState]      
                          OF yyReadRange  ;
   yyTComb              : ARRAY yyTCombRange            OF yyTCombType  ;
   yyNComb              : ARRAY yyNCombRange            OF yyNCombType  ;
   yyLength             : ARRAY yyReduceRange           OF yyTableElmt  ;
   yyLeftHandSide       : ARRAY yyReduceRange           OF yySymbolRange;
   yyContinuation       : ARRAY yyTableElmt [0 .. yyLastReadState]      
                          OF yySymbolRange;
   yyFinalToProd        : ARRAY yyReadReduceRange       OF yyReduceRange;
   yyIsInitialized      : BOOLEAN;
   yyTableFile          : System.tFile;

PROCEDURE TokenName (Token: SHORTCARD; VAR Name: ARRAY OF CHAR) =
   PROCEDURE Copy (READONLY Source: ARRAY OF CHAR; VAR Target: ARRAY OF CHAR) =
      VAR i, j: Word.T;
      BEGIN
         IF LAST (Source) < LAST (Target)
         THEN j := LAST (Source); ELSE j := LAST (Target); END;
         FOR i := 0 TO j DO Target [i] := Source [i]; END;
         IF LAST (Target) > j THEN Target [j + 1] := VAL (0,CHAR); END;
      END Copy;
   BEGIN
      CASE Token OF
      | 0=> Copy ("_EndOfFile", Name);
      | 1=> Copy ('=', Name);
      | 2=> Copy (':', Name);
      | 3=> Copy ('.', Name);
      | 4=> Copy ('|', Name);
      | 5=> Copy ('*', Name);
      | 6=> Copy ('+', Name);
      | 7=> Copy ("||", Name);
      | 8=> Copy ('(', Name);
      | 9=> Copy (')', Name);
      | 10=> Copy ('[', Name);
      | 11=> Copy (']', Name);
      | 12=> Copy ("EXPORT", Name);
      | 13=> Copy ("GLOBAL", Name);
      | 14=> Copy ("LOCAL", Name);
      | 15=> Copy ("BEGIN", Name);
      | 16=> Copy ("CLOSE", Name);
      | 17=> Copy ("TOKEN", Name);
      | 18=> Copy ("OPER", Name);
      | 19=> Copy ("NONE", Name);
      | 20=> Copy ("LEFT", Name);
      | 21=> Copy ("RIGHT", Name);
      | 22=> Copy ("RULE", Name);
      | 23=> Copy ("PREC", Name);
      | 24=> Copy ("Comment", Name);
      | 25=> Copy ("Number", Name);
      | 26=> Copy ("Action", Name);
      | 27=> Copy ("Identifier", Name);
      | 28=> Copy ("String", Name);
      | 29=> Copy ("SCANNER", Name);
      | 30=> Copy ("PARSER", Name);
      END;
   END TokenName;

PROCEDURE Parser (): Word.T =
(* line 33 "/tmp/lalr1305" *)
(* line 61 ../src/input.lalr *)
 VAR ActionMode : tActionMode; 
   VAR
      yyState           : yyStateRange;
      yyTerminal        : yySymbolRange;
      yyNonterminal     : yySymbolRange;        (* left-hand side symbol *)
      yyStackPtr        : yyStackPtrType;
      yyStateStackSize  : LONGINT;
      yyAttrStackSize   : LONGINT;
      yyShortStackSize  : yyStackPtrType;
      yyStateStack      : yyStackType;
      yyAttributeStack  : yyAttributeStackType;
      yySynAttribute    : tParsAttribute;       (* synthesized attribute *)
   yyRepairAttribute : Scanner.tScanAttribute;
      yyRepairToken     : yySymbolRange;
      yyTCombPtr        : yyTCombTypePtr;
      yyNCombPtr        : yyNCombTypePtr;
      yyIsRepairing     : BOOLEAN;
      yyErrorCount      : Word.T;
      yyTokenString     : ARRAY [0..127] OF CHAR;
   BEGIN
   BeginParser();
      yyState           := yyStartState;
   yyTerminal        := VAL ( Scanner.GetToken (),yySymbolRange);
      yyStateStackSize  := yyInitStackSize;
      yyAttrStackSize   := yyInitStackSize;
      DynArray.MakeArray 
        (yyStateStack, yyStateStackSize, SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 172
 $$ *).BYTESIZE (yyStateRange));
      DynArray.MakeArray 
        (yyAttributeStack, yyAttrStackSize, SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 174
 $$ *).BYTESIZE (tParsAttribute));
      yyShortStackSize  := VAL (   yyStateStackSize,yyStackPtrType ) - 1;
      yyStackPtr        := 0;
      yyErrorCount      := 0;
      yyIsRepairing     := FALSE;

      LOOP
         IF yyStackPtr >= yyShortStackSize THEN
            DynArray.ExtendArray 
              (yyStateStack, yyStateStackSize, SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 183
 $$ *).BYTESIZE (yyStateRange));
            DynArray.ExtendArray 
              (yyAttributeStack, yyAttrStackSize, 
               SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 186
 $$ *).BYTESIZE (tParsAttribute)
              );
            yyShortStackSize := VAL (   yyStateStackSize,yyStackPtrType ) - 1;
         END (* IF *) ;
         yyStateStack^ [yyStackPtr] := yyState;

         LOOP   (* SPEC State := Next (State, Terminal); terminal transition *)
            yyTCombPtr := LOOPHOLE 
                            ( LOOPHOLE ( yyTBasePtr [yyState] ,LONGCARD) 
                              + (VAL (   yyTerminal,LONGCARD ) 
                                * SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 196
 $$ *).BYTESIZE (yyTCombType))
                            ,yyTCombTypePtr);
            IF yyTCombPtr^.Check = yyState 
            THEN
               yyState := yyTCombPtr^.Next;
               EXIT;
            END (* IF *) ;
            yyState := yyDefault [yyState];

            IF yyState = yyNoState 
            THEN (* syntax error *)
               yyState := yyStateStack^ [yyStackPtr];
               IF yyIsRepairing 
               THEN (* repair *)
                  yyRepairToken := yyContinuation [yyState];
                  yyState := Next (yyState, yyRepairToken);
                  IF yyState <= yyLastReadTermState 
                  THEN (* read or read terminal reduce ? *)
                  Scanner.ErrorAttribute 
                       (VAL(yyRepairToken,INTEGER), yyRepairAttribute);
                     TokenName (yyRepairToken, yyTokenString);
                     Errors.ErrorMessageI 
                       (Errors.TokenInserted, Errors.Repair,
                     Scanner.Attribute.Position, Errors.Array, 
                        SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 220
 $$ *).ADR (yyTokenString[FIRST(yyTokenString)])
                       );
                     IF yyState >= yyFirstFinalState 
                     THEN (* avoid second push *)
                        yyState := yyFinalToProd [yyState];
                     END (* IF *) ;
                     INC (yyStackPtr);
                     yyAttributeStack^ [yyStackPtr].Scan := yyRepairAttribute;
                     yyStateStack^     [yyStackPtr] := yyState;
                  END (* IF *) ;
                  IF yyState >= yyFirstFinalState 
                  THEN (* final state ? *)
                    EXIT;
                  END (* IF *) ;
               ELSE (* report and recover *)
                  INC (yyErrorCount);
                  ErrorRecovery 
                    (yyTerminal, yyStateStack, yyStateStackSize, yyStackPtr);
                  yyIsRepairing := TRUE;
               END (* IF *) ;
            END (* IF *) ;
         END (* LOOP *) ;

         IF yyState >= yyFirstFinalState 
         THEN (* final state ? *)
            IF yyState <= yyLastReadTermState 
            THEN (* read terminal reduce ? *)
               INC (yyStackPtr);
            yyAttributeStack^ [yyStackPtr].Scan := Scanner.Attribute;
            yyTerminal := VAL(   Scanner.GetToken (),yySymbolRange );
               yyIsRepairing := FALSE;
            END (* IF *) ;

            LOOP (* reduce *)
CASE yyState OF
  | 97=> (* _0000_ : Grammar _EndOfFile .*)
  DynArray.ReleaseArray (yyStateStack, yyStateStackSize, SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 256
 $$ *).BYTESIZE (yyTableElmt));
  DynArray.ReleaseArray (yyAttributeStack, yyAttrStackSize, SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 257
 $$ *).BYTESIZE (tParsAttribute));
  RETURN yyErrorCount;

  | 98,96=> (* Grammar : CommentPart ScannerName ParserName Decl Tokens Oper Rules .*)
  DEC (yyStackPtr, 7); yyNonterminal := 38;
(* line 79 "/tmp/lalr1305" *)
  (* line 98 ../src/input.lalr *)
  
  MakeGlobalHeader (yyAttributeStack^[yyStackPtr+1].Scan.Comm(* $$ m2tom3 warning: application of variant field, possible cast of 'Comm' in line 265
 $$ *), yyAttributeStack^[yyStackPtr+1].Scan.Position);
  
  | 99=> (* ScannerName : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 32;
(* line 86 "/tmp/lalr1305" *)
  (* line 103 ../src/input.lalr *)
  
  ScannerName := NoIdent;
  
  | 100=> (* ScannerName : 'SCANNER' .*)
  DEC (yyStackPtr, 1); yyNonterminal := 32;
(* line 92 "/tmp/lalr1305" *)
  (* line 107 ../src/input.lalr *)
  
  ArrayToString ("Scanner", String); ScannerName := MakeIdent (String);
  
  | 101,64=> (* ScannerName : 'SCANNER' Identifier .*)
  DEC (yyStackPtr, 2); yyNonterminal := 32;
(* line 98 "/tmp/lalr1305" *)
  (* line 111 ../src/input.lalr *)
  
  ScannerName := yyAttributeStack^[yyStackPtr+2].Scan.Sym(* $$ m2tom3 warning: application of variant field, possible cast of 'Sym' in line 286
 $$ *);
  
  | 102=> (* ParserName : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 33;
(* line 105 "/tmp/lalr1305" *)
  (* line 116 ../src/input.lalr *)
  
  ParserName := NoIdent;
  
  | 103=> (* ParserName : 'PARSER' .*)
  DEC (yyStackPtr, 1); yyNonterminal := 33;
(* line 111 "/tmp/lalr1305" *)
  (* line 120 ../src/input.lalr *)
  
  ArrayToString ("Parser", String); ParserName  := MakeIdent (String);
  
  | 104,65=> (* ParserName : 'PARSER' Identifier .*)
  DEC (yyStackPtr, 2); yyNonterminal := 33;
(* line 117 "/tmp/lalr1305" *)
  (* line 124 ../src/input.lalr *)
  
  ParserName := yyAttributeStack^[yyStackPtr+2].Scan.Sym(* $$ m2tom3 warning: application of variant field, possible cast of 'Sym' in line 307
 $$ *);
  
  | 105,79=> (* Decl : Decl 'EXPORT' Decl_1 CommentPart Actions .*)
  DEC (yyStackPtr, 5); yyNonterminal := 34;
(* line 124 "/tmp/lalr1305" *)
  (* line 129 ../src/input.lalr *)
  
  PutComment(tActionMode.Export, yyAttributeStack^[yyStackPtr+2].Scan.Position, yyAttributeStack^[yyStackPtr+4].Scan.Comm(* $$ m2tom3 warning: application of variant field, possible cast of 'Comm' in line 314
 $$ *), yyAttributeStack^[yyStackPtr+4].Scan.Position);
  
  | 106,80=> (* Decl : Decl 'GLOBAL' Decl_2 CommentPart Actions .*)
  DEC (yyStackPtr, 5); yyNonterminal := 34;
(* line 130 "/tmp/lalr1305" *)
  (* line 133 ../src/input.lalr *)
  
  PutComment(tActionMode.Global, yyAttributeStack^[yyStackPtr+2].Scan.Position, yyAttributeStack^[yyStackPtr+4].Scan.Comm(* $$ m2tom3 warning: application of variant field, possible cast of 'Comm' in line 321
 $$ *), yyAttributeStack^[yyStackPtr+4].Scan.Position);
  
  | 107,81=> (* Decl : Decl 'LOCAL' Decl_3 CommentPart Actions .*)
  DEC (yyStackPtr, 5); yyNonterminal := 34;
(* line 136 "/tmp/lalr1305" *)
  (* line 137 ../src/input.lalr *)
  
  PutComment(tActionMode.Local, yyAttributeStack^[yyStackPtr+2].Scan.Position, yyAttributeStack^[yyStackPtr+4].Scan.Comm(* $$ m2tom3 warning: application of variant field, possible cast of 'Comm' in line 328
 $$ *), yyAttributeStack^[yyStackPtr+4].Scan.Position);
  
  | 108,82=> (* Decl : Decl 'BEGIN' Decl_4 CommentPart Actions .*)
  DEC (yyStackPtr, 5); yyNonterminal := 34;
(* line 142 "/tmp/lalr1305" *)
  (* line 141 ../src/input.lalr *)
  
  PutComment(tActionMode.Begin, yyAttributeStack^[yyStackPtr+2].Scan.Position, yyAttributeStack^[yyStackPtr+4].Scan.Comm(* $$ m2tom3 warning: application of variant field, possible cast of 'Comm' in line 335
 $$ *), yyAttributeStack^[yyStackPtr+4].Scan.Position);
  
  | 109,83=> (* Decl : Decl 'CLOSE' Decl_5 CommentPart Actions .*)
  DEC (yyStackPtr, 5); yyNonterminal := 34;
(* line 148 "/tmp/lalr1305" *)
  (* line 145 ../src/input.lalr *)
  
  PutComment(tActionMode.Close, yyAttributeStack^[yyStackPtr+2].Scan.Position, yyAttributeStack^[yyStackPtr+4].Scan.Comm(* $$ m2tom3 warning: application of variant field, possible cast of 'Comm' in line 342
 $$ *), yyAttributeStack^[yyStackPtr+4].Scan.Position);
  
  | 110=> (* Decl : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 34;

  | 111=> (* Decl_5 : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 44;
(* line 154 "/tmp/lalr1305" *)
  (* line 144 ../src/input.lalr *)
  ActionMode := tActionMode.Close;
  | 112=> (* Decl_4 : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 43;
(* line 156 "/tmp/lalr1305" *)
  (* line 140 ../src/input.lalr *)
  ActionMode := tActionMode.Begin;
  | 113=> (* Decl_3 : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 42;
(* line 158 "/tmp/lalr1305" *)
  (* line 136 ../src/input.lalr *)
  ActionMode := tActionMode.Local;
  | 114=> (* Decl_2 : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 41;
(* line 160 "/tmp/lalr1305" *)
  (* line 132 ../src/input.lalr *)
  ActionMode := tActionMode.Global;
  | 115=> (* Decl_1 : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 39;
(* line 162 "/tmp/lalr1305" *)
  (* line 128 ../src/input.lalr *)
  ActionMode := tActionMode.Export;
  | 116=> (* Actions : Action CommentPart .*)
  DEC (yyStackPtr, 2); yyNonterminal := 40;
(* line 166 "/tmp/lalr1305" *)
  (* line 151 ../src/input.lalr *)
  
  PutAction (ActionMode, yyAttributeStack^[yyStackPtr+1].Scan.Act(* $$ m2tom3 warning: application of variant field, possible cast of 'Act' in line 377
 $$ *), yyAttributeStack^[yyStackPtr+1].Scan.Position, yyAttributeStack^[yyStackPtr+2].Scan.Comm(* $$ m2tom3 warning: application of variant field, possible cast of 'Comm' in line 377
 $$ *), yyAttributeStack^[yyStackPtr+2].Scan.Position);
  
  | 117=> (* Actions : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 40;

  | 118=> (* Tokens : 'TOKEN' CommentPart Declarations .*)
  DEC (yyStackPtr, 3); yyNonterminal := 35;
(* line 174 "/tmp/lalr1305" *)
  (* line 157 ../src/input.lalr *)
  
  CompleteDeclarations();
  MakeTokensHeader( yyAttributeStack^[yyStackPtr+1].Scan.Position, yyAttributeStack^[yyStackPtr+2].Scan.Comm(* $$ m2tom3 warning: application of variant field, possible cast of 'Comm' in line 388
 $$ *), yyAttributeStack^[yyStackPtr+2].Scan.Position);
  
  | 119,84=> (* Declarations : Declarations Declaration .*)
  DEC (yyStackPtr, 2); yyNonterminal := 45;

  | 120,85=> (* Declarations : Declaration .*)
  DEC (yyStackPtr, 1); yyNonterminal := 45;

  | 121=> (* Declaration : Terminal Coding CommentPart .*)
  DEC (yyStackPtr, 3); yyNonterminal := 46;
(* line 185 "/tmp/lalr1305" *)
  (* line 166 ../src/input.lalr *)
  
  MakeDeclaration( yyAttributeStack^[yyStackPtr+1].Scan.Sym(* $$ m2tom3 warning: application of variant field, possible cast of 'Sym' in line 401
 $$ *), yyAttributeStack^[yyStackPtr+1].Scan.Position, yyAttributeStack^[yyStackPtr+2].Scan.HasCoding(* $$ m2tom3 warning: application of variant field, possible cast of 'HasCoding' in line 401
 $$ *), yyAttributeStack^[yyStackPtr+2].Scan.Position,
                   yyAttributeStack^[yyStackPtr+2].Scan.CodValue(* $$ m2tom3 warning: application of variant field, possible cast of 'CodValue' in line 402
 $$ *), yyAttributeStack^[yyStackPtr+2].Scan.CodNumbPos(* $$ m2tom3 warning: application of variant field, possible cast of 'CodNumbPos' in line 402
 $$ *), yyAttributeStack^[yyStackPtr+3].Scan.Comm(* $$ m2tom3 warning: application of variant field, possible cast of 'Comm' in line 402
 $$ *), yyAttributeStack^[yyStackPtr+3].Scan.Position);
  
  | 122,68=> (* Coding : '=' Number .*)
  DEC (yyStackPtr, 2); yyNonterminal := 48;
(* line 193 "/tmp/lalr1305" *)
  (* line 172 ../src/input.lalr *)
  
  yySynAttribute.Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 409
 $$ *) := Scanner.AttributeMode.Coding;
  IF (yyAttributeStack^[yyStackPtr+2].Scan.Value(* $$ m2tom3 warning: application of variant field, possible cast of 'Value' in line 410
 $$ *) > LAST(Terminal)) THEN
    ErrorMessageI (eNumToBig, eError, yyAttributeStack^[yyStackPtr+2].Scan.Position, eInteger, ADR(* $$ m2tom3 warning: unhandled ADR parameter 'ADR' in line 411
 $$ *) (yyAttributeStack^[yyStackPtr+2].Scan.Value(* $$ m2tom3 warning: application of variant field, possible cast of 'Value' in line 411
 $$ *)));
    yySynAttribute.Scan.HasCoding(* $$ m2tom3 warning: application of variant field, possible cast of 'HasCoding' in line 412
 $$ *)	:= FALSE;
    yySynAttribute.Scan.CodValue(* $$ m2tom3 warning: application of variant field, possible cast of 'CodValue' in line 413
 $$ *)	:= 0; (* Dummywert *)
    yySynAttribute.Scan.CodNumbPos(* $$ m2tom3 warning: application of variant field, possible cast of 'CodNumbPos' in line 414
 $$ *)	:= NoPosition;
  ELSE
    yySynAttribute.Scan.HasCoding(* $$ m2tom3 warning: application of variant field, possible cast of 'HasCoding' in line 416
 $$ *)	:= TRUE;
    yySynAttribute.Scan.CodValue(* $$ m2tom3 warning: application of variant field, possible cast of 'CodValue' in line 417
 $$ *)	:= yyAttributeStack^[yyStackPtr+2].Scan.Value(* $$ m2tom3 warning: application of variant field, possible cast of 'Value' in line 417
 $$ *);
    yySynAttribute.Scan.CodNumbPos(* $$ m2tom3 warning: application of variant field, possible cast of 'CodNumbPos' in line 418
 $$ *)	:= yyAttributeStack^[yyStackPtr+2].Scan.Position;
  END;
  
  | 123=> (* Coding : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 48;
(* line 209 "/tmp/lalr1305" *)
  (* line 186 ../src/input.lalr *)
  
  yySynAttribute.Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 426
 $$ *)		:= Scanner.AttributeMode.Coding;
  yySynAttribute.Scan.HasCoding(* $$ m2tom3 warning: application of variant field, possible cast of 'HasCoding' in line 427
 $$ *)	:= FALSE;
  yySynAttribute.Scan.CodValue(* $$ m2tom3 warning: application of variant field, possible cast of 'CodValue' in line 428
 $$ *)	:= 0; (* Dummywert *)
  yySynAttribute.Scan.CodNumbPos(* $$ m2tom3 warning: application of variant field, possible cast of 'CodNumbPos' in line 429
 $$ *)	:= NoPosition;
  
  | 124,86=> (* Oper : 'OPER' CommentPart Priorities .*)
  DEC (yyStackPtr, 3); yyNonterminal := 36;
(* line 219 "/tmp/lalr1305" *)
  (* line 194 ../src/input.lalr *)
  
  MakeOperHeader(yyAttributeStack^[yyStackPtr+1].Scan.Position, yyAttributeStack^[yyStackPtr+2].Scan.Comm(* $$ m2tom3 warning: application of variant field, possible cast of 'Comm' in line 436
 $$ *), yyAttributeStack^[yyStackPtr+2].Scan.Position);
  
  | 125=> (* Oper : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 36;

  | 126,87=> (* Priorities : Priority Priorities .*)
  DEC (yyStackPtr, 2); yyNonterminal := 49;

  | 127=> (* Priorities : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 49;

  | 128=> (* Priority : Associativity Operators CommentPart .*)
  DEC (yyStackPtr, 3); yyNonterminal := 50;
(* line 230 "/tmp/lalr1305" *)
  (* line 203 ../src/input.lalr *)
  
  CompletePriority(yyAttributeStack^[yyStackPtr+3].Scan.Comm(* $$ m2tom3 warning: application of variant field, possible cast of 'Comm' in line 452
 $$ *), yyAttributeStack^[yyStackPtr+3].Scan.Position);
  
  | 129,70=> (* Associativity : 'LEFT' .*)
  DEC (yyStackPtr, 1); yyNonterminal := 51;
(* line 236 "/tmp/lalr1305" *)
  (* line 207 ../src/input.lalr *)
  MakePriority(OperKind.Left, yyAttributeStack^[yyStackPtr+1].Scan.Position);
  | 130,71=> (* Associativity : 'RIGHT' .*)
  DEC (yyStackPtr, 1); yyNonterminal := 51;
(* line 238 "/tmp/lalr1305" *)
  (* line 208 ../src/input.lalr *)
  MakePriority(OperKind.Right, yyAttributeStack^[yyStackPtr+1].Scan.Position);
  | 131,69=> (* Associativity : 'NONE' .*)
  DEC (yyStackPtr, 1); yyNonterminal := 51;
(* line 240 "/tmp/lalr1305" *)
  (* line 209 ../src/input.lalr *)
  MakePriority(None, yyAttributeStack^[yyStackPtr+1].Scan.Position);
  | 132,89=> (* Operators : Operator Operators .*)
  DEC (yyStackPtr, 2); yyNonterminal := 52;

  | 133=> (* Operators : Operator .*)
  DEC (yyStackPtr, 1); yyNonterminal := 52;

  | 134,88=> (* Operator : Terminal .*)
  DEC (yyStackPtr, 1); yyNonterminal := 53;
(* line 247 "/tmp/lalr1305" *)
  (* line 215 ../src/input.lalr *)
  
  MakeOperator(yyAttributeStack^[yyStackPtr+1].Scan.Sym(* $$ m2tom3 warning: application of variant field, possible cast of 'Sym' in line 480
 $$ *), yyAttributeStack^[yyStackPtr+1].Scan.Position);
  
  | 135,66=> (* Terminal : Identifier .*)
  DEC (yyStackPtr, 1); yyNonterminal := 47;
(* line 254 "/tmp/lalr1305" *)
  (* line 220 ../src/input.lalr *)
  
  yySynAttribute.Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 487
 $$ *)		:= Scanner.AttributeMode.Symbol;
  yySynAttribute.Scan.Sym(* $$ m2tom3 warning: application of variant field, possible cast of 'Sym' in line 488
 $$ *)		:= yyAttributeStack^[yyStackPtr+1].Scan.Sym(* $$ m2tom3 warning: application of variant field, possible cast of 'Sym' in line 488
 $$ *);
  yySynAttribute.Scan.Position	:= yyAttributeStack^[yyStackPtr+1].Scan.Position;
  
  | 136,67=> (* Terminal : String .*)
  DEC (yyStackPtr, 1); yyNonterminal := 47;
(* line 262 "/tmp/lalr1305" *)
  (* line 226 ../src/input.lalr *)
  
  yySynAttribute.Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 496
 $$ *)		:= Scanner.AttributeMode.Symbol;
  yySynAttribute.Scan.Sym(* $$ m2tom3 warning: application of variant field, possible cast of 'Sym' in line 497
 $$ *)		:= yyAttributeStack^[yyStackPtr+1].Scan.Sym(* $$ m2tom3 warning: application of variant field, possible cast of 'Sym' in line 497
 $$ *);
  yySynAttribute.Scan.Position	:= yyAttributeStack^[yyStackPtr+1].Scan.Position;
  
  | 137=> (* Rules : 'RULE' CommentPart Rules_1 .*)
  DEC (yyStackPtr, 3); yyNonterminal := 37;
(* line 271 "/tmp/lalr1305" *)
  (* line 233 ../src/input.lalr *)
  
  MakeRulesHeader(yyAttributeStack^[yyStackPtr+1].Scan.Position, yyAttributeStack^[yyStackPtr+2].Scan.Comm(* $$ m2tom3 warning: application of variant field, possible cast of 'Comm' in line 505
 $$ *), yyAttributeStack^[yyStackPtr+2].Scan.Position);
  
  | 138=> (* Rules_1 : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 54;

  | 139,95=> (* Rules_1 : Rules_1 Rule .*)
  DEC (yyStackPtr, 2); yyNonterminal := 54;

  | 140=> (* Rule : Identifier ':' RightSide '.' CommentPart .*)
  DEC (yyStackPtr, 5); yyNonterminal := 55;
(* line 280 "/tmp/lalr1305" *)
  (* line 238 ../src/input.lalr *)
  
  MakeRule(yyAttributeStack^[yyStackPtr+1].Scan.Sym(* $$ m2tom3 warning: application of variant field, possible cast of 'Sym' in line 518
 $$ *),
           yyAttributeStack^[yyStackPtr+1].Scan.Position,
           yyAttributeStack^[yyStackPtr+2].Scan.Position,
           yyAttributeStack^[yyStackPtr+3].Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 521
 $$ *),
           yyAttributeStack^[yyStackPtr+5].Scan.Comm(* $$ m2tom3 warning: application of variant field, possible cast of 'Comm' in line 522
 $$ *),
           yyAttributeStack^[yyStackPtr+5].Scan.Position,
           yyAttributeStack^[yyStackPtr+4].Scan.Position,
           yyAttributeStack^[yyStackPtr+3].Scan.HasPrio(* $$ m2tom3 warning: application of variant field, possible cast of 'HasPrio' in line 525
 $$ *),   (* Prioritaet der letzten Alternative *)
           yyAttributeStack^[yyStackPtr+3].Scan.Position,
           yyAttributeStack^[yyStackPtr+3].Scan.PriSym(* $$ m2tom3 warning: application of variant field, possible cast of 'PriSym' in line 527
 $$ *),
           yyAttributeStack^[yyStackPtr+3].Scan.PriSymPos(* $$ m2tom3 warning: application of variant field, possible cast of 'PriSymPos' in line 528
 $$ *));
  
  | 141,93=> (* PrioPart : 'PREC' Terminal .*)
  DEC (yyStackPtr, 2); yyNonterminal := 57;
(* line 297 "/tmp/lalr1305" *)
  (* line 253 ../src/input.lalr *)
  
  yySynAttribute.Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 535
 $$ *)		:= Scanner.AttributeMode.PrioPart;
  yySynAttribute.Scan.HasPrio(* $$ m2tom3 warning: application of variant field, possible cast of 'HasPrio' in line 536
 $$ *)		:= TRUE;
  yySynAttribute.Scan.Position	:= yyAttributeStack^[yyStackPtr+1].Scan.Position;
  yySynAttribute.Scan.PriSym(* $$ m2tom3 warning: application of variant field, possible cast of 'PriSym' in line 538
 $$ *)		:= yyAttributeStack^[yyStackPtr+2].Scan.Sym(* $$ m2tom3 warning: application of variant field, possible cast of 'Sym' in line 538
 $$ *);
  yySynAttribute.Scan.PriSymPos(* $$ m2tom3 warning: application of variant field, possible cast of 'PriSymPos' in line 539
 $$ *)	:= yyAttributeStack^[yyStackPtr+2].Scan.Position;
  
  | 142=> (* PrioPart : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 57;
(* line 307 "/tmp/lalr1305" *)
  (* line 261 ../src/input.lalr *)
  
  yySynAttribute.Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 546
 $$ *)		:= Scanner.AttributeMode.PrioPart;
  yySynAttribute.Scan.HasPrio(* $$ m2tom3 warning: application of variant field, possible cast of 'HasPrio' in line 547
 $$ *)		:= FALSE;
  yySynAttribute.Scan.PriSymPos(* $$ m2tom3 warning: application of variant field, possible cast of 'PriSymPos' in line 548
 $$ *)	:= NoPosition;
  yySynAttribute.Scan.PriSym(* $$ m2tom3 warning: application of variant field, possible cast of 'PriSym' in line 549
 $$ *)		:= 0;
  
  | 143,94=> (* RightSide : Expressions PrioPart '|' RightSide .*)
  DEC (yyStackPtr, 4); yyNonterminal := 56;
(* line 317 "/tmp/lalr1305" *)
  (* line 269 ../src/input.lalr *)
  
  yySynAttribute.Scan		:= yyAttributeStack^[yyStackPtr+4].Scan;  (* PrioPart an Rule zurueckgeben *)
  yySynAttribute.Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 557
 $$ *)	:= Scanner.AttributeMode.RightSide;
  yySynAttribute.Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 558
 $$ *)	:=
  MakePrioAlternativeNode (yyAttributeStack^[yyStackPtr+3].Scan.Position,
                           yyAttributeStack^[yyStackPtr+1].Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 560
 $$ *),
                           yyAttributeStack^[yyStackPtr+4].Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 561
 $$ *),
                           yyAttributeStack^[yyStackPtr+2].Scan.HasPrio(* $$ m2tom3 warning: application of variant field, possible cast of 'HasPrio' in line 562
 $$ *),
                           yyAttributeStack^[yyStackPtr+2].Scan.Position,
                           yyAttributeStack^[yyStackPtr+2].Scan.PriSym(* $$ m2tom3 warning: application of variant field, possible cast of 'PriSym' in line 564
 $$ *),
                           yyAttributeStack^[yyStackPtr+2].Scan.PriSymPos(* $$ m2tom3 warning: application of variant field, possible cast of 'PriSymPos' in line 565
 $$ *));
  
  | 144=> (* RightSide : Expressions PrioPart .*)
  DEC (yyStackPtr, 2); yyNonterminal := 56;
(* line 332 "/tmp/lalr1305" *)
  (* line 282 ../src/input.lalr *)
  
  yySynAttribute.Scan		:= yyAttributeStack^[yyStackPtr+2].Scan;  (* Priopart an Rule zurueckgeben *)
  yySynAttribute.Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 573
 $$ *)	:= Scanner.AttributeMode.RightSide;
  IF yyAttributeStack^[yyStackPtr+1].Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 574
 $$ *) = Scanner.AttributeMode.Empty THEN
    yySynAttribute.Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 575
 $$ *)	:= NoExpression;
  ELSE
    yySynAttribute.Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 577
 $$ *)	:= yyAttributeStack^[yyStackPtr+1].Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 577
 $$ *);
  END;
  
  | 145,90=> (* Expressions : Expression Expressions .*)
  DEC (yyStackPtr, 2); yyNonterminal := 58;
(* line 345 "/tmp/lalr1305" *)
  (* line 293 ../src/input.lalr *)
  
  IF yyAttributeStack^[yyStackPtr+2].Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 585
 $$ *) # Scanner.AttributeMode.Empty
  THEN (* Binary *)
    yySynAttribute.Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 587
 $$ *)	:= Scanner.AttributeMode.RightSide;
    yySynAttribute.Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 588
 $$ *)	:= MakeBinaryNode(Operation.Sequence, NoPosition, yyAttributeStack^[yyStackPtr+1].Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 588
 $$ *), yyAttributeStack^[yyStackPtr+2].Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 588
 $$ *));
  ELSE (* Expressions ist leer - Expression ist weiterzureichen *)
    yySynAttribute.Scan	:= yyAttributeStack^[yyStackPtr+1].Scan;
  END; 
  
  | 146=> (* Expressions : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 58;
(* line 357 "/tmp/lalr1305" *)
  (* line 303 ../src/input.lalr *)
  
  yySynAttribute.Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 598
 $$ *)	:= Scanner.AttributeMode.Empty;  (* noetig damit kein 'leeres Bein' entsteht *)
  yySynAttribute.Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 599
 $$ *)	:= NoExpression;   (* noetig falls Expr weiterverwendet wird *)
  
  | 147=> (* Expression : Unit .*)
  DEC (yyStackPtr, 1); yyNonterminal := 59;
(* line 365 "/tmp/lalr1305" *)
  (* line 309 ../src/input.lalr *)
  
  yySynAttribute.Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 606
 $$ *)	:= Scanner.AttributeMode.RightSide;
  yySynAttribute.Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 607
 $$ *)	:= yyAttributeStack^[yyStackPtr+1].Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 607
 $$ *);
  
  | 148,75=> (* Expression : Unit '*' .*)
  DEC (yyStackPtr, 2); yyNonterminal := 59;
(* line 372 "/tmp/lalr1305" *)
  (* line 314 ../src/input.lalr *)
  
  yySynAttribute.Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 614
 $$ *)	:= Scanner.AttributeMode.RightSide;
  yySynAttribute.Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 615
 $$ *)	:= MakeUnaryNode(Operation.Star, yyAttributeStack^[yyStackPtr+2].Scan.Position, yyAttributeStack^[yyStackPtr+1].Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 615
 $$ *));
  
  | 149,76=> (* Expression : Unit '+' .*)
  DEC (yyStackPtr, 2); yyNonterminal := 59;
(* line 379 "/tmp/lalr1305" *)
  (* line 319 ../src/input.lalr *)
  
  yySynAttribute.Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 622
 $$ *)	:= Scanner.AttributeMode.RightSide;
  yySynAttribute.Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 623
 $$ *)	:= MakeUnaryNode(Operation.Plus, yyAttributeStack^[yyStackPtr+2].Scan.Position, yyAttributeStack^[yyStackPtr+1].Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 623
 $$ *));
  
  | 150,91=> (* Expression : Unit '||' Unit .*)
  DEC (yyStackPtr, 3); yyNonterminal := 59;
(* line 386 "/tmp/lalr1305" *)
  (* line 324 ../src/input.lalr *)
  
  yySynAttribute.Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 630
 $$ *)	:= Scanner.AttributeMode.RightSide;
  yySynAttribute.Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 631
 $$ *)	:= MakeBinaryNode(Operation.Separator, yyAttributeStack^[yyStackPtr+2].Scan.Position , yyAttributeStack^[yyStackPtr+1].Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 631
 $$ *), yyAttributeStack^[yyStackPtr+3].Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 631
 $$ *));
  
  | 151,77=> (* Unit : '[' Alternative ']' .*)
  DEC (yyStackPtr, 3); yyNonterminal := 60;
(* line 394 "/tmp/lalr1305" *)
  (* line 330 ../src/input.lalr *)
  
  yySynAttribute.Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 638
 $$ *)	:= Scanner.AttributeMode.RightSide;
  yySynAttribute.Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 639
 $$ *)	:= MakeBracketNode(Operation.Optional, yyAttributeStack^[yyStackPtr+1].Scan.Position, yyAttributeStack^[yyStackPtr+3].Scan.Position, yyAttributeStack^[yyStackPtr+2].Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 639
 $$ *));
  
  | 152,78=> (* Unit : '(' Alternative ')' .*)
  DEC (yyStackPtr, 3); yyNonterminal := 60;
(* line 401 "/tmp/lalr1305" *)
  (* line 335 ../src/input.lalr *)
  
  yySynAttribute.Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 646
 $$ *)	:= Scanner.AttributeMode.RightSide;
  yySynAttribute.Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 647
 $$ *)	:= MakeBracketNode(Operation.Bracket, yyAttributeStack^[yyStackPtr+1].Scan.Position, yyAttributeStack^[yyStackPtr+3].Scan.Position, yyAttributeStack^[yyStackPtr+2].Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 647
 $$ *));
  
  | 153,73=> (* Unit : Identifier .*)
  DEC (yyStackPtr, 1); yyNonterminal := 60;
(* line 408 "/tmp/lalr1305" *)
  (* line 340 ../src/input.lalr *)
  
  yySynAttribute.Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 654
 $$ *)	:= Scanner.AttributeMode.RightSide;
  yySynAttribute.Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 655
 $$ *)	:= MakeLeafNode(yyAttributeStack^[yyStackPtr+1].Scan.Sym(* $$ m2tom3 warning: application of variant field, possible cast of 'Sym' in line 655
 $$ *), yyAttributeStack^[yyStackPtr+1].Scan.Position);
  
  | 154,74=> (* Unit : String .*)
  DEC (yyStackPtr, 1); yyNonterminal := 60;
(* line 415 "/tmp/lalr1305" *)
  (* line 345 ../src/input.lalr *)
  
  yySynAttribute.Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 662
 $$ *)	:= Scanner.AttributeMode.RightSide;
  yySynAttribute.Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 663
 $$ *)	:= MakeLeafNode(yyAttributeStack^[yyStackPtr+1].Scan.Sym(* $$ m2tom3 warning: application of variant field, possible cast of 'Sym' in line 663
 $$ *), yyAttributeStack^[yyStackPtr+1].Scan.Position);
  
  | 155,72=> (* Unit : Action .*)
  DEC (yyStackPtr, 1); yyNonterminal := 60;
(* line 422 "/tmp/lalr1305" *)
  (* line 350 ../src/input.lalr *)
  
  yySynAttribute.Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 670
 $$ *)	:= Scanner.AttributeMode.RightSide;
  yySynAttribute.Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 671
 $$ *)	:= MakeActionNode (yyAttributeStack^[yyStackPtr+1].Scan.Act(* $$ m2tom3 warning: application of variant field, possible cast of 'Act' in line 671
 $$ *), yyAttributeStack^[yyStackPtr+1].Scan.Position);
  
  | 156,92=> (* Alternative : Expressions '|' Alternative .*)
  DEC (yyStackPtr, 3); yyNonterminal := 61;
(* line 430 "/tmp/lalr1305" *)
  (* line 356 ../src/input.lalr *)
  
  yySynAttribute.Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 678
 $$ *)	:= Scanner.AttributeMode.RightSide;
  yySynAttribute.Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 679
 $$ *)	:= MakeBinaryNode (Operation.Alternative, yyAttributeStack^[yyStackPtr+2].Scan.Position, yyAttributeStack^[yyStackPtr+1].Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 679
 $$ *), yyAttributeStack^[yyStackPtr+3].Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 679
 $$ *));
  
  | 157=> (* Alternative : Expressions .*)
  DEC (yyStackPtr, 1); yyNonterminal := 61;
(* line 437 "/tmp/lalr1305" *)
  (* line 361 ../src/input.lalr *)
  
  yySynAttribute.Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 686
 $$ *)	:= Scanner.AttributeMode.RightSide;
  IF yyAttributeStack^[yyStackPtr+1].Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 687
 $$ *) = Scanner.AttributeMode.Empty THEN
    yySynAttribute.Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 688
 $$ *)	:= NoExpression;
  ELSE
    yySynAttribute.Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 690
 $$ *)	:= yyAttributeStack^[yyStackPtr+1].Scan.Expr(* $$ m2tom3 warning: application of variant field, possible cast of 'Expr' in line 690
 $$ *);
  END;
  
  | 158,63=> (* CommentPart : CommentPart Comment .*)
  DEC (yyStackPtr, 2); yyNonterminal := 31;
(* line 449 "/tmp/lalr1305" *)
  (* line 371 ../src/input.lalr *)
  
  yySynAttribute.Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 698
 $$ *)	:= Scanner.AttributeMode.Comment;
  IF IsEmpty (yyAttributeStack^[yyStackPtr+1].Scan.Comm(* $$ m2tom3 warning: application of variant field, possible cast of 'Comm' in line 699
 $$ *)) THEN
    yySynAttribute.Scan.Position	:= yyAttributeStack^[yyStackPtr+2].Scan.Position;
    yySynAttribute.Scan.Comm(* $$ m2tom3 warning: application of variant field, possible cast of 'Comm' in line 701
 $$ *)		:= yyAttributeStack^[yyStackPtr+2].Scan.Comm(* $$ m2tom3 warning: application of variant field, possible cast of 'Comm' in line 701
 $$ *);
  ELSE
    Append (yyAttributeStack^[yyStackPtr+1].Scan.Comm(* $$ m2tom3 warning: application of variant field, possible cast of 'Comm' in line 703
 $$ *), EndOfLine);
    WHILE NOT IsEmpty (yyAttributeStack^[yyStackPtr+2].Scan.Comm(* $$ m2tom3 warning: application of variant field, possible cast of 'Comm' in line 704
 $$ *)) DO
      Append (yyAttributeStack^[yyStackPtr+1].Scan.Comm(* $$ m2tom3 warning: application of variant field, possible cast of 'Comm' in line 705
 $$ *), Head(yyAttributeStack^[yyStackPtr+2].Scan.Comm(* $$ m2tom3 warning: application of variant field, possible cast of 'Comm' in line 705
 $$ *)));
      Tail (yyAttributeStack^[yyStackPtr+2].Scan.Comm(* $$ m2tom3 warning: application of variant field, possible cast of 'Comm' in line 706
 $$ *));
    END;
    yySynAttribute.Scan.Position	:= yyAttributeStack^[yyStackPtr+1].Scan.Position;
    yySynAttribute.Scan.Comm(* $$ m2tom3 warning: application of variant field, possible cast of 'Comm' in line 709
 $$ *)		:= yyAttributeStack^[yyStackPtr+1].Scan.Comm(* $$ m2tom3 warning: application of variant field, possible cast of 'Comm' in line 709
 $$ *);
  END;
  
  | 159=> (* CommentPart : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 31;
(* line 467 "/tmp/lalr1305" *)
  (* line 387 ../src/input.lalr *)
  
  yySynAttribute.Scan.Mode(* $$ m2tom3 warning: application of variant field, possible cast of 'Mode' in line 717
 $$ *)		:= Scanner.AttributeMode.Comment;
  yySynAttribute.Scan.Position	:= NoPosition;
  MakeList (yySynAttribute.Scan.Comm(* $$ m2tom3 warning: application of variant field, possible cast of 'Comm' in line 719
 $$ *));
  
END;
              (* SPEC State 
                   := Next (Top (), Nonterminal); nonterminal transition *)
               yyNCombPtr 
                 := LOOPHOLE 
                      ( LOOPHOLE (yyNBasePtr [yyStateStack^ [yyStackPtr]],LONGCARD)
                        + (VAL (  yyNonterminal,LONGCARD )
                          * SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 728
 $$ *).BYTESIZE (yyNCombType))
                      ,yyNCombTypePtr);
               yyState := yyNCombPtr^;
               INC (yyStackPtr);
               yyAttributeStack^ [yyStackPtr] := yySynAttribute;
               IF yyState < yyFirstFinalState 
               THEN (* read nonterminal ? *)
                 EXIT 
               END (* IF *) ; 
            END (* LOOP *) ;

         ELSE (* read *)
            INC (yyStackPtr);
         yyAttributeStack^ [yyStackPtr].Scan := Scanner.Attribute;
         yyTerminal := VAL(Scanner.GetToken (),yySymbolRange);
            yyIsRepairing := FALSE;
         END (* IF *);
      END (* LOOP *) ;
   END Parser;

PROCEDURE ErrorRecovery (
      VAR Terminal      : yySymbolRange ;
          StateStack    : yyStackType   ;
          StackSize     : LONGINT       ;
          StackPtr      : yyStackPtrType) =
   VAR
      TokensSkipped     : BOOLEAN;
      ContinueSet       : Sets.tSet;
      RestartSet        : Sets.tSet;
      Token             : yySymbolRange;
      TokenArray        : ARRAY [0..127] OF CHAR;
      TokenString       : Strings.tString;
      ContinueString    : Strings.tString;
   BEGIN
   (* 1. report the error *)
         TokenName ( Terminal , TokenArray );
         Strings.ArrayToString (TokenArray, TokenString);
         Errors.ErrorMessageI (Errors.SyntaxError, Errors.Error, 
         Scanner.Attribute.Position, Errors.String, SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 766
 $$ *).ADR(TokenString) );

   (* 2. report the set of expected terminal symbols *)
      Sets.MakeSet (ContinueSet, yyLastTerminal);
      ComputeContinuation (StateStack, StackSize, StackPtr, ContinueSet);
      Strings.AssignEmpty (ContinueString);
      FOR Token := VAL(Sets.Minimum (ContinueSet),yySymbolRange) TO VAL(Sets.Maximum (ContinueSet),yySymbolRange) DO
         IF Sets.IsElement (VAL(Token,Sets.tElement), ContinueSet) THEN
            TokenName (Token, TokenArray);
            Strings.ArrayToString (TokenArray, TokenString);
            IF ((Strings.Length (ContinueString) + Strings.Length (TokenString) + 1) <= Strings.cMaxStrLength) THEN
               Strings.Concatenate (ContinueString, TokenString);
               Strings.Append (ContinueString, ' ');
            END;
         END;
      END;
      Errors.ErrorMessageI (Errors.ExpectedTokens, Errors.Information,
      Scanner.Attribute.Position, Errors.String, SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 783
 $$ *).ADR (ContinueString));
      Sets.ReleaseSet (ContinueSet);

   (* 3. compute the set of terminal symbols for restart of the parse *)
      Sets.MakeSet (RestartSet, yyLastTerminal);
      ComputeRestartPoints (StateStack, StackSize, StackPtr, RestartSet);

   (* 4. skip terminal symbols until a restart point is reached *)
      TokensSkipped := FALSE;
      WHILE NOT Sets.IsElement (VAL(Terminal,Sets.tElement), RestartSet) DO
      Terminal := VAL(Scanner.GetToken (),yySymbolRange);
         TokensSkipped := TRUE;
      END;
      Sets.ReleaseSet (RestartSet);

   (* 5. report the restart point *)
      IF TokensSkipped THEN
      Errors.ErrorMessage (Errors.RestartPoint, Errors.Information, Scanner.Attribute.Position);
      END;
   END ErrorRecovery;

(*
   compute the set of terminal symbols that can be accepted (read)
   in a given stack configuration (eventually after reduce actions)
*)

PROCEDURE ComputeContinuation (
          Stack         : yyStackType   ;
          StackSize     : LONGINT       ;
          StackPtr      : yyStackPtrType;
      VAR ContinueSet   : Sets.tSet     ) =
   VAR Terminal         : yySymbolRange;
   BEGIN
      Sets.AssignEmpty (ContinueSet);
      FOR Terminal := yyFirstTerminal TO yyLastTerminal DO
         IF IsContinuation (Terminal, Stack, StackSize, StackPtr) THEN
            Sets.Include (ContinueSet, VAL(Terminal,Sets.tElement));
         END;
      END;
   END ComputeContinuation;

(*
   check whether a given terminal symbol can be accepted (read)
   in a certain stack configuration (eventually after reduce actions)
*)

PROCEDURE IsContinuation (
      Terminal          : yySymbolRange ;
      ParseStack        : yyStackType   ;
      StackSize         : LONGINT       ;
      StackPtr          : yyStackPtrType): BOOLEAN =
   VAR
      State             : yyStackPtrType;
      Nonterminal       : yySymbolRange;
      Stack             : yyStackType;
   BEGIN
      DynArray.MakeArray (Stack, StackSize, SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 839
 $$ *).BYTESIZE (yyStateRange));
      FOR State := 0 TO StackPtr DO
         Stack^ [State] := ParseStack^ [State];
      END;
      State := Stack^ [StackPtr];
      LOOP
         Stack^ [StackPtr] := State;
         State := Next (State, Terminal);
         IF State = yyNoState THEN
            DynArray.ReleaseArray (Stack, StackSize, SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 848
 $$ *).BYTESIZE (yyStateRange));
            RETURN FALSE;
         END;
         IF State <= yyLastReadTermState THEN           (* read or read terminal reduce ? *)
            DynArray.ReleaseArray (Stack, StackSize, SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 852
 $$ *).BYTESIZE (yyStateRange));
            RETURN TRUE;
         END;

         LOOP                                           (* reduce *)
            IF State =  yyStopState THEN
               DynArray.ReleaseArray (Stack, StackSize, SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 858
 $$ *).BYTESIZE (yyStateRange));
               RETURN TRUE;
            ELSE 
               DEC (StackPtr, yyLength [State]);
               Nonterminal := yyLeftHandSide [State];
            END;

            State := Next (Stack^ [StackPtr], Nonterminal);
            IF StackPtr >= VAL (   StackSize,yyStackPtrType ) THEN
               DynArray.ExtendArray (Stack, StackSize, SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 867
 $$ *).BYTESIZE (yyStateRange));
            END;
            INC (StackPtr);
            IF State < yyFirstFinalState THEN EXIT; END; (* read nonterminal ? *)
            State := yyFinalToProd [State];             (* read nonterminal reduce *)
         END;
      END;
   END IsContinuation;

(*
   compute a set of terminal symbols that can be used to restart
   parsing in a given stack configuration. we simulate parsing until
   end of file using a suffix program synthesized by the function
   Continuation. All symbols acceptable in the states reached during
   the simulation can be used to restart parsing.
*)

PROCEDURE ComputeRestartPoints (
          ParseStack    : yyStackType   ;
          StackSize     : LONGINT       ;
          StackPtr      : yyStackPtrType;
      VAR RestartSet    : Sets.tSet     ) =
   VAR
      Stack             : yyStackType;
      State             : yyStackPtrType;
      Nonterminal       : yySymbolRange;
      ContinueSet       : Sets.tSet;
   BEGIN
      DynArray.MakeArray (Stack, StackSize, SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 895
 $$ *).BYTESIZE (yyStateRange));
      FOR State := 0 TO StackPtr DO
         Stack^ [State] := ParseStack^ [State];
      END;
      Sets.MakeSet (ContinueSet, yyLastTerminal);
      Sets.AssignEmpty (RestartSet);
      State := Stack^ [StackPtr];

      LOOP
         IF StackPtr >= VAL (   StackSize,yyStackPtrType ) THEN
            DynArray.ExtendArray (Stack, StackSize, SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 905
 $$ *).BYTESIZE (yyStateRange));
         END;
         Stack^ [StackPtr] := State;
         ComputeContinuation (Stack, StackSize, StackPtr, ContinueSet);
         Sets.Union (RestartSet, ContinueSet);
         State := Next (State, yyContinuation [State]);

         IF State >= yyFirstFinalState THEN             (* final state ? *)
            IF State <= yyLastReadTermState THEN        (* read terminal reduce ? *)
               INC (StackPtr);
               State := yyFinalToProd [State];
            END;

            LOOP                                        (* reduce *)
               IF State = yyStopState THEN
                  DynArray.ReleaseArray (Stack, StackSize, SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 920
 $$ *).BYTESIZE (yyStateRange));
                  Sets.ReleaseSet (ContinueSet);
                  RETURN;
               ELSE 
                  DEC (StackPtr, yyLength [State]);
                  Nonterminal := yyLeftHandSide [State];
               END;

               State := Next (Stack^ [StackPtr], Nonterminal);
               INC (StackPtr);
               IF State < yyFirstFinalState THEN EXIT; END; (* read nonterminal ? *)
               State := yyFinalToProd [State];          (* read nonterminal reduce *)
            END;
         ELSE                                           (* read *)
            INC (StackPtr);
         END;
      END;
   END ComputeRestartPoints;

(* access the parse table:   Next : State x Symbol -> State *)

PROCEDURE Next (State: yyStateRange; Symbol: yySymbolRange): yyStateRange =
   VAR
      TCombPtr          : yyTCombTypePtr;
      NCombPtr          : yyNCombTypePtr;
   BEGIN
      IF Symbol <= yyLastTerminal THEN
         LOOP
            TCombPtr 
              := LOOPHOLE 
                   ( LOOPHOLE (yyTBasePtr [State],LONGCARD) 
                     + (VAL (   Symbol,LONGCARD )
                       * SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 952
 $$ *).BYTESIZE (yyTCombType))
                   ,yyTCombTypePtr);
            IF TCombPtr^.Check # State THEN
               State := yyDefault [State];
               IF State = yyNoState THEN RETURN yyNoState; END;
            ELSE
               RETURN TCombPtr^.Next;
            END;
         END;
      ELSE
        NCombPtr 
          := LOOPHOLE 
               ( LOOPHOLE (yyNBasePtr [State],LONGCARD) 
                 + (VAL (   Symbol,LONGCARD )
                   * SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 966
 $$ *).BYTESIZE (yyNCombType))
               ,yyNCombTypePtr);
        RETURN NCombPtr^;
      END;
   END Next;

PROCEDURE yyGetTables() =
   VAR
      BlockSize, j, n   : Word.T;
      State     : yyStateRange;
      TBase     : ARRAY yyTableElmt[0 .. yyLastReadState] OF yyTCombRange;
      NBase     : ARRAY yyTableElmt[0 .. yyLastReadState] OF yyNCombRange;
   BEGIN
      BlockSize := 64000 DIV SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 979
 $$ *).BYTESIZE (yyTCombType);
      yyTableFile := System.OpenInput (ParsTabName);
      yyErrorCheck (Errors.OpenParseTable, yyTableFile);
      IF 
         ((yyGetTable (SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 983
 $$ *).ADR (TBase[FIRST(TBase)]         )) DIV SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 983
 $$ *).BYTESIZE (yyTCombRange ) - 1)
            # yyLastReadState) OR
         ((yyGetTable (SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 985
 $$ *).ADR (NBase[FIRST(NBase)]         )) DIV SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 985
 $$ *).BYTESIZE (yyNCombRange ) - 1)
            # yyLastReadState) OR
         ((yyGetTable (SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 987
 $$ *).ADR (yyDefault[FIRST(yyDefault)]     )) DIV SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 987
 $$ *).BYTESIZE (yyReadRange  ) - 1)
            # yyLastReadState) OR
         ((yyGetTable (SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 989
 $$ *).ADR (yyNComb[FIRST(yyNComb)]       )) DIV SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 989
 $$ *).BYTESIZE (yyNCombType  ))
            # (yyNTableMax - yyLastTerminal)) OR
         ((yyGetTable (SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 991
 $$ *).ADR (yyLength[FIRST(yyLength)]      )) DIV SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 991
 $$ *).BYTESIZE (yyTableElmt  ) - 1)
            # (yyLastReduceState - yyFirstReduceState)) OR
         ((yyGetTable (SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 993
 $$ *).ADR (yyLeftHandSide[FIRST(yyLeftHandSide)])) DIV SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 993
 $$ *).BYTESIZE (yySymbolRange) - 1)
            # (yyLastReduceState - yyFirstReduceState)) OR
         ((yyGetTable (SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 995
 $$ *).ADR (yyContinuation[FIRST(yyContinuation)])) DIV SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 995
 $$ *).BYTESIZE (yySymbolRange) - 1)
            # yyLastReadState) OR
         ((yyGetTable (SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 997
 $$ *).ADR (yyFinalToProd[FIRST(yyFinalToProd)] )) DIV SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 997
 $$ *).BYTESIZE (yyReduceRange) - 1)
            # (yyLastReadNontermState - yyFirstReadTermState))
      THEN
         Errors.ErrorMessage (Errors.WrongParseTable, Errors.Fatal, Positions.NoPosition);
      END;
      n := 0;
      j := 0;
      WHILE j <= yyTableMax DO
         INC (n, yyGetTable (SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 1005
 $$ *).ADR(* $$ m2tom3 warning: unhandled ADR parameter 'ADR' in line 1005
 $$ *) (yyTComb [VAL(j,yyStateRange)])) DIV SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 1005
 $$ *).BYTESIZE (yyTCombType));
         INC (j, BlockSize);
      END;
      IF n # (yyTableMax + 1) THEN 
         Errors.ErrorMessage (Errors.WrongParseTable, Errors.Fatal, Positions.NoPosition);
      END;
      System.Close (yyTableFile);

      FOR State := 1 TO yyLastReadState DO
         yyTBasePtr [State] := SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 1014
 $$ *).ADR(* $$ m2tom3 warning: unhandled ADR parameter 'ADR' in line 1014
 $$ *) (yyTComb [TBase [State]]);
      END;
      FOR State := 1 TO yyLastReadState DO
         yyNBasePtr [State] := SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 1017
 $$ *).ADR(* $$ m2tom3 warning: unhandled ADR parameter 'ADR' in line 1017
 $$ *) (yyNComb [NBase [State]]);
      END;
   END yyGetTables;

PROCEDURE yyGetTable (Address: SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 1021
 $$ *).ADDRESS): Word.T =
   VAR
      N         : INTEGER;
      Length    : yyTableElmt;
      LongLength : Word.T;
   BEGIN
      N := System.Read (yyTableFile, SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 1027
 $$ *).ADR (Length), SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 1027
 $$ *).BYTESIZE (yyTableElmt));
      yyErrorCheck (Errors.ReadParseTable, N);
      LongLength := VAL ( Word.T  Length, );
      N := System.Read (yyTableFile, Address, LongLength);
      yyErrorCheck (Errors.ReadParseTable, N);
      RETURN LongLength;
   END yyGetTable;

PROCEDURE yyErrorCheck (ErrorCode: INTEGER; Info: INTEGER) =
   VAR ErrNo: INTEGER;
   BEGIN
     IF Info < 0 THEN
        ErrNo := System.ErrNum ();
        Errors.ErrorMessageI (ErrorCode, Errors.Fatal, Positions.NoPosition,
           Errors.Integer, SYSTEM(* $$ m2tom3 warning: unable to resolve qualification 'SYSTEM' in line 1041
 $$ *).ADR (ErrNo));
     END;
   END yyErrorCheck;

PROCEDURE BeginParser() =
   BEGIN
(* line 37 "/tmp/lalr1305" *)
(* line 55 ../src/input.lalr *)

  AssignEmpty (EndOfLineString);
  Strings.Append (EndOfLineString, cEol);
  EndOfLine := LOOPHOLE (PutString (EndOfLineString),ADDRESS);

      IF NOT yyIsInitialized THEN
         yyIsInitialized := TRUE;
         yyGetTables();
      END;
   END BeginParser;

PROCEDURE CloseParser() =
   BEGIN

   END CloseParser;

BEGIN
    yyIsInitialized := FALSE;
    ParsTabName := "Parser.Tab";
END Parser.

