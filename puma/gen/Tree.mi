IMPLEMENTATION MODULE Tree;



IMPORT SYSTEM, System, General, Memory, DynArray, IO, Layout, StringMem, Strings, Idents, Texts, Sets, Positions;
(* line 194 "" *)


FROM SYSTEM     IMPORT ADR, ADDRESS, TSIZE;
FROM DynArray   IMPORT MakeArray;
FROM IO         IMPORT tFile, StdOutput, ReadI, WriteS, WriteI, WriteC, WriteNl;
FROM Strings    IMPORT tString, ArrayToString, Concatenate, Length, Char;
FROM StringMem  IMPORT tStringRef, WriteString;
FROM Idents     IMPORT tIdent, NoIdent, GetString, WriteIdent, MakeIdent, MaxIdent;
FROM Texts      IMPORT tText, MakeText;
FROM Sets       IMPORT tSet, Include, IsElement, MakeSet;
FROM Relations  IMPORT tRelation, IsRelated, MakeRelation;
FROM Positions  IMPORT tPosition;

IMPORT Relations, Errors;







CONST Backslash = 134C ; (* This code goes through cpp (via cg), as well as into
                            a modula-2 compiler.  cpp chokes on 
                            quote-backslash-quote. *)  

VAR IdentToClassPtr     : POINTER TO ARRAY [0..1000000] OF tTree;
VAR IdentToClassSize    : LONGINT;
VAR sIdentToClassSize   : tIdent;

PROCEDURE InitIdentifyClass (t: tTree);
   VAR i: INTEGER;
   BEGIN
      IdentToClassSize := MaxIdent () + 1;
      sIdentToClassSize := IdentToClassSize;
      MakeArray (IdentToClassPtr, IdentToClassSize, TSIZE (tTree));
      FOR i := 0 TO IdentToClassSize - 1 DO
         IdentToClassPtr^ [i] := NoTree;
      END;
      ForallClasses (t, InitIdentifyClass2);
   END InitIdentifyClass;

PROCEDURE InitIdentifyClass2 (t: tTree);
   BEGIN
      IdentToClassPtr^ [t^.Class.Name] := t;
   END InitIdentifyClass2;

PROCEDURE IdentifyClass (t: tTree; Ident: tIdent): tTree;
   BEGIN
      IF Ident < sIdentToClassSize THEN RETURN IdentToClassPtr^ [Ident]; END;
      RETURN NoTree;
   END IdentifyClass;

(* Return Attribute node for attribute "Ident" of class "t" *) 
PROCEDURE IdentifyAttribute (t: tTree; Ident: tIdent): tTree;
   VAR attribute        : tTree;
   BEGIN
      LOOP
         CASE t^.Kind OF
         | Class:
               attribute := IdentifyAttribute (t^.Class.BaseClass, Ident);
               IF attribute # NoTree THEN RETURN attribute; END;
               t := t^.Class.Attributes;
                        (* RETURN IdentifyAttribute (t^.Class.Attributes, Ident); *)
         | Child:
               IF t^.Child.Name = Ident THEN RETURN t; END;
               t := t^.Child.Next;
                        (* RETURN IdentifyAttribute (t^.Child.Next, Ident); *)
         | Attribute:
               IF t^.Attribute.Name = Ident THEN RETURN t; END;
               t := t^.Attribute.Next;
                        (* RETURN IdentifyAttribute (t^.Attribute.Next, Ident); *)
         | ActionPart:
               t := t^.ActionPart.Next;
                        (* RETURN IdentifyAttribute (t^.ActionPart.Next, Ident); *)
         ELSE
               RETURN NoTree;
         END;
      END;
   END IdentifyAttribute;

PROCEDURE ForallClasses (t: tTree; Proc: ProcOfT);
   BEGIN
      WHILE t^.Kind = Class DO
         Proc (t);
         ForallClasses (t^.Class.Extensions, Proc);
         t := t^.Class.Next;            (* ForallClasses (t^.Class.Next, Proc); *)
      END;
   END ForallClasses;

PROCEDURE ForallClassesExtensionsFirst (t: tTree; Proc: ProcOfT);
   BEGIN
      WHILE t^.Kind = Class DO
         ForallClassesExtensionsFirst (t^.Class.Extensions, Proc);
         Proc (t);
         t := t^.Class.Next;            (* ForallClassesExtensionsFirst (t^.Class.Next, Proc); *)
      END;
   END ForallClassesExtensionsFirst ;

(* R.M.B. *)
PROCEDURE ForallClassesPreAndPost (t: tTree; PreProc, PostProc : ProcOfT);
   BEGIN
      WHILE t^.Kind = Class DO
         PreProc (t);
         ForallClassesPreAndPost (t^.Class.Extensions, PreProc, PostProc);
         PostProc (t);
         t := t^.Class.Next;
      END;
   END ForallClassesPreAndPost;
(* R.M.B. end *)

PROCEDURE ForallAttributes (t: tTree; Proc: ProcOfT);
   BEGIN
      LOOP
         CASE t^.Kind OF
         | Class:
               ForallAttributes (t^.Class.BaseClass, Proc);
               t := t^.Class.Attributes; (* ForallAttributes (t^.Class.Attributes, Proc); *)
         | Child:
               Proc (t);
               t := t^.Child.Next;      (* ForallAttributes (t^.Child.Next, Proc); *)
         | Attribute:
               Proc (t);
               t := t^.Attribute.Next;  (* ForallAttributes (t^.Attribute.Next, Proc); *)
         | ActionPart:
               Proc (t);
               t := t^.ActionPart.Next; (* ForallAttributes (t^.ActionPart.Next, Proc); *)
         ELSE
               RETURN;
         END;
      END;
   END ForallAttributes;

PROCEDURE Error (ErrorCode: INTEGER; Pos: tPosition);
   BEGIN
      Errors.ErrorMessage (ErrorCode, Errors.Error, Pos);
      INC (ErrorCount);
   END Error;

PROCEDURE Warning (ErrorCode: INTEGER; Pos: tPosition);
   BEGIN
      Errors.ErrorMessage (ErrorCode, Errors.Warning, Pos);
   END Warning;

PROCEDURE Information (ErrorCode: INTEGER; Pos: tPosition);
   BEGIN
      Errors.ErrorMessage (ErrorCode, Errors.Information, Pos);
   END Information;

PROCEDURE ErrorI (ErrorCode: INTEGER; Pos: tPosition; iClass: INTEGER; iPtr: ADDRESS);
   BEGIN
      Errors.ErrorMessageI (ErrorCode, Errors.Error, Pos, iClass, iPtr);
      INC (ErrorCount);
   END ErrorI;

PROCEDURE WarningI (ErrorCode: INTEGER; Pos: tPosition; iClass: INTEGER; iPtr: ADDRESS);
   BEGIN
      Errors.ErrorMessageI (ErrorCode, Errors.Warning, Pos, iClass, iPtr);
   END WarningI;

PROCEDURE InformationI (ErrorCode: INTEGER; Pos: tPosition; iClass: INTEGER; iPtr: ADDRESS);
   BEGIN
      Errors.ErrorMessageI (ErrorCode, Errors.Information, Pos, iClass, iPtr);
   END InformationI;

PROCEDURE WI (i: tIdent); BEGIN WriteIdent (f, i); END WI;

PROCEDURE WE (i: tIdent);
   VAR s: tString; Ch: CHAR; j: SHORTCARD;
   BEGIN
      GetString (i, s);
      FOR j := 1 TO Length (s) DO
         Ch := Char (s, j);
         IF (Ch = '{') OR (Ch = '}') OR (Ch = Backslash) 
         THEN WriteC (f, Backslash); 
         END;
         WriteC (f, Ch);
      END;
   END WE;

PROCEDURE WN (n: INTEGER); BEGIN WriteI (f, n, 0); END WN;

(* line 501 "" *)
(* line 912 "" *)






























































































































































































































































































CONST yyBlockSize = 20480;

TYPE
 yytBlockPtr   = POINTER TO yytBlock;
 yytBlock      = RECORD
                    yyBlock    : ARRAY [1..yyBlockSize] OF CHAR;
                    yySuccessor: yytBlockPtr;
                 END;

VAR yyBlockList        : yytBlockPtr;
VAR yyMaxSize, yyi     : SHORTCARD;
VAR yyTypeRange        : ARRAY [0..138] OF SHORTCARD;

PROCEDURE yyAlloc (): tTree;
 VAR yyBlockPtr        : yytBlockPtr;
 BEGIN
  yyBlockPtr   := yyBlockList;
  yyBlockList  := Memory.Alloc (SYSTEM.TSIZE (yytBlock));
  yyBlockList^.yySuccessor := yyBlockPtr;
  yyPoolFreePtr        := SYSTEM.ADR (yyBlockList^.yyBlock);
  yyPoolMaxPtr := yyPoolFreePtr + yyBlockSize - yyMaxSize + 1;
  INC (HeapUsed, yyBlockSize);
  RETURN yyPoolFreePtr;
 END yyAlloc;

PROCEDURE MakeTree (yyKind: SHORTCARD): tTree;
 VAR yyByteCount       : LONGINT;
 VAR yyt       : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [yyKind] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := yyKind;
  RETURN yyt;
 END MakeTree;

PROCEDURE IsType (yyTree: tTree; yyKind: SHORTCARD): BOOLEAN;
 BEGIN
  RETURN (yyTree # NoTree) AND (yyKind <= yyTree^.Kind) AND (yyTree^.Kind <= yyTypeRange [yyKind]);
 END IsType;


PROCEDURE mClasses (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Classes] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Classes;
  RETURN yyt;
 END mClasses;

PROCEDURE mNoClass (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [NoClass] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := NoClass;
  RETURN yyt;
 END mNoClass;

PROCEDURE mClass (pName: tIdent; pProperties: tClassProperties; pAttributes: tTree; pExtensions: tTree; pNext: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Class] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Class;
  WITH yyt^.Class DO
   Name := pName;
   Properties := pProperties;
   Attributes := pAttributes;
   Extensions := pExtensions;
   Next := pNext;
    BaseClass  := NoTree; 
    Formals  := NoTree; 
    TypeDesc  := NoTree; 
    
    
  END;
  RETURN yyt;
 END mClass;

PROCEDURE mAttributes (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Attributes] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Attributes;
  RETURN yyt;
 END mAttributes;

PROCEDURE mNoAttribute (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [NoAttribute] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := NoAttribute;
  RETURN yyt;
 END mNoAttribute;

PROCEDURE mAttrOrAction (pNext: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [AttrOrAction] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := AttrOrAction;
  WITH yyt^.AttrOrAction DO
   Next := pNext;
  END;
  RETURN yyt;
 END mAttrOrAction;

PROCEDURE mChild (pNext: tTree; pName: tIdent; pType: tIdent; pProperties: tAttrProperties): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Child] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Child;
  WITH yyt^.Child DO
   Next := pNext;
   Name := pName;
   Type := pType;
   Properties := pProperties;
  END;
  RETURN yyt;
 END mChild;

PROCEDURE mAttribute (pNext: tTree; pName: tIdent; pType: tIdent; pProperties: tAttrProperties): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Attribute] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Attribute;
  WITH yyt^.Attribute DO
   Next := pNext;
   Name := pName;
   Type := pType;
   Properties := pProperties;
  END;
  RETURN yyt;
 END mAttribute;

PROCEDURE mActionPart (pNext: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [ActionPart] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := ActionPart;
  WITH yyt^.ActionPart DO
   Next := pNext;
  END;
  RETURN yyt;
 END mActionPart;

PROCEDURE mCodes (pExport: tText; pImport: tText; pGlobal: tText; pSpecWith: tText; pBodyWith: tText; pLocal: tText; pBegin: tText; pClose: tText; pExportLine: tPosition; pImportLine: tPosition; pGlobalLine: tPosition; pSpecWithLine: tPosition; pBodyWithLine: tPosition; pLocalLine: tPosition; pBeginLine: tPosition; pCloseLine: tPosition): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Codes] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Codes;
  WITH yyt^.Codes DO
   Export := pExport;
   Import := pImport;
   Global := pGlobal;
   SpecWith := pSpecWith;
   BodyWith := pBodyWith;
   Local := pLocal;
   Begin := pBegin;
   Close := pClose;
   ExportLine := pExportLine;
   ImportLine := pImportLine;
   GlobalLine := pGlobalLine;
   SpecWithLine := pSpecWithLine;
   BodyWithLine := pBodyWithLine;
   LocalLine := pLocalLine;
   BeginLine := pBeginLine;
   CloseLine := pCloseLine;
  END;
  RETURN yyt;
 END mCodes;

PROCEDURE mDesignators (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Designators] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Designators;
  RETURN yyt;
 END mDesignators;

PROCEDURE mNoDesignator (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [NoDesignator] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := NoDesignator;
  RETURN yyt;
 END mNoDesignator;

PROCEDURE mDesignator (pSelector: tIdent; pAttribute: tIdent; pPos: tPosition; pAttributePos: tPosition; pNext: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Designator] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Designator;
  WITH yyt^.Designator DO
   Selector := pSelector;
   Attribute := pAttribute;
   Pos := pPos;
   AttributePos := pAttributePos;
   Next := pNext;
    
    Type  := NoIdent; 
  END;
  RETURN yyt;
 END mDesignator;

PROCEDURE mIdent (pAttribute: tIdent; pPos: tPosition; pNext: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Ident] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Ident;
  WITH yyt^.Ident DO
   Attribute := pAttribute;
   Pos := pPos;
   Next := pNext;
    
  END;
  RETURN yyt;
 END mIdent;

PROCEDURE mRemote (pDesignators: tTree; pType: tIdent; pAttribute: tIdent; pPos: tPosition; pNext: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Remote] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Remote;
  WITH yyt^.Remote DO
   Designators := pDesignators;
   Type := pType;
   Attribute := pAttribute;
   Pos := pPos;
   Next := pNext;
  END;
  RETURN yyt;
 END mRemote;

PROCEDURE mAny (pCode: tStringRef; pNext: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Any] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Any;
  WITH yyt^.Any DO
   Code := pCode;
   Next := pNext;
  END;
  RETURN yyt;
 END mAny;

PROCEDURE mAnys (pLayouts: tTree; pNext: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Anys] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Anys;
  WITH yyt^.Anys DO
   Layouts := pLayouts;
   Next := pNext;
  END;
  RETURN yyt;
 END mAnys;

PROCEDURE mLayouts (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Layouts] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Layouts;
  RETURN yyt;
 END mLayouts;

PROCEDURE mNoLayout (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [NoLayout] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := NoLayout;
  RETURN yyt;
 END mNoLayout;

PROCEDURE mLayoutAny (pCode: tStringRef; pNext: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [LayoutAny] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := LayoutAny;
  WITH yyt^.LayoutAny DO
   Code := pCode;
   Next := pNext;
  END;
  RETURN yyt;
 END mLayoutAny;

PROCEDURE mNames (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Names] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Names;
  RETURN yyt;
 END mNames;

PROCEDURE mNoName (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [NoName] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := NoName;
  RETURN yyt;
 END mNoName;

PROCEDURE mName (pName: tIdent; pPos: tPosition; pNext: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Name] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Name;
  WITH yyt^.Name DO
   Name := pName;
   Pos := pPos;
   Next := pNext;
    
  END;
  RETURN yyt;
 END mName;

PROCEDURE mSpec (pTrafoName: tIdent; pTreeNames: tTree; pPublic: tTree; pExtern: tTree; pCodes: tTree; pRoutines: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Spec] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Spec;
  WITH yyt^.Spec DO
   TrafoName := pTrafoName;
   TreeNames := pTreeNames;
   Public := pPublic;
   Extern := pExtern;
   Codes := pCodes;
   Routines := pRoutines;
  END;
  RETURN yyt;
 END mSpec;

PROCEDURE mTreeNames (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [TreeNames] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := TreeNames;
  RETURN yyt;
 END mTreeNames;

PROCEDURE mNoTreeName (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [NoTreeName] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := NoTreeName;
  RETURN yyt;
 END mNoTreeName;

PROCEDURE mTreeName (pName: tIdent; pPos: tPosition; pNext: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [TreeName] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := TreeName;
  WITH yyt^.TreeName DO
   Name := pName;
   Pos := pPos;
   Next := pNext;
    Classes  := NoTree; 
    
    EmptyType  := NoTree; 
    UniversalClass  := NoTree; 
  END;
  RETURN yyt;
 END mTreeName;

PROCEDURE mRoutines (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Routines] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Routines;
  RETURN yyt;
 END mRoutines;

PROCEDURE mNoRoutine (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [NoRoutine] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := NoRoutine;
  RETURN yyt;
 END mNoRoutine;

PROCEDURE mRoutine (pNext: tTree; pName: tIdent; pPos: tPosition; pInParams: tTree; pOutParams: tTree; pExtern: tTree; pLocal: tText; pLocalLine: tPosition; pRules: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Routine] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Routine;
  WITH yyt^.Routine DO
   Next := pNext;
   Name := pName;
   Pos := pPos;
   InParams := pInParams;
   OutParams := pOutParams;
   Extern := pExtern;
   Local := pLocal;
   LocalLine := pLocalLine;
   Rules := pRules;
    InForm  := NoTree; 
    OutForm  := NoTree; 
    ParamDecls  := NoTree; 
    IsExtern  := FALSE; 
    Decisions  := NoTree; 
  END;
  RETURN yyt;
 END mRoutine;

PROCEDURE mProcedure (pNext: tTree; pName: tIdent; pPos: tPosition; pInParams: tTree; pOutParams: tTree; pExtern: tTree; pLocal: tText; pLocalLine: tPosition; pRules: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Procedure] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Procedure;
  WITH yyt^.Procedure DO
   Next := pNext;
   Name := pName;
   Pos := pPos;
   InParams := pInParams;
   OutParams := pOutParams;
   Extern := pExtern;
   Local := pLocal;
   LocalLine := pLocalLine;
   Rules := pRules;
    InForm  := NoTree; 
    OutForm  := NoTree; 
    ParamDecls  := NoTree; 
    IsExtern  := FALSE; 
    Decisions  := NoTree; 
  END;
  RETURN yyt;
 END mProcedure;

PROCEDURE mFunction (pNext: tTree; pName: tIdent; pPos: tPosition; pInParams: tTree; pOutParams: tTree; pExtern: tTree; pLocal: tText; pLocalLine: tPosition; pRules: tTree; pReturnParams: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Function] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Function;
  WITH yyt^.Function DO
   Next := pNext;
   Name := pName;
   Pos := pPos;
   InParams := pInParams;
   OutParams := pOutParams;
   Extern := pExtern;
   Local := pLocal;
   LocalLine := pLocalLine;
   Rules := pRules;
    InForm  := NoTree; 
    OutForm  := NoTree; 
    ParamDecls  := NoTree; 
    IsExtern  := FALSE; 
    Decisions  := NoTree; 
   ReturnParams := pReturnParams;
    ReturnForm  := NoTree; 
  END;
  RETURN yyt;
 END mFunction;

PROCEDURE mPredicate (pNext: tTree; pName: tIdent; pPos: tPosition; pInParams: tTree; pOutParams: tTree; pExtern: tTree; pLocal: tText; pLocalLine: tPosition; pRules: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Predicate] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Predicate;
  WITH yyt^.Predicate DO
   Next := pNext;
   Name := pName;
   Pos := pPos;
   InParams := pInParams;
   OutParams := pOutParams;
   Extern := pExtern;
   Local := pLocal;
   LocalLine := pLocalLine;
   Rules := pRules;
    InForm  := NoTree; 
    OutForm  := NoTree; 
    ParamDecls  := NoTree; 
    IsExtern  := FALSE; 
    Decisions  := NoTree; 
  END;
  RETURN yyt;
 END mPredicate;

PROCEDURE mParameters (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Parameters] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Parameters;
  RETURN yyt;
 END mParameters;

PROCEDURE mNoParameter (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [NoParameter] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := NoParameter;
  RETURN yyt;
 END mNoParameter;

PROCEDURE mParam (pIsRef: BOOLEAN; pName: tIdent; pPos: tPosition; pType: tTree; pNext: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Param] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Param;
  WITH yyt^.Param DO
   IsRef := pIsRef;
   Name := pName;
   Pos := pPos;
   Type := pType;
   Next := pNext;
  END;
  RETURN yyt;
 END mParam;

PROCEDURE mType (pName: tIdent; pPos: tPosition; pNames: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Type] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Type;
  WITH yyt^.Type DO
   Name := pName;
   Pos := pPos;
   Names := pNames;
  END;
  RETURN yyt;
 END mType;

PROCEDURE mRules (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Rules] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Rules;
  RETURN yyt;
 END mRules;

PROCEDURE mNoRule (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [NoRule] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := NoRule;
  RETURN yyt;
 END mNoRule;

PROCEDURE mRule (pLine: tPosition; pPatterns: tTree; pExprs: tTree; pExpr: tTree; pStatements: tTree; pNext: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Rule] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Rule;
  WITH yyt^.Rule DO
   Line := pLine;
   Patterns := pPatterns;
   Exprs := pExprs;
   Expr := pExpr;
   Statements := pStatements;
   Next := pNext;
    VarDecls  := NoTree; 
    HasTempos  := FALSE; 
    HasPatterns  := FALSE; 
    Tempo  := NoIdent; 
    
    Tests  := NoTree; 
    HasExit  := FALSE; 
    HasAssign  := FALSE; 
    HasTargetCode  := FALSE; 
    HasRejectOrFail  := FALSE; 
  END;
  RETURN yyt;
 END mRule;

PROCEDURE mPatterns (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Patterns] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Patterns;
  RETURN yyt;
 END mPatterns;

PROCEDURE mNoPattern (pPos: tPosition): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [NoPattern] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := NoPattern;
  WITH yyt^.NoPattern DO
   Pos := pPos;
  END;
  RETURN yyt;
 END mNoPattern;

PROCEDURE mOnePattern (pPattern: tTree; pNext: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [OnePattern] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := OnePattern;
  WITH yyt^.OnePattern DO
   Pattern := pPattern;
   Next := pNext;
  END;
  RETURN yyt;
 END mOnePattern;

PROCEDURE mOnePatternAlts (pPatternsList: tTree; pNext: tTree; pCurrent: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [OnePatternAlts] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := OnePatternAlts;
  WITH yyt^.OnePatternAlts DO
   PatternsList := pPatternsList;
   Next := pNext;
   Current := pCurrent;
  END;
  RETURN yyt;
 END mOnePatternAlts;

PROCEDURE mPatternsList (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [PatternsList] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := PatternsList;
  RETURN yyt;
 END mPatternsList;

PROCEDURE mNoPatternsList (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [NoPatternsList] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := NoPatternsList;
  RETURN yyt;
 END mNoPatternsList;

PROCEDURE mOnePatternsList (pPatterns: tTree; pNext: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [OnePatternsList] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := OnePatternsList;
  WITH yyt^.OnePatternsList DO
   Patterns := pPatterns;
   Next := pNext;
  END;
  RETURN yyt;
 END mOnePatternsList;

PROCEDURE mPattern (pPos: tPosition): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Pattern] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Pattern;
  WITH yyt^.Pattern DO
   Pos := pPos;
    Tempo  := NoIdent; 
    TypeDesc  := NoTree; 
    Path  := NoTree; 
  END;
  RETURN yyt;
 END mPattern;

PROCEDURE mDecompose (pPos: tPosition; pSelector: tIdent; pExpr: tTree; pPatterns: tTree; pWiden: BOOLEAN): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Decompose] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Decompose;
  WITH yyt^.Decompose DO
   Pos := pPos;
    Tempo  := NoIdent; 
    TypeDesc  := NoTree; 
    Path  := NoTree; 
   Selector := pSelector;
   Expr := pExpr;
   Patterns := pPatterns;
   Widen := pWiden;
    
    IsProperlyNarrowed  := FALSE; 
  END;
  RETURN yyt;
 END mDecompose;

PROCEDURE mVarDef (pPos: tPosition; pSelector: tIdent; pHasDelimiter: BOOLEAN): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [VarDef] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := VarDef;
  WITH yyt^.VarDef DO
   Pos := pPos;
    Tempo  := NoIdent; 
    TypeDesc  := NoTree; 
    Path  := NoTree; 
   Selector := pSelector;
   HasDelimiter := pHasDelimiter;
    
  END;
  RETURN yyt;
 END mVarDef;

PROCEDURE mNilTest (pPos: tPosition; pSelector: tIdent; pWiden: BOOLEAN): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [NilTest] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := NilTest;
  WITH yyt^.NilTest DO
   Pos := pPos;
    Tempo  := NoIdent; 
    TypeDesc  := NoTree; 
    Path  := NoTree; 
   Selector := pSelector;
   Widen := pWiden;
    IsProperlyNarrowed  := FALSE; 
  END;
  RETURN yyt;
 END mNilTest;

PROCEDURE mDontCare1 (pPos: tPosition; pSelector: tIdent): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [DontCare1] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := DontCare1;
  WITH yyt^.DontCare1 DO
   Pos := pPos;
    Tempo  := NoIdent; 
    TypeDesc  := NoTree; 
    Path  := NoTree; 
   Selector := pSelector;
  END;
  RETURN yyt;
 END mDontCare1;

PROCEDURE mDontCare1Explicit (pPos: tPosition; pSelector: tIdent): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [DontCare1Explicit] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := DontCare1Explicit;
  WITH yyt^.DontCare1Explicit DO
   Pos := pPos;
    Tempo  := NoIdent; 
    TypeDesc  := NoTree; 
    Path  := NoTree; 
   Selector := pSelector;
  END;
  RETURN yyt;
 END mDontCare1Explicit;

PROCEDURE mDontCare1Internal (pPos: tPosition; pSelector: tIdent): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [DontCare1Internal] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := DontCare1Internal;
  WITH yyt^.DontCare1Internal DO
   Pos := pPos;
    Tempo  := NoIdent; 
    TypeDesc  := NoTree; 
    Path  := NoTree; 
   Selector := pSelector;
  END;
  RETURN yyt;
 END mDontCare1Internal;

PROCEDURE mDontCare (pPos: tPosition): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [DontCare] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := DontCare;
  WITH yyt^.DontCare DO
   Pos := pPos;
    Tempo  := NoIdent; 
    TypeDesc  := NoTree; 
    Path  := NoTree; 
    Tempos  := NoTree; 
  END;
  RETURN yyt;
 END mDontCare;

PROCEDURE mDontCareExplicit (pPos: tPosition): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [DontCareExplicit] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := DontCareExplicit;
  WITH yyt^.DontCareExplicit DO
   Pos := pPos;
    Tempo  := NoIdent; 
    TypeDesc  := NoTree; 
    Path  := NoTree; 
    Tempos  := NoTree; 
  END;
  RETURN yyt;
 END mDontCareExplicit;

PROCEDURE mDontCareInternal (pPos: tPosition): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [DontCareInternal] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := DontCareInternal;
  WITH yyt^.DontCareInternal DO
   Pos := pPos;
    Tempo  := NoIdent; 
    TypeDesc  := NoTree; 
    Path  := NoTree; 
    Tempos  := NoTree; 
  END;
  RETURN yyt;
 END mDontCareInternal;

PROCEDURE mValue (pPos: tPosition; pSelector: tIdent; pExpr: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Value] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Value;
  WITH yyt^.Value DO
   Pos := pPos;
    Tempo  := NoIdent; 
    TypeDesc  := NoTree; 
    Path  := NoTree; 
   Selector := pSelector;
   Expr := pExpr;
  END;
  RETURN yyt;
 END mValue;

PROCEDURE mExprs (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Exprs] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Exprs;
  RETURN yyt;
 END mExprs;

PROCEDURE mNoExpr (pPos: tPosition): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [NoExpr] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := NoExpr;
  WITH yyt^.NoExpr DO
   Pos := pPos;
  END;
  RETURN yyt;
 END mNoExpr;

PROCEDURE mOneExpr (pExpr: tTree; pNext: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [OneExpr] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := OneExpr;
  WITH yyt^.OneExpr DO
   Expr := pExpr;
   Next := pNext;
  END;
  RETURN yyt;
 END mOneExpr;

PROCEDURE mNamedExpr (pExpr: tTree; pNext: tTree; pName: tIdent; pNamePos: tPosition): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [NamedExpr] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := NamedExpr;
  WITH yyt^.NamedExpr DO
   Expr := pExpr;
   Next := pNext;
   Name := pName;
   NamePos := pNamePos;
  END;
  RETURN yyt;
 END mNamedExpr;

PROCEDURE mExpr (pPos: tPosition; pSelector: tIdent): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Expr] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Expr;
  WITH yyt^.Expr DO
   Pos := pPos;
   Selector := pSelector;
  END;
  RETURN yyt;
 END mExpr;

PROCEDURE mCompose (pPos: tPosition; pSelector: tIdent; pExpr: tTree; pExprs: tTree; pWiden: BOOLEAN): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Compose] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Compose;
  WITH yyt^.Compose DO
   Pos := pPos;
   Selector := pSelector;
   Expr := pExpr;
   Exprs := pExprs;
   Widen := pWiden;
    
    Tempo  := NoIdent; 
    TypeDesc  := NoTree; 
  END;
  RETURN yyt;
 END mCompose;

PROCEDURE mVarUse (pPos: tPosition; pSelector: tIdent; pName: tIdent; pWiden: BOOLEAN): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [VarUse] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := VarUse;
  WITH yyt^.VarUse DO
   Pos := pPos;
   Selector := pSelector;
   Name := pName;
   Widen := pWiden;
    
  END;
  RETURN yyt;
 END mVarUse;

PROCEDURE mAttrDesc (pPos: tPosition; pSelector: tIdent; pName: tIdent; pWiden: BOOLEAN; pAttribute: tIdent; pAttributePos: tPosition): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [AttrDesc] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := AttrDesc;
  WITH yyt^.AttrDesc DO
   Pos := pPos;
   Selector := pSelector;
   Name := pName;
   Widen := pWiden;
    
   Attribute := pAttribute;
   AttributePos := pAttributePos;
    Type  := NoIdent; 
  END;
  RETURN yyt;
 END mAttrDesc;

PROCEDURE mNil (pPos: tPosition; pSelector: tIdent; pWiden: BOOLEAN): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Nil] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Nil;
  WITH yyt^.Nil DO
   Pos := pPos;
   Selector := pSelector;
   Widen := pWiden;
  END;
  RETURN yyt;
 END mNil;

PROCEDURE mCall (pPos: tPosition; pSelector: tIdent; pExpr: tTree; pExprs: tTree; pPatterns: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Call] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Call;
  WITH yyt^.Call DO
   Pos := pPos;
   Selector := pSelector;
   Expr := pExpr;
   Exprs := pExprs;
   Patterns := pPatterns;
    
  END;
  RETURN yyt;
 END mCall;

PROCEDURE mBinary (pPos: tPosition; pSelector: tIdent; pLop: tTree; pOperator: tIdent; pRop: tTree; pWiden: BOOLEAN): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Binary] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Binary;
  WITH yyt^.Binary DO
   Pos := pPos;
   Selector := pSelector;
   Lop := pLop;
   Operator := pOperator;
   Rop := pRop;
   Widen := pWiden;
  END;
  RETURN yyt;
 END mBinary;

PROCEDURE myy1 (pPos: tPosition; pSelector: tIdent; pLop: tTree; pOperator: tIdent; pRop: tTree; pWiden: BOOLEAN): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [yy1] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := yy1;
  WITH yyt^.yy1 DO
   Pos := pPos;
   Selector := pSelector;
   Lop := pLop;
   Operator := pOperator;
   Rop := pRop;
   Widen := pWiden;
  END;
  RETURN yyt;
 END myy1;

PROCEDURE mBinaryCompound (pPos: tPosition; pSelector: tIdent; pLop: tTree; pOperator: tIdent; pRop: tTree; pWiden: BOOLEAN; pCompoundOperator: tIdent): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [BinaryCompound] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := BinaryCompound;
  WITH yyt^.BinaryCompound DO
   Pos := pPos;
   Selector := pSelector;
   Lop := pLop;
   Operator := pOperator;
   Rop := pRop;
   Widen := pWiden;
   CompoundOperator := pCompoundOperator;
  END;
  RETURN yyt;
 END mBinaryCompound;

PROCEDURE mPreOperator (pPos: tPosition; pSelector: tIdent; pOperator: tIdent; pExpr: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [PreOperator] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := PreOperator;
  WITH yyt^.PreOperator DO
   Pos := pPos;
   Selector := pSelector;
   Operator := pOperator;
   Expr := pExpr;
  END;
  RETURN yyt;
 END mPreOperator;

PROCEDURE mPostOperator (pPos: tPosition; pSelector: tIdent; pOperator: tIdent; pExpr: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [PostOperator] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := PostOperator;
  WITH yyt^.PostOperator DO
   Pos := pPos;
   Selector := pSelector;
   Operator := pOperator;
   Expr := pExpr;
  END;
  RETURN yyt;
 END mPostOperator;

PROCEDURE mIndex (pPos: tPosition; pSelector: tIdent; pExpr: tTree; pExprs: tTree; pWiden: BOOLEAN): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Index] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Index;
  WITH yyt^.Index DO
   Pos := pPos;
   Selector := pSelector;
   Expr := pExpr;
   Exprs := pExprs;
   Widen := pWiden;
  END;
  RETURN yyt;
 END mIndex;

PROCEDURE mParents (pPos: tPosition; pSelector: tIdent; pExpr: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Parents] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Parents;
  WITH yyt^.Parents DO
   Pos := pPos;
   Selector := pSelector;
   Expr := pExpr;
  END;
  RETURN yyt;
 END mParents;

PROCEDURE mTargetExpr (pPos: tPosition; pSelector: tIdent; pExpr: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [TargetExpr] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := TargetExpr;
  WITH yyt^.TargetExpr DO
   Pos := pPos;
   Selector := pSelector;
   Expr := pExpr;
    
  END;
  RETURN yyt;
 END mTargetExpr;

PROCEDURE mStringExpr (pPos: tPosition; pSelector: tIdent; pString: tStringRef): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [StringExpr] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := StringExpr;
  WITH yyt^.StringExpr DO
   Pos := pPos;
   Selector := pSelector;
   String := pString;
  END;
  RETURN yyt;
 END mStringExpr;

PROCEDURE mStatements (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Statements] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Statements;
  RETURN yyt;
 END mStatements;

PROCEDURE mNoStatement (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [NoStatement] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := NoStatement;
  RETURN yyt;
 END mNoStatement;

PROCEDURE mStatement (pPos: tPosition; pNext: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Statement] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Statement;
  WITH yyt^.Statement DO
   Pos := pPos;
   Next := pNext;
  END;
  RETURN yyt;
 END mStatement;

PROCEDURE mProcCall (pPos: tPosition; pNext: tTree; pCall: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [ProcCall] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := ProcCall;
  WITH yyt^.ProcCall DO
   Pos := pPos;
   Next := pNext;
   Call := pCall;
  END;
  RETURN yyt;
 END mProcCall;

PROCEDURE mCondition (pPos: tPosition; pNext: tTree; pExpr: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Condition] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Condition;
  WITH yyt^.Condition DO
   Pos := pPos;
   Next := pNext;
   Expr := pExpr;
  END;
  RETURN yyt;
 END mCondition;

PROCEDURE mAssignment (pPos: tPosition; pNext: tTree; pAdr: tTree; pExpr: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Assignment] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Assignment;
  WITH yyt^.Assignment DO
   Pos := pPos;
   Next := pNext;
   Adr := pAdr;
   Expr := pExpr;
    
  END;
  RETURN yyt;
 END mAssignment;

PROCEDURE mReject (pPos: tPosition; pNext: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Reject] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Reject;
  WITH yyt^.Reject DO
   Pos := pPos;
   Next := pNext;
  END;
  RETURN yyt;
 END mReject;

PROCEDURE mFail (pPos: tPosition; pNext: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Fail] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Fail;
  WITH yyt^.Fail DO
   Pos := pPos;
   Next := pNext;
  END;
  RETURN yyt;
 END mFail;

PROCEDURE mTargetStmt (pPos: tPosition; pNext: tTree; pParameters: tTree; pStmt: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [TargetStmt] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := TargetStmt;
  WITH yyt^.TargetStmt DO
   Pos := pPos;
   Next := pNext;
   Parameters := pParameters;
   Stmt := pStmt;
    
  END;
  RETURN yyt;
 END mTargetStmt;

PROCEDURE mNl (pPos: tPosition; pNext: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Nl] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Nl;
  WITH yyt^.Nl DO
   Pos := pPos;
   Next := pNext;
  END;
  RETURN yyt;
 END mNl;

PROCEDURE mWriteStr (pPos: tPosition; pNext: tTree; pString: tStringRef): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [WriteStr] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := WriteStr;
  WITH yyt^.WriteStr DO
   Pos := pPos;
   Next := pNext;
   String := pString;
  END;
  RETURN yyt;
 END mWriteStr;

PROCEDURE mFormals (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Formals] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Formals;
  RETURN yyt;
 END mFormals;

PROCEDURE mNoFormal (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [NoFormal] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := NoFormal;
  RETURN yyt;
 END mNoFormal;

PROCEDURE mFormal (pNext: tTree; pHides: tTree; pName: tIdent; pDeclPos: tPosition; pTypeDesc: tTree; pPath: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Formal] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Formal;
  WITH yyt^.Formal DO
   Next := pNext;
   Hides := pHides;
   Name := pName;
   DeclPos := pDeclPos;
   TypeDesc := pTypeDesc;
   Path := pPath;
  END;
  RETURN yyt;
 END mFormal;

PROCEDURE mPlainFormal (pNext: tTree; pHides: tTree; pName: tIdent; pDeclPos: tPosition; pTypeDesc: tTree; pPath: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [PlainFormal] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := PlainFormal;
  WITH yyt^.PlainFormal DO
   Next := pNext;
   Hides := pHides;
   Name := pName;
   DeclPos := pDeclPos;
   TypeDesc := pTypeDesc;
   Path := pPath;
  END;
  RETURN yyt;
 END mPlainFormal;

PROCEDURE mRoutineFormal (pNext: tTree; pHides: tTree; pName: tIdent; pDeclPos: tPosition; pTypeDesc: tTree; pPath: tTree; pTargetClass: tTree; pDeclaredTypeIsGuaranteed: BOOLEAN): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [RoutineFormal] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := RoutineFormal;
  WITH yyt^.RoutineFormal DO
   Next := pNext;
   Hides := pHides;
   Name := pName;
   DeclPos := pDeclPos;
   TypeDesc := pTypeDesc;
   Path := pPath;
   TargetClass := pTargetClass;
   DeclaredTypeIsGuaranteed := pDeclaredTypeIsGuaranteed;
  END;
  RETURN yyt;
 END mRoutineFormal;

PROCEDURE mDummyFormal (pNext: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [DummyFormal] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := DummyFormal;
  WITH yyt^.DummyFormal DO
   Next := pNext;
  END;
  RETURN yyt;
 END mDummyFormal;

PROCEDURE mTypeDesc (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [TypeDesc] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := TypeDesc;
  RETURN yyt;
 END mTypeDesc;

PROCEDURE mNodeTypes (pTreeName: tTree; pTypes: tSet): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [NodeTypes] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := NodeTypes;
  WITH yyt^.NodeTypes DO
   TreeName := pTreeName;
   Types := pTypes;
  END;
  RETURN yyt;
 END mNodeTypes;

PROCEDURE mUserType (pType: tIdent): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [UserType] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := UserType;
  WITH yyt^.UserType DO
   Type := pType;
  END;
  RETURN yyt;
 END mUserType;

PROCEDURE mPath (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Path] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Path;
  RETURN yyt;
 END mPath;

PROCEDURE mVar (pName: tIdent; pIsOutput: BOOLEAN; pIsRegister: BOOLEAN): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Var] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Var;
  WITH yyt^.Var DO
   Name := pName;
   IsOutput := pIsOutput;
   IsRegister := pIsRegister;
  END;
  RETURN yyt;
 END mVar;

PROCEDURE mConsType (pNext: tTree; pName: tIdent; pIsProperlyNarrowed: BOOLEAN): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [ConsType] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := ConsType;
  WITH yyt^.ConsType DO
   Next := pNext;
   Name := pName;
   IsProperlyNarrowed := pIsProperlyNarrowed;
  END;
  RETURN yyt;
 END mConsType;

PROCEDURE mField (pNext: tTree; pName: tIdent): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Field] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Field;
  WITH yyt^.Field DO
   Next := pNext;
   Name := pName;
  END;
  RETURN yyt;
 END mField;

PROCEDURE mTests (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Tests] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Tests;
  RETURN yyt;
 END mTests;

PROCEDURE mNoTest (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [NoTest] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := NoTest;
  RETURN yyt;
 END mNoTest;

PROCEDURE mOneTest (pNext: tTree; pPath: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [OneTest] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := OneTest;
  WITH yyt^.OneTest DO
   Next := pNext;
   Path := pPath;
  END;
  RETURN yyt;
 END mOneTest;

PROCEDURE mTestKind (pNext: tTree; pPath: tTree; pTypeDesc: tTree; pName: tIdent): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [TestKind] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := TestKind;
  WITH yyt^.TestKind DO
   Next := pNext;
   Path := pPath;
   TypeDesc := pTypeDesc;
   Name := pName;
  END;
  RETURN yyt;
 END mTestKind;

PROCEDURE mTestIsType (pNext: tTree; pPath: tTree; pTypeDesc: tTree; pName: tIdent): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [TestIsType] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := TestIsType;
  WITH yyt^.TestIsType DO
   Next := pNext;
   Path := pPath;
   TypeDesc := pTypeDesc;
   Name := pName;
  END;
  RETURN yyt;
 END mTestIsType;

PROCEDURE mTestNil (pNext: tTree; pPath: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [TestNil] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := TestNil;
  WITH yyt^.TestNil DO
   Next := pNext;
   Path := pPath;
  END;
  RETURN yyt;
 END mTestNil;

PROCEDURE mTestNonlin (pNext: tTree; pPath: tTree; pPath2: tTree; pTypeDesc: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [TestNonlin] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := TestNonlin;
  WITH yyt^.TestNonlin DO
   Next := pNext;
   Path := pPath;
   Path2 := pPath2;
   TypeDesc := pTypeDesc;
  END;
  RETURN yyt;
 END mTestNonlin;

PROCEDURE mTestValue (pNext: tTree; pPath: tTree; pExpr: tTree; pTypeDesc: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [TestValue] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := TestValue;
  WITH yyt^.TestValue DO
   Next := pNext;
   Path := pPath;
   Expr := pExpr;
   TypeDesc := pTypeDesc;
  END;
  RETURN yyt;
 END mTestValue;

PROCEDURE mDecisions (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Decisions] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Decisions;
  RETURN yyt;
 END mDecisions;

PROCEDURE mNoDecision (): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [NoDecision] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := NoDecision;
  RETURN yyt;
 END mNoDecision;

PROCEDURE mDecision (pThenPart: tTree; pElsePart: tTree; pOneTest: tTree; pCases: SHORTCARD; pIsUnchanged: BOOLEAN): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Decision] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Decision;
  WITH yyt^.Decision DO
   ThenPart := pThenPart;
   ElsePart := pElsePart;
   OneTest := pOneTest;
   Cases := pCases;
   IsUnchanged := pIsUnchanged;
  END;
  RETURN yyt;
 END mDecision;

PROCEDURE mDecided (pElsePart: tTree; pRule: tTree): tTree;
 VAR yyByteCount    : LONGINT;
 VAR yyt    : tTree;
 BEGIN
   yyt  := yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyt ) >= yyPoolMaxPtr THEN  yyt  := yyAlloc (); END; INC (yyPoolFreePtr,   yyNodeSize [Decided] ); 
  yyt^.yyHead.yyMark := 0;
  yyt^.Kind := Decided;
  WITH yyt^.Decided DO
   ElsePart := pElsePart;
   Rule := pRule;
  END;
  RETURN yyt;
 END mDecided;

TYPE yyPtrtTree        = POINTER TO tTree;

VAR yyf        : IO.tFile;
VAR yyLabel    : SHORTCARD;
VAR yyKind     : SHORTCARD;
VAR yyc        : CHAR;
VAR yys        : Strings.tString;

PROCEDURE yyMark (yyt: tTree);
 BEGIN
  LOOP
   IF yyt = NoTree THEN RETURN; END;
   INC (yyt^.yyHead.yyMark);
   IF yyt^.yyHead.yyMark > 1 THEN RETURN; END;

   CASE yyt^.Kind OF
| Class:
yyMark (yyt^.Class.Attributes);
yyMark (yyt^.Class.Extensions);
yyMark (yyt^.Class.BaseClass);
yyMark (yyt^.Class.Formals);
yyMark (yyt^.Class.TypeDesc);
yyt := yyt^.Class.Next;
| AttrOrAction:
yyt := yyt^.AttrOrAction.Next;
| Child:
yyt := yyt^.Child.Next;
| Attribute:
yyt := yyt^.Attribute.Next;
| ActionPart:
yyt := yyt^.ActionPart.Next;
| Designator:
yyt := yyt^.Designator.Next;
| Ident:
yyt := yyt^.Ident.Next;
| Remote:
yyMark (yyt^.Remote.Designators);
yyt := yyt^.Remote.Next;
| Any:
yyt := yyt^.Any.Next;
| Anys:
yyMark (yyt^.Anys.Layouts);
yyt := yyt^.Anys.Next;
| LayoutAny:
yyt := yyt^.LayoutAny.Next;
| Name:
yyt := yyt^.Name.Next;
| Spec:
yyMark (yyt^.Spec.TreeNames);
yyMark (yyt^.Spec.Public);
yyMark (yyt^.Spec.Extern);
yyMark (yyt^.Spec.Codes);
yyt := yyt^.Spec.Routines;
| TreeName:
yyMark (yyt^.TreeName.Classes);
yyMark (yyt^.TreeName.EmptyType);
yyMark (yyt^.TreeName.UniversalClass);
yyt := yyt^.TreeName.Next;
| Routine:
yyMark (yyt^.Routine.InParams);
yyMark (yyt^.Routine.OutParams);
yyMark (yyt^.Routine.Extern);
yyMark (yyt^.Routine.Rules);
yyMark (yyt^.Routine.InForm);
yyMark (yyt^.Routine.OutForm);
yyMark (yyt^.Routine.ParamDecls);
yyMark (yyt^.Routine.Decisions);
yyt := yyt^.Routine.Next;
| Procedure:
yyMark (yyt^.Procedure.InParams);
yyMark (yyt^.Procedure.OutParams);
yyMark (yyt^.Procedure.Extern);
yyMark (yyt^.Procedure.Rules);
yyMark (yyt^.Procedure.InForm);
yyMark (yyt^.Procedure.OutForm);
yyMark (yyt^.Procedure.ParamDecls);
yyMark (yyt^.Procedure.Decisions);
yyt := yyt^.Procedure.Next;
| Function:
yyMark (yyt^.Function.InParams);
yyMark (yyt^.Function.OutParams);
yyMark (yyt^.Function.Extern);
yyMark (yyt^.Function.Rules);
yyMark (yyt^.Function.InForm);
yyMark (yyt^.Function.OutForm);
yyMark (yyt^.Function.ParamDecls);
yyMark (yyt^.Function.Decisions);
yyMark (yyt^.Function.ReturnParams);
yyMark (yyt^.Function.ReturnForm);
yyt := yyt^.Function.Next;
| Predicate:
yyMark (yyt^.Predicate.InParams);
yyMark (yyt^.Predicate.OutParams);
yyMark (yyt^.Predicate.Extern);
yyMark (yyt^.Predicate.Rules);
yyMark (yyt^.Predicate.InForm);
yyMark (yyt^.Predicate.OutForm);
yyMark (yyt^.Predicate.ParamDecls);
yyMark (yyt^.Predicate.Decisions);
yyt := yyt^.Predicate.Next;
| Param:
yyMark (yyt^.Param.Type);
yyt := yyt^.Param.Next;
| Type:
yyt := yyt^.Type.Names;
| Rule:
yyMark (yyt^.Rule.Patterns);
yyMark (yyt^.Rule.Exprs);
yyMark (yyt^.Rule.Expr);
yyMark (yyt^.Rule.Statements);
yyMark (yyt^.Rule.VarDecls);
yyMark (yyt^.Rule.Tests);
yyt := yyt^.Rule.Next;
| OnePattern:
yyMark (yyt^.OnePattern.Pattern);
yyt := yyt^.OnePattern.Next;
| OnePatternAlts:
yyMark (yyt^.OnePatternAlts.PatternsList);
yyMark (yyt^.OnePatternAlts.Current);
yyt := yyt^.OnePatternAlts.Next;
| OnePatternsList:
yyMark (yyt^.OnePatternsList.Patterns);
yyt := yyt^.OnePatternsList.Next;
| Pattern:
yyMark (yyt^.Pattern.TypeDesc);
yyt := yyt^.Pattern.Path;
| Decompose:
yyMark (yyt^.Decompose.TypeDesc);
yyMark (yyt^.Decompose.Path);
yyMark (yyt^.Decompose.Expr);
yyt := yyt^.Decompose.Patterns;
| VarDef:
yyMark (yyt^.VarDef.TypeDesc);
yyt := yyt^.VarDef.Path;
| NilTest:
yyMark (yyt^.NilTest.TypeDesc);
yyt := yyt^.NilTest.Path;
| DontCare1:
yyMark (yyt^.DontCare1.TypeDesc);
yyt := yyt^.DontCare1.Path;
| DontCare1Explicit:
yyMark (yyt^.DontCare1Explicit.TypeDesc);
yyt := yyt^.DontCare1Explicit.Path;
| DontCare1Internal:
yyMark (yyt^.DontCare1Internal.TypeDesc);
yyt := yyt^.DontCare1Internal.Path;
| DontCare:
yyMark (yyt^.DontCare.TypeDesc);
yyMark (yyt^.DontCare.Path);
yyt := yyt^.DontCare.Tempos;
| DontCareExplicit:
yyMark (yyt^.DontCareExplicit.TypeDesc);
yyMark (yyt^.DontCareExplicit.Path);
yyt := yyt^.DontCareExplicit.Tempos;
| DontCareInternal:
yyMark (yyt^.DontCareInternal.TypeDesc);
yyMark (yyt^.DontCareInternal.Path);
yyt := yyt^.DontCareInternal.Tempos;
| Value:
yyMark (yyt^.Value.TypeDesc);
yyMark (yyt^.Value.Path);
yyt := yyt^.Value.Expr;
| OneExpr:
yyMark (yyt^.OneExpr.Expr);
yyt := yyt^.OneExpr.Next;
| NamedExpr:
yyMark (yyt^.NamedExpr.Expr);
yyt := yyt^.NamedExpr.Next;
| Compose:
yyMark (yyt^.Compose.Expr);
yyMark (yyt^.Compose.Exprs);
yyt := yyt^.Compose.TypeDesc;
| Call:
yyMark (yyt^.Call.Expr);
yyMark (yyt^.Call.Exprs);
yyt := yyt^.Call.Patterns;
| Binary:
yyMark (yyt^.Binary.Lop);
yyt := yyt^.Binary.Rop;
| yy1:
yyMark (yyt^.yy1.Lop);
yyt := yyt^.yy1.Rop;
| BinaryCompound:
yyMark (yyt^.BinaryCompound.Lop);
yyt := yyt^.BinaryCompound.Rop;
| PreOperator:
yyt := yyt^.PreOperator.Expr;
| PostOperator:
yyt := yyt^.PostOperator.Expr;
| Index:
yyMark (yyt^.Index.Expr);
yyt := yyt^.Index.Exprs;
| Parents:
yyt := yyt^.Parents.Expr;
| TargetExpr:
yyt := yyt^.TargetExpr.Expr;
| Statement:
yyt := yyt^.Statement.Next;
| ProcCall:
yyMark (yyt^.ProcCall.Call);
yyt := yyt^.ProcCall.Next;
| Condition:
yyMark (yyt^.Condition.Expr);
yyt := yyt^.Condition.Next;
| Assignment:
yyMark (yyt^.Assignment.Adr);
yyMark (yyt^.Assignment.Expr);
yyt := yyt^.Assignment.Next;
| Reject:
yyt := yyt^.Reject.Next;
| Fail:
yyt := yyt^.Fail.Next;
| TargetStmt:
yyMark (yyt^.TargetStmt.Parameters);
yyMark (yyt^.TargetStmt.Stmt);
yyt := yyt^.TargetStmt.Next;
| Nl:
yyt := yyt^.Nl.Next;
| WriteStr:
yyt := yyt^.WriteStr.Next;
| Formal:
yyMark (yyt^.Formal.Hides);
yyMark (yyt^.Formal.TypeDesc);
yyMark (yyt^.Formal.Path);
yyt := yyt^.Formal.Next;
| PlainFormal:
yyMark (yyt^.PlainFormal.Hides);
yyMark (yyt^.PlainFormal.TypeDesc);
yyMark (yyt^.PlainFormal.Path);
yyt := yyt^.PlainFormal.Next;
| RoutineFormal:
yyMark (yyt^.RoutineFormal.Hides);
yyMark (yyt^.RoutineFormal.TypeDesc);
yyMark (yyt^.RoutineFormal.Path);
yyMark (yyt^.RoutineFormal.TargetClass);
yyt := yyt^.RoutineFormal.Next;
| DummyFormal:
yyt := yyt^.DummyFormal.Next;
| NodeTypes:
yyt := yyt^.NodeTypes.TreeName;
| ConsType:
yyt := yyt^.ConsType.Next;
| Field:
yyt := yyt^.Field.Next;
| OneTest:
yyMark (yyt^.OneTest.Next);
yyt := yyt^.OneTest.Path;
| TestKind:
yyMark (yyt^.TestKind.Next);
yyMark (yyt^.TestKind.Path);
yyt := yyt^.TestKind.TypeDesc;
| TestIsType:
yyMark (yyt^.TestIsType.Next);
yyMark (yyt^.TestIsType.Path);
yyt := yyt^.TestIsType.TypeDesc;
| TestNil:
yyMark (yyt^.TestNil.Next);
yyt := yyt^.TestNil.Path;
| TestNonlin:
yyMark (yyt^.TestNonlin.Next);
yyMark (yyt^.TestNonlin.Path);
yyMark (yyt^.TestNonlin.Path2);
yyt := yyt^.TestNonlin.TypeDesc;
| TestValue:
yyMark (yyt^.TestValue.Next);
yyMark (yyt^.TestValue.Path);
yyMark (yyt^.TestValue.Expr);
yyt := yyt^.TestValue.TypeDesc;
| Decision:
yyMark (yyt^.Decision.ThenPart);
yyMark (yyt^.Decision.ElsePart);
yyt := yyt^.Decision.OneTest;
| Decided:
yyMark (yyt^.Decided.ElsePart);
yyt := yyt^.Decided.Rule;
   ELSE RETURN;
   END;
  END;
 END yyMark;

CONST yyInitTreeStoreSize      = 32;

VAR yyTreeStoreSize    : LONGINT;
VAR yyTreeStorePtr     : POINTER TO ARRAY [0..50000] OF tTree;
VAR yyLabelCount       : INTEGER;
VAR yyRecursionLevel   : SHORTINT;

PROCEDURE yyMapToLabel (yyTree: tTree): SHORTCARD;
 VAR yyi       : INTEGER;
 BEGIN
  FOR yyi := 1 TO yyLabelCount DO
   IF yyTreeStorePtr^[yyi] = yyTree THEN RETURN yyi; END;
  END;
  INC (yyLabelCount);
  IF yyLabelCount = yyTreeStoreSize THEN
   DynArray.ExtendArray (yyTreeStorePtr, yyTreeStoreSize, SYSTEM.TSIZE (tTree));
  END;
  yyTreeStorePtr^[yyLabelCount] := yyTree;
  RETURN yyLabelCount;
 END yyMapToLabel;

PROCEDURE yyMapToTree (yyLabel: SHORTCARD): tTree;
 BEGIN RETURN yyTreeStorePtr^[yyLabel]; END yyMapToTree;

PROCEDURE yyWriteNl; BEGIN IO.WriteNl (yyf); END yyWriteNl;

PROCEDURE yyWriteSelector (yys: ARRAY OF CHAR);
 BEGIN IO.WriteS (yyf, yys); Layout.WriteSpaces (yyf, 15 - INTEGER (HIGH (yys))); IO.WriteS (yyf, ' = '); END yyWriteSelector;

PROCEDURE yyWriteHex (VAR yyx: ARRAY OF SYSTEM.BYTE);
 VAR yyi       : INTEGER;
 BEGIN
  FOR yyi := 0 TO INTEGER (HIGH (yyx)) DO
   IO.WriteN (yyf, ORD (CHAR (yyx [yyi])), 2, 16);
   IO.WriteC (yyf, ' ');
  END;
 END yyWriteHex;

PROCEDURE yyWriteAdr (yyt: tTree);
 BEGIN
  IF yyt = NoTree THEN
   IO.WriteS (yyf, 'NoTree');
  ELSE
   yyWriteHex (yyt);
  END;
  yyWriteNl;
 END yyWriteAdr;

PROCEDURE yyyWriteNodeClass (yyt: tTree);
 BEGIN
  yyWriteSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.Class.Name );  yyWriteNl;
  yyWriteSelector ('Properties'); yyWriteHex ( yyt^.Class.Properties );  yyWriteNl;
  yyWriteSelector ('Attributes'); yyWriteAdr (yyt^.Class.Attributes);
  yyWriteSelector ('Extensions'); yyWriteAdr (yyt^.Class.Extensions);
  yyWriteSelector ('Next'); yyWriteAdr (yyt^.Class.Next);
  yyWriteSelector ('BaseClass'); yyWriteAdr (yyt^.Class.BaseClass);
  yyWriteSelector ('Formals'); yyWriteAdr (yyt^.Class.Formals);
  yyWriteSelector ('TypeDesc'); yyWriteAdr (yyt^.Class.TypeDesc);
  yyWriteSelector ('Index'); IO.WriteI (yyf,  yyt^.Class.Index , 0);  yyWriteNl;
  yyWriteSelector ('Depth'); IO.WriteI (yyf,  yyt^.Class.Depth , 0);  yyWriteNl;
 END yyyWriteNodeClass;

PROCEDURE yyyWriteNodeAttrOrAction (yyt: tTree);
 BEGIN
  yyWriteSelector ('Next'); yyWriteAdr (yyt^.AttrOrAction.Next);
 END yyyWriteNodeAttrOrAction;

PROCEDURE yyyWriteNodeChild (yyt: tTree);
 BEGIN
  yyyWriteNodeAttrOrAction (yyt); 
  yyWriteSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.Child.Name );  yyWriteNl;
  yyWriteSelector ('Type'); Idents.WriteIdent (yyf,  yyt^.Child.Type );  yyWriteNl;
  yyWriteSelector ('Properties'); yyWriteHex ( yyt^.Child.Properties );  yyWriteNl;
 END yyyWriteNodeChild;

PROCEDURE yyyWriteNodeAttribute (yyt: tTree);
 BEGIN
  yyyWriteNodeAttrOrAction (yyt); 
  yyWriteSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.Attribute.Name );  yyWriteNl;
  yyWriteSelector ('Type'); Idents.WriteIdent (yyf,  yyt^.Attribute.Type );  yyWriteNl;
  yyWriteSelector ('Properties'); yyWriteHex ( yyt^.Attribute.Properties );  yyWriteNl;
 END yyyWriteNodeAttribute;

PROCEDURE yyyWriteNodeActionPart (yyt: tTree);
 BEGIN
  yyyWriteNodeAttrOrAction (yyt); 
 END yyyWriteNodeActionPart;

PROCEDURE yyyWriteNodeCodes (yyt: tTree);
 BEGIN
  yyWriteSelector ('Export'); Texts.WriteText (yyf,  yyt^.Codes.Export );  yyWriteNl;
  yyWriteSelector ('Import'); Texts.WriteText (yyf,  yyt^.Codes.Import );  yyWriteNl;
  yyWriteSelector ('Global'); Texts.WriteText (yyf,  yyt^.Codes.Global );  yyWriteNl;
  yyWriteSelector ('SpecWith'); Texts.WriteText (yyf,  yyt^.Codes.SpecWith );  yyWriteNl;
  yyWriteSelector ('BodyWith'); Texts.WriteText (yyf,  yyt^.Codes.BodyWith );  yyWriteNl;
  yyWriteSelector ('Local'); Texts.WriteText (yyf,  yyt^.Codes.Local );  yyWriteNl;
  yyWriteSelector ('Begin'); Texts.WriteText (yyf,  yyt^.Codes.Begin );  yyWriteNl;
  yyWriteSelector ('Close'); Texts.WriteText (yyf,  yyt^.Codes.Close );  yyWriteNl;
  yyWriteSelector ('ExportLine'); Positions.WritePosition (yyf,  yyt^.Codes.ExportLine );  yyWriteNl;
  yyWriteSelector ('ImportLine'); Positions.WritePosition (yyf,  yyt^.Codes.ImportLine );  yyWriteNl;
  yyWriteSelector ('GlobalLine'); Positions.WritePosition (yyf,  yyt^.Codes.GlobalLine );  yyWriteNl;
  yyWriteSelector ('SpecWithLine'); Positions.WritePosition (yyf,  yyt^.Codes.SpecWithLine );  yyWriteNl;
  yyWriteSelector ('BodyWithLine'); Positions.WritePosition (yyf,  yyt^.Codes.BodyWithLine );  yyWriteNl;
  yyWriteSelector ('LocalLine'); Positions.WritePosition (yyf,  yyt^.Codes.LocalLine );  yyWriteNl;
  yyWriteSelector ('BeginLine'); Positions.WritePosition (yyf,  yyt^.Codes.BeginLine );  yyWriteNl;
  yyWriteSelector ('CloseLine'); Positions.WritePosition (yyf,  yyt^.Codes.CloseLine );  yyWriteNl;
 END yyyWriteNodeCodes;

PROCEDURE yyyWriteNodeDesignator (yyt: tTree);
 BEGIN
  yyWriteSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.Designator.Selector );  yyWriteNl;
  yyWriteSelector ('Attribute'); Idents.WriteIdent (yyf,  yyt^.Designator.Attribute );  yyWriteNl;
  yyWriteSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Designator.Pos );  yyWriteNl;
  yyWriteSelector ('AttributePos'); Positions.WritePosition (yyf,  yyt^.Designator.AttributePos );  yyWriteNl;
  yyWriteSelector ('Next'); yyWriteAdr (yyt^.Designator.Next);
  yyWriteSelector ('Object'); yyWriteHex ( yyt^.Designator.Object );  yyWriteNl;
  yyWriteSelector ('Type'); Idents.WriteIdent (yyf,  yyt^.Designator.Type );  yyWriteNl;
 END yyyWriteNodeDesignator;

PROCEDURE yyyWriteNodeIdent (yyt: tTree);
 BEGIN
  yyWriteSelector ('Attribute'); Idents.WriteIdent (yyf,  yyt^.Ident.Attribute );  yyWriteNl;
  yyWriteSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Ident.Pos );  yyWriteNl;
  yyWriteSelector ('Next'); yyWriteAdr (yyt^.Ident.Next);
  yyWriteSelector ('Object'); yyWriteHex ( yyt^.Ident.Object );  yyWriteNl;
 END yyyWriteNodeIdent;

PROCEDURE yyyWriteNodeRemote (yyt: tTree);
 BEGIN
  yyWriteSelector ('Designators'); yyWriteAdr (yyt^.Remote.Designators);
  yyWriteSelector ('Type'); Idents.WriteIdent (yyf,  yyt^.Remote.Type );  yyWriteNl;
  yyWriteSelector ('Attribute'); Idents.WriteIdent (yyf,  yyt^.Remote.Attribute );  yyWriteNl;
  yyWriteSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Remote.Pos );  yyWriteNl;
  yyWriteSelector ('Next'); yyWriteAdr (yyt^.Remote.Next);
 END yyyWriteNodeRemote;

PROCEDURE yyyWriteNodeAny (yyt: tTree);
 BEGIN
  yyWriteSelector ('Code'); StringMem.WriteString (yyf,  yyt^.Any.Code );  yyWriteNl;
  yyWriteSelector ('Next'); yyWriteAdr (yyt^.Any.Next);
 END yyyWriteNodeAny;

PROCEDURE yyyWriteNodeAnys (yyt: tTree);
 BEGIN
  yyWriteSelector ('Layouts'); yyWriteAdr (yyt^.Anys.Layouts);
  yyWriteSelector ('Next'); yyWriteAdr (yyt^.Anys.Next);
 END yyyWriteNodeAnys;

PROCEDURE yyyWriteNodeLayoutAny (yyt: tTree);
 BEGIN
  yyWriteSelector ('Code'); StringMem.WriteString (yyf,  yyt^.LayoutAny.Code );  yyWriteNl;
  yyWriteSelector ('Next'); yyWriteAdr (yyt^.LayoutAny.Next);
 END yyyWriteNodeLayoutAny;

PROCEDURE yyyWriteNodeName (yyt: tTree);
 BEGIN
  yyWriteSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.Name.Name );  yyWriteNl;
  yyWriteSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Name.Pos );  yyWriteNl;
  yyWriteSelector ('Next'); yyWriteAdr (yyt^.Name.Next);
  yyWriteSelector ('Object'); yyWriteHex ( yyt^.Name.Object );  yyWriteNl;
 END yyyWriteNodeName;

PROCEDURE yyyWriteNodeSpec (yyt: tTree);
 BEGIN
  yyWriteSelector ('TrafoName'); Idents.WriteIdent (yyf,  yyt^.Spec.TrafoName );  yyWriteNl;
  yyWriteSelector ('TreeNames'); yyWriteAdr (yyt^.Spec.TreeNames);
  yyWriteSelector ('Public'); yyWriteAdr (yyt^.Spec.Public);
  yyWriteSelector ('Extern'); yyWriteAdr (yyt^.Spec.Extern);
  yyWriteSelector ('Codes'); yyWriteAdr (yyt^.Spec.Codes);
  yyWriteSelector ('Routines'); yyWriteAdr (yyt^.Spec.Routines);
 END yyyWriteNodeSpec;

PROCEDURE yyyWriteNodeTreeName (yyt: tTree);
 BEGIN
  yyWriteSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.TreeName.Name );  yyWriteNl;
  yyWriteSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.TreeName.Pos );  yyWriteNl;
  yyWriteSelector ('Next'); yyWriteAdr (yyt^.TreeName.Next);
  yyWriteSelector ('Classes'); yyWriteAdr (yyt^.TreeName.Classes);
  yyWriteSelector ('ClassCount'); IO.WriteI (yyf,  yyt^.TreeName.ClassCount , 0);  yyWriteNl;
  yyWriteSelector ('EmptyType'); yyWriteAdr (yyt^.TreeName.EmptyType);
  yyWriteSelector ('UniversalClass'); yyWriteAdr (yyt^.TreeName.UniversalClass);
 END yyyWriteNodeTreeName;

PROCEDURE yyyWriteNodeRoutine (yyt: tTree);
 BEGIN
  yyWriteSelector ('Next'); yyWriteAdr (yyt^.Routine.Next);
  yyWriteSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.Routine.Name );  yyWriteNl;
  yyWriteSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Routine.Pos );  yyWriteNl;
  yyWriteSelector ('InParams'); yyWriteAdr (yyt^.Routine.InParams);
  yyWriteSelector ('OutParams'); yyWriteAdr (yyt^.Routine.OutParams);
  yyWriteSelector ('Extern'); yyWriteAdr (yyt^.Routine.Extern);
  yyWriteSelector ('Local'); Texts.WriteText (yyf,  yyt^.Routine.Local );  yyWriteNl;
  yyWriteSelector ('LocalLine'); Positions.WritePosition (yyf,  yyt^.Routine.LocalLine );  yyWriteNl;
  yyWriteSelector ('Rules'); yyWriteAdr (yyt^.Routine.Rules);
  yyWriteSelector ('InForm'); yyWriteAdr (yyt^.Routine.InForm);
  yyWriteSelector ('OutForm'); yyWriteAdr (yyt^.Routine.OutForm);
  yyWriteSelector ('ParamDecls'); yyWriteAdr (yyt^.Routine.ParamDecls);
  yyWriteSelector ('IsExtern'); IO.WriteB (yyf,  yyt^.Routine.IsExtern );  yyWriteNl;
  yyWriteSelector ('Decisions'); yyWriteAdr (yyt^.Routine.Decisions);
 END yyyWriteNodeRoutine;

PROCEDURE yyyWriteNodeProcedure (yyt: tTree);
 BEGIN
  yyyWriteNodeRoutine (yyt); 
 END yyyWriteNodeProcedure;

PROCEDURE yyyWriteNodeFunction (yyt: tTree);
 BEGIN
  yyyWriteNodeRoutine (yyt); 
  yyWriteSelector ('ReturnParams'); yyWriteAdr (yyt^.Function.ReturnParams);
  yyWriteSelector ('ReturnForm'); yyWriteAdr (yyt^.Function.ReturnForm);
 END yyyWriteNodeFunction;

PROCEDURE yyyWriteNodePredicate (yyt: tTree);
 BEGIN
  yyyWriteNodeRoutine (yyt); 
 END yyyWriteNodePredicate;

PROCEDURE yyyWriteNodeParam (yyt: tTree);
 BEGIN
  yyWriteSelector ('IsRef'); IO.WriteB (yyf,  yyt^.Param.IsRef );  yyWriteNl;
  yyWriteSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.Param.Name );  yyWriteNl;
  yyWriteSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Param.Pos );  yyWriteNl;
  yyWriteSelector ('Type'); yyWriteAdr (yyt^.Param.Type);
  yyWriteSelector ('Next'); yyWriteAdr (yyt^.Param.Next);
 END yyyWriteNodeParam;

PROCEDURE yyyWriteNodeType (yyt: tTree);
 BEGIN
  yyWriteSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.Type.Name );  yyWriteNl;
  yyWriteSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Type.Pos );  yyWriteNl;
  yyWriteSelector ('Names'); yyWriteAdr (yyt^.Type.Names);
 END yyyWriteNodeType;

PROCEDURE yyyWriteNodeRule (yyt: tTree);
 BEGIN
  yyWriteSelector ('Line'); Positions.WritePosition (yyf,  yyt^.Rule.Line );  yyWriteNl;
  yyWriteSelector ('Patterns'); yyWriteAdr (yyt^.Rule.Patterns);
  yyWriteSelector ('Exprs'); yyWriteAdr (yyt^.Rule.Exprs);
  yyWriteSelector ('Expr'); yyWriteAdr (yyt^.Rule.Expr);
  yyWriteSelector ('Statements'); yyWriteAdr (yyt^.Rule.Statements);
  yyWriteSelector ('Next'); yyWriteAdr (yyt^.Rule.Next);
  yyWriteSelector ('VarDecls'); yyWriteAdr (yyt^.Rule.VarDecls);
  yyWriteSelector ('HasTempos'); IO.WriteB (yyf,  yyt^.Rule.HasTempos );  yyWriteNl;
  yyWriteSelector ('HasPatterns'); IO.WriteB (yyf,  yyt^.Rule.HasPatterns );  yyWriteNl;
  yyWriteSelector ('Tempo'); Idents.WriteIdent (yyf,  yyt^.Rule.Tempo );  yyWriteNl;
  yyWriteSelector ('Index'); IO.WriteI (yyf,  yyt^.Rule.Index , 0);  yyWriteNl;
  yyWriteSelector ('Tests'); yyWriteAdr (yyt^.Rule.Tests);
  yyWriteSelector ('HasExit'); IO.WriteB (yyf,  yyt^.Rule.HasExit );  yyWriteNl;
  yyWriteSelector ('HasAssign'); IO.WriteB (yyf,  yyt^.Rule.HasAssign );  yyWriteNl;
  yyWriteSelector ('HasTargetCode'); IO.WriteB (yyf,  yyt^.Rule.HasTargetCode );  yyWriteNl;
  yyWriteSelector ('HasRejectOrFail'); IO.WriteB (yyf,  yyt^.Rule.HasRejectOrFail );  yyWriteNl;
 END yyyWriteNodeRule;

PROCEDURE yyyWriteNodeNoPattern (yyt: tTree);
 BEGIN
  yyWriteSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.NoPattern.Pos );  yyWriteNl;
 END yyyWriteNodeNoPattern;

PROCEDURE yyyWriteNodeOnePattern (yyt: tTree);
 BEGIN
  yyWriteSelector ('Pattern'); yyWriteAdr (yyt^.OnePattern.Pattern);
  yyWriteSelector ('Next'); yyWriteAdr (yyt^.OnePattern.Next);
 END yyyWriteNodeOnePattern;

PROCEDURE yyyWriteNodeOnePatternAlts (yyt: tTree);
 BEGIN
  yyWriteSelector ('PatternsList'); yyWriteAdr (yyt^.OnePatternAlts.PatternsList);
  yyWriteSelector ('Next'); yyWriteAdr (yyt^.OnePatternAlts.Next);
  yyWriteSelector ('Current'); yyWriteAdr (yyt^.OnePatternAlts.Current);
 END yyyWriteNodeOnePatternAlts;

PROCEDURE yyyWriteNodeOnePatternsList (yyt: tTree);
 BEGIN
  yyWriteSelector ('Patterns'); yyWriteAdr (yyt^.OnePatternsList.Patterns);
  yyWriteSelector ('Next'); yyWriteAdr (yyt^.OnePatternsList.Next);
 END yyyWriteNodeOnePatternsList;

PROCEDURE yyyWriteNodePattern (yyt: tTree);
 BEGIN
  yyWriteSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Pattern.Pos );  yyWriteNl;
  yyWriteSelector ('Tempo'); Idents.WriteIdent (yyf,  yyt^.Pattern.Tempo );  yyWriteNl;
  yyWriteSelector ('TypeDesc'); yyWriteAdr (yyt^.Pattern.TypeDesc);
  yyWriteSelector ('Path'); yyWriteAdr (yyt^.Pattern.Path);
 END yyyWriteNodePattern;

PROCEDURE yyyWriteNodeDecompose (yyt: tTree);
 BEGIN
  yyyWriteNodePattern (yyt); 
  yyWriteSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.Decompose.Selector );  yyWriteNl;
  yyWriteSelector ('Expr'); yyWriteAdr (yyt^.Decompose.Expr);
  yyWriteSelector ('Patterns'); yyWriteAdr (yyt^.Decompose.Patterns);
  yyWriteSelector ('Widen'); IO.WriteB (yyf,  yyt^.Decompose.Widen );  yyWriteNl;
  yyWriteSelector ('Object'); yyWriteHex ( yyt^.Decompose.Object );  yyWriteNl;
  yyWriteSelector ('IsProperlyNarrowed'); IO.WriteB (yyf,  yyt^.Decompose.IsProperlyNarrowed );  yyWriteNl;
 END yyyWriteNodeDecompose;

PROCEDURE yyyWriteNodeVarDef (yyt: tTree);
 BEGIN
  yyyWriteNodePattern (yyt); 
  yyWriteSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.VarDef.Selector );  yyWriteNl;
  yyWriteSelector ('HasDelimiter'); IO.WriteB (yyf,  yyt^.VarDef.HasDelimiter );  yyWriteNl;
  yyWriteSelector ('Object'); yyWriteHex ( yyt^.VarDef.Object );  yyWriteNl;
 END yyyWriteNodeVarDef;

PROCEDURE yyyWriteNodeNilTest (yyt: tTree);
 BEGIN
  yyyWriteNodePattern (yyt); 
  yyWriteSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.NilTest.Selector );  yyWriteNl;
  yyWriteSelector ('Widen'); IO.WriteB (yyf,  yyt^.NilTest.Widen );  yyWriteNl;
  yyWriteSelector ('IsProperlyNarrowed'); IO.WriteB (yyf,  yyt^.NilTest.IsProperlyNarrowed );  yyWriteNl;
 END yyyWriteNodeNilTest;

PROCEDURE yyyWriteNodeDontCare1 (yyt: tTree);
 BEGIN
  yyyWriteNodePattern (yyt); 
  yyWriteSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.DontCare1.Selector );  yyWriteNl;
 END yyyWriteNodeDontCare1;

PROCEDURE yyyWriteNodeDontCare1Explicit (yyt: tTree);
 BEGIN
  yyyWriteNodeDontCare1 (yyt); 
 END yyyWriteNodeDontCare1Explicit;

PROCEDURE yyyWriteNodeDontCare1Internal (yyt: tTree);
 BEGIN
  yyyWriteNodeDontCare1 (yyt); 
 END yyyWriteNodeDontCare1Internal;

PROCEDURE yyyWriteNodeDontCare (yyt: tTree);
 BEGIN
  yyyWriteNodePattern (yyt); 
  yyWriteSelector ('Tempos'); yyWriteAdr (yyt^.DontCare.Tempos);
 END yyyWriteNodeDontCare;

PROCEDURE yyyWriteNodeDontCareExplicit (yyt: tTree);
 BEGIN
  yyyWriteNodeDontCare (yyt); 
 END yyyWriteNodeDontCareExplicit;

PROCEDURE yyyWriteNodeDontCareInternal (yyt: tTree);
 BEGIN
  yyyWriteNodeDontCare (yyt); 
 END yyyWriteNodeDontCareInternal;

PROCEDURE yyyWriteNodeValue (yyt: tTree);
 BEGIN
  yyyWriteNodePattern (yyt); 
  yyWriteSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.Value.Selector );  yyWriteNl;
  yyWriteSelector ('Expr'); yyWriteAdr (yyt^.Value.Expr);
 END yyyWriteNodeValue;

PROCEDURE yyyWriteNodeNoExpr (yyt: tTree);
 BEGIN
  yyWriteSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.NoExpr.Pos );  yyWriteNl;
 END yyyWriteNodeNoExpr;

PROCEDURE yyyWriteNodeOneExpr (yyt: tTree);
 BEGIN
  yyWriteSelector ('Expr'); yyWriteAdr (yyt^.OneExpr.Expr);
  yyWriteSelector ('Next'); yyWriteAdr (yyt^.OneExpr.Next);
 END yyyWriteNodeOneExpr;

PROCEDURE yyyWriteNodeNamedExpr (yyt: tTree);
 BEGIN
  yyyWriteNodeOneExpr (yyt); 
  yyWriteSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.NamedExpr.Name );  yyWriteNl;
  yyWriteSelector ('NamePos'); Positions.WritePosition (yyf,  yyt^.NamedExpr.NamePos );  yyWriteNl;
 END yyyWriteNodeNamedExpr;

PROCEDURE yyyWriteNodeExpr (yyt: tTree);
 BEGIN
  yyWriteSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Expr.Pos );  yyWriteNl;
  yyWriteSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.Expr.Selector );  yyWriteNl;
 END yyyWriteNodeExpr;

PROCEDURE yyyWriteNodeCompose (yyt: tTree);
 BEGIN
  yyyWriteNodeExpr (yyt); 
  yyWriteSelector ('Expr'); yyWriteAdr (yyt^.Compose.Expr);
  yyWriteSelector ('Exprs'); yyWriteAdr (yyt^.Compose.Exprs);
  yyWriteSelector ('Widen'); IO.WriteB (yyf,  yyt^.Compose.Widen );  yyWriteNl;
  yyWriteSelector ('Object'); yyWriteHex ( yyt^.Compose.Object );  yyWriteNl;
  yyWriteSelector ('Tempo'); Idents.WriteIdent (yyf,  yyt^.Compose.Tempo );  yyWriteNl;
  yyWriteSelector ('TypeDesc'); yyWriteAdr (yyt^.Compose.TypeDesc);
 END yyyWriteNodeCompose;

PROCEDURE yyyWriteNodeVarUse (yyt: tTree);
 BEGIN
  yyyWriteNodeExpr (yyt); 
  yyWriteSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.VarUse.Name );  yyWriteNl;
  yyWriteSelector ('Widen'); IO.WriteB (yyf,  yyt^.VarUse.Widen );  yyWriteNl;
  yyWriteSelector ('Object'); yyWriteHex ( yyt^.VarUse.Object );  yyWriteNl;
 END yyyWriteNodeVarUse;

PROCEDURE yyyWriteNodeAttrDesc (yyt: tTree);
 BEGIN
  yyyWriteNodeVarUse (yyt); 
  yyWriteSelector ('Attribute'); Idents.WriteIdent (yyf,  yyt^.AttrDesc.Attribute );  yyWriteNl;
  yyWriteSelector ('AttributePos'); Positions.WritePosition (yyf,  yyt^.AttrDesc.AttributePos );  yyWriteNl;
  yyWriteSelector ('Type'); Idents.WriteIdent (yyf,  yyt^.AttrDesc.Type );  yyWriteNl;
 END yyyWriteNodeAttrDesc;

PROCEDURE yyyWriteNodeNil (yyt: tTree);
 BEGIN
  yyyWriteNodeExpr (yyt); 
  yyWriteSelector ('Widen'); IO.WriteB (yyf,  yyt^.Nil.Widen );  yyWriteNl;
 END yyyWriteNodeNil;

PROCEDURE yyyWriteNodeCall (yyt: tTree);
 BEGIN
  yyyWriteNodeExpr (yyt); 
  yyWriteSelector ('Expr'); yyWriteAdr (yyt^.Call.Expr);
  yyWriteSelector ('Exprs'); yyWriteAdr (yyt^.Call.Exprs);
  yyWriteSelector ('Patterns'); yyWriteAdr (yyt^.Call.Patterns);
  yyWriteSelector ('Object'); yyWriteHex ( yyt^.Call.Object );  yyWriteNl;
 END yyyWriteNodeCall;

PROCEDURE yyyWriteNodeBinary (yyt: tTree);
 BEGIN
  yyyWriteNodeExpr (yyt); 
  yyWriteSelector ('Lop'); yyWriteAdr (yyt^.Binary.Lop);
  yyWriteSelector ('Operator'); Idents.WriteIdent (yyf,  yyt^.Binary.Operator );  yyWriteNl;
  yyWriteSelector ('Rop'); yyWriteAdr (yyt^.Binary.Rop);
  yyWriteSelector ('Widen'); IO.WriteB (yyf,  yyt^.Binary.Widen );  yyWriteNl;
 END yyyWriteNodeBinary;

PROCEDURE yyyWriteNodeyy1 (yyt: tTree);
 BEGIN
  yyyWriteNodeBinary (yyt); 
 END yyyWriteNodeyy1;

PROCEDURE yyyWriteNodeBinaryCompound (yyt: tTree);
 BEGIN
  yyyWriteNodeBinary (yyt); 
  yyWriteSelector ('CompoundOperator'); Idents.WriteIdent (yyf,  yyt^.BinaryCompound.CompoundOperator );  yyWriteNl;
 END yyyWriteNodeBinaryCompound;

PROCEDURE yyyWriteNodePreOperator (yyt: tTree);
 BEGIN
  yyyWriteNodeExpr (yyt); 
  yyWriteSelector ('Operator'); Idents.WriteIdent (yyf,  yyt^.PreOperator.Operator );  yyWriteNl;
  yyWriteSelector ('Expr'); yyWriteAdr (yyt^.PreOperator.Expr);
 END yyyWriteNodePreOperator;

PROCEDURE yyyWriteNodePostOperator (yyt: tTree);
 BEGIN
  yyyWriteNodeExpr (yyt); 
  yyWriteSelector ('Operator'); Idents.WriteIdent (yyf,  yyt^.PostOperator.Operator );  yyWriteNl;
  yyWriteSelector ('Expr'); yyWriteAdr (yyt^.PostOperator.Expr);
 END yyyWriteNodePostOperator;

PROCEDURE yyyWriteNodeIndex (yyt: tTree);
 BEGIN
  yyyWriteNodeExpr (yyt); 
  yyWriteSelector ('Expr'); yyWriteAdr (yyt^.Index.Expr);
  yyWriteSelector ('Exprs'); yyWriteAdr (yyt^.Index.Exprs);
  yyWriteSelector ('Widen'); IO.WriteB (yyf,  yyt^.Index.Widen );  yyWriteNl;
 END yyyWriteNodeIndex;

PROCEDURE yyyWriteNodeParents (yyt: tTree);
 BEGIN
  yyyWriteNodeExpr (yyt); 
  yyWriteSelector ('Expr'); yyWriteAdr (yyt^.Parents.Expr);
 END yyyWriteNodeParents;

PROCEDURE yyyWriteNodeTargetExpr (yyt: tTree);
 BEGIN
  yyyWriteNodeExpr (yyt); 
  yyWriteSelector ('Expr'); yyWriteAdr (yyt^.TargetExpr.Expr);
  yyWriteSelector ('UsedNames'); Sets.WriteSet (yyf,  yyt^.TargetExpr.UsedNames );  yyWriteNl;
 END yyyWriteNodeTargetExpr;

PROCEDURE yyyWriteNodeStringExpr (yyt: tTree);
 BEGIN
  yyyWriteNodeExpr (yyt); 
  yyWriteSelector ('String'); StringMem.WriteString (yyf,  yyt^.StringExpr.String );  yyWriteNl;
 END yyyWriteNodeStringExpr;

PROCEDURE yyyWriteNodeStatement (yyt: tTree);
 BEGIN
  yyWriteSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Statement.Pos );  yyWriteNl;
  yyWriteSelector ('Next'); yyWriteAdr (yyt^.Statement.Next);
 END yyyWriteNodeStatement;

PROCEDURE yyyWriteNodeProcCall (yyt: tTree);
 BEGIN
  yyyWriteNodeStatement (yyt); 
  yyWriteSelector ('Call'); yyWriteAdr (yyt^.ProcCall.Call);
 END yyyWriteNodeProcCall;

PROCEDURE yyyWriteNodeCondition (yyt: tTree);
 BEGIN
  yyyWriteNodeStatement (yyt); 
  yyWriteSelector ('Expr'); yyWriteAdr (yyt^.Condition.Expr);
 END yyyWriteNodeCondition;

PROCEDURE yyyWriteNodeAssignment (yyt: tTree);
 BEGIN
  yyyWriteNodeStatement (yyt); 
  yyWriteSelector ('Adr'); yyWriteAdr (yyt^.Assignment.Adr);
  yyWriteSelector ('Expr'); yyWriteAdr (yyt^.Assignment.Expr);
  yyWriteSelector ('Object'); yyWriteHex ( yyt^.Assignment.Object );  yyWriteNl;
 END yyyWriteNodeAssignment;

PROCEDURE yyyWriteNodeReject (yyt: tTree);
 BEGIN
  yyyWriteNodeStatement (yyt); 
 END yyyWriteNodeReject;

PROCEDURE yyyWriteNodeFail (yyt: tTree);
 BEGIN
  yyyWriteNodeStatement (yyt); 
 END yyyWriteNodeFail;

PROCEDURE yyyWriteNodeTargetStmt (yyt: tTree);
 BEGIN
  yyyWriteNodeStatement (yyt); 
  yyWriteSelector ('Parameters'); yyWriteAdr (yyt^.TargetStmt.Parameters);
  yyWriteSelector ('Stmt'); yyWriteAdr (yyt^.TargetStmt.Stmt);
  yyWriteSelector ('UsedNames'); Sets.WriteSet (yyf,  yyt^.TargetStmt.UsedNames );  yyWriteNl;
 END yyyWriteNodeTargetStmt;

PROCEDURE yyyWriteNodeNl (yyt: tTree);
 BEGIN
  yyyWriteNodeStatement (yyt); 
 END yyyWriteNodeNl;

PROCEDURE yyyWriteNodeWriteStr (yyt: tTree);
 BEGIN
  yyyWriteNodeStatement (yyt); 
  yyWriteSelector ('String'); StringMem.WriteString (yyf,  yyt^.WriteStr.String );  yyWriteNl;
 END yyyWriteNodeWriteStr;

PROCEDURE yyyWriteNodeFormal (yyt: tTree);
 BEGIN
  yyWriteSelector ('Next'); yyWriteAdr (yyt^.Formal.Next);
  yyWriteSelector ('Hides'); yyWriteAdr (yyt^.Formal.Hides);
  yyWriteSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.Formal.Name );  yyWriteNl;
  yyWriteSelector ('DeclPos'); Positions.WritePosition (yyf,  yyt^.Formal.DeclPos );  yyWriteNl;
  yyWriteSelector ('TypeDesc'); yyWriteAdr (yyt^.Formal.TypeDesc);
  yyWriteSelector ('Path'); yyWriteAdr (yyt^.Formal.Path);
 END yyyWriteNodeFormal;

PROCEDURE yyyWriteNodePlainFormal (yyt: tTree);
 BEGIN
  yyyWriteNodeFormal (yyt); 
 END yyyWriteNodePlainFormal;

PROCEDURE yyyWriteNodeRoutineFormal (yyt: tTree);
 BEGIN
  yyyWriteNodeFormal (yyt); 
  yyWriteSelector ('TargetClass'); yyWriteAdr (yyt^.RoutineFormal.TargetClass);
  yyWriteSelector ('DeclaredTypeIsGuaranteed'); IO.WriteB (yyf,  yyt^.RoutineFormal.DeclaredTypeIsGuaranteed );  yyWriteNl;
 END yyyWriteNodeRoutineFormal;

PROCEDURE yyyWriteNodeDummyFormal (yyt: tTree);
 BEGIN
  yyWriteSelector ('Next'); yyWriteAdr (yyt^.DummyFormal.Next);
 END yyyWriteNodeDummyFormal;

PROCEDURE yyyWriteNodeNodeTypes (yyt: tTree);
 BEGIN
  yyWriteSelector ('TreeName'); yyWriteAdr (yyt^.NodeTypes.TreeName);
  yyWriteSelector ('Types'); Sets.WriteSet (yyf,  yyt^.NodeTypes.Types );  yyWriteNl;
 END yyyWriteNodeNodeTypes;

PROCEDURE yyyWriteNodeUserType (yyt: tTree);
 BEGIN
  yyWriteSelector ('Type'); Idents.WriteIdent (yyf,  yyt^.UserType.Type );  yyWriteNl;
 END yyyWriteNodeUserType;

PROCEDURE yyyWriteNodeVar (yyt: tTree);
 BEGIN
  yyWriteSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.Var.Name );  yyWriteNl;
  yyWriteSelector ('IsOutput'); IO.WriteB (yyf,  yyt^.Var.IsOutput );  yyWriteNl;
  yyWriteSelector ('IsRegister'); IO.WriteB (yyf,  yyt^.Var.IsRegister );  yyWriteNl;
 END yyyWriteNodeVar;

PROCEDURE yyyWriteNodeConsType (yyt: tTree);
 BEGIN
  yyWriteSelector ('Next'); yyWriteAdr (yyt^.ConsType.Next);
  yyWriteSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.ConsType.Name );  yyWriteNl;
  yyWriteSelector ('IsProperlyNarrowed'); IO.WriteB (yyf,  yyt^.ConsType.IsProperlyNarrowed );  yyWriteNl;
 END yyyWriteNodeConsType;

PROCEDURE yyyWriteNodeField (yyt: tTree);
 BEGIN
  yyWriteSelector ('Next'); yyWriteAdr (yyt^.Field.Next);
  yyWriteSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.Field.Name );  yyWriteNl;
 END yyyWriteNodeField;

PROCEDURE yyyWriteNodeOneTest (yyt: tTree);
 BEGIN
  yyWriteSelector ('Next'); yyWriteAdr (yyt^.OneTest.Next);
  yyWriteSelector ('Path'); yyWriteAdr (yyt^.OneTest.Path);
 END yyyWriteNodeOneTest;

PROCEDURE yyyWriteNodeTestKind (yyt: tTree);
 BEGIN
  yyyWriteNodeOneTest (yyt); 
  yyWriteSelector ('TypeDesc'); yyWriteAdr (yyt^.TestKind.TypeDesc);
  yyWriteSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.TestKind.Name );  yyWriteNl;
 END yyyWriteNodeTestKind;

PROCEDURE yyyWriteNodeTestIsType (yyt: tTree);
 BEGIN
  yyyWriteNodeOneTest (yyt); 
  yyWriteSelector ('TypeDesc'); yyWriteAdr (yyt^.TestIsType.TypeDesc);
  yyWriteSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.TestIsType.Name );  yyWriteNl;
 END yyyWriteNodeTestIsType;

PROCEDURE yyyWriteNodeTestNil (yyt: tTree);
 BEGIN
  yyyWriteNodeOneTest (yyt); 
 END yyyWriteNodeTestNil;

PROCEDURE yyyWriteNodeTestNonlin (yyt: tTree);
 BEGIN
  yyyWriteNodeOneTest (yyt); 
  yyWriteSelector ('Path2'); yyWriteAdr (yyt^.TestNonlin.Path2);
  yyWriteSelector ('TypeDesc'); yyWriteAdr (yyt^.TestNonlin.TypeDesc);
 END yyyWriteNodeTestNonlin;

PROCEDURE yyyWriteNodeTestValue (yyt: tTree);
 BEGIN
  yyyWriteNodeOneTest (yyt); 
  yyWriteSelector ('Expr'); yyWriteAdr (yyt^.TestValue.Expr);
  yyWriteSelector ('TypeDesc'); yyWriteAdr (yyt^.TestValue.TypeDesc);
 END yyyWriteNodeTestValue;

PROCEDURE yyyWriteNodeDecision (yyt: tTree);
 BEGIN
  yyWriteSelector ('ThenPart'); yyWriteAdr (yyt^.Decision.ThenPart);
  yyWriteSelector ('ElsePart'); yyWriteAdr (yyt^.Decision.ElsePart);
  yyWriteSelector ('OneTest'); yyWriteAdr (yyt^.Decision.OneTest);
  yyWriteSelector ('Cases'); IO.WriteI (yyf,  yyt^.Decision.Cases , 0);  yyWriteNl;
  yyWriteSelector ('IsUnchanged'); IO.WriteB (yyf,  yyt^.Decision.IsUnchanged );  yyWriteNl;
 END yyyWriteNodeDecision;

PROCEDURE yyyWriteNodeDecided (yyt: tTree);
 BEGIN
  yyWriteSelector ('ElsePart'); yyWriteAdr (yyt^.Decided.ElsePart);
  yyWriteSelector ('Rule'); yyWriteAdr (yyt^.Decided.Rule);
 END yyyWriteNodeDecided;

PROCEDURE WriteTreeNode (yyyf: IO.tFile; yyt: tTree);
 BEGIN
  yyf := yyyf;
  IF yyt = NoTree THEN
   IO.WriteS (yyf, 'NoTree'); yyWriteNl; RETURN;
  END;

  CASE yyt^.Kind OF
| Classes: IO.WriteS (yyf, 'Classes'); yyWriteNl;
| NoClass: IO.WriteS (yyf, 'NoClass'); yyWriteNl;
| Class: IO.WriteS (yyf, 'Class'); yyWriteNl; yyyWriteNodeClass (yyt);
| Attributes: IO.WriteS (yyf, 'Attributes'); yyWriteNl;
| NoAttribute: IO.WriteS (yyf, 'NoAttribute'); yyWriteNl;
| AttrOrAction: IO.WriteS (yyf, 'AttrOrAction'); yyWriteNl; yyyWriteNodeAttrOrAction (yyt);
| Child: IO.WriteS (yyf, 'Child'); yyWriteNl; yyyWriteNodeChild (yyt);
| Attribute: IO.WriteS (yyf, 'Attribute'); yyWriteNl; yyyWriteNodeAttribute (yyt);
| ActionPart: IO.WriteS (yyf, 'ActionPart'); yyWriteNl; yyyWriteNodeActionPart (yyt);
| Codes: IO.WriteS (yyf, 'Codes'); yyWriteNl; yyyWriteNodeCodes (yyt);
| Designators: IO.WriteS (yyf, 'Designators'); yyWriteNl;
| NoDesignator: IO.WriteS (yyf, 'NoDesignator'); yyWriteNl;
| Designator: IO.WriteS (yyf, 'Designator'); yyWriteNl; yyyWriteNodeDesignator (yyt);
| Ident: IO.WriteS (yyf, 'Ident'); yyWriteNl; yyyWriteNodeIdent (yyt);
| Remote: IO.WriteS (yyf, 'Remote'); yyWriteNl; yyyWriteNodeRemote (yyt);
| Any: IO.WriteS (yyf, 'Any'); yyWriteNl; yyyWriteNodeAny (yyt);
| Anys: IO.WriteS (yyf, 'Anys'); yyWriteNl; yyyWriteNodeAnys (yyt);
| Layouts: IO.WriteS (yyf, 'Layouts'); yyWriteNl;
| NoLayout: IO.WriteS (yyf, 'NoLayout'); yyWriteNl;
| LayoutAny: IO.WriteS (yyf, 'LayoutAny'); yyWriteNl; yyyWriteNodeLayoutAny (yyt);
| Names: IO.WriteS (yyf, 'Names'); yyWriteNl;
| NoName: IO.WriteS (yyf, 'NoName'); yyWriteNl;
| Name: IO.WriteS (yyf, 'Name'); yyWriteNl; yyyWriteNodeName (yyt);
| Spec: IO.WriteS (yyf, 'Spec'); yyWriteNl; yyyWriteNodeSpec (yyt);
| TreeNames: IO.WriteS (yyf, 'TreeNames'); yyWriteNl;
| NoTreeName: IO.WriteS (yyf, 'NoTreeName'); yyWriteNl;
| TreeName: IO.WriteS (yyf, 'TreeName'); yyWriteNl; yyyWriteNodeTreeName (yyt);
| Routines: IO.WriteS (yyf, 'Routines'); yyWriteNl;
| NoRoutine: IO.WriteS (yyf, 'NoRoutine'); yyWriteNl;
| Routine: IO.WriteS (yyf, 'Routine'); yyWriteNl; yyyWriteNodeRoutine (yyt);
| Procedure: IO.WriteS (yyf, 'Procedure'); yyWriteNl; yyyWriteNodeProcedure (yyt);
| Function: IO.WriteS (yyf, 'Function'); yyWriteNl; yyyWriteNodeFunction (yyt);
| Predicate: IO.WriteS (yyf, 'Predicate'); yyWriteNl; yyyWriteNodePredicate (yyt);
| Parameters: IO.WriteS (yyf, 'Parameters'); yyWriteNl;
| NoParameter: IO.WriteS (yyf, 'NoParameter'); yyWriteNl;
| Param: IO.WriteS (yyf, 'Param'); yyWriteNl; yyyWriteNodeParam (yyt);
| Type: IO.WriteS (yyf, 'Type'); yyWriteNl; yyyWriteNodeType (yyt);
| Rules: IO.WriteS (yyf, 'Rules'); yyWriteNl;
| NoRule: IO.WriteS (yyf, 'NoRule'); yyWriteNl;
| Rule: IO.WriteS (yyf, 'Rule'); yyWriteNl; yyyWriteNodeRule (yyt);
| Patterns: IO.WriteS (yyf, 'Patterns'); yyWriteNl;
| NoPattern: IO.WriteS (yyf, 'NoPattern'); yyWriteNl; yyyWriteNodeNoPattern (yyt);
| OnePattern: IO.WriteS (yyf, 'OnePattern'); yyWriteNl; yyyWriteNodeOnePattern (yyt);
| OnePatternAlts: IO.WriteS (yyf, 'OnePatternAlts'); yyWriteNl; yyyWriteNodeOnePatternAlts (yyt);
| PatternsList: IO.WriteS (yyf, 'PatternsList'); yyWriteNl;
| NoPatternsList: IO.WriteS (yyf, 'NoPatternsList'); yyWriteNl;
| OnePatternsList: IO.WriteS (yyf, 'OnePatternsList'); yyWriteNl; yyyWriteNodeOnePatternsList (yyt);
| Pattern: IO.WriteS (yyf, 'Pattern'); yyWriteNl; yyyWriteNodePattern (yyt);
| Decompose: IO.WriteS (yyf, 'Decompose'); yyWriteNl; yyyWriteNodeDecompose (yyt);
| VarDef: IO.WriteS (yyf, 'VarDef'); yyWriteNl; yyyWriteNodeVarDef (yyt);
| NilTest: IO.WriteS (yyf, 'NilTest'); yyWriteNl; yyyWriteNodeNilTest (yyt);
| DontCare1: IO.WriteS (yyf, 'DontCare1'); yyWriteNl; yyyWriteNodeDontCare1 (yyt);
| DontCare1Explicit: IO.WriteS (yyf, 'DontCare1Explicit'); yyWriteNl; yyyWriteNodeDontCare1Explicit (yyt);
| DontCare1Internal: IO.WriteS (yyf, 'DontCare1Internal'); yyWriteNl; yyyWriteNodeDontCare1Internal (yyt);
| DontCare: IO.WriteS (yyf, 'DontCare'); yyWriteNl; yyyWriteNodeDontCare (yyt);
| DontCareExplicit: IO.WriteS (yyf, 'DontCareExplicit'); yyWriteNl; yyyWriteNodeDontCareExplicit (yyt);
| DontCareInternal: IO.WriteS (yyf, 'DontCareInternal'); yyWriteNl; yyyWriteNodeDontCareInternal (yyt);
| Value: IO.WriteS (yyf, 'Value'); yyWriteNl; yyyWriteNodeValue (yyt);
| Exprs: IO.WriteS (yyf, 'Exprs'); yyWriteNl;
| NoExpr: IO.WriteS (yyf, 'NoExpr'); yyWriteNl; yyyWriteNodeNoExpr (yyt);
| OneExpr: IO.WriteS (yyf, 'OneExpr'); yyWriteNl; yyyWriteNodeOneExpr (yyt);
| NamedExpr: IO.WriteS (yyf, 'NamedExpr'); yyWriteNl; yyyWriteNodeNamedExpr (yyt);
| Expr: IO.WriteS (yyf, 'Expr'); yyWriteNl; yyyWriteNodeExpr (yyt);
| Compose: IO.WriteS (yyf, 'Compose'); yyWriteNl; yyyWriteNodeCompose (yyt);
| VarUse: IO.WriteS (yyf, 'VarUse'); yyWriteNl; yyyWriteNodeVarUse (yyt);
| AttrDesc: IO.WriteS (yyf, 'AttrDesc'); yyWriteNl; yyyWriteNodeAttrDesc (yyt);
| Nil: IO.WriteS (yyf, 'Nil'); yyWriteNl; yyyWriteNodeNil (yyt);
| Call: IO.WriteS (yyf, 'Call'); yyWriteNl; yyyWriteNodeCall (yyt);
| Binary: IO.WriteS (yyf, 'Binary'); yyWriteNl; yyyWriteNodeBinary (yyt);
| yy1: IO.WriteS (yyf, 'yy1'); yyWriteNl; yyyWriteNodeyy1 (yyt);
| BinaryCompound: IO.WriteS (yyf, 'BinaryCompound'); yyWriteNl; yyyWriteNodeBinaryCompound (yyt);
| PreOperator: IO.WriteS (yyf, 'PreOperator'); yyWriteNl; yyyWriteNodePreOperator (yyt);
| PostOperator: IO.WriteS (yyf, 'PostOperator'); yyWriteNl; yyyWriteNodePostOperator (yyt);
| Index: IO.WriteS (yyf, 'Index'); yyWriteNl; yyyWriteNodeIndex (yyt);
| Parents: IO.WriteS (yyf, 'Parents'); yyWriteNl; yyyWriteNodeParents (yyt);
| TargetExpr: IO.WriteS (yyf, 'TargetExpr'); yyWriteNl; yyyWriteNodeTargetExpr (yyt);
| StringExpr: IO.WriteS (yyf, 'StringExpr'); yyWriteNl; yyyWriteNodeStringExpr (yyt);
| Statements: IO.WriteS (yyf, 'Statements'); yyWriteNl;
| NoStatement: IO.WriteS (yyf, 'NoStatement'); yyWriteNl;
| Statement: IO.WriteS (yyf, 'Statement'); yyWriteNl; yyyWriteNodeStatement (yyt);
| ProcCall: IO.WriteS (yyf, 'ProcCall'); yyWriteNl; yyyWriteNodeProcCall (yyt);
| Condition: IO.WriteS (yyf, 'Condition'); yyWriteNl; yyyWriteNodeCondition (yyt);
| Assignment: IO.WriteS (yyf, 'Assignment'); yyWriteNl; yyyWriteNodeAssignment (yyt);
| Reject: IO.WriteS (yyf, 'Reject'); yyWriteNl; yyyWriteNodeReject (yyt);
| Fail: IO.WriteS (yyf, 'Fail'); yyWriteNl; yyyWriteNodeFail (yyt);
| TargetStmt: IO.WriteS (yyf, 'TargetStmt'); yyWriteNl; yyyWriteNodeTargetStmt (yyt);
| Nl: IO.WriteS (yyf, 'Nl'); yyWriteNl; yyyWriteNodeNl (yyt);
| WriteStr: IO.WriteS (yyf, 'WriteStr'); yyWriteNl; yyyWriteNodeWriteStr (yyt);
| Formals: IO.WriteS (yyf, 'Formals'); yyWriteNl;
| NoFormal: IO.WriteS (yyf, 'NoFormal'); yyWriteNl;
| Formal: IO.WriteS (yyf, 'Formal'); yyWriteNl; yyyWriteNodeFormal (yyt);
| PlainFormal: IO.WriteS (yyf, 'PlainFormal'); yyWriteNl; yyyWriteNodePlainFormal (yyt);
| RoutineFormal: IO.WriteS (yyf, 'RoutineFormal'); yyWriteNl; yyyWriteNodeRoutineFormal (yyt);
| DummyFormal: IO.WriteS (yyf, 'DummyFormal'); yyWriteNl; yyyWriteNodeDummyFormal (yyt);
| TypeDesc: IO.WriteS (yyf, 'TypeDesc'); yyWriteNl;
| NodeTypes: IO.WriteS (yyf, 'NodeTypes'); yyWriteNl; yyyWriteNodeNodeTypes (yyt);
| UserType: IO.WriteS (yyf, 'UserType'); yyWriteNl; yyyWriteNodeUserType (yyt);
| Path: IO.WriteS (yyf, 'Path'); yyWriteNl;
| Var: IO.WriteS (yyf, 'Var'); yyWriteNl; yyyWriteNodeVar (yyt);
| ConsType: IO.WriteS (yyf, 'ConsType'); yyWriteNl; yyyWriteNodeConsType (yyt);
| Field: IO.WriteS (yyf, 'Field'); yyWriteNl; yyyWriteNodeField (yyt);
| Tests: IO.WriteS (yyf, 'Tests'); yyWriteNl;
| NoTest: IO.WriteS (yyf, 'NoTest'); yyWriteNl;
| OneTest: IO.WriteS (yyf, 'OneTest'); yyWriteNl; yyyWriteNodeOneTest (yyt);
| TestKind: IO.WriteS (yyf, 'TestKind'); yyWriteNl; yyyWriteNodeTestKind (yyt);
| TestIsType: IO.WriteS (yyf, 'TestIsType'); yyWriteNl; yyyWriteNodeTestIsType (yyt);
| TestNil: IO.WriteS (yyf, 'TestNil'); yyWriteNl; yyyWriteNodeTestNil (yyt);
| TestNonlin: IO.WriteS (yyf, 'TestNonlin'); yyWriteNl; yyyWriteNodeTestNonlin (yyt);
| TestValue: IO.WriteS (yyf, 'TestValue'); yyWriteNl; yyyWriteNodeTestValue (yyt);
| Decisions: IO.WriteS (yyf, 'Decisions'); yyWriteNl;
| NoDecision: IO.WriteS (yyf, 'NoDecision'); yyWriteNl;
| Decision: IO.WriteS (yyf, 'Decision'); yyWriteNl; yyyWriteNodeDecision (yyt);
| Decided: IO.WriteS (yyf, 'Decided'); yyWriteNl; yyyWriteNodeDecided (yyt);
  ELSE
  END;
 END WriteTreeNode;

VAR yyIndentLevel      : SHORTINT;
VAR yyActualIndent , yyIndentQuotient , yyIndentRemainder : SHORTINT;
CONST yyIndentFactor = 20; 
PROCEDURE yySetIndentInfo ( ); 
  BEGIN 
   yyIndentQuotient := yyIndentLevel DIV yyIndentFactor;    yyIndentRemainder := yyIndentLevel MOD yyIndentFactor; 
   yyActualIndent      := VAL ( SHORTINT , 10 * ORD ( yyIndentQuotient > 0 ) )         + yyIndentRemainder 
  END yySetIndentInfo ; 

PROCEDURE WriteTree (yyyf: IO.tFile; yyt: tTree);
 VAR yySaveLevel       : SHORTINT;
 BEGIN
  yyf := yyyf;
  IF yyRecursionLevel = 0 THEN yyLabelCount := 0; END;
  INC (yyRecursionLevel);
  yyMark (yyt);
  yySaveLevel := yyIndentLevel;
  yyIndentLevel := 0;
  yySetIndentInfo ( ) ;   yyWriteTree (yyt);
  yyIndentLevel := yySaveLevel;
  yySetIndentInfo ( ) ;   DEC (yyRecursionLevel);
 END WriteTree;

PROCEDURE yyIndentSelector (yys: ARRAY OF CHAR);
 BEGIN    IF yyIndentQuotient > 0    THEN IO.WriteC ( yyf , '(' ); IO.WriteC ( yyf , '*' ); 
     IO.WriteN ( yyf , yyIndentQuotient * yyIndentFactor , 6 , 10 ); 
     IO.WriteC ( yyf , '*' ); IO.WriteC ( yyf , ')' ); 
     Layout.WriteSpaces (yyf, yyIndentRemainder ); 
   ELSE Layout.WriteSpaces (yyf, yyIndentRemainder); 
   END ;    yyWriteSelector (yys); 
 END yyIndentSelector;

PROCEDURE yyIndentSelectorTree (yys: ARRAY OF CHAR; yyt: tTree);
 BEGIN yyIndentSelector (yys); yyWriteTree ( yyt );  END yyIndentSelectorTree;

PROCEDURE yWriteClass (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Class'); yyWriteNl;
  yyIndentSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.Class.Name );  yyWriteNl;
  yyIndentSelector ('Properties'); yyWriteHex ( yyt^.Class.Properties );  yyWriteNl;
  yyIndentSelectorTree ('Attributes', yyt^.Class.Attributes);
  yyIndentSelectorTree ('Extensions', yyt^.Class.Extensions);
  yyIndentSelectorTree ('BaseClass', yyt^.Class.BaseClass);
  yyIndentSelectorTree ('Formals', yyt^.Class.Formals);
  yyIndentSelectorTree ('TypeDesc', yyt^.Class.TypeDesc);
  yyIndentSelector ('Index'); IO.WriteI (yyf,  yyt^.Class.Index , 0);  yyWriteNl;
  yyIndentSelector ('Depth'); IO.WriteI (yyf,  yyt^.Class.Depth , 0);  yyWriteNl;
 END yWriteClass;

PROCEDURE yWriteAttrOrAction (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'AttrOrAction'); yyWriteNl;
 END yWriteAttrOrAction;

PROCEDURE yWriteChild (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Child'); yyWriteNl;
  yyIndentSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.Child.Name );  yyWriteNl;
  yyIndentSelector ('Type'); Idents.WriteIdent (yyf,  yyt^.Child.Type );  yyWriteNl;
  yyIndentSelector ('Properties'); yyWriteHex ( yyt^.Child.Properties );  yyWriteNl;
 END yWriteChild;

PROCEDURE yWriteAttribute (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Attribute'); yyWriteNl;
  yyIndentSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.Attribute.Name );  yyWriteNl;
  yyIndentSelector ('Type'); Idents.WriteIdent (yyf,  yyt^.Attribute.Type );  yyWriteNl;
  yyIndentSelector ('Properties'); yyWriteHex ( yyt^.Attribute.Properties );  yyWriteNl;
 END yWriteAttribute;

PROCEDURE yWriteActionPart (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'ActionPart'); yyWriteNl;
 END yWriteActionPart;

PROCEDURE yWriteCodes (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Codes'); yyWriteNl;
  yyIndentSelector ('Export'); Texts.WriteText (yyf,  yyt^.Codes.Export );  yyWriteNl;
  yyIndentSelector ('Import'); Texts.WriteText (yyf,  yyt^.Codes.Import );  yyWriteNl;
  yyIndentSelector ('Global'); Texts.WriteText (yyf,  yyt^.Codes.Global );  yyWriteNl;
  yyIndentSelector ('SpecWith'); Texts.WriteText (yyf,  yyt^.Codes.SpecWith );  yyWriteNl;
  yyIndentSelector ('BodyWith'); Texts.WriteText (yyf,  yyt^.Codes.BodyWith );  yyWriteNl;
  yyIndentSelector ('Local'); Texts.WriteText (yyf,  yyt^.Codes.Local );  yyWriteNl;
  yyIndentSelector ('Begin'); Texts.WriteText (yyf,  yyt^.Codes.Begin );  yyWriteNl;
  yyIndentSelector ('Close'); Texts.WriteText (yyf,  yyt^.Codes.Close );  yyWriteNl;
  yyIndentSelector ('ExportLine'); Positions.WritePosition (yyf,  yyt^.Codes.ExportLine );  yyWriteNl;
  yyIndentSelector ('ImportLine'); Positions.WritePosition (yyf,  yyt^.Codes.ImportLine );  yyWriteNl;
  yyIndentSelector ('GlobalLine'); Positions.WritePosition (yyf,  yyt^.Codes.GlobalLine );  yyWriteNl;
  yyIndentSelector ('SpecWithLine'); Positions.WritePosition (yyf,  yyt^.Codes.SpecWithLine );  yyWriteNl;
  yyIndentSelector ('BodyWithLine'); Positions.WritePosition (yyf,  yyt^.Codes.BodyWithLine );  yyWriteNl;
  yyIndentSelector ('LocalLine'); Positions.WritePosition (yyf,  yyt^.Codes.LocalLine );  yyWriteNl;
  yyIndentSelector ('BeginLine'); Positions.WritePosition (yyf,  yyt^.Codes.BeginLine );  yyWriteNl;
  yyIndentSelector ('CloseLine'); Positions.WritePosition (yyf,  yyt^.Codes.CloseLine );  yyWriteNl;
 END yWriteCodes;

PROCEDURE yWriteDesignator (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Designator'); yyWriteNl;
  yyIndentSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.Designator.Selector );  yyWriteNl;
  yyIndentSelector ('Attribute'); Idents.WriteIdent (yyf,  yyt^.Designator.Attribute );  yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Designator.Pos );  yyWriteNl;
  yyIndentSelector ('AttributePos'); Positions.WritePosition (yyf,  yyt^.Designator.AttributePos );  yyWriteNl;
  yyIndentSelector ('Object'); yyWriteHex ( yyt^.Designator.Object );  yyWriteNl;
  yyIndentSelector ('Type'); Idents.WriteIdent (yyf,  yyt^.Designator.Type );  yyWriteNl;
 END yWriteDesignator;

PROCEDURE yWriteIdent (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Ident'); yyWriteNl;
  yyIndentSelector ('Attribute'); Idents.WriteIdent (yyf,  yyt^.Ident.Attribute );  yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Ident.Pos );  yyWriteNl;
  yyIndentSelector ('Object'); yyWriteHex ( yyt^.Ident.Object );  yyWriteNl;
 END yWriteIdent;

PROCEDURE yWriteRemote (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Remote'); yyWriteNl;
  yyIndentSelectorTree ('Designators', yyt^.Remote.Designators);
  yyIndentSelector ('Type'); Idents.WriteIdent (yyf,  yyt^.Remote.Type );  yyWriteNl;
  yyIndentSelector ('Attribute'); Idents.WriteIdent (yyf,  yyt^.Remote.Attribute );  yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Remote.Pos );  yyWriteNl;
 END yWriteRemote;

PROCEDURE yWriteAny (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Any'); yyWriteNl;
  yyIndentSelector ('Code'); StringMem.WriteString (yyf,  yyt^.Any.Code );  yyWriteNl;
 END yWriteAny;

PROCEDURE yWriteAnys (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Anys'); yyWriteNl;
  yyIndentSelectorTree ('Layouts', yyt^.Anys.Layouts);
 END yWriteAnys;

PROCEDURE yWriteLayoutAny (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'LayoutAny'); yyWriteNl;
  yyIndentSelector ('Code'); StringMem.WriteString (yyf,  yyt^.LayoutAny.Code );  yyWriteNl;
 END yWriteLayoutAny;

PROCEDURE yWriteName (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Name'); yyWriteNl;
  yyIndentSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.Name.Name );  yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Name.Pos );  yyWriteNl;
  yyIndentSelector ('Object'); yyWriteHex ( yyt^.Name.Object );  yyWriteNl;
 END yWriteName;

PROCEDURE yWriteSpec (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Spec'); yyWriteNl;
  yyIndentSelector ('TrafoName'); Idents.WriteIdent (yyf,  yyt^.Spec.TrafoName );  yyWriteNl;
  yyIndentSelectorTree ('TreeNames', yyt^.Spec.TreeNames);
  yyIndentSelectorTree ('Public', yyt^.Spec.Public);
  yyIndentSelectorTree ('Extern', yyt^.Spec.Extern);
  yyIndentSelectorTree ('Codes', yyt^.Spec.Codes);
 END yWriteSpec;

PROCEDURE yWriteTreeName (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'TreeName'); yyWriteNl;
  yyIndentSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.TreeName.Name );  yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.TreeName.Pos );  yyWriteNl;
  yyIndentSelectorTree ('Classes', yyt^.TreeName.Classes);
  yyIndentSelector ('ClassCount'); IO.WriteI (yyf,  yyt^.TreeName.ClassCount , 0);  yyWriteNl;
  yyIndentSelectorTree ('EmptyType', yyt^.TreeName.EmptyType);
  yyIndentSelectorTree ('UniversalClass', yyt^.TreeName.UniversalClass);
 END yWriteTreeName;

PROCEDURE yWriteRoutine (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Routine'); yyWriteNl;
  yyIndentSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.Routine.Name );  yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Routine.Pos );  yyWriteNl;
  yyIndentSelectorTree ('InParams', yyt^.Routine.InParams);
  yyIndentSelectorTree ('OutParams', yyt^.Routine.OutParams);
  yyIndentSelectorTree ('Extern', yyt^.Routine.Extern);
  yyIndentSelector ('Local'); Texts.WriteText (yyf,  yyt^.Routine.Local );  yyWriteNl;
  yyIndentSelector ('LocalLine'); Positions.WritePosition (yyf,  yyt^.Routine.LocalLine );  yyWriteNl;
  yyIndentSelectorTree ('Rules', yyt^.Routine.Rules);
  yyIndentSelectorTree ('InForm', yyt^.Routine.InForm);
  yyIndentSelectorTree ('OutForm', yyt^.Routine.OutForm);
  yyIndentSelectorTree ('ParamDecls', yyt^.Routine.ParamDecls);
  yyIndentSelector ('IsExtern'); IO.WriteB (yyf,  yyt^.Routine.IsExtern );  yyWriteNl;
  yyIndentSelectorTree ('Decisions', yyt^.Routine.Decisions);
 END yWriteRoutine;

PROCEDURE yWriteProcedure (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Procedure'); yyWriteNl;
  yyIndentSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.Procedure.Name );  yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Procedure.Pos );  yyWriteNl;
  yyIndentSelectorTree ('InParams', yyt^.Procedure.InParams);
  yyIndentSelectorTree ('OutParams', yyt^.Procedure.OutParams);
  yyIndentSelectorTree ('Extern', yyt^.Procedure.Extern);
  yyIndentSelector ('Local'); Texts.WriteText (yyf,  yyt^.Procedure.Local );  yyWriteNl;
  yyIndentSelector ('LocalLine'); Positions.WritePosition (yyf,  yyt^.Procedure.LocalLine );  yyWriteNl;
  yyIndentSelectorTree ('Rules', yyt^.Procedure.Rules);
  yyIndentSelectorTree ('InForm', yyt^.Procedure.InForm);
  yyIndentSelectorTree ('OutForm', yyt^.Procedure.OutForm);
  yyIndentSelectorTree ('ParamDecls', yyt^.Procedure.ParamDecls);
  yyIndentSelector ('IsExtern'); IO.WriteB (yyf,  yyt^.Procedure.IsExtern );  yyWriteNl;
  yyIndentSelectorTree ('Decisions', yyt^.Procedure.Decisions);
 END yWriteProcedure;

PROCEDURE yWriteFunction (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Function'); yyWriteNl;
  yyIndentSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.Function.Name );  yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Function.Pos );  yyWriteNl;
  yyIndentSelectorTree ('InParams', yyt^.Function.InParams);
  yyIndentSelectorTree ('OutParams', yyt^.Function.OutParams);
  yyIndentSelectorTree ('Extern', yyt^.Function.Extern);
  yyIndentSelector ('Local'); Texts.WriteText (yyf,  yyt^.Function.Local );  yyWriteNl;
  yyIndentSelector ('LocalLine'); Positions.WritePosition (yyf,  yyt^.Function.LocalLine );  yyWriteNl;
  yyIndentSelectorTree ('Rules', yyt^.Function.Rules);
  yyIndentSelectorTree ('InForm', yyt^.Function.InForm);
  yyIndentSelectorTree ('OutForm', yyt^.Function.OutForm);
  yyIndentSelectorTree ('ParamDecls', yyt^.Function.ParamDecls);
  yyIndentSelector ('IsExtern'); IO.WriteB (yyf,  yyt^.Function.IsExtern );  yyWriteNl;
  yyIndentSelectorTree ('Decisions', yyt^.Function.Decisions);
  yyIndentSelectorTree ('ReturnParams', yyt^.Function.ReturnParams);
  yyIndentSelectorTree ('ReturnForm', yyt^.Function.ReturnForm);
 END yWriteFunction;

PROCEDURE yWritePredicate (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Predicate'); yyWriteNl;
  yyIndentSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.Predicate.Name );  yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Predicate.Pos );  yyWriteNl;
  yyIndentSelectorTree ('InParams', yyt^.Predicate.InParams);
  yyIndentSelectorTree ('OutParams', yyt^.Predicate.OutParams);
  yyIndentSelectorTree ('Extern', yyt^.Predicate.Extern);
  yyIndentSelector ('Local'); Texts.WriteText (yyf,  yyt^.Predicate.Local );  yyWriteNl;
  yyIndentSelector ('LocalLine'); Positions.WritePosition (yyf,  yyt^.Predicate.LocalLine );  yyWriteNl;
  yyIndentSelectorTree ('Rules', yyt^.Predicate.Rules);
  yyIndentSelectorTree ('InForm', yyt^.Predicate.InForm);
  yyIndentSelectorTree ('OutForm', yyt^.Predicate.OutForm);
  yyIndentSelectorTree ('ParamDecls', yyt^.Predicate.ParamDecls);
  yyIndentSelector ('IsExtern'); IO.WriteB (yyf,  yyt^.Predicate.IsExtern );  yyWriteNl;
  yyIndentSelectorTree ('Decisions', yyt^.Predicate.Decisions);
 END yWritePredicate;

PROCEDURE yWriteParam (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Param'); yyWriteNl;
  yyIndentSelector ('IsRef'); IO.WriteB (yyf,  yyt^.Param.IsRef );  yyWriteNl;
  yyIndentSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.Param.Name );  yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Param.Pos );  yyWriteNl;
  yyIndentSelectorTree ('Type', yyt^.Param.Type);
 END yWriteParam;

PROCEDURE yWriteType (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Type'); yyWriteNl;
  yyIndentSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.Type.Name );  yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Type.Pos );  yyWriteNl;
 END yWriteType;

PROCEDURE yWriteRule (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Rule'); yyWriteNl;
  yyIndentSelector ('Line'); Positions.WritePosition (yyf,  yyt^.Rule.Line );  yyWriteNl;
  yyIndentSelectorTree ('Patterns', yyt^.Rule.Patterns);
  yyIndentSelectorTree ('Exprs', yyt^.Rule.Exprs);
  yyIndentSelectorTree ('Expr', yyt^.Rule.Expr);
  yyIndentSelectorTree ('Statements', yyt^.Rule.Statements);
  yyIndentSelectorTree ('VarDecls', yyt^.Rule.VarDecls);
  yyIndentSelector ('HasTempos'); IO.WriteB (yyf,  yyt^.Rule.HasTempos );  yyWriteNl;
  yyIndentSelector ('HasPatterns'); IO.WriteB (yyf,  yyt^.Rule.HasPatterns );  yyWriteNl;
  yyIndentSelector ('Tempo'); Idents.WriteIdent (yyf,  yyt^.Rule.Tempo );  yyWriteNl;
  yyIndentSelector ('Index'); IO.WriteI (yyf,  yyt^.Rule.Index , 0);  yyWriteNl;
  yyIndentSelectorTree ('Tests', yyt^.Rule.Tests);
  yyIndentSelector ('HasExit'); IO.WriteB (yyf,  yyt^.Rule.HasExit );  yyWriteNl;
  yyIndentSelector ('HasAssign'); IO.WriteB (yyf,  yyt^.Rule.HasAssign );  yyWriteNl;
  yyIndentSelector ('HasTargetCode'); IO.WriteB (yyf,  yyt^.Rule.HasTargetCode );  yyWriteNl;
  yyIndentSelector ('HasRejectOrFail'); IO.WriteB (yyf,  yyt^.Rule.HasRejectOrFail );  yyWriteNl;
 END yWriteRule;

PROCEDURE yWriteNoPattern (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'NoPattern'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.NoPattern.Pos );  yyWriteNl;
 END yWriteNoPattern;

PROCEDURE yWriteOnePattern (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'OnePattern'); yyWriteNl;
  yyIndentSelectorTree ('Pattern', yyt^.OnePattern.Pattern);
 END yWriteOnePattern;

PROCEDURE yWriteOnePatternAlts (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'OnePatternAlts'); yyWriteNl;
  yyIndentSelectorTree ('PatternsList', yyt^.OnePatternAlts.PatternsList);
  yyIndentSelectorTree ('Current', yyt^.OnePatternAlts.Current);
 END yWriteOnePatternAlts;

PROCEDURE yWriteOnePatternsList (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'OnePatternsList'); yyWriteNl;
  yyIndentSelectorTree ('Patterns', yyt^.OnePatternsList.Patterns);
 END yWriteOnePatternsList;

PROCEDURE yWritePattern (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Pattern'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Pattern.Pos );  yyWriteNl;
  yyIndentSelector ('Tempo'); Idents.WriteIdent (yyf,  yyt^.Pattern.Tempo );  yyWriteNl;
  yyIndentSelectorTree ('TypeDesc', yyt^.Pattern.TypeDesc);
 END yWritePattern;

PROCEDURE yWriteDecompose (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Decompose'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Decompose.Pos );  yyWriteNl;
  yyIndentSelector ('Tempo'); Idents.WriteIdent (yyf,  yyt^.Decompose.Tempo );  yyWriteNl;
  yyIndentSelectorTree ('TypeDesc', yyt^.Decompose.TypeDesc);
  yyIndentSelectorTree ('Path', yyt^.Decompose.Path);
  yyIndentSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.Decompose.Selector );  yyWriteNl;
  yyIndentSelectorTree ('Expr', yyt^.Decompose.Expr);
  yyIndentSelector ('Widen'); IO.WriteB (yyf,  yyt^.Decompose.Widen );  yyWriteNl;
  yyIndentSelector ('Object'); yyWriteHex ( yyt^.Decompose.Object );  yyWriteNl;
  yyIndentSelector ('IsProperlyNarrowed'); IO.WriteB (yyf,  yyt^.Decompose.IsProperlyNarrowed );  yyWriteNl;
 END yWriteDecompose;

PROCEDURE yWriteVarDef (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'VarDef'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.VarDef.Pos );  yyWriteNl;
  yyIndentSelector ('Tempo'); Idents.WriteIdent (yyf,  yyt^.VarDef.Tempo );  yyWriteNl;
  yyIndentSelectorTree ('TypeDesc', yyt^.VarDef.TypeDesc);
  yyIndentSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.VarDef.Selector );  yyWriteNl;
  yyIndentSelector ('HasDelimiter'); IO.WriteB (yyf,  yyt^.VarDef.HasDelimiter );  yyWriteNl;
  yyIndentSelector ('Object'); yyWriteHex ( yyt^.VarDef.Object );  yyWriteNl;
 END yWriteVarDef;

PROCEDURE yWriteNilTest (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'NilTest'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.NilTest.Pos );  yyWriteNl;
  yyIndentSelector ('Tempo'); Idents.WriteIdent (yyf,  yyt^.NilTest.Tempo );  yyWriteNl;
  yyIndentSelectorTree ('TypeDesc', yyt^.NilTest.TypeDesc);
  yyIndentSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.NilTest.Selector );  yyWriteNl;
  yyIndentSelector ('Widen'); IO.WriteB (yyf,  yyt^.NilTest.Widen );  yyWriteNl;
  yyIndentSelector ('IsProperlyNarrowed'); IO.WriteB (yyf,  yyt^.NilTest.IsProperlyNarrowed );  yyWriteNl;
 END yWriteNilTest;

PROCEDURE yWriteDontCare1 (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'DontCare1'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.DontCare1.Pos );  yyWriteNl;
  yyIndentSelector ('Tempo'); Idents.WriteIdent (yyf,  yyt^.DontCare1.Tempo );  yyWriteNl;
  yyIndentSelectorTree ('TypeDesc', yyt^.DontCare1.TypeDesc);
  yyIndentSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.DontCare1.Selector );  yyWriteNl;
 END yWriteDontCare1;

PROCEDURE yWriteDontCare1Explicit (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'DontCare1Explicit'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.DontCare1Explicit.Pos );  yyWriteNl;
  yyIndentSelector ('Tempo'); Idents.WriteIdent (yyf,  yyt^.DontCare1Explicit.Tempo );  yyWriteNl;
  yyIndentSelectorTree ('TypeDesc', yyt^.DontCare1Explicit.TypeDesc);
  yyIndentSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.DontCare1Explicit.Selector );  yyWriteNl;
 END yWriteDontCare1Explicit;

PROCEDURE yWriteDontCare1Internal (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'DontCare1Internal'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.DontCare1Internal.Pos );  yyWriteNl;
  yyIndentSelector ('Tempo'); Idents.WriteIdent (yyf,  yyt^.DontCare1Internal.Tempo );  yyWriteNl;
  yyIndentSelectorTree ('TypeDesc', yyt^.DontCare1Internal.TypeDesc);
  yyIndentSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.DontCare1Internal.Selector );  yyWriteNl;
 END yWriteDontCare1Internal;

PROCEDURE yWriteDontCare (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'DontCare'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.DontCare.Pos );  yyWriteNl;
  yyIndentSelector ('Tempo'); Idents.WriteIdent (yyf,  yyt^.DontCare.Tempo );  yyWriteNl;
  yyIndentSelectorTree ('TypeDesc', yyt^.DontCare.TypeDesc);
  yyIndentSelectorTree ('Path', yyt^.DontCare.Path);
 END yWriteDontCare;

PROCEDURE yWriteDontCareExplicit (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'DontCareExplicit'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.DontCareExplicit.Pos );  yyWriteNl;
  yyIndentSelector ('Tempo'); Idents.WriteIdent (yyf,  yyt^.DontCareExplicit.Tempo );  yyWriteNl;
  yyIndentSelectorTree ('TypeDesc', yyt^.DontCareExplicit.TypeDesc);
  yyIndentSelectorTree ('Path', yyt^.DontCareExplicit.Path);
 END yWriteDontCareExplicit;

PROCEDURE yWriteDontCareInternal (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'DontCareInternal'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.DontCareInternal.Pos );  yyWriteNl;
  yyIndentSelector ('Tempo'); Idents.WriteIdent (yyf,  yyt^.DontCareInternal.Tempo );  yyWriteNl;
  yyIndentSelectorTree ('TypeDesc', yyt^.DontCareInternal.TypeDesc);
  yyIndentSelectorTree ('Path', yyt^.DontCareInternal.Path);
 END yWriteDontCareInternal;

PROCEDURE yWriteValue (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Value'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Value.Pos );  yyWriteNl;
  yyIndentSelector ('Tempo'); Idents.WriteIdent (yyf,  yyt^.Value.Tempo );  yyWriteNl;
  yyIndentSelectorTree ('TypeDesc', yyt^.Value.TypeDesc);
  yyIndentSelectorTree ('Path', yyt^.Value.Path);
  yyIndentSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.Value.Selector );  yyWriteNl;
 END yWriteValue;

PROCEDURE yWriteNoExpr (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'NoExpr'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.NoExpr.Pos );  yyWriteNl;
 END yWriteNoExpr;

PROCEDURE yWriteOneExpr (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'OneExpr'); yyWriteNl;
  yyIndentSelectorTree ('Expr', yyt^.OneExpr.Expr);
 END yWriteOneExpr;

PROCEDURE yWriteNamedExpr (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'NamedExpr'); yyWriteNl;
  yyIndentSelectorTree ('Expr', yyt^.NamedExpr.Expr);
  yyIndentSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.NamedExpr.Name );  yyWriteNl;
  yyIndentSelector ('NamePos'); Positions.WritePosition (yyf,  yyt^.NamedExpr.NamePos );  yyWriteNl;
 END yWriteNamedExpr;

PROCEDURE yWriteExpr (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Expr'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Expr.Pos );  yyWriteNl;
  yyIndentSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.Expr.Selector );  yyWriteNl;
 END yWriteExpr;

PROCEDURE yWriteCompose (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Compose'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Compose.Pos );  yyWriteNl;
  yyIndentSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.Compose.Selector );  yyWriteNl;
  yyIndentSelectorTree ('Expr', yyt^.Compose.Expr);
  yyIndentSelectorTree ('Exprs', yyt^.Compose.Exprs);
  yyIndentSelector ('Widen'); IO.WriteB (yyf,  yyt^.Compose.Widen );  yyWriteNl;
  yyIndentSelector ('Object'); yyWriteHex ( yyt^.Compose.Object );  yyWriteNl;
  yyIndentSelector ('Tempo'); Idents.WriteIdent (yyf,  yyt^.Compose.Tempo );  yyWriteNl;
 END yWriteCompose;

PROCEDURE yWriteVarUse (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'VarUse'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.VarUse.Pos );  yyWriteNl;
  yyIndentSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.VarUse.Selector );  yyWriteNl;
  yyIndentSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.VarUse.Name );  yyWriteNl;
  yyIndentSelector ('Widen'); IO.WriteB (yyf,  yyt^.VarUse.Widen );  yyWriteNl;
  yyIndentSelector ('Object'); yyWriteHex ( yyt^.VarUse.Object );  yyWriteNl;
 END yWriteVarUse;

PROCEDURE yWriteAttrDesc (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'AttrDesc'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.AttrDesc.Pos );  yyWriteNl;
  yyIndentSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.AttrDesc.Selector );  yyWriteNl;
  yyIndentSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.AttrDesc.Name );  yyWriteNl;
  yyIndentSelector ('Widen'); IO.WriteB (yyf,  yyt^.AttrDesc.Widen );  yyWriteNl;
  yyIndentSelector ('Object'); yyWriteHex ( yyt^.AttrDesc.Object );  yyWriteNl;
  yyIndentSelector ('Attribute'); Idents.WriteIdent (yyf,  yyt^.AttrDesc.Attribute );  yyWriteNl;
  yyIndentSelector ('AttributePos'); Positions.WritePosition (yyf,  yyt^.AttrDesc.AttributePos );  yyWriteNl;
  yyIndentSelector ('Type'); Idents.WriteIdent (yyf,  yyt^.AttrDesc.Type );  yyWriteNl;
 END yWriteAttrDesc;

PROCEDURE yWriteNil (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Nil'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Nil.Pos );  yyWriteNl;
  yyIndentSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.Nil.Selector );  yyWriteNl;
  yyIndentSelector ('Widen'); IO.WriteB (yyf,  yyt^.Nil.Widen );  yyWriteNl;
 END yWriteNil;

PROCEDURE yWriteCall (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Call'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Call.Pos );  yyWriteNl;
  yyIndentSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.Call.Selector );  yyWriteNl;
  yyIndentSelectorTree ('Expr', yyt^.Call.Expr);
  yyIndentSelectorTree ('Exprs', yyt^.Call.Exprs);
  yyIndentSelector ('Object'); yyWriteHex ( yyt^.Call.Object );  yyWriteNl;
 END yWriteCall;

PROCEDURE yWriteBinary (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Binary'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Binary.Pos );  yyWriteNl;
  yyIndentSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.Binary.Selector );  yyWriteNl;
  yyIndentSelectorTree ('Lop', yyt^.Binary.Lop);
  yyIndentSelector ('Operator'); Idents.WriteIdent (yyf,  yyt^.Binary.Operator );  yyWriteNl;
  yyIndentSelector ('Widen'); IO.WriteB (yyf,  yyt^.Binary.Widen );  yyWriteNl;
 END yWriteBinary;

PROCEDURE yWriteyy1 (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'yy1'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.yy1.Pos );  yyWriteNl;
  yyIndentSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.yy1.Selector );  yyWriteNl;
  yyIndentSelectorTree ('Lop', yyt^.yy1.Lop);
  yyIndentSelector ('Operator'); Idents.WriteIdent (yyf,  yyt^.yy1.Operator );  yyWriteNl;
  yyIndentSelector ('Widen'); IO.WriteB (yyf,  yyt^.yy1.Widen );  yyWriteNl;
 END yWriteyy1;

PROCEDURE yWriteBinaryCompound (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'BinaryCompound'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.BinaryCompound.Pos );  yyWriteNl;
  yyIndentSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.BinaryCompound.Selector );  yyWriteNl;
  yyIndentSelectorTree ('Lop', yyt^.BinaryCompound.Lop);
  yyIndentSelector ('Operator'); Idents.WriteIdent (yyf,  yyt^.BinaryCompound.Operator );  yyWriteNl;
  yyIndentSelector ('Widen'); IO.WriteB (yyf,  yyt^.BinaryCompound.Widen );  yyWriteNl;
  yyIndentSelector ('CompoundOperator'); Idents.WriteIdent (yyf,  yyt^.BinaryCompound.CompoundOperator );  yyWriteNl;
 END yWriteBinaryCompound;

PROCEDURE yWritePreOperator (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'PreOperator'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.PreOperator.Pos );  yyWriteNl;
  yyIndentSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.PreOperator.Selector );  yyWriteNl;
  yyIndentSelector ('Operator'); Idents.WriteIdent (yyf,  yyt^.PreOperator.Operator );  yyWriteNl;
 END yWritePreOperator;

PROCEDURE yWritePostOperator (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'PostOperator'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.PostOperator.Pos );  yyWriteNl;
  yyIndentSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.PostOperator.Selector );  yyWriteNl;
  yyIndentSelector ('Operator'); Idents.WriteIdent (yyf,  yyt^.PostOperator.Operator );  yyWriteNl;
 END yWritePostOperator;

PROCEDURE yWriteIndex (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Index'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Index.Pos );  yyWriteNl;
  yyIndentSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.Index.Selector );  yyWriteNl;
  yyIndentSelectorTree ('Expr', yyt^.Index.Expr);
  yyIndentSelector ('Widen'); IO.WriteB (yyf,  yyt^.Index.Widen );  yyWriteNl;
 END yWriteIndex;

PROCEDURE yWriteParents (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Parents'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Parents.Pos );  yyWriteNl;
  yyIndentSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.Parents.Selector );  yyWriteNl;
 END yWriteParents;

PROCEDURE yWriteTargetExpr (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'TargetExpr'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.TargetExpr.Pos );  yyWriteNl;
  yyIndentSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.TargetExpr.Selector );  yyWriteNl;
  yyIndentSelector ('UsedNames'); Sets.WriteSet (yyf,  yyt^.TargetExpr.UsedNames );  yyWriteNl;
 END yWriteTargetExpr;

PROCEDURE yWriteStringExpr (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'StringExpr'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.StringExpr.Pos );  yyWriteNl;
  yyIndentSelector ('Selector'); Idents.WriteIdent (yyf,  yyt^.StringExpr.Selector );  yyWriteNl;
  yyIndentSelector ('String'); StringMem.WriteString (yyf,  yyt^.StringExpr.String );  yyWriteNl;
 END yWriteStringExpr;

PROCEDURE yWriteStatement (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Statement'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Statement.Pos );  yyWriteNl;
 END yWriteStatement;

PROCEDURE yWriteProcCall (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'ProcCall'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.ProcCall.Pos );  yyWriteNl;
  yyIndentSelectorTree ('Call', yyt^.ProcCall.Call);
 END yWriteProcCall;

PROCEDURE yWriteCondition (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Condition'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Condition.Pos );  yyWriteNl;
  yyIndentSelectorTree ('Expr', yyt^.Condition.Expr);
 END yWriteCondition;

PROCEDURE yWriteAssignment (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Assignment'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Assignment.Pos );  yyWriteNl;
  yyIndentSelectorTree ('Adr', yyt^.Assignment.Adr);
  yyIndentSelectorTree ('Expr', yyt^.Assignment.Expr);
  yyIndentSelector ('Object'); yyWriteHex ( yyt^.Assignment.Object );  yyWriteNl;
 END yWriteAssignment;

PROCEDURE yWriteReject (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Reject'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Reject.Pos );  yyWriteNl;
 END yWriteReject;

PROCEDURE yWriteFail (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Fail'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Fail.Pos );  yyWriteNl;
 END yWriteFail;

PROCEDURE yWriteTargetStmt (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'TargetStmt'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.TargetStmt.Pos );  yyWriteNl;
  yyIndentSelectorTree ('Parameters', yyt^.TargetStmt.Parameters);
  yyIndentSelectorTree ('Stmt', yyt^.TargetStmt.Stmt);
  yyIndentSelector ('UsedNames'); Sets.WriteSet (yyf,  yyt^.TargetStmt.UsedNames );  yyWriteNl;
 END yWriteTargetStmt;

PROCEDURE yWriteNl (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Nl'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.Nl.Pos );  yyWriteNl;
 END yWriteNl;

PROCEDURE yWriteWriteStr (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'WriteStr'); yyWriteNl;
  yyIndentSelector ('Pos'); Positions.WritePosition (yyf,  yyt^.WriteStr.Pos );  yyWriteNl;
  yyIndentSelector ('String'); StringMem.WriteString (yyf,  yyt^.WriteStr.String );  yyWriteNl;
 END yWriteWriteStr;

PROCEDURE yWriteFormal (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Formal'); yyWriteNl;
  yyIndentSelectorTree ('Hides', yyt^.Formal.Hides);
  yyIndentSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.Formal.Name );  yyWriteNl;
  yyIndentSelector ('DeclPos'); Positions.WritePosition (yyf,  yyt^.Formal.DeclPos );  yyWriteNl;
  yyIndentSelectorTree ('TypeDesc', yyt^.Formal.TypeDesc);
  yyIndentSelectorTree ('Path', yyt^.Formal.Path);
 END yWriteFormal;

PROCEDURE yWritePlainFormal (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'PlainFormal'); yyWriteNl;
  yyIndentSelectorTree ('Hides', yyt^.PlainFormal.Hides);
  yyIndentSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.PlainFormal.Name );  yyWriteNl;
  yyIndentSelector ('DeclPos'); Positions.WritePosition (yyf,  yyt^.PlainFormal.DeclPos );  yyWriteNl;
  yyIndentSelectorTree ('TypeDesc', yyt^.PlainFormal.TypeDesc);
  yyIndentSelectorTree ('Path', yyt^.PlainFormal.Path);
 END yWritePlainFormal;

PROCEDURE yWriteRoutineFormal (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'RoutineFormal'); yyWriteNl;
  yyIndentSelectorTree ('Hides', yyt^.RoutineFormal.Hides);
  yyIndentSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.RoutineFormal.Name );  yyWriteNl;
  yyIndentSelector ('DeclPos'); Positions.WritePosition (yyf,  yyt^.RoutineFormal.DeclPos );  yyWriteNl;
  yyIndentSelectorTree ('TypeDesc', yyt^.RoutineFormal.TypeDesc);
  yyIndentSelectorTree ('Path', yyt^.RoutineFormal.Path);
  yyIndentSelectorTree ('TargetClass', yyt^.RoutineFormal.TargetClass);
  yyIndentSelector ('DeclaredTypeIsGuaranteed'); IO.WriteB (yyf,  yyt^.RoutineFormal.DeclaredTypeIsGuaranteed );  yyWriteNl;
 END yWriteRoutineFormal;

PROCEDURE yWriteDummyFormal (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'DummyFormal'); yyWriteNl;
 END yWriteDummyFormal;

PROCEDURE yWriteNodeTypes (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'NodeTypes'); yyWriteNl;
  yyIndentSelector ('Types'); Sets.WriteSet (yyf,  yyt^.NodeTypes.Types );  yyWriteNl;
 END yWriteNodeTypes;

PROCEDURE yWriteUserType (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'UserType'); yyWriteNl;
  yyIndentSelector ('Type'); Idents.WriteIdent (yyf,  yyt^.UserType.Type );  yyWriteNl;
 END yWriteUserType;

PROCEDURE yWriteVar (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Var'); yyWriteNl;
  yyIndentSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.Var.Name );  yyWriteNl;
  yyIndentSelector ('IsOutput'); IO.WriteB (yyf,  yyt^.Var.IsOutput );  yyWriteNl;
  yyIndentSelector ('IsRegister'); IO.WriteB (yyf,  yyt^.Var.IsRegister );  yyWriteNl;
 END yWriteVar;

PROCEDURE yWriteConsType (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'ConsType'); yyWriteNl;
  yyIndentSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.ConsType.Name );  yyWriteNl;
  yyIndentSelector ('IsProperlyNarrowed'); IO.WriteB (yyf,  yyt^.ConsType.IsProperlyNarrowed );  yyWriteNl;
 END yWriteConsType;

PROCEDURE yWriteField (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Field'); yyWriteNl;
  yyIndentSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.Field.Name );  yyWriteNl;
 END yWriteField;

PROCEDURE yWriteOneTest (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'OneTest'); yyWriteNl;
  yyIndentSelectorTree ('Next', yyt^.OneTest.Next);
 END yWriteOneTest;

PROCEDURE yWriteTestKind (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'TestKind'); yyWriteNl;
  yyIndentSelectorTree ('Next', yyt^.TestKind.Next);
  yyIndentSelectorTree ('Path', yyt^.TestKind.Path);
  yyIndentSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.TestKind.Name );  yyWriteNl;
 END yWriteTestKind;

PROCEDURE yWriteTestIsType (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'TestIsType'); yyWriteNl;
  yyIndentSelectorTree ('Next', yyt^.TestIsType.Next);
  yyIndentSelectorTree ('Path', yyt^.TestIsType.Path);
  yyIndentSelector ('Name'); Idents.WriteIdent (yyf,  yyt^.TestIsType.Name );  yyWriteNl;
 END yWriteTestIsType;

PROCEDURE yWriteTestNil (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'TestNil'); yyWriteNl;
  yyIndentSelectorTree ('Next', yyt^.TestNil.Next);
 END yWriteTestNil;

PROCEDURE yWriteTestNonlin (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'TestNonlin'); yyWriteNl;
  yyIndentSelectorTree ('Next', yyt^.TestNonlin.Next);
  yyIndentSelectorTree ('Path', yyt^.TestNonlin.Path);
  yyIndentSelectorTree ('Path2', yyt^.TestNonlin.Path2);
 END yWriteTestNonlin;

PROCEDURE yWriteTestValue (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'TestValue'); yyWriteNl;
  yyIndentSelectorTree ('Next', yyt^.TestValue.Next);
  yyIndentSelectorTree ('Path', yyt^.TestValue.Path);
  yyIndentSelectorTree ('Expr', yyt^.TestValue.Expr);
 END yWriteTestValue;

PROCEDURE yWriteDecision (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Decision'); yyWriteNl;
  yyIndentSelectorTree ('ThenPart', yyt^.Decision.ThenPart);
  yyIndentSelectorTree ('ElsePart', yyt^.Decision.ElsePart);
  yyIndentSelector ('Cases'); IO.WriteI (yyf,  yyt^.Decision.Cases , 0);  yyWriteNl;
  yyIndentSelector ('IsUnchanged'); IO.WriteB (yyf,  yyt^.Decision.IsUnchanged );  yyWriteNl;
 END yWriteDecision;

PROCEDURE yWriteDecided (yyt: tTree);
 BEGIN
  IO.WriteS (yyf, 'Decided'); yyWriteNl;
  yyIndentSelectorTree ('ElsePart', yyt^.Decided.ElsePart);
 END yWriteDecided;

PROCEDURE yyWriteTree (yyt: tTree);
 VAR yyLevel   : SHORTCARD;
 BEGIN
  yyLevel := yyIndentLevel;
  LOOP
   IF yyt = NoTree THEN
    IO.WriteS (yyf, ' NoTree'); yyWriteNl; EXIT;
   ELSIF yyt^.yyHead.yyMark = 0 THEN
    IO.WriteC (yyf, '^'); IO.WriteI (yyf, yyMapToLabel (yyt), 0); yyWriteNl; EXIT;
   ELSIF yyt^.yyHead.yyMark > 1 THEN
    yyWriteNl; IO.WriteN (yyf, yyMapToLabel (yyt), 6, 10); IO.WriteC (yyf, ':');
    Layout.WriteSpaces (yyf, yyActualIndent - 7);
   ELSE
    IO.WriteC (yyf, ' ');
   END;
   yyt^.yyHead.yyMark := 0;
   INC (yyIndentLevel, 2);
   yySetIndentInfo ( ) ; 
   CASE yyt^.Kind OF
| Classes: IO.WriteS (yyf, 'Classes'); yyWriteNl; EXIT;
| NoClass: IO.WriteS (yyf, 'NoClass'); yyWriteNl; EXIT;
| Class: yWriteClass (yyt); yyIndentSelector ('Next'); yyt := yyt^.Class.Next;
| Attributes: IO.WriteS (yyf, 'Attributes'); yyWriteNl; EXIT;
| NoAttribute: IO.WriteS (yyf, 'NoAttribute'); yyWriteNl; EXIT;
| AttrOrAction: yWriteAttrOrAction (yyt); yyIndentSelector ('Next'); yyt := yyt^.AttrOrAction.Next;
| Child: yWriteChild (yyt); yyIndentSelector ('Next'); yyt := yyt^.Child.Next;
| Attribute: yWriteAttribute (yyt); yyIndentSelector ('Next'); yyt := yyt^.Attribute.Next;
| ActionPart: yWriteActionPart (yyt); yyIndentSelector ('Next'); yyt := yyt^.ActionPart.Next;
| Codes: yWriteCodes (yyt); EXIT;
| Designators: IO.WriteS (yyf, 'Designators'); yyWriteNl; EXIT;
| NoDesignator: IO.WriteS (yyf, 'NoDesignator'); yyWriteNl; EXIT;
| Designator: yWriteDesignator (yyt); yyIndentSelector ('Next'); yyt := yyt^.Designator.Next;
| Ident: yWriteIdent (yyt); yyIndentSelector ('Next'); yyt := yyt^.Ident.Next;
| Remote: yWriteRemote (yyt); yyIndentSelector ('Next'); yyt := yyt^.Remote.Next;
| Any: yWriteAny (yyt); yyIndentSelector ('Next'); yyt := yyt^.Any.Next;
| Anys: yWriteAnys (yyt); yyIndentSelector ('Next'); yyt := yyt^.Anys.Next;
| Layouts: IO.WriteS (yyf, 'Layouts'); yyWriteNl; EXIT;
| NoLayout: IO.WriteS (yyf, 'NoLayout'); yyWriteNl; EXIT;
| LayoutAny: yWriteLayoutAny (yyt); yyIndentSelector ('Next'); yyt := yyt^.LayoutAny.Next;
| Names: IO.WriteS (yyf, 'Names'); yyWriteNl; EXIT;
| NoName: IO.WriteS (yyf, 'NoName'); yyWriteNl; EXIT;
| Name: yWriteName (yyt); yyIndentSelector ('Next'); yyt := yyt^.Name.Next;
| Spec: yWriteSpec (yyt); yyIndentSelector ('Routines'); yyt := yyt^.Spec.Routines;
| TreeNames: IO.WriteS (yyf, 'TreeNames'); yyWriteNl; EXIT;
| NoTreeName: IO.WriteS (yyf, 'NoTreeName'); yyWriteNl; EXIT;
| TreeName: yWriteTreeName (yyt); yyIndentSelector ('Next'); yyt := yyt^.TreeName.Next;
| Routines: IO.WriteS (yyf, 'Routines'); yyWriteNl; EXIT;
| NoRoutine: IO.WriteS (yyf, 'NoRoutine'); yyWriteNl; EXIT;
| Routine: yWriteRoutine (yyt); yyIndentSelector ('Next'); yyt := yyt^.Routine.Next;
| Procedure: yWriteProcedure (yyt); yyIndentSelector ('Next'); yyt := yyt^.Procedure.Next;
| Function: yWriteFunction (yyt); yyIndentSelector ('Next'); yyt := yyt^.Function.Next;
| Predicate: yWritePredicate (yyt); yyIndentSelector ('Next'); yyt := yyt^.Predicate.Next;
| Parameters: IO.WriteS (yyf, 'Parameters'); yyWriteNl; EXIT;
| NoParameter: IO.WriteS (yyf, 'NoParameter'); yyWriteNl; EXIT;
| Param: yWriteParam (yyt); yyIndentSelector ('Next'); yyt := yyt^.Param.Next;
| Type: yWriteType (yyt); yyIndentSelector ('Names'); yyt := yyt^.Type.Names;
| Rules: IO.WriteS (yyf, 'Rules'); yyWriteNl; EXIT;
| NoRule: IO.WriteS (yyf, 'NoRule'); yyWriteNl; EXIT;
| Rule: yWriteRule (yyt); yyIndentSelector ('Next'); yyt := yyt^.Rule.Next;
| Patterns: IO.WriteS (yyf, 'Patterns'); yyWriteNl; EXIT;
| NoPattern: yWriteNoPattern (yyt); EXIT;
| OnePattern: yWriteOnePattern (yyt); yyIndentSelector ('Next'); yyt := yyt^.OnePattern.Next;
| OnePatternAlts: yWriteOnePatternAlts (yyt); yyIndentSelector ('Next'); yyt := yyt^.OnePatternAlts.Next;
| PatternsList: IO.WriteS (yyf, 'PatternsList'); yyWriteNl; EXIT;
| NoPatternsList: IO.WriteS (yyf, 'NoPatternsList'); yyWriteNl; EXIT;
| OnePatternsList: yWriteOnePatternsList (yyt); yyIndentSelector ('Next'); yyt := yyt^.OnePatternsList.Next;
| Pattern: yWritePattern (yyt); yyIndentSelector ('Path'); yyt := yyt^.Pattern.Path;
| Decompose: yWriteDecompose (yyt); yyIndentSelector ('Patterns'); yyt := yyt^.Decompose.Patterns;
| VarDef: yWriteVarDef (yyt); yyIndentSelector ('Path'); yyt := yyt^.VarDef.Path;
| NilTest: yWriteNilTest (yyt); yyIndentSelector ('Path'); yyt := yyt^.NilTest.Path;
| DontCare1: yWriteDontCare1 (yyt); yyIndentSelector ('Path'); yyt := yyt^.DontCare1.Path;
| DontCare1Explicit: yWriteDontCare1Explicit (yyt); yyIndentSelector ('Path'); yyt := yyt^.DontCare1Explicit.Path;
| DontCare1Internal: yWriteDontCare1Internal (yyt); yyIndentSelector ('Path'); yyt := yyt^.DontCare1Internal.Path;
| DontCare: yWriteDontCare (yyt); yyIndentSelector ('Tempos'); yyt := yyt^.DontCare.Tempos;
| DontCareExplicit: yWriteDontCareExplicit (yyt); yyIndentSelector ('Tempos'); yyt := yyt^.DontCareExplicit.Tempos;
| DontCareInternal: yWriteDontCareInternal (yyt); yyIndentSelector ('Tempos'); yyt := yyt^.DontCareInternal.Tempos;
| Value: yWriteValue (yyt); yyIndentSelector ('Expr'); yyt := yyt^.Value.Expr;
| Exprs: IO.WriteS (yyf, 'Exprs'); yyWriteNl; EXIT;
| NoExpr: yWriteNoExpr (yyt); EXIT;
| OneExpr: yWriteOneExpr (yyt); yyIndentSelector ('Next'); yyt := yyt^.OneExpr.Next;
| NamedExpr: yWriteNamedExpr (yyt); yyIndentSelector ('Next'); yyt := yyt^.NamedExpr.Next;
| Expr: yWriteExpr (yyt); EXIT;
| Compose: yWriteCompose (yyt); yyIndentSelector ('TypeDesc'); yyt := yyt^.Compose.TypeDesc;
| VarUse: yWriteVarUse (yyt); EXIT;
| AttrDesc: yWriteAttrDesc (yyt); EXIT;
| Nil: yWriteNil (yyt); EXIT;
| Call: yWriteCall (yyt); yyIndentSelector ('Patterns'); yyt := yyt^.Call.Patterns;
| Binary: yWriteBinary (yyt); yyIndentSelector ('Rop'); yyt := yyt^.Binary.Rop;
| yy1: yWriteyy1 (yyt); yyIndentSelector ('Rop'); yyt := yyt^.yy1.Rop;
| BinaryCompound: yWriteBinaryCompound (yyt); yyIndentSelector ('Rop'); yyt := yyt^.BinaryCompound.Rop;
| PreOperator: yWritePreOperator (yyt); yyIndentSelector ('Expr'); yyt := yyt^.PreOperator.Expr;
| PostOperator: yWritePostOperator (yyt); yyIndentSelector ('Expr'); yyt := yyt^.PostOperator.Expr;
| Index: yWriteIndex (yyt); yyIndentSelector ('Exprs'); yyt := yyt^.Index.Exprs;
| Parents: yWriteParents (yyt); yyIndentSelector ('Expr'); yyt := yyt^.Parents.Expr;
| TargetExpr: yWriteTargetExpr (yyt); yyIndentSelector ('Expr'); yyt := yyt^.TargetExpr.Expr;
| StringExpr: yWriteStringExpr (yyt); EXIT;
| Statements: IO.WriteS (yyf, 'Statements'); yyWriteNl; EXIT;
| NoStatement: IO.WriteS (yyf, 'NoStatement'); yyWriteNl; EXIT;
| Statement: yWriteStatement (yyt); yyIndentSelector ('Next'); yyt := yyt^.Statement.Next;
| ProcCall: yWriteProcCall (yyt); yyIndentSelector ('Next'); yyt := yyt^.ProcCall.Next;
| Condition: yWriteCondition (yyt); yyIndentSelector ('Next'); yyt := yyt^.Condition.Next;
| Assignment: yWriteAssignment (yyt); yyIndentSelector ('Next'); yyt := yyt^.Assignment.Next;
| Reject: yWriteReject (yyt); yyIndentSelector ('Next'); yyt := yyt^.Reject.Next;
| Fail: yWriteFail (yyt); yyIndentSelector ('Next'); yyt := yyt^.Fail.Next;
| TargetStmt: yWriteTargetStmt (yyt); yyIndentSelector ('Next'); yyt := yyt^.TargetStmt.Next;
| Nl: yWriteNl (yyt); yyIndentSelector ('Next'); yyt := yyt^.Nl.Next;
| WriteStr: yWriteWriteStr (yyt); yyIndentSelector ('Next'); yyt := yyt^.WriteStr.Next;
| Formals: IO.WriteS (yyf, 'Formals'); yyWriteNl; EXIT;
| NoFormal: IO.WriteS (yyf, 'NoFormal'); yyWriteNl; EXIT;
| Formal: yWriteFormal (yyt); yyIndentSelector ('Next'); yyt := yyt^.Formal.Next;
| PlainFormal: yWritePlainFormal (yyt); yyIndentSelector ('Next'); yyt := yyt^.PlainFormal.Next;
| RoutineFormal: yWriteRoutineFormal (yyt); yyIndentSelector ('Next'); yyt := yyt^.RoutineFormal.Next;
| DummyFormal: yWriteDummyFormal (yyt); yyIndentSelector ('Next'); yyt := yyt^.DummyFormal.Next;
| TypeDesc: IO.WriteS (yyf, 'TypeDesc'); yyWriteNl; EXIT;
| NodeTypes: yWriteNodeTypes (yyt); yyIndentSelector ('TreeName'); yyt := yyt^.NodeTypes.TreeName;
| UserType: yWriteUserType (yyt); EXIT;
| Path: IO.WriteS (yyf, 'Path'); yyWriteNl; EXIT;
| Var: yWriteVar (yyt); EXIT;
| ConsType: yWriteConsType (yyt); yyIndentSelector ('Next'); yyt := yyt^.ConsType.Next;
| Field: yWriteField (yyt); yyIndentSelector ('Next'); yyt := yyt^.Field.Next;
| Tests: IO.WriteS (yyf, 'Tests'); yyWriteNl; EXIT;
| NoTest: IO.WriteS (yyf, 'NoTest'); yyWriteNl; EXIT;
| OneTest: yWriteOneTest (yyt); yyIndentSelector ('Path'); yyt := yyt^.OneTest.Path;
| TestKind: yWriteTestKind (yyt); yyIndentSelector ('TypeDesc'); yyt := yyt^.TestKind.TypeDesc;
| TestIsType: yWriteTestIsType (yyt); yyIndentSelector ('TypeDesc'); yyt := yyt^.TestIsType.TypeDesc;
| TestNil: yWriteTestNil (yyt); yyIndentSelector ('Path'); yyt := yyt^.TestNil.Path;
| TestNonlin: yWriteTestNonlin (yyt); yyIndentSelector ('TypeDesc'); yyt := yyt^.TestNonlin.TypeDesc;
| TestValue: yWriteTestValue (yyt); yyIndentSelector ('TypeDesc'); yyt := yyt^.TestValue.TypeDesc;
| Decisions: IO.WriteS (yyf, 'Decisions'); yyWriteNl; EXIT;
| NoDecision: IO.WriteS (yyf, 'NoDecision'); yyWriteNl; EXIT;
| Decision: yWriteDecision (yyt); yyIndentSelector ('OneTest'); yyt := yyt^.Decision.OneTest;
| Decided: yWriteDecided (yyt); yyIndentSelector ('Rule'); yyt := yyt^.Decided.Rule;
   ELSE EXIT;
   END;
  END;
  yyIndentLevel := yyLevel;
  yySetIndentInfo ( ) ;  END yyWriteTree;

CONST yyNil    = 374C;
CONST yyNoLabel        = 375C;
CONST yyLabelDef       = 376C;
CONST yyLabelUse       = 377C;

PROCEDURE ReverseTree (yyOld: tTree): tTree;
 VAR yyNew, yyNext, yyTail     : tTree;
 BEGIN
  yyNew        := yyOld;
  yyTail       := yyOld;
  LOOP
   CASE yyOld^.Kind OF
| Class: yyNext := yyOld^.Class.Next; yyOld^.Class.Next := yyNew;
| AttrOrAction: yyNext := yyOld^.AttrOrAction.Next; yyOld^.AttrOrAction.Next := yyNew;
| Child: yyNext := yyOld^.Child.Next; yyOld^.Child.Next := yyNew;
| Attribute: yyNext := yyOld^.Attribute.Next; yyOld^.Attribute.Next := yyNew;
| ActionPart: yyNext := yyOld^.ActionPart.Next; yyOld^.ActionPart.Next := yyNew;
| Designator: yyNext := yyOld^.Designator.Next; yyOld^.Designator.Next := yyNew;
| Ident: yyNext := yyOld^.Ident.Next; yyOld^.Ident.Next := yyNew;
| Remote: yyNext := yyOld^.Remote.Next; yyOld^.Remote.Next := yyNew;
| Any: yyNext := yyOld^.Any.Next; yyOld^.Any.Next := yyNew;
| Anys: yyNext := yyOld^.Anys.Next; yyOld^.Anys.Next := yyNew;
| LayoutAny: yyNext := yyOld^.LayoutAny.Next; yyOld^.LayoutAny.Next := yyNew;
| Name: yyNext := yyOld^.Name.Next; yyOld^.Name.Next := yyNew;
| TreeName: yyNext := yyOld^.TreeName.Next; yyOld^.TreeName.Next := yyNew;
| Routine: yyNext := yyOld^.Routine.Next; yyOld^.Routine.Next := yyNew;
| Procedure: yyNext := yyOld^.Procedure.Next; yyOld^.Procedure.Next := yyNew;
| Function: yyNext := yyOld^.Function.Next; yyOld^.Function.Next := yyNew;
| Predicate: yyNext := yyOld^.Predicate.Next; yyOld^.Predicate.Next := yyNew;
| Param: yyNext := yyOld^.Param.Next; yyOld^.Param.Next := yyNew;
| Rule: yyNext := yyOld^.Rule.Next; yyOld^.Rule.Next := yyNew;
| OnePattern: yyNext := yyOld^.OnePattern.Next; yyOld^.OnePattern.Next := yyNew;
| OnePatternAlts: yyNext := yyOld^.OnePatternAlts.Next; yyOld^.OnePatternAlts.Next := yyNew;
| OnePatternsList: yyNext := yyOld^.OnePatternsList.Next; yyOld^.OnePatternsList.Next := yyNew;
| OneExpr: yyNext := yyOld^.OneExpr.Next; yyOld^.OneExpr.Next := yyNew;
| NamedExpr: yyNext := yyOld^.NamedExpr.Next; yyOld^.NamedExpr.Next := yyNew;
| Statement: yyNext := yyOld^.Statement.Next; yyOld^.Statement.Next := yyNew;
| ProcCall: yyNext := yyOld^.ProcCall.Next; yyOld^.ProcCall.Next := yyNew;
| Condition: yyNext := yyOld^.Condition.Next; yyOld^.Condition.Next := yyNew;
| Assignment: yyNext := yyOld^.Assignment.Next; yyOld^.Assignment.Next := yyNew;
| Reject: yyNext := yyOld^.Reject.Next; yyOld^.Reject.Next := yyNew;
| Fail: yyNext := yyOld^.Fail.Next; yyOld^.Fail.Next := yyNew;
| TargetStmt: yyNext := yyOld^.TargetStmt.Next; yyOld^.TargetStmt.Next := yyNew;
| Nl: yyNext := yyOld^.Nl.Next; yyOld^.Nl.Next := yyNew;
| WriteStr: yyNext := yyOld^.WriteStr.Next; yyOld^.WriteStr.Next := yyNew;
| Formal: yyNext := yyOld^.Formal.Next; yyOld^.Formal.Next := yyNew;
| PlainFormal: yyNext := yyOld^.PlainFormal.Next; yyOld^.PlainFormal.Next := yyNew;
| RoutineFormal: yyNext := yyOld^.RoutineFormal.Next; yyOld^.RoutineFormal.Next := yyNew;
   ELSE EXIT;
   END;
   yyNew       := yyOld;
   yyOld       := yyNext;
  END;
  CASE yyTail^.Kind OF
| Class: yyTail^.Class.Next := yyOld;
| AttrOrAction: yyTail^.AttrOrAction.Next := yyOld;
| Child: yyTail^.Child.Next := yyOld;
| Attribute: yyTail^.Attribute.Next := yyOld;
| ActionPart: yyTail^.ActionPart.Next := yyOld;
| Designator: yyTail^.Designator.Next := yyOld;
| Ident: yyTail^.Ident.Next := yyOld;
| Remote: yyTail^.Remote.Next := yyOld;
| Any: yyTail^.Any.Next := yyOld;
| Anys: yyTail^.Anys.Next := yyOld;
| LayoutAny: yyTail^.LayoutAny.Next := yyOld;
| Name: yyTail^.Name.Next := yyOld;
| TreeName: yyTail^.TreeName.Next := yyOld;
| Routine: yyTail^.Routine.Next := yyOld;
| Procedure: yyTail^.Procedure.Next := yyOld;
| Function: yyTail^.Function.Next := yyOld;
| Predicate: yyTail^.Predicate.Next := yyOld;
| Param: yyTail^.Param.Next := yyOld;
| Rule: yyTail^.Rule.Next := yyOld;
| OnePattern: yyTail^.OnePattern.Next := yyOld;
| OnePatternAlts: yyTail^.OnePatternAlts.Next := yyOld;
| OnePatternsList: yyTail^.OnePatternsList.Next := yyOld;
| OneExpr: yyTail^.OneExpr.Next := yyOld;
| NamedExpr: yyTail^.NamedExpr.Next := yyOld;
| Statement: yyTail^.Statement.Next := yyOld;
| ProcCall: yyTail^.ProcCall.Next := yyOld;
| Condition: yyTail^.Condition.Next := yyOld;
| Assignment: yyTail^.Assignment.Next := yyOld;
| Reject: yyTail^.Reject.Next := yyOld;
| Fail: yyTail^.Fail.Next := yyOld;
| TargetStmt: yyTail^.TargetStmt.Next := yyOld;
| Nl: yyTail^.Nl.Next := yyOld;
| WriteStr: yyTail^.WriteStr.Next := yyOld;
| Formal: yyTail^.Formal.Next := yyOld;
| PlainFormal: yyTail^.PlainFormal.Next := yyOld;
| RoutineFormal: yyTail^.RoutineFormal.Next := yyOld;
  ELSE
  END;
  RETURN yyNew;
 END ReverseTree;

CONST yyInitOldToNewStoreSize  = 32;

TYPE yytOldToNew = RECORD yyOld, yyNew: tTree; END;

VAR yyOldToNewStoreSize        : LONGINT;
VAR yyOldToNewStorePtr : POINTER TO ARRAY [0..50000] OF yytOldToNew;
VAR yyOldToNewCount    : INTEGER;

PROCEDURE yyStoreOldToNew (yyOld, yyNew: tTree);
 BEGIN
  IF (yyOldToNewCount = yyOldToNewStoreSize) THEN
   DynArray.ExtendArray (yyOldToNewStorePtr, yyOldToNewStoreSize, SYSTEM.TSIZE (yytOldToNew));
  END;
  yyOldToNewStorePtr^[yyOldToNewCount].yyOld := yyOld;
  yyOldToNewStorePtr^[yyOldToNewCount].yyNew := yyNew;
  INC (yyOldToNewCount);
 END yyStoreOldToNew;

PROCEDURE yyMapOldToNew (yyOld: tTree): tTree;
 VAR yyi: INTEGER;
 BEGIN
  FOR yyi := 0 TO yyOldToNewCount - 1 DO
   IF yyOldToNewStorePtr^[yyi].yyOld = yyOld THEN
    RETURN yyOldToNewStorePtr^[yyi].yyNew;
   END;
  END;
 END yyMapOldToNew;

PROCEDURE yyCopyTree (yyt: tTree; yyNew: yyPtrtTree);
 BEGIN
  LOOP
   IF yyt = NoTree THEN yyNew^ := NoTree; RETURN; END;
   IF yyt^.yyHead.yyMark = 0 THEN yyNew^ := yyMapOldToNew (yyt); RETURN; END;
   yyNew^ := MakeTree (yyt^.Kind);
   IF yyt^.yyHead.yyMark > 1 THEN yyStoreOldToNew (yyt, yyNew^); END;
   yyt^.yyHead.yyMark := 0;

   CASE yyt^.Kind OF
| Classes: yyNew^^.Classes := yyt^.Classes;
RETURN;
| NoClass: yyNew^^.NoClass := yyt^.NoClass;
RETURN;
| Class: yyNew^^.Class := yyt^.Class;
 
 
yyCopyTree (  yyt^.Class.Attributes , SYSTEM.ADR ( yyNew^^.Class.Attributes )); 
yyCopyTree (  yyt^.Class.Extensions , SYSTEM.ADR ( yyNew^^.Class.Extensions )); 
yyCopyTree (  yyt^.Class.BaseClass , SYSTEM.ADR ( yyNew^^.Class.BaseClass )); 
yyCopyTree (  yyt^.Class.Formals , SYSTEM.ADR ( yyNew^^.Class.Formals )); 
yyCopyTree (  yyt^.Class.TypeDesc , SYSTEM.ADR ( yyNew^^.Class.TypeDesc )); 
 
 
yyt := yyt^.Class.Next;
yyNew := SYSTEM.ADR (yyNew^^.Class.Next);
| Attributes: yyNew^^.Attributes := yyt^.Attributes;
RETURN;
| NoAttribute: yyNew^^.NoAttribute := yyt^.NoAttribute;
RETURN;
| AttrOrAction: yyNew^^.AttrOrAction := yyt^.AttrOrAction;
yyt := yyt^.AttrOrAction.Next;
yyNew := SYSTEM.ADR (yyNew^^.AttrOrAction.Next);
| Child: yyNew^^.Child := yyt^.Child;
 
 
 
yyt := yyt^.Child.Next;
yyNew := SYSTEM.ADR (yyNew^^.Child.Next);
| Attribute: yyNew^^.Attribute := yyt^.Attribute;
 
 
 
yyt := yyt^.Attribute.Next;
yyNew := SYSTEM.ADR (yyNew^^.Attribute.Next);
| ActionPart: yyNew^^.ActionPart := yyt^.ActionPart;
yyt := yyt^.ActionPart.Next;
yyNew := SYSTEM.ADR (yyNew^^.ActionPart.Next);
| Codes: yyNew^^.Codes := yyt^.Codes;
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
RETURN;
| Designators: yyNew^^.Designators := yyt^.Designators;
RETURN;
| NoDesignator: yyNew^^.NoDesignator := yyt^.NoDesignator;
RETURN;
| Designator: yyNew^^.Designator := yyt^.Designator;
 
 
 
 
 
 
yyt := yyt^.Designator.Next;
yyNew := SYSTEM.ADR (yyNew^^.Designator.Next);
| Ident: yyNew^^.Ident := yyt^.Ident;
 
 
 
yyt := yyt^.Ident.Next;
yyNew := SYSTEM.ADR (yyNew^^.Ident.Next);
| Remote: yyNew^^.Remote := yyt^.Remote;
yyCopyTree (  yyt^.Remote.Designators , SYSTEM.ADR ( yyNew^^.Remote.Designators )); 
 
 
 
yyt := yyt^.Remote.Next;
yyNew := SYSTEM.ADR (yyNew^^.Remote.Next);
| Any: yyNew^^.Any := yyt^.Any;
 
yyt := yyt^.Any.Next;
yyNew := SYSTEM.ADR (yyNew^^.Any.Next);
| Anys: yyNew^^.Anys := yyt^.Anys;
yyCopyTree (  yyt^.Anys.Layouts , SYSTEM.ADR ( yyNew^^.Anys.Layouts )); 
yyt := yyt^.Anys.Next;
yyNew := SYSTEM.ADR (yyNew^^.Anys.Next);
| Layouts: yyNew^^.Layouts := yyt^.Layouts;
RETURN;
| NoLayout: yyNew^^.NoLayout := yyt^.NoLayout;
RETURN;
| LayoutAny: yyNew^^.LayoutAny := yyt^.LayoutAny;
 
yyt := yyt^.LayoutAny.Next;
yyNew := SYSTEM.ADR (yyNew^^.LayoutAny.Next);
| Names: yyNew^^.Names := yyt^.Names;
RETURN;
| NoName: yyNew^^.NoName := yyt^.NoName;
RETURN;
| Name: yyNew^^.Name := yyt^.Name;
 
 
 
yyt := yyt^.Name.Next;
yyNew := SYSTEM.ADR (yyNew^^.Name.Next);
| Spec: yyNew^^.Spec := yyt^.Spec;
 
yyCopyTree (  yyt^.Spec.TreeNames , SYSTEM.ADR ( yyNew^^.Spec.TreeNames )); 
yyCopyTree (  yyt^.Spec.Public , SYSTEM.ADR ( yyNew^^.Spec.Public )); 
yyCopyTree (  yyt^.Spec.Extern , SYSTEM.ADR ( yyNew^^.Spec.Extern )); 
yyCopyTree (  yyt^.Spec.Codes , SYSTEM.ADR ( yyNew^^.Spec.Codes )); 
yyt := yyt^.Spec.Routines;
yyNew := SYSTEM.ADR (yyNew^^.Spec.Routines);
| TreeNames: yyNew^^.TreeNames := yyt^.TreeNames;
RETURN;
| NoTreeName: yyNew^^.NoTreeName := yyt^.NoTreeName;
RETURN;
| TreeName: yyNew^^.TreeName := yyt^.TreeName;
 
 
yyCopyTree (  yyt^.TreeName.Classes , SYSTEM.ADR ( yyNew^^.TreeName.Classes )); 
 
yyCopyTree (  yyt^.TreeName.EmptyType , SYSTEM.ADR ( yyNew^^.TreeName.EmptyType )); 
yyCopyTree (  yyt^.TreeName.UniversalClass , SYSTEM.ADR ( yyNew^^.TreeName.UniversalClass )); 
yyt := yyt^.TreeName.Next;
yyNew := SYSTEM.ADR (yyNew^^.TreeName.Next);
| Routines: yyNew^^.Routines := yyt^.Routines;
RETURN;
| NoRoutine: yyNew^^.NoRoutine := yyt^.NoRoutine;
RETURN;
| Routine: yyNew^^.Routine := yyt^.Routine;
 
 
yyCopyTree (  yyt^.Routine.InParams , SYSTEM.ADR ( yyNew^^.Routine.InParams )); 
yyCopyTree (  yyt^.Routine.OutParams , SYSTEM.ADR ( yyNew^^.Routine.OutParams )); 
yyCopyTree (  yyt^.Routine.Extern , SYSTEM.ADR ( yyNew^^.Routine.Extern )); 
 
 
yyCopyTree (  yyt^.Routine.Rules , SYSTEM.ADR ( yyNew^^.Routine.Rules )); 
yyCopyTree (  yyt^.Routine.InForm , SYSTEM.ADR ( yyNew^^.Routine.InForm )); 
yyCopyTree (  yyt^.Routine.OutForm , SYSTEM.ADR ( yyNew^^.Routine.OutForm )); 
yyCopyTree (  yyt^.Routine.ParamDecls , SYSTEM.ADR ( yyNew^^.Routine.ParamDecls )); 
 
yyCopyTree (  yyt^.Routine.Decisions , SYSTEM.ADR ( yyNew^^.Routine.Decisions )); 
yyt := yyt^.Routine.Next;
yyNew := SYSTEM.ADR (yyNew^^.Routine.Next);
| Procedure: yyNew^^.Procedure := yyt^.Procedure;
 
 
yyCopyTree (  yyt^.Procedure.InParams , SYSTEM.ADR ( yyNew^^.Procedure.InParams )); 
yyCopyTree (  yyt^.Procedure.OutParams , SYSTEM.ADR ( yyNew^^.Procedure.OutParams )); 
yyCopyTree (  yyt^.Procedure.Extern , SYSTEM.ADR ( yyNew^^.Procedure.Extern )); 
 
 
yyCopyTree (  yyt^.Procedure.Rules , SYSTEM.ADR ( yyNew^^.Procedure.Rules )); 
yyCopyTree (  yyt^.Procedure.InForm , SYSTEM.ADR ( yyNew^^.Procedure.InForm )); 
yyCopyTree (  yyt^.Procedure.OutForm , SYSTEM.ADR ( yyNew^^.Procedure.OutForm )); 
yyCopyTree (  yyt^.Procedure.ParamDecls , SYSTEM.ADR ( yyNew^^.Procedure.ParamDecls )); 
 
yyCopyTree (  yyt^.Procedure.Decisions , SYSTEM.ADR ( yyNew^^.Procedure.Decisions )); 
yyt := yyt^.Procedure.Next;
yyNew := SYSTEM.ADR (yyNew^^.Procedure.Next);
| Function: yyNew^^.Function := yyt^.Function;
 
 
yyCopyTree (  yyt^.Function.InParams , SYSTEM.ADR ( yyNew^^.Function.InParams )); 
yyCopyTree (  yyt^.Function.OutParams , SYSTEM.ADR ( yyNew^^.Function.OutParams )); 
yyCopyTree (  yyt^.Function.Extern , SYSTEM.ADR ( yyNew^^.Function.Extern )); 
 
 
yyCopyTree (  yyt^.Function.Rules , SYSTEM.ADR ( yyNew^^.Function.Rules )); 
yyCopyTree (  yyt^.Function.InForm , SYSTEM.ADR ( yyNew^^.Function.InForm )); 
yyCopyTree (  yyt^.Function.OutForm , SYSTEM.ADR ( yyNew^^.Function.OutForm )); 
yyCopyTree (  yyt^.Function.ParamDecls , SYSTEM.ADR ( yyNew^^.Function.ParamDecls )); 
 
yyCopyTree (  yyt^.Function.Decisions , SYSTEM.ADR ( yyNew^^.Function.Decisions )); 
yyCopyTree (  yyt^.Function.ReturnParams , SYSTEM.ADR ( yyNew^^.Function.ReturnParams )); 
yyCopyTree (  yyt^.Function.ReturnForm , SYSTEM.ADR ( yyNew^^.Function.ReturnForm )); 
yyt := yyt^.Function.Next;
yyNew := SYSTEM.ADR (yyNew^^.Function.Next);
| Predicate: yyNew^^.Predicate := yyt^.Predicate;
 
 
yyCopyTree (  yyt^.Predicate.InParams , SYSTEM.ADR ( yyNew^^.Predicate.InParams )); 
yyCopyTree (  yyt^.Predicate.OutParams , SYSTEM.ADR ( yyNew^^.Predicate.OutParams )); 
yyCopyTree (  yyt^.Predicate.Extern , SYSTEM.ADR ( yyNew^^.Predicate.Extern )); 
 
 
yyCopyTree (  yyt^.Predicate.Rules , SYSTEM.ADR ( yyNew^^.Predicate.Rules )); 
yyCopyTree (  yyt^.Predicate.InForm , SYSTEM.ADR ( yyNew^^.Predicate.InForm )); 
yyCopyTree (  yyt^.Predicate.OutForm , SYSTEM.ADR ( yyNew^^.Predicate.OutForm )); 
yyCopyTree (  yyt^.Predicate.ParamDecls , SYSTEM.ADR ( yyNew^^.Predicate.ParamDecls )); 
 
yyCopyTree (  yyt^.Predicate.Decisions , SYSTEM.ADR ( yyNew^^.Predicate.Decisions )); 
yyt := yyt^.Predicate.Next;
yyNew := SYSTEM.ADR (yyNew^^.Predicate.Next);
| Parameters: yyNew^^.Parameters := yyt^.Parameters;
RETURN;
| NoParameter: yyNew^^.NoParameter := yyt^.NoParameter;
RETURN;
| Param: yyNew^^.Param := yyt^.Param;
 
 
 
yyCopyTree (  yyt^.Param.Type , SYSTEM.ADR ( yyNew^^.Param.Type )); 
yyt := yyt^.Param.Next;
yyNew := SYSTEM.ADR (yyNew^^.Param.Next);
| Type: yyNew^^.Type := yyt^.Type;
 
 
yyt := yyt^.Type.Names;
yyNew := SYSTEM.ADR (yyNew^^.Type.Names);
| Rules: yyNew^^.Rules := yyt^.Rules;
RETURN;
| NoRule: yyNew^^.NoRule := yyt^.NoRule;
RETURN;
| Rule: yyNew^^.Rule := yyt^.Rule;
 
yyCopyTree (  yyt^.Rule.Patterns , SYSTEM.ADR ( yyNew^^.Rule.Patterns )); 
yyCopyTree (  yyt^.Rule.Exprs , SYSTEM.ADR ( yyNew^^.Rule.Exprs )); 
yyCopyTree (  yyt^.Rule.Expr , SYSTEM.ADR ( yyNew^^.Rule.Expr )); 
yyCopyTree (  yyt^.Rule.Statements , SYSTEM.ADR ( yyNew^^.Rule.Statements )); 
yyCopyTree (  yyt^.Rule.VarDecls , SYSTEM.ADR ( yyNew^^.Rule.VarDecls )); 
 
 
 
 
yyCopyTree (  yyt^.Rule.Tests , SYSTEM.ADR ( yyNew^^.Rule.Tests )); 
 
 
 
 
yyt := yyt^.Rule.Next;
yyNew := SYSTEM.ADR (yyNew^^.Rule.Next);
| Patterns: yyNew^^.Patterns := yyt^.Patterns;
RETURN;
| NoPattern: yyNew^^.NoPattern := yyt^.NoPattern;
 
RETURN;
| OnePattern: yyNew^^.OnePattern := yyt^.OnePattern;
yyCopyTree (  yyt^.OnePattern.Pattern , SYSTEM.ADR ( yyNew^^.OnePattern.Pattern )); 
yyt := yyt^.OnePattern.Next;
yyNew := SYSTEM.ADR (yyNew^^.OnePattern.Next);
| OnePatternAlts: yyNew^^.OnePatternAlts := yyt^.OnePatternAlts;
yyCopyTree (  yyt^.OnePatternAlts.PatternsList , SYSTEM.ADR ( yyNew^^.OnePatternAlts.PatternsList )); 
yyCopyTree (  yyt^.OnePatternAlts.Current , SYSTEM.ADR ( yyNew^^.OnePatternAlts.Current )); 
yyt := yyt^.OnePatternAlts.Next;
yyNew := SYSTEM.ADR (yyNew^^.OnePatternAlts.Next);
| PatternsList: yyNew^^.PatternsList := yyt^.PatternsList;
RETURN;
| NoPatternsList: yyNew^^.NoPatternsList := yyt^.NoPatternsList;
RETURN;
| OnePatternsList: yyNew^^.OnePatternsList := yyt^.OnePatternsList;
yyCopyTree (  yyt^.OnePatternsList.Patterns , SYSTEM.ADR ( yyNew^^.OnePatternsList.Patterns )); 
yyt := yyt^.OnePatternsList.Next;
yyNew := SYSTEM.ADR (yyNew^^.OnePatternsList.Next);
| Pattern: yyNew^^.Pattern := yyt^.Pattern;
 
 
yyCopyTree (  yyt^.Pattern.TypeDesc , SYSTEM.ADR ( yyNew^^.Pattern.TypeDesc )); 
yyt := yyt^.Pattern.Path;
yyNew := SYSTEM.ADR (yyNew^^.Pattern.Path);
| Decompose: yyNew^^.Decompose := yyt^.Decompose;
 
 
yyCopyTree (  yyt^.Decompose.TypeDesc , SYSTEM.ADR ( yyNew^^.Decompose.TypeDesc )); 
yyCopyTree (  yyt^.Decompose.Path , SYSTEM.ADR ( yyNew^^.Decompose.Path )); 
 
yyCopyTree (  yyt^.Decompose.Expr , SYSTEM.ADR ( yyNew^^.Decompose.Expr )); 
 
 
 
yyt := yyt^.Decompose.Patterns;
yyNew := SYSTEM.ADR (yyNew^^.Decompose.Patterns);
| VarDef: yyNew^^.VarDef := yyt^.VarDef;
 
 
yyCopyTree (  yyt^.VarDef.TypeDesc , SYSTEM.ADR ( yyNew^^.VarDef.TypeDesc )); 
 
 
 
yyt := yyt^.VarDef.Path;
yyNew := SYSTEM.ADR (yyNew^^.VarDef.Path);
| NilTest: yyNew^^.NilTest := yyt^.NilTest;
 
 
yyCopyTree (  yyt^.NilTest.TypeDesc , SYSTEM.ADR ( yyNew^^.NilTest.TypeDesc )); 
 
 
 
yyt := yyt^.NilTest.Path;
yyNew := SYSTEM.ADR (yyNew^^.NilTest.Path);
| DontCare1: yyNew^^.DontCare1 := yyt^.DontCare1;
 
 
yyCopyTree (  yyt^.DontCare1.TypeDesc , SYSTEM.ADR ( yyNew^^.DontCare1.TypeDesc )); 
 
yyt := yyt^.DontCare1.Path;
yyNew := SYSTEM.ADR (yyNew^^.DontCare1.Path);
| DontCare1Explicit: yyNew^^.DontCare1Explicit := yyt^.DontCare1Explicit;
 
 
yyCopyTree (  yyt^.DontCare1Explicit.TypeDesc , SYSTEM.ADR ( yyNew^^.DontCare1Explicit.TypeDesc )); 
 
yyt := yyt^.DontCare1Explicit.Path;
yyNew := SYSTEM.ADR (yyNew^^.DontCare1Explicit.Path);
| DontCare1Internal: yyNew^^.DontCare1Internal := yyt^.DontCare1Internal;
 
 
yyCopyTree (  yyt^.DontCare1Internal.TypeDesc , SYSTEM.ADR ( yyNew^^.DontCare1Internal.TypeDesc )); 
 
yyt := yyt^.DontCare1Internal.Path;
yyNew := SYSTEM.ADR (yyNew^^.DontCare1Internal.Path);
| DontCare: yyNew^^.DontCare := yyt^.DontCare;
 
 
yyCopyTree (  yyt^.DontCare.TypeDesc , SYSTEM.ADR ( yyNew^^.DontCare.TypeDesc )); 
yyCopyTree (  yyt^.DontCare.Path , SYSTEM.ADR ( yyNew^^.DontCare.Path )); 
yyt := yyt^.DontCare.Tempos;
yyNew := SYSTEM.ADR (yyNew^^.DontCare.Tempos);
| DontCareExplicit: yyNew^^.DontCareExplicit := yyt^.DontCareExplicit;
 
 
yyCopyTree (  yyt^.DontCareExplicit.TypeDesc , SYSTEM.ADR ( yyNew^^.DontCareExplicit.TypeDesc )); 
yyCopyTree (  yyt^.DontCareExplicit.Path , SYSTEM.ADR ( yyNew^^.DontCareExplicit.Path )); 
yyt := yyt^.DontCareExplicit.Tempos;
yyNew := SYSTEM.ADR (yyNew^^.DontCareExplicit.Tempos);
| DontCareInternal: yyNew^^.DontCareInternal := yyt^.DontCareInternal;
 
 
yyCopyTree (  yyt^.DontCareInternal.TypeDesc , SYSTEM.ADR ( yyNew^^.DontCareInternal.TypeDesc )); 
yyCopyTree (  yyt^.DontCareInternal.Path , SYSTEM.ADR ( yyNew^^.DontCareInternal.Path )); 
yyt := yyt^.DontCareInternal.Tempos;
yyNew := SYSTEM.ADR (yyNew^^.DontCareInternal.Tempos);
| Value: yyNew^^.Value := yyt^.Value;
 
 
yyCopyTree (  yyt^.Value.TypeDesc , SYSTEM.ADR ( yyNew^^.Value.TypeDesc )); 
yyCopyTree (  yyt^.Value.Path , SYSTEM.ADR ( yyNew^^.Value.Path )); 
 
yyt := yyt^.Value.Expr;
yyNew := SYSTEM.ADR (yyNew^^.Value.Expr);
| Exprs: yyNew^^.Exprs := yyt^.Exprs;
RETURN;
| NoExpr: yyNew^^.NoExpr := yyt^.NoExpr;
 
RETURN;
| OneExpr: yyNew^^.OneExpr := yyt^.OneExpr;
yyCopyTree (  yyt^.OneExpr.Expr , SYSTEM.ADR ( yyNew^^.OneExpr.Expr )); 
yyt := yyt^.OneExpr.Next;
yyNew := SYSTEM.ADR (yyNew^^.OneExpr.Next);
| NamedExpr: yyNew^^.NamedExpr := yyt^.NamedExpr;
yyCopyTree (  yyt^.NamedExpr.Expr , SYSTEM.ADR ( yyNew^^.NamedExpr.Expr )); 
 
 
yyt := yyt^.NamedExpr.Next;
yyNew := SYSTEM.ADR (yyNew^^.NamedExpr.Next);
| Expr: yyNew^^.Expr := yyt^.Expr;
 
 
RETURN;
| Compose: yyNew^^.Compose := yyt^.Compose;
 
 
yyCopyTree (  yyt^.Compose.Expr , SYSTEM.ADR ( yyNew^^.Compose.Expr )); 
yyCopyTree (  yyt^.Compose.Exprs , SYSTEM.ADR ( yyNew^^.Compose.Exprs )); 
 
 
 
yyt := yyt^.Compose.TypeDesc;
yyNew := SYSTEM.ADR (yyNew^^.Compose.TypeDesc);
| VarUse: yyNew^^.VarUse := yyt^.VarUse;
 
 
 
 
 
RETURN;
| AttrDesc: yyNew^^.AttrDesc := yyt^.AttrDesc;
 
 
 
 
 
 
 
 
RETURN;
| Nil: yyNew^^.Nil := yyt^.Nil;
 
 
 
RETURN;
| Call: yyNew^^.Call := yyt^.Call;
 
 
yyCopyTree (  yyt^.Call.Expr , SYSTEM.ADR ( yyNew^^.Call.Expr )); 
yyCopyTree (  yyt^.Call.Exprs , SYSTEM.ADR ( yyNew^^.Call.Exprs )); 
 
yyt := yyt^.Call.Patterns;
yyNew := SYSTEM.ADR (yyNew^^.Call.Patterns);
| Binary: yyNew^^.Binary := yyt^.Binary;
 
 
yyCopyTree (  yyt^.Binary.Lop , SYSTEM.ADR ( yyNew^^.Binary.Lop )); 
 
 
yyt := yyt^.Binary.Rop;
yyNew := SYSTEM.ADR (yyNew^^.Binary.Rop);
| yy1: yyNew^^.yy1 := yyt^.yy1;
 
 
yyCopyTree (  yyt^.yy1.Lop , SYSTEM.ADR ( yyNew^^.yy1.Lop )); 
 
 
yyt := yyt^.yy1.Rop;
yyNew := SYSTEM.ADR (yyNew^^.yy1.Rop);
| BinaryCompound: yyNew^^.BinaryCompound := yyt^.BinaryCompound;
 
 
yyCopyTree (  yyt^.BinaryCompound.Lop , SYSTEM.ADR ( yyNew^^.BinaryCompound.Lop )); 
 
 
 
yyt := yyt^.BinaryCompound.Rop;
yyNew := SYSTEM.ADR (yyNew^^.BinaryCompound.Rop);
| PreOperator: yyNew^^.PreOperator := yyt^.PreOperator;
 
 
 
yyt := yyt^.PreOperator.Expr;
yyNew := SYSTEM.ADR (yyNew^^.PreOperator.Expr);
| PostOperator: yyNew^^.PostOperator := yyt^.PostOperator;
 
 
 
yyt := yyt^.PostOperator.Expr;
yyNew := SYSTEM.ADR (yyNew^^.PostOperator.Expr);
| Index: yyNew^^.Index := yyt^.Index;
 
 
yyCopyTree (  yyt^.Index.Expr , SYSTEM.ADR ( yyNew^^.Index.Expr )); 
 
yyt := yyt^.Index.Exprs;
yyNew := SYSTEM.ADR (yyNew^^.Index.Exprs);
| Parents: yyNew^^.Parents := yyt^.Parents;
 
 
yyt := yyt^.Parents.Expr;
yyNew := SYSTEM.ADR (yyNew^^.Parents.Expr);
| TargetExpr: yyNew^^.TargetExpr := yyt^.TargetExpr;
 
 
 
yyt := yyt^.TargetExpr.Expr;
yyNew := SYSTEM.ADR (yyNew^^.TargetExpr.Expr);
| StringExpr: yyNew^^.StringExpr := yyt^.StringExpr;
 
 
 
RETURN;
| Statements: yyNew^^.Statements := yyt^.Statements;
RETURN;
| NoStatement: yyNew^^.NoStatement := yyt^.NoStatement;
RETURN;
| Statement: yyNew^^.Statement := yyt^.Statement;
 
yyt := yyt^.Statement.Next;
yyNew := SYSTEM.ADR (yyNew^^.Statement.Next);
| ProcCall: yyNew^^.ProcCall := yyt^.ProcCall;
 
yyCopyTree (  yyt^.ProcCall.Call , SYSTEM.ADR ( yyNew^^.ProcCall.Call )); 
yyt := yyt^.ProcCall.Next;
yyNew := SYSTEM.ADR (yyNew^^.ProcCall.Next);
| Condition: yyNew^^.Condition := yyt^.Condition;
 
yyCopyTree (  yyt^.Condition.Expr , SYSTEM.ADR ( yyNew^^.Condition.Expr )); 
yyt := yyt^.Condition.Next;
yyNew := SYSTEM.ADR (yyNew^^.Condition.Next);
| Assignment: yyNew^^.Assignment := yyt^.Assignment;
 
yyCopyTree (  yyt^.Assignment.Adr , SYSTEM.ADR ( yyNew^^.Assignment.Adr )); 
yyCopyTree (  yyt^.Assignment.Expr , SYSTEM.ADR ( yyNew^^.Assignment.Expr )); 
 
yyt := yyt^.Assignment.Next;
yyNew := SYSTEM.ADR (yyNew^^.Assignment.Next);
| Reject: yyNew^^.Reject := yyt^.Reject;
 
yyt := yyt^.Reject.Next;
yyNew := SYSTEM.ADR (yyNew^^.Reject.Next);
| Fail: yyNew^^.Fail := yyt^.Fail;
 
yyt := yyt^.Fail.Next;
yyNew := SYSTEM.ADR (yyNew^^.Fail.Next);
| TargetStmt: yyNew^^.TargetStmt := yyt^.TargetStmt;
 
yyCopyTree (  yyt^.TargetStmt.Parameters , SYSTEM.ADR ( yyNew^^.TargetStmt.Parameters )); 
yyCopyTree (  yyt^.TargetStmt.Stmt , SYSTEM.ADR ( yyNew^^.TargetStmt.Stmt )); 
 
yyt := yyt^.TargetStmt.Next;
yyNew := SYSTEM.ADR (yyNew^^.TargetStmt.Next);
| Nl: yyNew^^.Nl := yyt^.Nl;
 
yyt := yyt^.Nl.Next;
yyNew := SYSTEM.ADR (yyNew^^.Nl.Next);
| WriteStr: yyNew^^.WriteStr := yyt^.WriteStr;
 
 
yyt := yyt^.WriteStr.Next;
yyNew := SYSTEM.ADR (yyNew^^.WriteStr.Next);
| Formals: yyNew^^.Formals := yyt^.Formals;
RETURN;
| NoFormal: yyNew^^.NoFormal := yyt^.NoFormal;
RETURN;
| Formal: yyNew^^.Formal := yyt^.Formal;
yyCopyTree (  yyt^.Formal.Hides , SYSTEM.ADR ( yyNew^^.Formal.Hides )); 
 
 
yyCopyTree (  yyt^.Formal.TypeDesc , SYSTEM.ADR ( yyNew^^.Formal.TypeDesc )); 
yyCopyTree (  yyt^.Formal.Path , SYSTEM.ADR ( yyNew^^.Formal.Path )); 
yyt := yyt^.Formal.Next;
yyNew := SYSTEM.ADR (yyNew^^.Formal.Next);
| PlainFormal: yyNew^^.PlainFormal := yyt^.PlainFormal;
yyCopyTree (  yyt^.PlainFormal.Hides , SYSTEM.ADR ( yyNew^^.PlainFormal.Hides )); 
 
 
yyCopyTree (  yyt^.PlainFormal.TypeDesc , SYSTEM.ADR ( yyNew^^.PlainFormal.TypeDesc )); 
yyCopyTree (  yyt^.PlainFormal.Path , SYSTEM.ADR ( yyNew^^.PlainFormal.Path )); 
yyt := yyt^.PlainFormal.Next;
yyNew := SYSTEM.ADR (yyNew^^.PlainFormal.Next);
| RoutineFormal: yyNew^^.RoutineFormal := yyt^.RoutineFormal;
yyCopyTree (  yyt^.RoutineFormal.Hides , SYSTEM.ADR ( yyNew^^.RoutineFormal.Hides )); 
 
 
yyCopyTree (  yyt^.RoutineFormal.TypeDesc , SYSTEM.ADR ( yyNew^^.RoutineFormal.TypeDesc )); 
yyCopyTree (  yyt^.RoutineFormal.Path , SYSTEM.ADR ( yyNew^^.RoutineFormal.Path )); 
yyCopyTree (  yyt^.RoutineFormal.TargetClass , SYSTEM.ADR ( yyNew^^.RoutineFormal.TargetClass )); 
 
yyt := yyt^.RoutineFormal.Next;
yyNew := SYSTEM.ADR (yyNew^^.RoutineFormal.Next);
| DummyFormal: yyNew^^.DummyFormal := yyt^.DummyFormal;
yyt := yyt^.DummyFormal.Next;
yyNew := SYSTEM.ADR (yyNew^^.DummyFormal.Next);
| TypeDesc: yyNew^^.TypeDesc := yyt^.TypeDesc;
RETURN;
| NodeTypes: yyNew^^.NodeTypes := yyt^.NodeTypes;
 
yyt := yyt^.NodeTypes.TreeName;
yyNew := SYSTEM.ADR (yyNew^^.NodeTypes.TreeName);
| UserType: yyNew^^.UserType := yyt^.UserType;
 
RETURN;
| Path: yyNew^^.Path := yyt^.Path;
RETURN;
| Var: yyNew^^.Var := yyt^.Var;
 
 
 
RETURN;
| ConsType: yyNew^^.ConsType := yyt^.ConsType;
 
 
yyt := yyt^.ConsType.Next;
yyNew := SYSTEM.ADR (yyNew^^.ConsType.Next);
| Field: yyNew^^.Field := yyt^.Field;
 
yyt := yyt^.Field.Next;
yyNew := SYSTEM.ADR (yyNew^^.Field.Next);
| Tests: yyNew^^.Tests := yyt^.Tests;
RETURN;
| NoTest: yyNew^^.NoTest := yyt^.NoTest;
RETURN;
| OneTest: yyNew^^.OneTest := yyt^.OneTest;
yyCopyTree (  yyt^.OneTest.Next , SYSTEM.ADR ( yyNew^^.OneTest.Next )); 
yyt := yyt^.OneTest.Path;
yyNew := SYSTEM.ADR (yyNew^^.OneTest.Path);
| TestKind: yyNew^^.TestKind := yyt^.TestKind;
yyCopyTree (  yyt^.TestKind.Next , SYSTEM.ADR ( yyNew^^.TestKind.Next )); 
yyCopyTree (  yyt^.TestKind.Path , SYSTEM.ADR ( yyNew^^.TestKind.Path )); 
 
yyt := yyt^.TestKind.TypeDesc;
yyNew := SYSTEM.ADR (yyNew^^.TestKind.TypeDesc);
| TestIsType: yyNew^^.TestIsType := yyt^.TestIsType;
yyCopyTree (  yyt^.TestIsType.Next , SYSTEM.ADR ( yyNew^^.TestIsType.Next )); 
yyCopyTree (  yyt^.TestIsType.Path , SYSTEM.ADR ( yyNew^^.TestIsType.Path )); 
 
yyt := yyt^.TestIsType.TypeDesc;
yyNew := SYSTEM.ADR (yyNew^^.TestIsType.TypeDesc);
| TestNil: yyNew^^.TestNil := yyt^.TestNil;
yyCopyTree (  yyt^.TestNil.Next , SYSTEM.ADR ( yyNew^^.TestNil.Next )); 
yyt := yyt^.TestNil.Path;
yyNew := SYSTEM.ADR (yyNew^^.TestNil.Path);
| TestNonlin: yyNew^^.TestNonlin := yyt^.TestNonlin;
yyCopyTree (  yyt^.TestNonlin.Next , SYSTEM.ADR ( yyNew^^.TestNonlin.Next )); 
yyCopyTree (  yyt^.TestNonlin.Path , SYSTEM.ADR ( yyNew^^.TestNonlin.Path )); 
yyCopyTree (  yyt^.TestNonlin.Path2 , SYSTEM.ADR ( yyNew^^.TestNonlin.Path2 )); 
yyt := yyt^.TestNonlin.TypeDesc;
yyNew := SYSTEM.ADR (yyNew^^.TestNonlin.TypeDesc);
| TestValue: yyNew^^.TestValue := yyt^.TestValue;
yyCopyTree (  yyt^.TestValue.Next , SYSTEM.ADR ( yyNew^^.TestValue.Next )); 
yyCopyTree (  yyt^.TestValue.Path , SYSTEM.ADR ( yyNew^^.TestValue.Path )); 
yyCopyTree (  yyt^.TestValue.Expr , SYSTEM.ADR ( yyNew^^.TestValue.Expr )); 
yyt := yyt^.TestValue.TypeDesc;
yyNew := SYSTEM.ADR (yyNew^^.TestValue.TypeDesc);
| Decisions: yyNew^^.Decisions := yyt^.Decisions;
RETURN;
| NoDecision: yyNew^^.NoDecision := yyt^.NoDecision;
RETURN;
| Decision: yyNew^^.Decision := yyt^.Decision;
yyCopyTree (  yyt^.Decision.ThenPart , SYSTEM.ADR ( yyNew^^.Decision.ThenPart )); 
yyCopyTree (  yyt^.Decision.ElsePart , SYSTEM.ADR ( yyNew^^.Decision.ElsePart )); 
 
 
yyt := yyt^.Decision.OneTest;
yyNew := SYSTEM.ADR (yyNew^^.Decision.OneTest);
| Decided: yyNew^^.Decided := yyt^.Decided;
yyCopyTree (  yyt^.Decided.ElsePart , SYSTEM.ADR ( yyNew^^.Decided.ElsePart )); 
yyt := yyt^.Decided.Rule;
yyNew := SYSTEM.ADR (yyNew^^.Decided.Rule);
   ELSE
   END;
  END;
 END yyCopyTree;

PROCEDURE CopyTree (yyt: tTree): tTree;
 VAR yyNew     : tTree;
 BEGIN
  yyMark (yyt);
  yyOldToNewCount := 0;
  yyCopyTree (yyt, SYSTEM.ADR (yyNew));
  RETURN yyNew;
 END CopyTree;

CONST yyyWrite = 1; yyyRead = 2; yyyQuit = 3;

VAR yyString   : ARRAY [0..31] OF CHAR;
VAR yyLength   : INTEGER;
VAR yyCh       : CHAR;
VAR yyState    : INTEGER;

PROCEDURE yyyIsEqual (yya: ARRAY OF CHAR): BOOLEAN;
 VAR yyi       : INTEGER;
 BEGIN
  IF (yyLength >= 0) AND (yyString [yyLength] = ' ') THEN
   IF yyLength - 1 # INTEGER (HIGH (yya)) THEN RETURN FALSE; END;
   FOR yyi := 0 TO yyLength - 1 DO
    IF yyString [yyi] # yya [yyi] THEN RETURN FALSE; END;
   END;
  ELSE
   IF yyLength > INTEGER (HIGH (yya)) THEN RETURN FALSE; END;
   FOR yyi := 0 TO yyLength DO
    IF yyString [yyi] # yya [yyi] THEN RETURN FALSE; END;
   END;
  END;
  RETURN TRUE;
 END yyyIsEqual;

PROCEDURE QueryTree (yyt: tTree);
 BEGIN
  yyState := yyyWrite;
  LOOP
   CASE yyState OF
   | yyyQuit   : RETURN;
   | yyyWrite  : WriteTreeNode (IO.StdOutput, yyt); yyState := yyyRead;
   | yyyRead   : IO.WriteS (IO.StdOutput, '? '); yyLength := -1; yyCh := IO.ReadC (IO.StdInput);
    WHILE yyCh # 12C DO INC (yyLength); yyString [yyLength] := yyCh; yyCh := IO.ReadC (IO.StdInput); END;
    IF    yyyIsEqual ('parent') THEN yyState := yyyWrite; RETURN;
    ELSIF yyyIsEqual ('quit'  ) THEN yyState := yyyQuit ; RETURN;
    ELSIF yyt # NoTree THEN
     CASE yyt^.Kind OF
| Class: IF FALSE THEN
ELSIF yyyIsEqual ('Attributes') THEN QueryTree (yyt^.Class.Attributes);
ELSIF yyyIsEqual ('Extensions') THEN QueryTree (yyt^.Class.Extensions);
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.Class.Next);
ELSIF yyyIsEqual ('BaseClass') THEN QueryTree (yyt^.Class.BaseClass);
ELSIF yyyIsEqual ('Formals') THEN QueryTree (yyt^.Class.Formals);
ELSIF yyyIsEqual ('TypeDesc') THEN QueryTree (yyt^.Class.TypeDesc);
END;
| AttrOrAction: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.AttrOrAction.Next);
END;
| Child: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.Child.Next);
END;
| Attribute: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.Attribute.Next);
END;
| ActionPart: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.ActionPart.Next);
END;
| Designator: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.Designator.Next);
END;
| Ident: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.Ident.Next);
END;
| Remote: IF FALSE THEN
ELSIF yyyIsEqual ('Designators') THEN QueryTree (yyt^.Remote.Designators);
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.Remote.Next);
END;
| Any: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.Any.Next);
END;
| Anys: IF FALSE THEN
ELSIF yyyIsEqual ('Layouts') THEN QueryTree (yyt^.Anys.Layouts);
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.Anys.Next);
END;
| LayoutAny: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.LayoutAny.Next);
END;
| Name: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.Name.Next);
END;
| Spec: IF FALSE THEN
ELSIF yyyIsEqual ('TreeNames') THEN QueryTree (yyt^.Spec.TreeNames);
ELSIF yyyIsEqual ('Public') THEN QueryTree (yyt^.Spec.Public);
ELSIF yyyIsEqual ('Extern') THEN QueryTree (yyt^.Spec.Extern);
ELSIF yyyIsEqual ('Codes') THEN QueryTree (yyt^.Spec.Codes);
ELSIF yyyIsEqual ('Routines') THEN QueryTree (yyt^.Spec.Routines);
END;
| TreeName: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.TreeName.Next);
ELSIF yyyIsEqual ('Classes') THEN QueryTree (yyt^.TreeName.Classes);
ELSIF yyyIsEqual ('EmptyType') THEN QueryTree (yyt^.TreeName.EmptyType);
ELSIF yyyIsEqual ('UniversalClass') THEN QueryTree (yyt^.TreeName.UniversalClass);
END;
| Routine: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.Routine.Next);
ELSIF yyyIsEqual ('InParams') THEN QueryTree (yyt^.Routine.InParams);
ELSIF yyyIsEqual ('OutParams') THEN QueryTree (yyt^.Routine.OutParams);
ELSIF yyyIsEqual ('Extern') THEN QueryTree (yyt^.Routine.Extern);
ELSIF yyyIsEqual ('Rules') THEN QueryTree (yyt^.Routine.Rules);
ELSIF yyyIsEqual ('InForm') THEN QueryTree (yyt^.Routine.InForm);
ELSIF yyyIsEqual ('OutForm') THEN QueryTree (yyt^.Routine.OutForm);
ELSIF yyyIsEqual ('ParamDecls') THEN QueryTree (yyt^.Routine.ParamDecls);
ELSIF yyyIsEqual ('Decisions') THEN QueryTree (yyt^.Routine.Decisions);
END;
| Procedure: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.Procedure.Next);
ELSIF yyyIsEqual ('InParams') THEN QueryTree (yyt^.Procedure.InParams);
ELSIF yyyIsEqual ('OutParams') THEN QueryTree (yyt^.Procedure.OutParams);
ELSIF yyyIsEqual ('Extern') THEN QueryTree (yyt^.Procedure.Extern);
ELSIF yyyIsEqual ('Rules') THEN QueryTree (yyt^.Procedure.Rules);
ELSIF yyyIsEqual ('InForm') THEN QueryTree (yyt^.Procedure.InForm);
ELSIF yyyIsEqual ('OutForm') THEN QueryTree (yyt^.Procedure.OutForm);
ELSIF yyyIsEqual ('ParamDecls') THEN QueryTree (yyt^.Procedure.ParamDecls);
ELSIF yyyIsEqual ('Decisions') THEN QueryTree (yyt^.Procedure.Decisions);
END;
| Function: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.Function.Next);
ELSIF yyyIsEqual ('InParams') THEN QueryTree (yyt^.Function.InParams);
ELSIF yyyIsEqual ('OutParams') THEN QueryTree (yyt^.Function.OutParams);
ELSIF yyyIsEqual ('Extern') THEN QueryTree (yyt^.Function.Extern);
ELSIF yyyIsEqual ('Rules') THEN QueryTree (yyt^.Function.Rules);
ELSIF yyyIsEqual ('InForm') THEN QueryTree (yyt^.Function.InForm);
ELSIF yyyIsEqual ('OutForm') THEN QueryTree (yyt^.Function.OutForm);
ELSIF yyyIsEqual ('ParamDecls') THEN QueryTree (yyt^.Function.ParamDecls);
ELSIF yyyIsEqual ('Decisions') THEN QueryTree (yyt^.Function.Decisions);
ELSIF yyyIsEqual ('ReturnParams') THEN QueryTree (yyt^.Function.ReturnParams);
ELSIF yyyIsEqual ('ReturnForm') THEN QueryTree (yyt^.Function.ReturnForm);
END;
| Predicate: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.Predicate.Next);
ELSIF yyyIsEqual ('InParams') THEN QueryTree (yyt^.Predicate.InParams);
ELSIF yyyIsEqual ('OutParams') THEN QueryTree (yyt^.Predicate.OutParams);
ELSIF yyyIsEqual ('Extern') THEN QueryTree (yyt^.Predicate.Extern);
ELSIF yyyIsEqual ('Rules') THEN QueryTree (yyt^.Predicate.Rules);
ELSIF yyyIsEqual ('InForm') THEN QueryTree (yyt^.Predicate.InForm);
ELSIF yyyIsEqual ('OutForm') THEN QueryTree (yyt^.Predicate.OutForm);
ELSIF yyyIsEqual ('ParamDecls') THEN QueryTree (yyt^.Predicate.ParamDecls);
ELSIF yyyIsEqual ('Decisions') THEN QueryTree (yyt^.Predicate.Decisions);
END;
| Param: IF FALSE THEN
ELSIF yyyIsEqual ('Type') THEN QueryTree (yyt^.Param.Type);
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.Param.Next);
END;
| Type: IF FALSE THEN
ELSIF yyyIsEqual ('Names') THEN QueryTree (yyt^.Type.Names);
END;
| Rule: IF FALSE THEN
ELSIF yyyIsEqual ('Patterns') THEN QueryTree (yyt^.Rule.Patterns);
ELSIF yyyIsEqual ('Exprs') THEN QueryTree (yyt^.Rule.Exprs);
ELSIF yyyIsEqual ('Expr') THEN QueryTree (yyt^.Rule.Expr);
ELSIF yyyIsEqual ('Statements') THEN QueryTree (yyt^.Rule.Statements);
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.Rule.Next);
ELSIF yyyIsEqual ('VarDecls') THEN QueryTree (yyt^.Rule.VarDecls);
ELSIF yyyIsEqual ('Tests') THEN QueryTree (yyt^.Rule.Tests);
END;
| OnePattern: IF FALSE THEN
ELSIF yyyIsEqual ('Pattern') THEN QueryTree (yyt^.OnePattern.Pattern);
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.OnePattern.Next);
END;
| OnePatternAlts: IF FALSE THEN
ELSIF yyyIsEqual ('PatternsList') THEN QueryTree (yyt^.OnePatternAlts.PatternsList);
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.OnePatternAlts.Next);
ELSIF yyyIsEqual ('Current') THEN QueryTree (yyt^.OnePatternAlts.Current);
END;
| OnePatternsList: IF FALSE THEN
ELSIF yyyIsEqual ('Patterns') THEN QueryTree (yyt^.OnePatternsList.Patterns);
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.OnePatternsList.Next);
END;
| Pattern: IF FALSE THEN
ELSIF yyyIsEqual ('TypeDesc') THEN QueryTree (yyt^.Pattern.TypeDesc);
ELSIF yyyIsEqual ('Path') THEN QueryTree (yyt^.Pattern.Path);
END;
| Decompose: IF FALSE THEN
ELSIF yyyIsEqual ('TypeDesc') THEN QueryTree (yyt^.Decompose.TypeDesc);
ELSIF yyyIsEqual ('Path') THEN QueryTree (yyt^.Decompose.Path);
ELSIF yyyIsEqual ('Expr') THEN QueryTree (yyt^.Decompose.Expr);
ELSIF yyyIsEqual ('Patterns') THEN QueryTree (yyt^.Decompose.Patterns);
END;
| VarDef: IF FALSE THEN
ELSIF yyyIsEqual ('TypeDesc') THEN QueryTree (yyt^.VarDef.TypeDesc);
ELSIF yyyIsEqual ('Path') THEN QueryTree (yyt^.VarDef.Path);
END;
| NilTest: IF FALSE THEN
ELSIF yyyIsEqual ('TypeDesc') THEN QueryTree (yyt^.NilTest.TypeDesc);
ELSIF yyyIsEqual ('Path') THEN QueryTree (yyt^.NilTest.Path);
END;
| DontCare1: IF FALSE THEN
ELSIF yyyIsEqual ('TypeDesc') THEN QueryTree (yyt^.DontCare1.TypeDesc);
ELSIF yyyIsEqual ('Path') THEN QueryTree (yyt^.DontCare1.Path);
END;
| DontCare1Explicit: IF FALSE THEN
ELSIF yyyIsEqual ('TypeDesc') THEN QueryTree (yyt^.DontCare1Explicit.TypeDesc);
ELSIF yyyIsEqual ('Path') THEN QueryTree (yyt^.DontCare1Explicit.Path);
END;
| DontCare1Internal: IF FALSE THEN
ELSIF yyyIsEqual ('TypeDesc') THEN QueryTree (yyt^.DontCare1Internal.TypeDesc);
ELSIF yyyIsEqual ('Path') THEN QueryTree (yyt^.DontCare1Internal.Path);
END;
| DontCare: IF FALSE THEN
ELSIF yyyIsEqual ('TypeDesc') THEN QueryTree (yyt^.DontCare.TypeDesc);
ELSIF yyyIsEqual ('Path') THEN QueryTree (yyt^.DontCare.Path);
ELSIF yyyIsEqual ('Tempos') THEN QueryTree (yyt^.DontCare.Tempos);
END;
| DontCareExplicit: IF FALSE THEN
ELSIF yyyIsEqual ('TypeDesc') THEN QueryTree (yyt^.DontCareExplicit.TypeDesc);
ELSIF yyyIsEqual ('Path') THEN QueryTree (yyt^.DontCareExplicit.Path);
ELSIF yyyIsEqual ('Tempos') THEN QueryTree (yyt^.DontCareExplicit.Tempos);
END;
| DontCareInternal: IF FALSE THEN
ELSIF yyyIsEqual ('TypeDesc') THEN QueryTree (yyt^.DontCareInternal.TypeDesc);
ELSIF yyyIsEqual ('Path') THEN QueryTree (yyt^.DontCareInternal.Path);
ELSIF yyyIsEqual ('Tempos') THEN QueryTree (yyt^.DontCareInternal.Tempos);
END;
| Value: IF FALSE THEN
ELSIF yyyIsEqual ('TypeDesc') THEN QueryTree (yyt^.Value.TypeDesc);
ELSIF yyyIsEqual ('Path') THEN QueryTree (yyt^.Value.Path);
ELSIF yyyIsEqual ('Expr') THEN QueryTree (yyt^.Value.Expr);
END;
| OneExpr: IF FALSE THEN
ELSIF yyyIsEqual ('Expr') THEN QueryTree (yyt^.OneExpr.Expr);
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.OneExpr.Next);
END;
| NamedExpr: IF FALSE THEN
ELSIF yyyIsEqual ('Expr') THEN QueryTree (yyt^.NamedExpr.Expr);
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.NamedExpr.Next);
END;
| Compose: IF FALSE THEN
ELSIF yyyIsEqual ('Expr') THEN QueryTree (yyt^.Compose.Expr);
ELSIF yyyIsEqual ('Exprs') THEN QueryTree (yyt^.Compose.Exprs);
ELSIF yyyIsEqual ('TypeDesc') THEN QueryTree (yyt^.Compose.TypeDesc);
END;
| Call: IF FALSE THEN
ELSIF yyyIsEqual ('Expr') THEN QueryTree (yyt^.Call.Expr);
ELSIF yyyIsEqual ('Exprs') THEN QueryTree (yyt^.Call.Exprs);
ELSIF yyyIsEqual ('Patterns') THEN QueryTree (yyt^.Call.Patterns);
END;
| Binary: IF FALSE THEN
ELSIF yyyIsEqual ('Lop') THEN QueryTree (yyt^.Binary.Lop);
ELSIF yyyIsEqual ('Rop') THEN QueryTree (yyt^.Binary.Rop);
END;
| yy1: IF FALSE THEN
ELSIF yyyIsEqual ('Lop') THEN QueryTree (yyt^.yy1.Lop);
ELSIF yyyIsEqual ('Rop') THEN QueryTree (yyt^.yy1.Rop);
END;
| BinaryCompound: IF FALSE THEN
ELSIF yyyIsEqual ('Lop') THEN QueryTree (yyt^.BinaryCompound.Lop);
ELSIF yyyIsEqual ('Rop') THEN QueryTree (yyt^.BinaryCompound.Rop);
END;
| PreOperator: IF FALSE THEN
ELSIF yyyIsEqual ('Expr') THEN QueryTree (yyt^.PreOperator.Expr);
END;
| PostOperator: IF FALSE THEN
ELSIF yyyIsEqual ('Expr') THEN QueryTree (yyt^.PostOperator.Expr);
END;
| Index: IF FALSE THEN
ELSIF yyyIsEqual ('Expr') THEN QueryTree (yyt^.Index.Expr);
ELSIF yyyIsEqual ('Exprs') THEN QueryTree (yyt^.Index.Exprs);
END;
| Parents: IF FALSE THEN
ELSIF yyyIsEqual ('Expr') THEN QueryTree (yyt^.Parents.Expr);
END;
| TargetExpr: IF FALSE THEN
ELSIF yyyIsEqual ('Expr') THEN QueryTree (yyt^.TargetExpr.Expr);
END;
| Statement: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.Statement.Next);
END;
| ProcCall: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.ProcCall.Next);
ELSIF yyyIsEqual ('Call') THEN QueryTree (yyt^.ProcCall.Call);
END;
| Condition: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.Condition.Next);
ELSIF yyyIsEqual ('Expr') THEN QueryTree (yyt^.Condition.Expr);
END;
| Assignment: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.Assignment.Next);
ELSIF yyyIsEqual ('Adr') THEN QueryTree (yyt^.Assignment.Adr);
ELSIF yyyIsEqual ('Expr') THEN QueryTree (yyt^.Assignment.Expr);
END;
| Reject: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.Reject.Next);
END;
| Fail: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.Fail.Next);
END;
| TargetStmt: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.TargetStmt.Next);
ELSIF yyyIsEqual ('Parameters') THEN QueryTree (yyt^.TargetStmt.Parameters);
ELSIF yyyIsEqual ('Stmt') THEN QueryTree (yyt^.TargetStmt.Stmt);
END;
| Nl: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.Nl.Next);
END;
| WriteStr: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.WriteStr.Next);
END;
| Formal: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.Formal.Next);
ELSIF yyyIsEqual ('Hides') THEN QueryTree (yyt^.Formal.Hides);
ELSIF yyyIsEqual ('TypeDesc') THEN QueryTree (yyt^.Formal.TypeDesc);
ELSIF yyyIsEqual ('Path') THEN QueryTree (yyt^.Formal.Path);
END;
| PlainFormal: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.PlainFormal.Next);
ELSIF yyyIsEqual ('Hides') THEN QueryTree (yyt^.PlainFormal.Hides);
ELSIF yyyIsEqual ('TypeDesc') THEN QueryTree (yyt^.PlainFormal.TypeDesc);
ELSIF yyyIsEqual ('Path') THEN QueryTree (yyt^.PlainFormal.Path);
END;
| RoutineFormal: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.RoutineFormal.Next);
ELSIF yyyIsEqual ('Hides') THEN QueryTree (yyt^.RoutineFormal.Hides);
ELSIF yyyIsEqual ('TypeDesc') THEN QueryTree (yyt^.RoutineFormal.TypeDesc);
ELSIF yyyIsEqual ('Path') THEN QueryTree (yyt^.RoutineFormal.Path);
ELSIF yyyIsEqual ('TargetClass') THEN QueryTree (yyt^.RoutineFormal.TargetClass);
END;
| DummyFormal: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.DummyFormal.Next);
END;
| NodeTypes: IF FALSE THEN
ELSIF yyyIsEqual ('TreeName') THEN QueryTree (yyt^.NodeTypes.TreeName);
END;
| ConsType: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.ConsType.Next);
END;
| Field: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.Field.Next);
END;
| OneTest: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.OneTest.Next);
ELSIF yyyIsEqual ('Path') THEN QueryTree (yyt^.OneTest.Path);
END;
| TestKind: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.TestKind.Next);
ELSIF yyyIsEqual ('Path') THEN QueryTree (yyt^.TestKind.Path);
ELSIF yyyIsEqual ('TypeDesc') THEN QueryTree (yyt^.TestKind.TypeDesc);
END;
| TestIsType: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.TestIsType.Next);
ELSIF yyyIsEqual ('Path') THEN QueryTree (yyt^.TestIsType.Path);
ELSIF yyyIsEqual ('TypeDesc') THEN QueryTree (yyt^.TestIsType.TypeDesc);
END;
| TestNil: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.TestNil.Next);
ELSIF yyyIsEqual ('Path') THEN QueryTree (yyt^.TestNil.Path);
END;
| TestNonlin: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.TestNonlin.Next);
ELSIF yyyIsEqual ('Path') THEN QueryTree (yyt^.TestNonlin.Path);
ELSIF yyyIsEqual ('Path2') THEN QueryTree (yyt^.TestNonlin.Path2);
ELSIF yyyIsEqual ('TypeDesc') THEN QueryTree (yyt^.TestNonlin.TypeDesc);
END;
| TestValue: IF FALSE THEN
ELSIF yyyIsEqual ('Next') THEN QueryTree (yyt^.TestValue.Next);
ELSIF yyyIsEqual ('Path') THEN QueryTree (yyt^.TestValue.Path);
ELSIF yyyIsEqual ('Expr') THEN QueryTree (yyt^.TestValue.Expr);
ELSIF yyyIsEqual ('TypeDesc') THEN QueryTree (yyt^.TestValue.TypeDesc);
END;
| Decision: IF FALSE THEN
ELSIF yyyIsEqual ('ThenPart') THEN QueryTree (yyt^.Decision.ThenPart);
ELSIF yyyIsEqual ('ElsePart') THEN QueryTree (yyt^.Decision.ElsePart);
ELSIF yyyIsEqual ('OneTest') THEN QueryTree (yyt^.Decision.OneTest);
END;
| Decided: IF FALSE THEN
ELSIF yyyIsEqual ('ElsePart') THEN QueryTree (yyt^.Decided.ElsePart);
ELSIF yyyIsEqual ('Rule') THEN QueryTree (yyt^.Decided.Rule);
END;
     ELSE
     END;
    END;
   END;
  END;
 END QueryTree;

PROCEDURE BeginTree;
 BEGIN
(* line 376 "" *)

   ErrorCount := 0;
   MakeSet (Options, 127);
   NoCodeAttr  := {Test, Dummy, Virtual, Parameter};
   NoCodeClass := {Ignore, Abstract};

(* line 839 "" *)
 END BeginTree;

PROCEDURE CloseTree;
 BEGIN
 END CloseTree;

PROCEDURE xxExit;
 BEGIN
  IO.CloseIO; System.Exit (1);
 END xxExit;

BEGIN
 yyBlockList   := NIL;
 yyPoolFreePtr := NIL;
 yyPoolMaxPtr  := NIL;
 HeapUsed      := 0;
 yyExit        := xxExit;
 yyNodeSize [Classes] := SYSTEM.TSIZE (yClasses);
 yyNodeSize [NoClass] := SYSTEM.TSIZE (yNoClass);
 yyNodeSize [Class] := SYSTEM.TSIZE (yClass);
 yyNodeSize [Attributes] := SYSTEM.TSIZE (yAttributes);
 yyNodeSize [NoAttribute] := SYSTEM.TSIZE (yNoAttribute);
 yyNodeSize [AttrOrAction] := SYSTEM.TSIZE (yAttrOrAction);
 yyNodeSize [Child] := SYSTEM.TSIZE (yChild);
 yyNodeSize [Attribute] := SYSTEM.TSIZE (yAttribute);
 yyNodeSize [ActionPart] := SYSTEM.TSIZE (yActionPart);
 yyNodeSize [Codes] := SYSTEM.TSIZE (yCodes);
 yyNodeSize [Designators] := SYSTEM.TSIZE (yDesignators);
 yyNodeSize [NoDesignator] := SYSTEM.TSIZE (yNoDesignator);
 yyNodeSize [Designator] := SYSTEM.TSIZE (yDesignator);
 yyNodeSize [Ident] := SYSTEM.TSIZE (yIdent);
 yyNodeSize [Remote] := SYSTEM.TSIZE (yRemote);
 yyNodeSize [Any] := SYSTEM.TSIZE (yAny);
 yyNodeSize [Anys] := SYSTEM.TSIZE (yAnys);
 yyNodeSize [Layouts] := SYSTEM.TSIZE (yLayouts);
 yyNodeSize [NoLayout] := SYSTEM.TSIZE (yNoLayout);
 yyNodeSize [LayoutAny] := SYSTEM.TSIZE (yLayoutAny);
 yyNodeSize [Names] := SYSTEM.TSIZE (yNames);
 yyNodeSize [NoName] := SYSTEM.TSIZE (yNoName);
 yyNodeSize [Name] := SYSTEM.TSIZE (yName);
 yyNodeSize [Spec] := SYSTEM.TSIZE (ySpec);
 yyNodeSize [TreeNames] := SYSTEM.TSIZE (yTreeNames);
 yyNodeSize [NoTreeName] := SYSTEM.TSIZE (yNoTreeName);
 yyNodeSize [TreeName] := SYSTEM.TSIZE (yTreeName);
 yyNodeSize [Routines] := SYSTEM.TSIZE (yRoutines);
 yyNodeSize [NoRoutine] := SYSTEM.TSIZE (yNoRoutine);
 yyNodeSize [Routine] := SYSTEM.TSIZE (yRoutine);
 yyNodeSize [Procedure] := SYSTEM.TSIZE (yProcedure);
 yyNodeSize [Function] := SYSTEM.TSIZE (yFunction);
 yyNodeSize [Predicate] := SYSTEM.TSIZE (yPredicate);
 yyNodeSize [Parameters] := SYSTEM.TSIZE (yParameters);
 yyNodeSize [NoParameter] := SYSTEM.TSIZE (yNoParameter);
 yyNodeSize [Param] := SYSTEM.TSIZE (yParam);
 yyNodeSize [Type] := SYSTEM.TSIZE (yType);
 yyNodeSize [Rules] := SYSTEM.TSIZE (yRules);
 yyNodeSize [NoRule] := SYSTEM.TSIZE (yNoRule);
 yyNodeSize [Rule] := SYSTEM.TSIZE (yRule);
 yyNodeSize [Patterns] := SYSTEM.TSIZE (yPatterns);
 yyNodeSize [NoPattern] := SYSTEM.TSIZE (yNoPattern);
 yyNodeSize [OnePattern] := SYSTEM.TSIZE (yOnePattern);
 yyNodeSize [OnePatternAlts] := SYSTEM.TSIZE (yOnePatternAlts);
 yyNodeSize [PatternsList] := SYSTEM.TSIZE (yPatternsList);
 yyNodeSize [NoPatternsList] := SYSTEM.TSIZE (yNoPatternsList);
 yyNodeSize [OnePatternsList] := SYSTEM.TSIZE (yOnePatternsList);
 yyNodeSize [Pattern] := SYSTEM.TSIZE (yPattern);
 yyNodeSize [Decompose] := SYSTEM.TSIZE (yDecompose);
 yyNodeSize [VarDef] := SYSTEM.TSIZE (yVarDef);
 yyNodeSize [NilTest] := SYSTEM.TSIZE (yNilTest);
 yyNodeSize [DontCare1] := SYSTEM.TSIZE (yDontCare1);
 yyNodeSize [DontCare1Explicit] := SYSTEM.TSIZE (yDontCare1Explicit);
 yyNodeSize [DontCare1Internal] := SYSTEM.TSIZE (yDontCare1Internal);
 yyNodeSize [DontCare] := SYSTEM.TSIZE (yDontCare);
 yyNodeSize [DontCareExplicit] := SYSTEM.TSIZE (yDontCareExplicit);
 yyNodeSize [DontCareInternal] := SYSTEM.TSIZE (yDontCareInternal);
 yyNodeSize [Value] := SYSTEM.TSIZE (yValue);
 yyNodeSize [Exprs] := SYSTEM.TSIZE (yExprs);
 yyNodeSize [NoExpr] := SYSTEM.TSIZE (yNoExpr);
 yyNodeSize [OneExpr] := SYSTEM.TSIZE (yOneExpr);
 yyNodeSize [NamedExpr] := SYSTEM.TSIZE (yNamedExpr);
 yyNodeSize [Expr] := SYSTEM.TSIZE (yExpr);
 yyNodeSize [Compose] := SYSTEM.TSIZE (yCompose);
 yyNodeSize [VarUse] := SYSTEM.TSIZE (yVarUse);
 yyNodeSize [AttrDesc] := SYSTEM.TSIZE (yAttrDesc);
 yyNodeSize [Nil] := SYSTEM.TSIZE (yNil);
 yyNodeSize [Call] := SYSTEM.TSIZE (yCall);
 yyNodeSize [Binary] := SYSTEM.TSIZE (yBinary);
 yyNodeSize [yy1] := SYSTEM.TSIZE (yyy1);
 yyNodeSize [BinaryCompound] := SYSTEM.TSIZE (yBinaryCompound);
 yyNodeSize [PreOperator] := SYSTEM.TSIZE (yPreOperator);
 yyNodeSize [PostOperator] := SYSTEM.TSIZE (yPostOperator);
 yyNodeSize [Index] := SYSTEM.TSIZE (yIndex);
 yyNodeSize [Parents] := SYSTEM.TSIZE (yParents);
 yyNodeSize [TargetExpr] := SYSTEM.TSIZE (yTargetExpr);
 yyNodeSize [StringExpr] := SYSTEM.TSIZE (yStringExpr);
 yyNodeSize [Statements] := SYSTEM.TSIZE (yStatements);
 yyNodeSize [NoStatement] := SYSTEM.TSIZE (yNoStatement);
 yyNodeSize [Statement] := SYSTEM.TSIZE (yStatement);
 yyNodeSize [ProcCall] := SYSTEM.TSIZE (yProcCall);
 yyNodeSize [Condition] := SYSTEM.TSIZE (yCondition);
 yyNodeSize [Assignment] := SYSTEM.TSIZE (yAssignment);
 yyNodeSize [Reject] := SYSTEM.TSIZE (yReject);
 yyNodeSize [Fail] := SYSTEM.TSIZE (yFail);
 yyNodeSize [TargetStmt] := SYSTEM.TSIZE (yTargetStmt);
 yyNodeSize [Nl] := SYSTEM.TSIZE (yNl);
 yyNodeSize [WriteStr] := SYSTEM.TSIZE (yWriteStr);
 yyNodeSize [Formals] := SYSTEM.TSIZE (yFormals);
 yyNodeSize [NoFormal] := SYSTEM.TSIZE (yNoFormal);
 yyNodeSize [Formal] := SYSTEM.TSIZE (yFormal);
 yyNodeSize [PlainFormal] := SYSTEM.TSIZE (yPlainFormal);
 yyNodeSize [RoutineFormal] := SYSTEM.TSIZE (yRoutineFormal);
 yyNodeSize [DummyFormal] := SYSTEM.TSIZE (yDummyFormal);
 yyNodeSize [TypeDesc] := SYSTEM.TSIZE (yTypeDesc);
 yyNodeSize [NodeTypes] := SYSTEM.TSIZE (yNodeTypes);
 yyNodeSize [UserType] := SYSTEM.TSIZE (yUserType);
 yyNodeSize [Path] := SYSTEM.TSIZE (yPath);
 yyNodeSize [Var] := SYSTEM.TSIZE (yVar);
 yyNodeSize [ConsType] := SYSTEM.TSIZE (yConsType);
 yyNodeSize [Field] := SYSTEM.TSIZE (yField);
 yyNodeSize [Tests] := SYSTEM.TSIZE (yTests);
 yyNodeSize [NoTest] := SYSTEM.TSIZE (yNoTest);
 yyNodeSize [OneTest] := SYSTEM.TSIZE (yOneTest);
 yyNodeSize [TestKind] := SYSTEM.TSIZE (yTestKind);
 yyNodeSize [TestIsType] := SYSTEM.TSIZE (yTestIsType);
 yyNodeSize [TestNil] := SYSTEM.TSIZE (yTestNil);
 yyNodeSize [TestNonlin] := SYSTEM.TSIZE (yTestNonlin);
 yyNodeSize [TestValue] := SYSTEM.TSIZE (yTestValue);
 yyNodeSize [Decisions] := SYSTEM.TSIZE (yDecisions);
 yyNodeSize [NoDecision] := SYSTEM.TSIZE (yNoDecision);
 yyNodeSize [Decision] := SYSTEM.TSIZE (yDecision);
 yyNodeSize [Decided] := SYSTEM.TSIZE (yDecided);
 yyMaxSize     := 0;
 FOR yyi := 1 TO 138 DO
  yyNodeSize [yyi] := LONGINT (BITSET (yyNodeSize [yyi] + CARDINAL (General.MaxAlign) - 1) * General.AlignMasks [General.MaxAlign]);
  yyMaxSize := General.Max (yyNodeSize [yyi], yyMaxSize);
 END;
 yyTypeRange [Classes] := Class;
 yyTypeRange [NoClass] := NoClass;
 yyTypeRange [Class] := Class;
 yyTypeRange [Attributes] := ActionPart;
 yyTypeRange [NoAttribute] := NoAttribute;
 yyTypeRange [AttrOrAction] := ActionPart;
 yyTypeRange [Child] := Child;
 yyTypeRange [Attribute] := Attribute;
 yyTypeRange [ActionPart] := ActionPart;
 yyTypeRange [Codes] := Codes;
 yyTypeRange [Designators] := Anys;
 yyTypeRange [NoDesignator] := NoDesignator;
 yyTypeRange [Designator] := Designator;
 yyTypeRange [Ident] := Ident;
 yyTypeRange [Remote] := Remote;
 yyTypeRange [Any] := Any;
 yyTypeRange [Anys] := Anys;
 yyTypeRange [Layouts] := LayoutAny;
 yyTypeRange [NoLayout] := NoLayout;
 yyTypeRange [LayoutAny] := LayoutAny;
 yyTypeRange [Names] := Name;
 yyTypeRange [NoName] := NoName;
 yyTypeRange [Name] := Name;
 yyTypeRange [Spec] := Spec;
 yyTypeRange [TreeNames] := TreeName;
 yyTypeRange [NoTreeName] := NoTreeName;
 yyTypeRange [TreeName] := TreeName;
 yyTypeRange [Routines] := Predicate;
 yyTypeRange [NoRoutine] := NoRoutine;
 yyTypeRange [Routine] := Predicate;
 yyTypeRange [Procedure] := Procedure;
 yyTypeRange [Function] := Function;
 yyTypeRange [Predicate] := Predicate;
 yyTypeRange [Parameters] := Param;
 yyTypeRange [NoParameter] := NoParameter;
 yyTypeRange [Param] := Param;
 yyTypeRange [Type] := Type;
 yyTypeRange [Rules] := Rule;
 yyTypeRange [NoRule] := NoRule;
 yyTypeRange [Rule] := Rule;
 yyTypeRange [Patterns] := OnePatternAlts;
 yyTypeRange [NoPattern] := NoPattern;
 yyTypeRange [OnePattern] := OnePattern;
 yyTypeRange [OnePatternAlts] := OnePatternAlts;
 yyTypeRange [PatternsList] := OnePatternsList;
 yyTypeRange [NoPatternsList] := NoPatternsList;
 yyTypeRange [OnePatternsList] := OnePatternsList;
 yyTypeRange [Pattern] := Value;
 yyTypeRange [Decompose] := Decompose;
 yyTypeRange [VarDef] := VarDef;
 yyTypeRange [NilTest] := NilTest;
 yyTypeRange [DontCare1] := DontCare1Internal;
 yyTypeRange [DontCare1Explicit] := DontCare1Explicit;
 yyTypeRange [DontCare1Internal] := DontCare1Internal;
 yyTypeRange [DontCare] := DontCareInternal;
 yyTypeRange [DontCareExplicit] := DontCareExplicit;
 yyTypeRange [DontCareInternal] := DontCareInternal;
 yyTypeRange [Value] := Value;
 yyTypeRange [Exprs] := NamedExpr;
 yyTypeRange [NoExpr] := NoExpr;
 yyTypeRange [OneExpr] := NamedExpr;
 yyTypeRange [NamedExpr] := NamedExpr;
 yyTypeRange [Expr] := StringExpr;
 yyTypeRange [Compose] := Compose;
 yyTypeRange [VarUse] := AttrDesc;
 yyTypeRange [AttrDesc] := AttrDesc;
 yyTypeRange [Nil] := Nil;
 yyTypeRange [Call] := Call;
 yyTypeRange [Binary] := BinaryCompound;
 yyTypeRange [yy1] := yy1;
 yyTypeRange [BinaryCompound] := BinaryCompound;
 yyTypeRange [PreOperator] := PreOperator;
 yyTypeRange [PostOperator] := PostOperator;
 yyTypeRange [Index] := Index;
 yyTypeRange [Parents] := Parents;
 yyTypeRange [TargetExpr] := TargetExpr;
 yyTypeRange [StringExpr] := StringExpr;
 yyTypeRange [Statements] := WriteStr;
 yyTypeRange [NoStatement] := NoStatement;
 yyTypeRange [Statement] := WriteStr;
 yyTypeRange [ProcCall] := ProcCall;
 yyTypeRange [Condition] := Condition;
 yyTypeRange [Assignment] := Assignment;
 yyTypeRange [Reject] := Reject;
 yyTypeRange [Fail] := Fail;
 yyTypeRange [TargetStmt] := TargetStmt;
 yyTypeRange [Nl] := Nl;
 yyTypeRange [WriteStr] := WriteStr;
 yyTypeRange [Formals] := DummyFormal;
 yyTypeRange [NoFormal] := NoFormal;
 yyTypeRange [Formal] := RoutineFormal;
 yyTypeRange [PlainFormal] := PlainFormal;
 yyTypeRange [RoutineFormal] := RoutineFormal;
 yyTypeRange [DummyFormal] := DummyFormal;
 yyTypeRange [TypeDesc] := UserType;
 yyTypeRange [NodeTypes] := NodeTypes;
 yyTypeRange [UserType] := UserType;
 yyTypeRange [Path] := Field;
 yyTypeRange [Var] := Var;
 yyTypeRange [ConsType] := ConsType;
 yyTypeRange [Field] := Field;
 yyTypeRange [Tests] := TestValue;
 yyTypeRange [NoTest] := NoTest;
 yyTypeRange [OneTest] := TestValue;
 yyTypeRange [TestKind] := TestKind;
 yyTypeRange [TestIsType] := TestIsType;
 yyTypeRange [TestNil] := TestNil;
 yyTypeRange [TestNonlin] := TestNonlin;
 yyTypeRange [TestValue] := TestValue;
 yyTypeRange [Decisions] := Decided;
 yyTypeRange [NoDecision] := NoDecision;
 yyTypeRange [Decision] := Decision;
 yyTypeRange [Decided] := Decided;
 yyRecursionLevel := 0;
 yyTreeStoreSize := yyInitTreeStoreSize;
 DynArray.MakeArray (yyTreeStorePtr, yyTreeStoreSize, SYSTEM.TSIZE (tTree));
 yyOldToNewStoreSize := yyInitOldToNewStoreSize;
 DynArray.MakeArray (yyOldToNewStorePtr, yyOldToNewStoreSize, SYSTEM.TSIZE (yytOldToNew));
 BeginTree;
END Tree.
