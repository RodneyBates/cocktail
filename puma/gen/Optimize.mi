
(* This file was mechanically generated by puma. *)

IMPLEMENTATION MODULE Optimize;








IMPORT SYSTEM, System, IO, Tree;
(* line 39 "../src/opt.puma" *)


FROM IO         IMPORT StdOutput, WriteB, WriteS, WriteI, WriteNl;
FROM Idents     IMPORT WriteIdent;
FROM M2         IMPORT ImplMod;
FROM Tree       IMPORT tTree, NoTree, mTestIsType, mNodeTypes, Options;
FROM Scanner    IMPORT Warning;
FROM Positions  IMPORT tPosition;

FROM Sets       IMPORT
   tSet         , MakeSet       , ReleaseSet    , AssignEmpty   ,
   IsEmpty      , Difference    , IsSubset      , Assign        ,
   IsEqual      , IsNotEqual    , Intersection  , Union         ,
   Size         , WriteSet      , IsElement ;

IMPORT Sets;

CONST MinCases = 2 ; 

VAR
   gHasExit : BOOLEAN;
   gHasAssign : BOOLEAN;
   gHasTargetCode : BOOLEAN;
   gHasRejectOrFail: BOOLEAN; 
   gRule, nNoDecision, nNoTest  : tTree;

PROCEDURE IsDisjoint (s1, s2: tSet): BOOLEAN;
   VAR s: tSet; Result: BOOLEAN;
   BEGIN
      MakeSet (s, Size (s1));
      Assign (s, s1);
      Intersection (s, s2);
      Result := IsEmpty (s);
      ReleaseSet (s);
      RETURN Result;
   END IsDisjoint;




























































PROCEDURE yyAbort (yyFunction: ARRAY OF CHAR);
 BEGIN
  IO.WriteS (IO.StdError, 'Error: module Optimize, routine ');
  IO.WriteS (IO.StdError, yyFunction);
  IO.WriteS (IO.StdError, ' failed');
  IO.WriteNl (IO.StdError);
  Exit;
 END yyAbort;

PROCEDURE yyIsEqual (yya, yyb: ARRAY OF SYSTEM.BYTE): BOOLEAN;
 VAR yyi       : INTEGER;
 BEGIN
  FOR yyi := 0 TO INTEGER (HIGH (yya)) DO
   IF yya [yyi] # yyb [yyi] THEN RETURN FALSE; END;
  END;
  RETURN TRUE;
 END yyIsEqual;

PROCEDURE Optimize (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 1: yyR1: RECORD
  yyV1: Tree.tTree;
  yyV2: Tree.tTree;
  END;
 | 2: yyR2: RECORD
  yyV1: Tree.tTree;
  yyV2: Tree.tTree;
  yyV3: tSet;
  yyV4: Tree.tTree;
  yyV5: SHORTCARD;
  yyV6: tSet;
  END;
 END; END;
 BEGIN

  CASE t^.Kind OF
  | Tree.Spec:
(* line 79 "../src/opt.puma" *)
    WITH yyTempo.yyR1 DO  
     WITH t^.Spec DO
(* line 80 "../src/opt.puma" *)
       yyV1  :=  Tree .yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyV1 ) >=  Tree .yyPoolMaxPtr THEN  yyV1  :=  Tree .yyAlloc (); END; INC ( Tree .yyPoolFreePtr,  Tree .yyNodeSize [ Tree . NoDecision ]);  yyV1 ^.yyHead.yyMark := 0;  yyV1 ^.Kind :=  Tree . NoDecision ; 
      nNoDecision := yyV1;
(* line 81 "../src/opt.puma" *)
       yyV2  :=  Tree .yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyV2 ) >=  Tree .yyPoolMaxPtr THEN  yyV2  :=  Tree .yyAlloc (); END; INC ( Tree .yyPoolFreePtr,  Tree .yyNodeSize [ Tree . NoTest ]);  yyV2 ^.yyHead.yyMark := 0;  yyV2 ^.Kind :=  Tree . NoTest ; 
      nNoTest := yyV2;
(* line 82 "../src/opt.puma" *)
      Optimize (Routines);
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.Routine
  , Tree.Procedure
  , Tree.Function
  , Tree.Predicate:
(* line 85 "../src/opt.puma" *)
    WITH yyTempo.yyR2 DO  
     WITH t^.Routine DO
(* line 86 "../src/opt.puma" *)
      RuleProperties (Rules);
(* line 87 "../src/opt.puma" *)
      CollectTests (Rules, InForm);
(* line 88 "../src/opt.puma" *)
      BuildTree (Rules, nNoDecision, yyV1);
(* line 89 "../src/opt.puma" *)
      Decisions := yyV1;
(* line 90 "../src/opt.puma" *)
      ElimDeadTests (Decisions, yyV2, (FALSE), yyV3);
(* line 91 "../src/opt.puma" *)
      FindCases (Decisions, yyV4, yyV5, yyV6);
(* line 92 "../src/opt.puma" *)
      MarkCases (Decisions, yyV5, yyV6);
(* line 93 "../src/opt.puma" *)
      Optimize (Next);
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  ELSE END;

 END Optimize;

PROCEDURE RuleProperties (yyP1: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN

  CASE yyP1^.Kind OF
  | Tree.Spec:
(* line 100 "../src/opt.puma" *)
     WITH yyP1^.Spec DO
(* line 101 "../src/opt.puma" *)
      RuleProperties (Routines);
      RETURN;
     END (* WITH *) ;

  | Tree.Routine
  , Tree.Procedure
  , Tree.Function
  , Tree.Predicate:
(* line 103 "../src/opt.puma" *)
     WITH yyP1^.Routine DO
(* line 104 "../src/opt.puma" *)
      RuleProperties (Rules);
(* line 105 "../src/opt.puma" *)
      RuleProperties (Next);
      RETURN;
     END (* WITH *) ;

  | Tree.Rule:
(* line 108 "../src/opt.puma" *)
     WITH yyP1^.Rule DO
(* line 109 "../src/opt.puma" *)
      gHasExit := FALSE;
(* line 110 "../src/opt.puma" *)
      gHasAssign := FALSE;
(* line 111 "../src/opt.puma" *)
      gHasTargetCode := FALSE;
(* line 112 "../src/opt.puma" *)
      gHasRejectOrFail := FALSE;
(* line 113 "../src/opt.puma" *)
      RuleProperties (Statements);
(* line 114 "../src/opt.puma" *)
      RuleProperties (Exprs);
(* line 115 "../src/opt.puma" *)
      RuleProperties (Expr);
(* line 116 "../src/opt.puma" *)
      HasExit := gHasExit;
(* line 117 "../src/opt.puma" *)
      HasAssign := gHasAssign;
(* line 118 "../src/opt.puma" *)
      HasTargetCode := gHasTargetCode;
(* line 119 "../src/opt.puma" *)
      HasRejectOrFail := gHasRejectOrFail;
(* line 120 "../src/opt.puma" *)
      RuleProperties (Next);
      RETURN;
     END (* WITH *) ;

  | Tree.ProcCall:
(* line 123 "../src/opt.puma" *)
     WITH yyP1^.ProcCall DO
(* line 124 "../src/opt.puma" *)
      RuleProperties (Call);
(* line 125 "../src/opt.puma" *)
      RuleProperties (Next);
      RETURN;
     END (* WITH *) ;

  | Tree.Assignment:
(* line 128 "../src/opt.puma" *)
     WITH yyP1^.Assignment DO
(* line 129 "../src/opt.puma" *)
      gHasAssign := TRUE;
(* line 130 "../src/opt.puma" *)
      RuleProperties (Adr);
(* line 131 "../src/opt.puma" *)
      RuleProperties (Expr);
(* line 132 "../src/opt.puma" *)
      RuleProperties (Next);
      RETURN;
     END (* WITH *) ;

  | Tree.Condition:
(* line 135 "../src/opt.puma" *)
     WITH yyP1^.Condition DO
(* line 136 "../src/opt.puma" *)
      gHasExit := TRUE;
(* line 137 "../src/opt.puma" *)
      RuleProperties (Next);
      RETURN;
     END (* WITH *) ;

  | Tree.Reject:
(* line 140 "../src/opt.puma" *)
     WITH yyP1^.Reject DO
(* line 141 "../src/opt.puma" *)
      gHasExit := TRUE;
(* line 142 "../src/opt.puma" *)
      gHasRejectOrFail := TRUE;
(* line 143 "../src/opt.puma" *)
      RuleProperties (Next);
      RETURN;
     END (* WITH *) ;

  | Tree.Fail:
(* line 146 "../src/opt.puma" *)
     WITH yyP1^.Fail DO
(* line 147 "../src/opt.puma" *)
      gHasRejectOrFail := TRUE;
(* line 148 "../src/opt.puma" *)
      RuleProperties (Next);
      RETURN;
     END (* WITH *) ;

  | Tree.TargetStmt:
(* line 151 "../src/opt.puma" *)
     WITH yyP1^.TargetStmt DO
(* line 152 "../src/opt.puma" *)
      gHasTargetCode := TRUE;
(* line 153 "../src/opt.puma" *)
      RuleProperties (Next);
      RETURN;
     END (* WITH *) ;

  | Tree.Statement
  , Tree.Nl
  , Tree.WriteStr:
(* line 156 "../src/opt.puma" *)
     WITH yyP1^.Statement DO
(* line 157 "../src/opt.puma" *)
      RuleProperties (Next);
      RETURN;
     END (* WITH *) ;

  | Tree.OneExpr
  , Tree.NamedExpr:
(* line 159 "../src/opt.puma" *)
     WITH yyP1^.OneExpr DO
(* line 160 "../src/opt.puma" *)
      RuleProperties (Expr);
(* line 161 "../src/opt.puma" *)
      RuleProperties (Next);
      RETURN;
     END (* WITH *) ;

  | Tree.Expr
  , Tree.Compose
  , Tree.VarUse
  , Tree.AttrDesc
  , Tree.Nil
  , Tree.Call
  , Tree.Binary
  , Tree.yy1
  , Tree.BinaryCompound
  , Tree.PreOperator
  , Tree.PostOperator
  , Tree.Index
  , Tree.Parents
  , Tree.TargetExpr
  , Tree.StringExpr:
(* line 164 "../src/opt.puma" *)
     WITH yyP1^.Expr DO
(* line 165 "../src/opt.puma" *)
      gHasExit := gHasExit OR NeedsMatch (yyP1);
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END RuleProperties;

PROCEDURE NeedsMatch (yyP2: Tree.tTree): BOOLEAN;

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF (yyP2^.Kind = Tree.TestValue) THEN
(* line 171 "../src/opt.puma" *)
   LOOP
     WITH yyP2^.TestValue DO
(* line 171 "../src/opt.puma" *)
      IF NOT (NeedsMatch (Expr) OR NeedsMatch (Next)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;

  CASE yyP2^.Kind OF
  | Tree.OneTest
  , Tree.TestKind
  , Tree.TestIsType
  , Tree.TestNil
  , Tree.TestNonlin
  , Tree.TestValue:
(* line 173 "../src/opt.puma" *)
   LOOP
     WITH yyP2^.OneTest DO
(* line 173 "../src/opt.puma" *)
      IF NOT (NeedsMatch (Next)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.OneExpr
  , Tree.NamedExpr:
(* line 175 "../src/opt.puma" *)
   LOOP
     WITH yyP2^.OneExpr DO
(* line 175 "../src/opt.puma" *)
      IF NOT (NeedsMatch (Expr) OR NeedsMatch (Next)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.Compose:
(* line 177 "../src/opt.puma" *)
   LOOP
     WITH yyP2^.Compose DO
(* line 177 "../src/opt.puma" *)
      IF NOT (NeedsMatch (Exprs)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.Call:
(* line 179 "../src/opt.puma" *)
   LOOP
     WITH yyP2^.Call DO
(* line 182 "../src/opt.puma" *)
      IF NOT (NeedsMatch (Expr) OR NeedsMatch (Exprs) OR (Object # NoTree) AND NeedsMatch2 (Patterns, Object ^ . Routine . OutForm)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.Binary
  , Tree.yy1
  , Tree.BinaryCompound:
(* line 184 "../src/opt.puma" *)
   LOOP
     WITH yyP2^.Binary DO
(* line 184 "../src/opt.puma" *)
      IF NOT (NeedsMatch (Lop) OR NeedsMatch (Rop)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.Parents:
(* line 186 "../src/opt.puma" *)
   LOOP
     WITH yyP2^.Parents DO
(* line 188 "../src/opt.puma" *)
      IF NOT (NeedsMatch (Expr)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.PreOperator:
(* line 186 "../src/opt.puma" *)
   LOOP
     WITH yyP2^.PreOperator DO
(* line 188 "../src/opt.puma" *)
      IF NOT (NeedsMatch (Expr)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.PostOperator:
(* line 186 "../src/opt.puma" *)
   LOOP
     WITH yyP2^.PostOperator DO
(* line 188 "../src/opt.puma" *)
      IF NOT (NeedsMatch (Expr)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.Index:
(* line 190 "../src/opt.puma" *)
   LOOP
     WITH yyP2^.Index DO
(* line 190 "../src/opt.puma" *)
      IF NOT (NeedsMatch (Expr) OR NeedsMatch (Exprs)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  ELSE END;

  RETURN FALSE;
 END NeedsMatch;

PROCEDURE NeedsMatch2 (yyP4: Tree.tTree; yyP3: Tree.tTree): BOOLEAN;

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN

  CASE yyP4^.Kind OF
  | Tree.OnePattern:
(* line 195 "../src/opt.puma" *)
   LOOP
     WITH yyP4^.OnePattern DO
(* line 196 "../src/opt.puma" *)
      IF NOT (NeedsMatch2 (Pattern, yyP3) OR NeedsMatch2 (Next, yyP3 ^ . Formal . Next)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.Decompose:
(* line 199 "../src/opt.puma" *)
   LOOP
     WITH yyP4^.Decompose DO
     WITH yyP3^.Formal DO
(* line 208 "../src/opt.puma" *)
      IF NOT ((yyP3^.Formal.TypeDesc ^ . Kind = Tree . UserType) OR IsNotEqual (Object ^ . Class . TypeDesc ^ . NodeTypes . Types, yyP3^.Formal.TypeDesc ^ . NodeTypes . Types) OR NeedsMatch2 (Patterns, Object ^ . Class . Formals)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.VarDef:
(* line 210 "../src/opt.puma" *)
   LOOP
     WITH yyP4^.VarDef DO
(* line 210 "../src/opt.puma" *)
      IF NOT (Object # NoTree) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.NilTest:
(* line 212 "../src/opt.puma" *)
      RETURN TRUE;

  | Tree.Value:
(* line 213 "../src/opt.puma" *)
      RETURN TRUE;

  ELSE END;

  RETURN FALSE;
 END NeedsMatch2;

PROCEDURE NeedsTempo (yyP5: Tree.tTree; VAR yyP6: Tree.tTree): BOOLEAN;

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 1: yyR1: RECORD
  yyV1: Tree.tTree;
  END;
 END; END;
 BEGIN

  CASE yyP5^.Kind OF
  | Tree.Decision:
(* line 217 "../src/opt.puma" *)
    WITH yyTempo.yyR1 DO  
   LOOP
     WITH yyP5^.Decision DO
(* line 218 "../src/opt.puma" *)
      IF NOT (NeedsTempo (yyP5^.Decision.ThenPart, yyV1)) THEN EXIT; END;
      yyP6 := yyV1;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.Decided:
  IF ( yyP5^.Decided.Rule^.Rule.HasTempos  =   (TRUE)  ) THEN
(* line 220 "../src/opt.puma" *)
     WITH yyP5^.Decided DO
     WITH Rule^.Rule DO
      yyP6 := yyP5^.Decided.Rule;
      RETURN TRUE;
     END (* WITH *) ;
     END (* WITH *) ;

  END;
  ELSE END;

  RETURN FALSE;
 END NeedsTempo;

PROCEDURE NeedsNoFinale (yyP7: Tree.tTree): BOOLEAN;

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN

  CASE yyP7^.Kind OF
  | Tree.Decision:
(* line 225 "../src/opt.puma" *)
   LOOP
     WITH yyP7^.Decision DO
(* line 225 "../src/opt.puma" *)
      IF NOT (NeedsNoFinale (yyP7^.Decision.ElsePart)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.Decided:
  IF ( yyP7^.Decided.Rule^.Rule.HasExit  =   (FALSE)  ) THEN
(* line 227 "../src/opt.puma" *)
      RETURN TRUE;

  END;
(* line 229 "../src/opt.puma" *)
   LOOP
     WITH yyP7^.Decided DO
(* line 229 "../src/opt.puma" *)
      IF NOT (NeedsNoFinale (yyP7^.Decided.ElsePart)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  ELSE END;

  RETURN FALSE;
 END NeedsNoFinale;

PROCEDURE GetRule (yyP8: Tree.tTree; VAR yyP9: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 1: yyR1: RECORD
  yyV1: Tree.tTree;
  END;
 END; END;
 BEGIN

  CASE yyP8^.Kind OF
  | Tree.Decision:
(* line 233 "../src/opt.puma" *)
    WITH yyTempo.yyR1 DO  
     WITH yyP8^.Decision DO
(* line 233 "../src/opt.puma" *)
      GetRule (yyP8^.Decision.ThenPart, yyV1);
      yyP9 := yyV1;
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.Decided:
(* line 235 "../src/opt.puma" *)
     WITH yyP8^.Decided DO
      yyP9 := yyP8^.Decided.Rule;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END GetRule;

PROCEDURE CollectTests (yyP11: Tree.tTree; yyP10: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 1: yyR1: RECORD
  yyV1: Tree.tTree;
  END;
 END; END;
 BEGIN
  IF (yyP11^.Kind = Tree.Rule) THEN
(* line 241 "../src/opt.puma" *)
    WITH yyTempo.yyR1 DO  
     WITH yyP11^.Rule DO
(* line 242 "../src/opt.puma" *)
      CollectTests2 (Patterns, yyP10, nNoTest, yyV1);
(* line 243 "../src/opt.puma" *)
      Tests := yyV1;
(* line 244 "../src/opt.puma" *)
      CollectTests (Next, yyP10);
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  END;
 END CollectTests;

PROCEDURE CollectTests2 (yyP14: Tree.tTree; yyP13: Tree.tTree; yyP12: Tree.tTree; VAR yyP15: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 1: yyR1: RECORD
  yyV1: Tree.tTree;
  yyV2: Tree.tTree;
  END;
 | 2: yyR2: RECORD
  yyV1: Tree.tTree;
  END;
 | 3: yyR3: RECORD
  yyV1: Tree.tTree;
  END;
 | 4: yyR4: RECORD
  yyV1: Tree.tTree;
  END;
 END; END;
 BEGIN

  CASE yyP14^.Kind OF
  | Tree.OnePattern:
  IF Tree.IsType (yyP13, Tree.Formal) THEN
(* line 249 "../src/opt.puma" *)
    WITH yyTempo.yyR1 DO  
     WITH yyP14^.OnePattern DO
     WITH yyP13^.Formal DO
(* line 251 "../src/opt.puma" *)
      CollectTests2 (yyP14^.OnePattern.Next, yyP13^.Formal.Next, yyP12, yyV1);
(* line 252 "../src/opt.puma" *)
      CollectTests2 (yyP14^.OnePattern.Pattern, yyP13, yyV1, yyV2);
      yyP15 := yyV2;
      RETURN;
     END (* WITH *) ;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  END;
  | Tree.Decompose:
  IF Tree.IsType (yyP13, Tree.Formal) THEN
(* line 257 "../src/opt.puma" *)
    WITH yyTempo.yyR2 DO  
   LOOP
     WITH yyP14^.Decompose DO
     WITH yyP13^.Formal DO
(* line 262 "../src/opt.puma" *)
      IF NOT ((yyP13^.Formal.TypeDesc ^ . Kind # Tree . UserType) AND IsEqual (Object ^ . Class . TypeDesc ^ . NodeTypes . Types, yyP13^.Formal.TypeDesc ^ . NodeTypes . Types)) THEN EXIT; END;
(* line 266 "../src/opt.puma" *)
      CollectTests2 (Patterns, Object ^ . Class . Formals, yyP12, yyV1);
      yyP15 := yyV1;
      RETURN;
     END (* WITH *) ;
     END (* WITH *) ;
   END (* LOOP *) ;
    END (* WITH yyTempos.yyR ... *) ;  

(* line 270 "../src/opt.puma" *)
    WITH yyTempo.yyR3 DO  
   LOOP
     WITH yyP14^.Decompose DO
     WITH yyP13^.Formal DO
(* line 275 "../src/opt.puma" *)
      IF NOT (yyP14^.Decompose.Object ^ . Class . Extensions ^ . Kind = Tree . NoClass) THEN EXIT; END;
(* line 277 "../src/opt.puma" *)
      CollectTests2 (yyP14^.Decompose.Patterns, yyP14^.Decompose.Object ^ . Class . Formals, yyP12, yyV1);
       yyP15  :=  Tree .yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyP15 ) >=  Tree .yyPoolMaxPtr THEN  yyP15  :=  Tree .yyAlloc (); END; INC ( Tree .yyPoolFreePtr,  Tree .yyNodeSize [ Tree . TestKind ]);  yyP15 ^.yyHead.yyMark := 0;  yyP15 ^.Kind :=  Tree . TestKind ; 
      WITH yyP15^.TestKind DO
      Next := yyV1;
      Path := yyP14^.Decompose.Path;
      TypeDesc := yyP14^.Decompose.Object ^ . Class . TypeDesc;
      Name := yyP14^.Decompose.Object ^ . Class . Name;
      END;
      RETURN;
     END (* WITH *) ;
     END (* WITH *) ;
   END (* LOOP *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  END;
(* line 280 "../src/opt.puma" *)
    WITH yyTempo.yyR4 DO  
     WITH yyP14^.Decompose DO
(* line 286 "../src/opt.puma" *)
      CollectTests2 (yyP14^.Decompose.Patterns, yyP14^.Decompose.Object ^ . Class . Formals, yyP12, yyV1);
       yyP15  :=  Tree .yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyP15 ) >=  Tree .yyPoolMaxPtr THEN  yyP15  :=  Tree .yyAlloc (); END; INC ( Tree .yyPoolFreePtr,  Tree .yyNodeSize [ Tree . TestIsType ]);  yyP15 ^.yyHead.yyMark := 0;  yyP15 ^.Kind :=  Tree . TestIsType ; 
      WITH yyP15^.TestIsType DO
      Next := yyV1;
      Path := yyP14^.Decompose.Path;
      TypeDesc := yyP14^.Decompose.Object ^ . Class . TypeDesc;
      Name := yyP14^.Decompose.Object ^ . Class . Name;
      END;
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.VarDef:
(* line 288 "../src/opt.puma" *)
   LOOP
     WITH yyP14^.VarDef DO
(* line 293 "../src/opt.puma" *)
      IF NOT (Object # NoTree) THEN EXIT; END;
       yyP15  :=  Tree .yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyP15 ) >=  Tree .yyPoolMaxPtr THEN  yyP15  :=  Tree .yyAlloc (); END; INC ( Tree .yyPoolFreePtr,  Tree .yyNodeSize [ Tree . TestNonlin ]);  yyP15 ^.yyHead.yyMark := 0;  yyP15 ^.Kind :=  Tree . TestNonlin ; 
      WITH yyP15^.TestNonlin DO
      Next := yyP12;
      Path := Object ^ . Formal . Path;
      Path2 := yyP14^.VarDef.Path;
      TypeDesc := Object ^ . Formal . TypeDesc;
      END;
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.NilTest:
(* line 295 "../src/opt.puma" *)
     WITH yyP14^.NilTest DO
       yyP15  :=  Tree .yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyP15 ) >=  Tree .yyPoolMaxPtr THEN  yyP15  :=  Tree .yyAlloc (); END; INC ( Tree .yyPoolFreePtr,  Tree .yyNodeSize [ Tree . TestNil ]);  yyP15 ^.yyHead.yyMark := 0;  yyP15 ^.Kind :=  Tree . TestNil ; 
      WITH yyP15^.TestNil DO
      Next := yyP12;
      Path := yyP14^.NilTest.Path;
      END;
      RETURN;
     END (* WITH *) ;

  | Tree.Value:
  IF Tree.IsType (yyP13, Tree.Formal) THEN
(* line 299 "../src/opt.puma" *)
     WITH yyP14^.Value DO
     WITH yyP13^.Formal DO
       yyP15  :=  Tree .yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyP15 ) >=  Tree .yyPoolMaxPtr THEN  yyP15  :=  Tree .yyAlloc (); END; INC ( Tree .yyPoolFreePtr,  Tree .yyNodeSize [ Tree . TestValue ]);  yyP15 ^.yyHead.yyMark := 0;  yyP15 ^.Kind :=  Tree . TestValue ; 
      WITH yyP15^.TestValue DO
      Next := yyP12;
      Path := yyP14^.Value.Path;
      Expr := yyP14^.Value.Expr;
      TypeDesc := yyP13 ^ . Formal . TypeDesc;
      END;
      RETURN;
     END (* WITH *) ;
     END (* WITH *) ;

  END;
  ELSE END;

(* line 305 "../src/opt.puma" *)
      yyP15 := yyP12;
      RETURN;

 END CollectTests2;

PROCEDURE IsSamePath (yyP17: Tree.tTree; yyP16: Tree.tTree): BOOLEAN;

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN

  CASE yyP17^.Kind OF
  | Tree.Var:
  IF (yyP16^.Kind = Tree.Var) THEN
  IF ( yyP17^.Var.Name  =   yyP16^.Var.Name  ) THEN
(* line 310 "../src/opt.puma" *)
      RETURN TRUE;

  END;
  END;
  | Tree.ConsType:
  IF (yyP16^.Kind = Tree.ConsType) THEN
  IF ( yyP17^.ConsType.Name  =   yyP16^.ConsType.Name  ) THEN
(* line 311 "../src/opt.puma" *)
   LOOP
     WITH yyP17^.ConsType DO
     WITH yyP16^.ConsType DO
(* line 313 "../src/opt.puma" *)
      IF NOT (IsSamePath (yyP17^.ConsType.Next, yyP16^.ConsType.Next)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
  END;
  | Tree.Field:
  IF (yyP16^.Kind = Tree.Field) THEN
  IF ( yyP17^.Field.Name  =   yyP16^.Field.Name  ) THEN
(* line 311 "../src/opt.puma" *)
   LOOP
     WITH yyP17^.Field DO
     WITH yyP16^.Field DO
(* line 313 "../src/opt.puma" *)
      IF NOT (IsSamePath (yyP17^.Field.Next, yyP16^.Field.Next)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
  END;
  ELSE END;

  RETURN FALSE;
 END IsSamePath;

PROCEDURE IsSameType (yyP19: Tree.tTree; yyP18: Tree.tTree): BOOLEAN;

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN

  CASE yyP19^.Kind OF
  | Tree.NodeTypes:
  IF (yyP18^.Kind = Tree.NodeTypes) THEN
  IF ( yyP19^.NodeTypes.TreeName^.TreeName.Name  =   yyP18^.NodeTypes.TreeName^.TreeName.Name  ) THEN
  IF (Sets.IsEqual ( yyP19^.NodeTypes.Types ,   yyP18^.NodeTypes.Types ) ) THEN
(* line 317 "../src/opt.puma" *)
      RETURN TRUE;

  END;
  END;
  END;
  | Tree.UserType:
  IF (yyP18^.Kind = Tree.UserType) THEN
  IF ( yyP19^.UserType.Type  =   yyP18^.UserType.Type  ) THEN
(* line 320 "../src/opt.puma" *)
      RETURN TRUE;

  END;
  END;
  ELSE END;

  RETURN FALSE;
 END IsSameType;

PROCEDURE IsSameTest (yyP21: Tree.tTree; yyP20: Tree.tTree): BOOLEAN;

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN

  CASE yyP21^.Kind OF
  | Tree.TestKind:
  IF (yyP20^.Kind = Tree.TestKind) THEN
(* line 326 "../src/opt.puma" *)
   LOOP
     WITH yyP21^.TestKind DO
     WITH yyP20^.TestKind DO
(* line 330 "../src/opt.puma" *)
      IF NOT (IsSamePath (yyP21^.TestKind.Path, yyP20^.TestKind.Path)) THEN EXIT; END;
(* line 331 "../src/opt.puma" *)
      IF NOT (IsSameType (yyP21^.TestKind.TypeDesc, yyP20^.TestKind.TypeDesc)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
  | Tree.TestIsType:
  IF (yyP20^.Kind = Tree.TestIsType) THEN
(* line 326 "../src/opt.puma" *)
   LOOP
     WITH yyP21^.TestIsType DO
     WITH yyP20^.TestIsType DO
(* line 330 "../src/opt.puma" *)
      IF NOT (IsSamePath (yyP21^.TestIsType.Path, yyP20^.TestIsType.Path)) THEN EXIT; END;
(* line 331 "../src/opt.puma" *)
      IF NOT (IsSameType (yyP21^.TestIsType.TypeDesc, yyP20^.TestIsType.TypeDesc)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
  | Tree.TestNil:
  IF (yyP20^.Kind = Tree.TestNil) THEN
(* line 333 "../src/opt.puma" *)
   LOOP
     WITH yyP21^.TestNil DO
     WITH yyP20^.TestNil DO
(* line 334 "../src/opt.puma" *)
      IF NOT (IsSamePath (yyP21^.TestNil.Path, yyP20^.TestNil.Path)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
  | Tree.TestNonlin:
  IF (yyP20^.Kind = Tree.TestNonlin) THEN
(* line 336 "../src/opt.puma" *)
   LOOP
     WITH yyP21^.TestNonlin DO
     WITH yyP20^.TestNonlin DO
(* line 337 "../src/opt.puma" *)
      IF NOT (IsSamePath (yyP21^.TestNonlin.Path, yyP20^.TestNonlin.Path)) THEN EXIT; END;
(* line 338 "../src/opt.puma" *)
      IF NOT (IsSamePath (yyP21^.TestNonlin.Path2, yyP20^.TestNonlin.Path2)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
  ELSE END;

  RETURN FALSE;
 END IsSameTest;

PROCEDURE BuildTree (yyP23: Tree.tTree; yyP22: Tree.tTree; VAR yyP24: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 1: yyR1: RECORD
  yyV1: Tree.tTree;
  yyV2: Tree.tTree;
  END;
 END; END;
 BEGIN

  CASE yyP23^.Kind OF
  | Tree.Rule:
(* line 343 "../src/opt.puma" *)
    WITH yyTempo.yyR1 DO  
     WITH yyP23^.Rule DO
(* line 344 "../src/opt.puma" *)
      gRule := yyP23;
(* line 345 "../src/opt.puma" *)
      BuildTree2 (Tests, yyP22, yyV1);
(* line 346 "../src/opt.puma" *)
      UpdateChange (yyV1, gRule);
(* line 347 "../src/opt.puma" *)
      BuildTree (Next, yyV1, yyV2);
      yyP24 := yyV2;
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.NoRule:
(* line 349 "../src/opt.puma" *)
     WITH yyP23^.NoRule DO
      yyP24 := yyP22;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END BuildTree;

PROCEDURE BuildTree2 (t: Tree.tTree; d: Tree.tTree; VAR yyP25: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 1: yyR1: RECORD
  yyV1: Tree.tTree;
  END;
 | 2: yyR2: RECORD
  yyV1: Tree.tTree;
  END;
 | 3: yyR3: RECORD
  yyV1: Tree.tTree;
  END;
 | 4: yyR4: RECORD
  yyV1: Tree.tTree;
  END;
 | 6: yyR6: RECORD
  yyV1: Tree.tTree;
  END;
 | 7: yyR7: RECORD
  yyV1: Tree.tTree;
  END;
 END; END;
 BEGIN

  CASE t^.Kind OF
  | Tree.OneTest
  , Tree.TestKind
  , Tree.TestIsType
  , Tree.TestNil
  , Tree.TestNonlin
  , Tree.TestValue:

  CASE d^.Kind OF
  | Tree.NoDecision:
(* line 357 "../src/opt.puma" *)
    WITH yyTempo.yyR1 DO  
     WITH t^.OneTest DO
     WITH d^.NoDecision DO
(* line 358 "../src/opt.puma" *)
      BuildTree2 (t^.OneTest.Next, d, yyV1);
(* line 359 "../src/opt.puma" *)
      UpdateChange (yyV1, gRule);
       yyP25  :=  Tree .yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyP25 ) >=  Tree .yyPoolMaxPtr THEN  yyP25  :=  Tree .yyAlloc (); END; INC ( Tree .yyPoolFreePtr,  Tree .yyNodeSize [ Tree . Decision ]);  yyP25 ^.yyHead.yyMark := 0;  yyP25 ^.Kind :=  Tree . Decision ; 
      WITH yyP25^.Decision DO
      ThenPart := yyV1;
      ElsePart := d;
      OneTest := t;
      Cases := 0;
      IsUnchanged := TRUE;
      END;
      RETURN;
     END (* WITH *) ;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.Decision:
    WITH yyTempo.yyR2 DO 
  IF ( d^.Decision.IsUnchanged  =   (TRUE)  ) THEN
(* line 362 "../src/opt.puma" *)
   LOOP
     WITH t^.OneTest DO
     WITH d^.Decision DO
(* line 365 "../src/opt.puma" *)
      IF NOT (IsSameTest (t, d^.Decision.OneTest)) THEN EXIT; END;
(* line 366 "../src/opt.puma" *)
      IF NOT (NOT HasInterference (t, d^.Decision.ElsePart)) THEN EXIT; END;
(* line 367 "../src/opt.puma" *)
      BuildTree2 (t^.OneTest.Next, d^.Decision.ThenPart, yyV1);
(* line 369 "../src/opt.puma" *)
      d^.Decision.ThenPart := yyV1;
(* line 370 "../src/opt.puma" *)
      UpdateChange (yyV1, gRule);
      yyP25 := d;
      RETURN;
     END (* WITH *) ;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
    END (* WITH yyTempo.yyR ... *) ; 
(* line 372 "../src/opt.puma" *)
    WITH yyTempo.yyR3 DO  
     WITH t^.OneTest DO
     WITH d^.Decision DO
(* line 375 "../src/opt.puma" *)
      BuildTree2 (t, d^.Decision.ElsePart, yyV1);
(* line 376 "../src/opt.puma" *)
      d^.Decision.ElsePart := yyV1;
(* line 377 "../src/opt.puma" *)
      UpdateChange (yyV1, gRule);
      yyP25 := d;
      RETURN;
     END (* WITH *) ;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.Decided:
(* line 379 "../src/opt.puma" *)
    WITH yyTempo.yyR4 DO  
     WITH t^.OneTest DO
     WITH d^.Decided DO
(* line 382 "../src/opt.puma" *)
      BuildTree2 (t, d^.Decided.ElsePart, yyV1);
(* line 383 "../src/opt.puma" *)
      d^.Decided.ElsePart := yyV1;
(* line 384 "../src/opt.puma" *)
      UpdateChange (yyV1, gRule);
      yyP25 := d;
      RETURN;
     END (* WITH *) ;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  ELSE END;

  | Tree.NoTest:

  CASE d^.Kind OF
  | Tree.NoDecision:
(* line 386 "../src/opt.puma" *)
     WITH t^.NoTest DO
     WITH d^.NoDecision DO
       yyP25  :=  Tree .yyPoolFreePtr; IF SYSTEM.ADDRESS ( yyP25 ) >=  Tree .yyPoolMaxPtr THEN  yyP25  :=  Tree .yyAlloc (); END; INC ( Tree .yyPoolFreePtr,  Tree .yyNodeSize [ Tree . Decided ]);  yyP25 ^.yyHead.yyMark := 0;  yyP25 ^.Kind :=  Tree . Decided ; 
      WITH yyP25^.Decided DO
      ElsePart := d;
      Rule := gRule;
      END;
      RETURN;
     END (* WITH *) ;
     END (* WITH *) ;

  | Tree.Decision:
(* line 388 "../src/opt.puma" *)
    WITH yyTempo.yyR6 DO  
     WITH t^.NoTest DO
     WITH d^.Decision DO
(* line 391 "../src/opt.puma" *)
      BuildTree2 (t, d^.Decision.ElsePart, yyV1);
(* line 392 "../src/opt.puma" *)
      d^.Decision.ElsePart := yyV1;
      yyP25 := d;
      RETURN;
     END (* WITH *) ;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.Decided:
(* line 394 "../src/opt.puma" *)
    WITH yyTempo.yyR7 DO  
     WITH t^.NoTest DO
     WITH d^.Decided DO
(* line 395 "../src/opt.puma" *)
      BuildTree2 (t, d^.Decided.ElsePart, yyV1);
(* line 396 "../src/opt.puma" *)
      d^.Decided.ElsePart := yyV1;
      yyP25 := d;
      RETURN;
     END (* WITH *) ;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  ELSE END;

  ELSE END;

 END BuildTree2;

PROCEDURE HasInterference (yyP27: Tree.tTree; yyP26: Tree.tTree): BOOLEAN;

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF (yyP26^.Kind = Tree.Decided) THEN
(* line 404 "../src/opt.puma" *)
      RETURN TRUE;

  END;

  CASE yyP27^.Kind OF
  | Tree.TestKind:
  IF (yyP26^.Kind = Tree.Decision) THEN

  CASE yyP26^.Decision.OneTest^.Kind OF
  | Tree.TestKind:
(* line 405 "../src/opt.puma" *)
   LOOP
     WITH yyP27^.TestKind DO
     WITH TypeDesc^.NodeTypes DO
     WITH yyP26^.Decision DO
     WITH OneTest^.TestKind DO
     WITH TypeDesc^.NodeTypes DO
(* line 413 "../src/opt.puma" *)
      IF NOT (IsSamePath (yyP27^.TestKind.Path, yyP26^.Decision.OneTest^.TestKind.Path)) THEN EXIT; END;
(* line 414 "../src/opt.puma" *)
      IF NOT (NOT IsDisjoint (yyP27^.TestKind.TypeDesc^.NodeTypes.Types, yyP26^.Decision.OneTest^.TestKind.TypeDesc^.NodeTypes.Types)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.TestIsType:
(* line 405 "../src/opt.puma" *)
   LOOP
     WITH yyP27^.TestKind DO
     WITH TypeDesc^.NodeTypes DO
     WITH yyP26^.Decision DO
     WITH OneTest^.TestIsType DO
     WITH TypeDesc^.NodeTypes DO
(* line 413 "../src/opt.puma" *)
      IF NOT (IsSamePath (yyP27^.TestKind.Path, yyP26^.Decision.OneTest^.TestIsType.Path)) THEN EXIT; END;
(* line 414 "../src/opt.puma" *)
      IF NOT (NOT IsDisjoint (yyP27^.TestKind.TypeDesc^.NodeTypes.Types, yyP26^.Decision.OneTest^.TestIsType.TypeDesc^.NodeTypes.Types)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
   END (* LOOP *) ;

  ELSE END;

  END;
  | Tree.TestIsType:
  IF (yyP26^.Kind = Tree.Decision) THEN

  CASE yyP26^.Decision.OneTest^.Kind OF
  | Tree.TestKind:
(* line 405 "../src/opt.puma" *)
   LOOP
     WITH yyP27^.TestIsType DO
     WITH TypeDesc^.NodeTypes DO
     WITH yyP26^.Decision DO
     WITH OneTest^.TestKind DO
     WITH TypeDesc^.NodeTypes DO
(* line 413 "../src/opt.puma" *)
      IF NOT (IsSamePath (yyP27^.TestIsType.Path, yyP26^.Decision.OneTest^.TestKind.Path)) THEN EXIT; END;
(* line 414 "../src/opt.puma" *)
      IF NOT (NOT IsDisjoint (yyP27^.TestIsType.TypeDesc^.NodeTypes.Types, yyP26^.Decision.OneTest^.TestKind.TypeDesc^.NodeTypes.Types)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.TestIsType:
(* line 405 "../src/opt.puma" *)
   LOOP
     WITH yyP27^.TestIsType DO
     WITH TypeDesc^.NodeTypes DO
     WITH yyP26^.Decision DO
     WITH OneTest^.TestIsType DO
     WITH TypeDesc^.NodeTypes DO
(* line 413 "../src/opt.puma" *)
      IF NOT (IsSamePath (yyP27^.TestIsType.Path, yyP26^.Decision.OneTest^.TestIsType.Path)) THEN EXIT; END;
(* line 414 "../src/opt.puma" *)
      IF NOT (NOT IsDisjoint (yyP27^.TestIsType.TypeDesc^.NodeTypes.Types, yyP26^.Decision.OneTest^.TestIsType.TypeDesc^.NodeTypes.Types)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
   END (* LOOP *) ;

  ELSE END;

  END;
  ELSE END;

  IF (yyP26^.Kind = Tree.Decision) THEN
(* line 416 "../src/opt.puma" *)
   LOOP
     WITH yyP26^.Decision DO
(* line 416 "../src/opt.puma" *)
      IF NOT (HasInterference (yyP27, yyP26^.Decision.ElsePart)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
  RETURN FALSE;
 END HasInterference;

PROCEDURE UpdateChange (yyP29: Tree.tTree; yyP28: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF (yyP29^.Kind = Tree.Decision) THEN

  CASE yyP29^.Decision.OneTest^.Kind OF
  | Tree.TestKind:
  IF ( yyP28^.Rule.HasExit  =   (TRUE)  ) THEN
  IF ( yyP28^.Rule.HasAssign  =   (TRUE)  ) THEN
(* line 421 "../src/opt.puma" *)
   LOOP
     WITH yyP29^.Decision DO
     WITH OneTest^.TestKind DO
     WITH yyP28^.Rule DO
(* line 425 "../src/opt.puma" *)
      IF NOT (IsChanged (yyP29^.Decision.OneTest^.TestKind.Path, yyP28^.Rule.Statements)) THEN EXIT; END;
(* line 426 "../src/opt.puma" *)
      yyP29^.Decision.IsUnchanged := FALSE;
      RETURN;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
  END;
  | Tree.TestIsType:
  IF ( yyP28^.Rule.HasExit  =   (TRUE)  ) THEN
  IF ( yyP28^.Rule.HasAssign  =   (TRUE)  ) THEN
(* line 421 "../src/opt.puma" *)
   LOOP
     WITH yyP29^.Decision DO
     WITH OneTest^.TestIsType DO
     WITH yyP28^.Rule DO
(* line 425 "../src/opt.puma" *)
      IF NOT (IsChanged (yyP29^.Decision.OneTest^.TestIsType.Path, yyP28^.Rule.Statements)) THEN EXIT; END;
(* line 426 "../src/opt.puma" *)
      yyP29^.Decision.IsUnchanged := FALSE;
      RETURN;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
  END;
  ELSE END;

  END;
 END UpdateChange;

PROCEDURE IsChanged (yyP31: Tree.tTree; yyP30: Tree.tTree): BOOLEAN;

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF (yyP30^.Kind = Tree.Assignment) THEN
(* line 432 "../src/opt.puma" *)
   LOOP
     WITH yyP30^.Assignment DO
(* line 433 "../src/opt.puma" *)
      IF NOT (yyP30^.Assignment.Object # NIL) THEN EXIT; END;
(* line 433 "../src/opt.puma" *)
      IF NOT (IsSamePath (yyP31, yyP30^.Assignment.Object ^ . Formal . Path)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
  IF Tree.IsType (yyP30, Tree.Statement) THEN
(* line 434 "../src/opt.puma" *)
   LOOP
     WITH yyP30^.Statement DO
(* line 434 "../src/opt.puma" *)
      IF NOT (IsChanged (yyP31, yyP30^.Statement.Next)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
  RETURN FALSE;
 END IsChanged;

PROCEDURE FindCases (yyP32: Tree.tTree; VAR yyP35: Tree.tTree; VAR yyP34: SHORTCARD; VAR yyP33: tSet);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 1: yyR1: RECORD
  yyV1: Tree.tTree;
  yyV2: SHORTCARD;
  yyV3: tSet;
  yyV4: Tree.tTree;
  yyV5: SHORTCARD;
  yyV6: tSet;
  k: SHORTCARD;
  s: tSet;
  END;
 | 2: yyR2: RECORD
  yyV1: Tree.tTree;
  yyV2: SHORTCARD;
  yyV3: tSet;
  yyV4: Tree.tTree;
  yyV5: SHORTCARD;
  yyV6: tSet;
  k: SHORTCARD;
  s: tSet;
  END;
 | 3: yyR3: RECORD
  yyV1: Tree.tTree;
  yyV2: SHORTCARD;
  yyV3: tSet;
  yyV4: Tree.tTree;
  yyV5: SHORTCARD;
  yyV6: tSet;
  END;
 | 4: yyR4: RECORD
  yyV1: Tree.tTree;
  yyV2: SHORTCARD;
  yyV3: tSet;
  END;
 END; END;
 BEGIN

  CASE yyP32^.Kind OF
  | Tree.Decision:

  CASE yyP32^.Decision.OneTest^.Kind OF
  | Tree.TestKind:
(* line 442 "../src/opt.puma" *)
    WITH yyTempo.yyR1 DO  
     WITH yyP32^.Decision DO
     WITH OneTest^.TestKind DO
     WITH TypeDesc^.NodeTypes DO
     WITH TreeName^.TreeName DO
(* line 471 "../src/opt.puma" *)
      FindCases (yyP32^.Decision.ThenPart, yyV1, yyV2, yyV3);
(* line 472 "../src/opt.puma" *)
      MarkCases (yyP32^.Decision.ThenPart, yyV2, yyV3);
(* line 473 "../src/opt.puma" *)
      FindCases (yyP32^.Decision.ElsePart, yyV4, yyV5, yyV6);
(* line 474 "../src/opt.puma" *)
      ;
(* line 475 "../src/opt.puma" *)
      ;
(* line 476 "../src/opt.puma" *)
      
       IF yyV5 = 0 THEN
          k := 1;
          MakeSet (s, yyP32^.Decision.OneTest^.TestKind.TypeDesc^.NodeTypes.TreeName^.TreeName.ClassCount);
          Assign (s, yyP32^.Decision.OneTest^.TestKind.TypeDesc^.NodeTypes.Types);
       ELSIF IsSamePath (yyP32^.Decision.OneTest^.TestKind.Path, yyV4) AND IsDisjoint (yyV6, yyP32^.Decision.OneTest^.TestKind.TypeDesc^.NodeTypes.Types) THEN
          k := yyV5 + 1;
          s := yyV6;
          Union (s, yyP32^.Decision.OneTest^.TestKind.TypeDesc^.NodeTypes.Types);
       ELSE
          MarkCases (yyP32^.Decision.ElsePart, yyV5, yyV6);
          k := 1;
          MakeSet (s, yyP32^.Decision.OneTest^.TestKind.TypeDesc^.NodeTypes.TreeName^.TreeName.ClassCount);
          Assign (s, yyP32^.Decision.OneTest^.TestKind.TypeDesc^.NodeTypes.Types);
       END;
    ;
      yyP35 := yyP32^.Decision.OneTest^.TestKind.Path;
      yyP34 := k;
      yyP33 := s;
      RETURN;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.TestIsType:
(* line 442 "../src/opt.puma" *)
    WITH yyTempo.yyR2 DO  
     WITH yyP32^.Decision DO
     WITH OneTest^.TestIsType DO
     WITH TypeDesc^.NodeTypes DO
     WITH TreeName^.TreeName DO
(* line 471 "../src/opt.puma" *)
      FindCases (yyP32^.Decision.ThenPart, yyV1, yyV2, yyV3);
(* line 472 "../src/opt.puma" *)
      MarkCases (yyP32^.Decision.ThenPart, yyV2, yyV3);
(* line 473 "../src/opt.puma" *)
      FindCases (yyP32^.Decision.ElsePart, yyV4, yyV5, yyV6);
(* line 474 "../src/opt.puma" *)
      ;
(* line 475 "../src/opt.puma" *)
      ;
(* line 476 "../src/opt.puma" *)
      
       IF yyV5 = 0 THEN
          k := 1;
          MakeSet (s, yyP32^.Decision.OneTest^.TestIsType.TypeDesc^.NodeTypes.TreeName^.TreeName.ClassCount);
          Assign (s, yyP32^.Decision.OneTest^.TestIsType.TypeDesc^.NodeTypes.Types);
       ELSIF IsSamePath (yyP32^.Decision.OneTest^.TestIsType.Path, yyV4) AND IsDisjoint (yyV6, yyP32^.Decision.OneTest^.TestIsType.TypeDesc^.NodeTypes.Types) THEN
          k := yyV5 + 1;
          s := yyV6;
          Union (s, yyP32^.Decision.OneTest^.TestIsType.TypeDesc^.NodeTypes.Types);
       ELSE
          MarkCases (yyP32^.Decision.ElsePart, yyV5, yyV6);
          k := 1;
          MakeSet (s, yyP32^.Decision.OneTest^.TestIsType.TypeDesc^.NodeTypes.TreeName^.TreeName.ClassCount);
          Assign (s, yyP32^.Decision.OneTest^.TestIsType.TypeDesc^.NodeTypes.Types);
       END;
    ;
      yyP35 := yyP32^.Decision.OneTest^.TestIsType.Path;
      yyP34 := k;
      yyP33 := s;
      RETURN;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  ELSE END;

(* line 493 "../src/opt.puma" *)
    WITH yyTempo.yyR3 DO  
     WITH yyP32^.Decision DO
(* line 494 "../src/opt.puma" *)
      FindCases (yyP32^.Decision.ThenPart, yyV1, yyV2, yyV3);
(* line 495 "../src/opt.puma" *)
      MarkCases (yyP32^.Decision.ThenPart, yyV2, yyV3);
(* line 496 "../src/opt.puma" *)
      FindCases (yyP32^.Decision.ElsePart, yyV4, yyV5, yyV6);
(* line 497 "../src/opt.puma" *)
      MarkCases (yyP32^.Decision.ElsePart, yyV5, yyV6);
       yyP35  := NIL; 
      yyP34 := 0;
       
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.Decided:
(* line 499 "../src/opt.puma" *)
    WITH yyTempo.yyR4 DO  
     WITH yyP32^.Decided DO
(* line 500 "../src/opt.puma" *)
      FindCases (yyP32^.Decided.ElsePart, yyV1, yyV2, yyV3);
(* line 501 "../src/opt.puma" *)
      MarkCases (yyP32^.Decided.ElsePart, yyV2, yyV3);
       yyP35  := NIL; 
      yyP34 := 0;
       
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.NoDecision:
(* line 503 "../src/opt.puma" *)
     WITH yyP32^.NoDecision DO
       yyP35  := NIL; 
      yyP34 := 0;
       
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END FindCases;

PROCEDURE MarkCases (yyP38: Tree.tTree; yyP37: SHORTCARD; yyP36: tSet);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF (yyP38^.Kind = Tree.Decision) THEN
(* line 507 "../src/opt.puma" *)
   LOOP
     WITH yyP38^.Decision DO
(* line 508 "../src/opt.puma" *)
      IF NOT (yyP37 >= (MinCases)) THEN EXIT; END;
(* line 508 "../src/opt.puma" *)
      yyP38^.Decision.Cases := yyP37;
(* line 508 "../src/opt.puma" *)
      ReleaseSet (yyP36);
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
 END MarkCases;

PROCEDURE ElimDeadTests (yyP42: Tree.tTree; yyP41: Tree.tTree; yyP40: BOOLEAN; yyP39: tSet);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 1: yyR1: RECORD
  s: tSet;
  yyV1: Tree.tTree;
  yyV2: tSet;
  END;
 | 2: yyR2: RECORD
  s: tSet;
  yyV1: Tree.tTree;
  yyV2: tSet;
  END;
 | 3: yyR3: RECORD
  LTypes: tSet;
  s2: tSet;
  yyV1: Tree.tTree;
  yyV2: tSet;
  END;
 | 4: yyR4: RECORD
  LTypes: tSet;
  s2: tSet;
  yyV1: Tree.tTree;
  yyV2: tSet;
  END;
 | 5: yyR5: RECORD
  yyV1: Tree.tTree;
  yyV2: tSet;
  yyV3: Tree.tTree;
  yyV4: tSet;
  END;
 | 6: yyR6: RECORD
  yyV1: Tree.tTree;
  yyV2: tSet;
  END;
 END; END;
 BEGIN

  CASE yyP42^.Kind OF
  | Tree.Decision:

  CASE yyP42^.Decision.OneTest^.Kind OF
  | Tree.TestKind:
    WITH yyTempo.yyR1 DO 
  IF ( yyP40  =   (FALSE)  ) THEN
(* line 512 "../src/opt.puma" *)
     WITH yyP42^.Decision DO
     WITH OneTest^.TestKind DO
     WITH TypeDesc^.NodeTypes DO
     WITH TreeName^.TreeName DO
(* line 517 "../src/opt.puma" *)
      ;
(* line 518 "../src/opt.puma" *)
        MakeSet (s, yyP42^.Decision.OneTest^.TestKind.TypeDesc^.NodeTypes.TreeName^.TreeName.ClassCount); IF IsDeadEnd (yyP42^.Decision.ThenPart) THEN Assign (s, yyP42^.Decision.OneTest^.TestKind.TypeDesc^.NodeTypes.Types); END; ;
(* line 519 "../src/opt.puma" *)
      ElimDeadTests (yyP42^.Decision.ElsePart, yyP42^.Decision.OneTest^.TestKind.Path, (TRUE), s);
(* line 520 "../src/opt.puma" *)
      ElimDeadTests (yyP42^.Decision.ThenPart, yyV1, (FALSE), yyV2);
      RETURN;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;

  END;
    END (* WITH yyTempo.yyR ... *) ; 
(* line 525 "../src/opt.puma" *)
    WITH yyTempo.yyR3 DO  
     WITH yyP42^.Decision DO
     WITH OneTest^.TestKind DO
     WITH TypeDesc^.NodeTypes DO
     WITH TreeName^.TreeName DO
(* line 530 "../src/opt.puma" *)
      ;
(* line 531 "../src/opt.puma" *)
      ;
(* line 532 "../src/opt.puma" *)
      
      s2 := yyP39;
      IF IsSamePath (yyP42^.Decision.OneTest^.TestKind.Path, yyP41) THEN
         IF NOT IsDisjoint (yyP42^.Decision.OneTest^.TestKind.TypeDesc^.NodeTypes.Types, yyP39) THEN
            MakeSet (LTypes, yyP42^.Decision.OneTest^.TestKind.TypeDesc^.NodeTypes.TreeName^.TreeName.ClassCount);
            Assign (LTypes, yyP42^.Decision.OneTest^.TestKind.TypeDesc^.NodeTypes.Types);
            Difference (LTypes, yyP39);
            yyP42^.Decision.OneTest := mTestIsType (yyP42^.Decision.OneTest^.TestKind.Next, yyP42^.Decision.OneTest^.TestKind.Path, mNodeTypes (yyP42^.Decision.OneTest^.TestKind.TypeDesc^.NodeTypes.TreeName, LTypes), yyP42^.Decision.OneTest^.TestKind.Name);
         END;
      ELSE
         AssignEmpty (s2);
      END;
      IF IsDeadEnd (yyP42^.Decision.ThenPart) THEN Union (s2, yyP42^.Decision.OneTest^.TestKind.TypeDesc^.NodeTypes.Types); END;
   
   ;
(* line 561 "../src/opt.puma" *)
      ElimDeadTests (yyP42^.Decision.ElsePart, yyP42^.Decision.OneTest^.TestKind.Path, (TRUE), s2);
(* line 562 "../src/opt.puma" *)
      ElimDeadTests (yyP42^.Decision.ThenPart, yyV1, (FALSE), yyV2);
      RETURN;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.TestIsType:
    WITH yyTempo.yyR2 DO 
  IF ( yyP40  =   (FALSE)  ) THEN
(* line 512 "../src/opt.puma" *)
     WITH yyP42^.Decision DO
     WITH OneTest^.TestIsType DO
     WITH TypeDesc^.NodeTypes DO
     WITH TreeName^.TreeName DO
(* line 517 "../src/opt.puma" *)
      ;
(* line 518 "../src/opt.puma" *)
        MakeSet (s, yyP42^.Decision.OneTest^.TestIsType.TypeDesc^.NodeTypes.TreeName^.TreeName.ClassCount); IF IsDeadEnd (yyP42^.Decision.ThenPart) THEN Assign (s, yyP42^.Decision.OneTest^.TestIsType.TypeDesc^.NodeTypes.Types); END; ;
(* line 519 "../src/opt.puma" *)
      ElimDeadTests (yyP42^.Decision.ElsePart, yyP42^.Decision.OneTest^.TestIsType.Path, (TRUE), s);
(* line 520 "../src/opt.puma" *)
      ElimDeadTests (yyP42^.Decision.ThenPart, yyV1, (FALSE), yyV2);
      RETURN;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;

  END;
    END (* WITH yyTempo.yyR ... *) ; 
(* line 525 "../src/opt.puma" *)
    WITH yyTempo.yyR4 DO  
     WITH yyP42^.Decision DO
     WITH OneTest^.TestIsType DO
     WITH TypeDesc^.NodeTypes DO
     WITH TreeName^.TreeName DO
(* line 530 "../src/opt.puma" *)
      ;
(* line 531 "../src/opt.puma" *)
      ;
(* line 532 "../src/opt.puma" *)
      
      s2 := yyP39;
      IF IsSamePath (yyP42^.Decision.OneTest^.TestIsType.Path, yyP41) THEN
         IF NOT IsDisjoint (yyP42^.Decision.OneTest^.TestIsType.TypeDesc^.NodeTypes.Types, yyP39) THEN
            MakeSet (LTypes, yyP42^.Decision.OneTest^.TestIsType.TypeDesc^.NodeTypes.TreeName^.TreeName.ClassCount);
            Assign (LTypes, yyP42^.Decision.OneTest^.TestIsType.TypeDesc^.NodeTypes.Types);
            Difference (LTypes, yyP39);
            yyP42^.Decision.OneTest := mTestIsType (yyP42^.Decision.OneTest^.TestIsType.Next, yyP42^.Decision.OneTest^.TestIsType.Path, mNodeTypes (yyP42^.Decision.OneTest^.TestIsType.TypeDesc^.NodeTypes.TreeName, LTypes), yyP42^.Decision.OneTest^.TestIsType.Name);
         END;
      ELSE
         AssignEmpty (s2);
      END;
      IF IsDeadEnd (yyP42^.Decision.ThenPart) THEN Union (s2, yyP42^.Decision.OneTest^.TestIsType.TypeDesc^.NodeTypes.Types); END;
   
   ;
(* line 561 "../src/opt.puma" *)
      ElimDeadTests (yyP42^.Decision.ElsePart, yyP42^.Decision.OneTest^.TestIsType.Path, (TRUE), s2);
(* line 562 "../src/opt.puma" *)
      ElimDeadTests (yyP42^.Decision.ThenPart, yyV1, (FALSE), yyV2);
      RETURN;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  ELSE END;

(* line 564 "../src/opt.puma" *)
    WITH yyTempo.yyR5 DO  
     WITH yyP42^.Decision DO
(* line 565 "../src/opt.puma" *)
        IF yyP40 THEN ReleaseSet (yyP39); END; ;
(* line 566 "../src/opt.puma" *)
      ElimDeadTests (yyP42^.Decision.ElsePart, yyV1, (FALSE), yyV2);
(* line 567 "../src/opt.puma" *)
      ElimDeadTests (yyP42^.Decision.ThenPart, yyV3, (FALSE), yyV4);
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.Decided:
(* line 569 "../src/opt.puma" *)
    WITH yyTempo.yyR6 DO  
     WITH yyP42^.Decided DO
     WITH Rule^.Rule DO
(* line 570 "../src/opt.puma" *)
        IF yyP40 THEN ReleaseSet (yyP39); END; ;
(* line 571 "../src/opt.puma" *)
        IF NOT yyP42^.Decided.Rule^.Rule.HasExit THEN ReportWarning (yyP42^.Decided.ElsePart); END; ;
(* line 572 "../src/opt.puma" *)
      ElimDeadTests (yyP42^.Decided.ElsePart, yyV1, (FALSE), yyV2);
      RETURN;
     END (* WITH *) ;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.NoDecision:
  IF ( yyP40  =   (TRUE)  ) THEN
(* line 574 "../src/opt.puma" *)
     WITH yyP42^.NoDecision DO
(* line 575 "../src/opt.puma" *)
      ReleaseSet (yyP39);
      RETURN;
     END (* WITH *) ;

  END;
  ELSE END;

 END ElimDeadTests;

PROCEDURE IsDeadEnd (yyP43: Tree.tTree): BOOLEAN;

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF (yyP43^.Kind = Tree.Decided) THEN
(* line 580 "../src/opt.puma" *)
   LOOP
     WITH yyP43^.Decided DO
     WITH Rule^.Rule DO
(* line 580 "../src/opt.puma" *)
      IF NOT (NOT yyP43^.Decided.Rule^.Rule.HasExit OR IsDeadEnd (yyP43^.Decided.ElsePart)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
  RETURN FALSE;
 END IsDeadEnd;

PROCEDURE ReportWarning (yyP44: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN

  CASE yyP44^.Kind OF
  | Tree.Decided:
(* line 584 "../src/opt.puma" *)
     WITH yyP44^.Decided DO
     WITH Rule^.Rule DO
(* line 585 "../src/opt.puma" *)
      Warning ("unreachable code", yyP44^.Decided.Rule^.Rule.Line);
(* line 586 "../src/opt.puma" *)
      ReportWarning (yyP44^.Decided.ElsePart);
      RETURN;
     END (* WITH *) ;
     END (* WITH *) ;

  | Tree.Decision:
(* line 588 "../src/opt.puma" *)
     WITH yyP44^.Decision DO
(* line 589 "../src/opt.puma" *)
      ReportWarning (yyP44^.Decision.ThenPart);
(* line 590 "../src/opt.puma" *)
      ReportWarning (yyP44^.Decision.ElsePart);
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ReportWarning;

PROCEDURE BeginOptimize;
 BEGIN

 END BeginOptimize;

PROCEDURE CloseOptimize;
 BEGIN

 END CloseOptimize;

PROCEDURE yyExit;
 BEGIN
  IO.CloseIO; System.Exit (1);
 END yyExit;

BEGIN
 yyf   := IO.StdOutput;
 Exit  := yyExit;
 BeginOptimize;
END Optimize.

