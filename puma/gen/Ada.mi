
(* This file was mechanically generated by puma. *)

IMPLEMENTATION MODULE Ada;








IMPORT SYSTEM, System, IO, Tree;
(* line 42 "" *)


FROM Positions  IMPORT tPosition;
FROM IO         IMPORT StdOutput, WriteS, WriteNl;
FROM StringMem  IMPORT WriteString;
FROM Strings    IMPORT tString, IntToString, ArrayToString, Concatenate;
FROM Idents     IMPORT tIdent, NoIdent, MakeIdent, GetString;
FROM Texts      IMPORT WriteText;
FROM Sets       IMPORT IsElement, IsNotEqual, Minimum, Maximum, IsEmpty;
FROM Semantics  IMPORT IdentifyVar, LookupClass;
FROM Optimize   IMPORT NeedsTempo, NeedsMatch, NeedsNoFinale, GetRule;
FROM Tree       IMPORT NoTree, tTree, Options, f, SourceFile, WI, WN;
FROM Assertions IMPORT Assert, AssertPos, CantHappen, CantHappenPos; 

VAR
   RoutineKind  : (kProcedure, kFunction, kPredicate);
   i, j         : CARDINAL;
   ListCount    , 
   WithCount    : INTEGER;
   rule         ,
   TheClass     ,
   InFormals    ,
   OutFormals   ,
   ReturnFormals,
   Decls        : tTree;
   TheName      : tIdent;
   TemposDone   : BOOLEAN;

PROCEDURE WriteLine (Line: tPosition);
   BEGIN
      IF Line.Line # 0 THEN
         WriteS (f, "-- line "); WN (Line.Line); WriteS (f, ', file "'); WriteS (f, SourceFile); WriteS (f, '" '); WriteNl (f);
      END;
   END WriteLine;

PROCEDURE Match (t, Formals: tTree);
   VAR TreeName : tIdent;
   VAR Pattern  : tTree;
   BEGIN
      IF (t^.Kind = Tree.NoPattern) 
         OR NOT Tree . IsType ( Formals , Tree . Formal ) 
      THEN RETURN; 
      END;
      Pattern := t^.OnePattern.Pattern;
      CASE Pattern^.Kind OF
      | Tree.Decompose: WITH Pattern^.Decompose DO
            TreeName := Object^.Class.TypeDesc^.NodeTypes.TreeName^.TreeName.Name;
            IF (Formals^.Formal.TypeDesc^.Kind = Tree.UserType) OR
               IsNotEqual 
                 ( Object^.Class.TypeDesc^.NodeTypes.Types
                 , Formals^.Formal.TypeDesc^.NodeTypes.Types
                 ) 
            THEN
               IF Object^.Class.Extensions^.Kind = Tree.NoClass THEN    (* Low ? *)
                  WriteS (f, "        IF ("); WritePath ( Path ); WriteS (f, ".ALL.Kind /= "); 
               ELSE
                  WriteS (f, "        IF NOT "); WI (TreeName); WriteS (f, ".IsType ("); WritePath ( Path ); WriteS (f, ", "); 
               END;
               WI (TreeName); WriteS (f, " . "); WI (Object^.Class.Name); WriteS (f, ") THEN EXIT ; END IF ;"); WriteNl (f);
            END;
            Match (Patterns, Object^.Class.Formals);
         END;

      | Tree.VarDef: WITH Pattern^.VarDef DO
            IF Object # NoTree THEN
               WITH Object^.Formal DO
                  WriteS (f, "        IF NOT (equal"); PackBody ( TypeDesc ); WriteS (f, " ("); WritePath  ( Path );
                  WriteS (f, ", "); WritePath ( Pattern^.VarDef.Path ); WriteS (f, ")) THEN EXIT ; END IF ;"); WriteNl (f);
               END;
            END;
         END;

      | Tree.NilTest:
         WriteS (f, "        IF "); WritePath ( Pattern^.NilTest.Path ); WriteS (f, " /= NULL THEN EXIT ; END IF ;"); WriteNl (f);

      | Tree.DontCare1Explicit , Tree.DontCare1Internal :
      | Tree.DontCareExplicit , Tree.DontCareInternal : RETURN;

      | Tree.Value: WITH Pattern^.Value DO
            AssignTempo (Expr);
            WriteS (f, "        IF NOT (equal"); PackBody (Formals^.Formal.TypeDesc);
            WriteS (f, " ("); WritePath ( Path ); WriteS (f, ", "); Expression (Expr); WriteS (f, ")) THEN EXIT ; END IF ;"); WriteNl (f);
            MatchExpr (Expr);
         END;
      END;
      Match (t^.OnePattern.Next, Formals^.Formal.Next);
   END Match;

PROCEDURE MatchExprs (t: tTree);
   BEGIN
      IF t^.Kind = Tree.NoExpr THEN RETURN; END;
      IF Tree . IsType ( t^.OneExpr.Expr , Tree.DontCare ) THEN RETURN; END;
      MatchExpr (t^.OneExpr.Expr);
      MatchExprs (t^.OneExpr.Next);
   END MatchExprs;

PROCEDURE MatchExpr (t: tTree);
   BEGIN
      CASE t^.Kind OF
      | Tree.Compose:
         MatchExprs (t^.Compose.Exprs);

      | Tree.VarUse     :
      | Tree.Nil        :
      | Tree.DontCare1Explicit , Tree.DontCare1Internal :
      | Tree.TargetExpr :
      | Tree.StringExpr :
      | Tree.AttrDesc   :

      | Tree.Call       : WITH t^.Call DO
            MatchExpr (Expr);
            MatchExprs (Exprs);
            IF Object # NoTree THEN
               Match (Patterns, Object^.Routine.OutForm);
            END;
         END;

      | Tree.Binary     : WITH t^.Binary DO
            MatchExpr (Lop);
            MatchExpr (Rop);
         END;

      | Tree.PreOperator, Tree.PostOperator     :
         MatchExpr (t^.PreOperator.Expr);

      | Tree.Index      :
         MatchExpr (t^.Index.Expr);
         MatchExprs (t^.Index.Exprs);

      | Tree.Parents    :
         MatchExpr (t^.Parents.Expr);
      END;
   END MatchExpr;

PROCEDURE AssignTempos (t: tTree);
   BEGIN
      IF t^.Kind = Tree.NoExpr THEN RETURN; END;
      IF Tree . IsType ( t^.OneExpr.Expr , Tree.DontCare ) THEN RETURN; END;
      AssignTempo (t^.OneExpr.Expr);
      AssignTempos (t^.OneExpr.Next);
   END AssignTempos;

PROCEDURE AssignTempo (t: tTree);
   VAR TreeName : tIdent;
   BEGIN
      CASE t^.Kind OF
      | Tree.Compose: WITH t^.Compose DO
            TreeName := Object^.Class.TypeDesc^.NodeTypes.TreeName^.TreeName.Name;
            WriteS (f, "      "); WI ( Tempo ) ; WriteS (f, " := NEW "); WI ( TreeName ) ; 
              WriteS (f, " . yyNode ( "); WI ( Object ^ . Class . Name ) ; WriteS (f, " ) ; "); WriteNl (f);
            AssignSubFormals 
              (Exprs, Object^.Class.Formals , Tempo , Object^.Class.Name );
         END;

      | Tree.VarUse     :
      | Tree.Nil        :
      | Tree.DontCare1Explicit , Tree.DontCare1Internal :
      | Tree.TargetExpr :
      | Tree.StringExpr :
      | Tree.AttrDesc   :

      | Tree.Call       : WITH t^.Call DO
            AssignTempo (Expr);
            AssignTempos (Exprs);
         END;

      | Tree.Binary     : WITH t^.Binary DO
            AssignTempo (Lop);
            AssignTempo (Rop);
         END;

      | Tree.PreOperator, Tree.PostOperator     :
         AssignTempo (t^.PreOperator.Expr);

      | Tree.Index      :
         AssignTempo (t^.Index.Expr);
         AssignTempos (t^.Index.Exprs);

      | Tree.Parents    :
         AssignTempo (t^.Parents.Expr);
      END;
   END AssignTempo;

(* Generate assignments to a formals list *) 

PROCEDURE MakeWith (): tIdent;
   VAR String1, String2 : tString;
   BEGIN
      INC (WithCount);
      ArrayToString ("yyW", String1);
      IntToString (WithCount, String2);
      Concatenate (String1, String2);
      RETURN MakeIdent (String1);
   END MakeWith;

PROCEDURE AssignFormals (t, Formals: tTree );
   BEGIN
      IF (t^.Kind = Tree.NoExpr) 
         OR NOT Tree . IsType ( Formals , Tree . Formal ) 
      THEN RETURN; 
      END;
      IF Tree . IsType ( t^.OneExpr.Expr , Tree.DontCare ) THEN
         BeginFormals (Formals );
         RETURN;
      END;
      AssignFormal (t^.OneExpr.Expr, Formals );
(* c.puma has a call on MatchExpr here *) 
      AssignFormals (t^.OneExpr.Next, Formals^.Formal.Next );
   END AssignFormals;

PROCEDURE AssignFormal (t, Formals: tTree );
   VAR TreeName , With : tIdent;
   BEGIN
      IF t^.Kind = Tree.Compose THEN
         WITH t^.Compose DO
            TreeName := Object^.Class.TypeDesc^.NodeTypes.TreeName^.TreeName.Name;
            With := MakeWith ( ) ; 
            WriteS (f, "      DECLARE -- Compose "); WriteNl (f);
            WriteS (f, "        "); WI ( With ) ; WriteS (f, " : "); WI ( TreeName ) ; WriteS (f, " . t"); WI ( TreeName ) ; 
            WriteS (f, "            := NEW "); WI ( TreeName ) ; 
                         WriteS (f, " . yyNode ( "); WI ( Object ^ . Class . Name ) ; WriteS (f, " ) ; "); WriteNl (f);
            WriteS (f, "      BEGIN -- DECLARE Compose "); 
            WriteS (f, "        "); WI ( Formals^.Formal.Name ) ; WriteS (f, " := "); WI ( With ) ; WriteS (f, " ; "); WriteNl (f);

            AssignSubFormals (Exprs, Object^.Class.Formals, With , Object^.Class.Name);
            WriteS (f, "      END ; -- DECLARE Compose "); 
         END;
      ELSE
         AssignTempo (t);
      END;
      CASE t^.Kind OF
      | Tree.VarUse, Tree.Nil, Tree.Call, Tree.Binary, Tree.PreOperator,
        Tree.PostOperator, Tree.Index, Tree.Parents, Tree.TargetExpr, Tree.StringExpr,
        Tree.AttrDesc:
         WriteS (f, "      "); WI (Formals^.Formal.Name); WriteS (f, " := "); Expression (t); WriteS (f, ";"); WriteNl (f);
      | Tree.DontCare1Explicit , Tree.DontCare1Internal :
         WriteS (f, "begin"); PackBody (Formals^.Formal.TypeDesc); 
           WriteS (f, " ( "); WI (Formals^.Formal.Name); WriteS (f, " ) ; "); WriteNl (f);
      ELSE
      END;

   END AssignFormal;

PROCEDURE BeginFormals (Formals: tTree );
   BEGIN
      IF Tree . IsType ( Formals , Tree . Formal ) 
      THEN
         WITH Formals^.Formal DO
            WriteS (f, "      begin"); PackBody (TypeDesc); WriteS (f, " ( "); WI (Name); WriteS (f, " ) ; "); 
            BeginFormals ( Next );
         END;
      END;
   END BeginFormals;

PROCEDURE AssignSubFormals (t, Formals: tTree ; PrevWith , Composer : tIdent );
   BEGIN
      IF (t^.Kind = Tree.NoExpr) 
         OR NOT Tree . IsType ( Formals , Tree . Formal ) 
      THEN RETURN; 
      END;
      IF Tree . IsType ( t^.OneExpr.Expr , Tree.DontCare ) THEN
         BeginSubFormals (Formals , PrevWith , Composer );
         RETURN;
      END;
      AssignSubFormal (t^.OneExpr.Expr, Formals , PrevWith , Composer );
      AssignSubFormals (t^.OneExpr.Next, Formals^.Formal.Next , PrevWith , Composer );
   END AssignSubFormals;

PROCEDURE AssignSubFormal (t, Formals: tTree ; PrevWith , Composer : tIdent );
   VAR TreeName , With : tIdent;
   BEGIN
      IF t^.Kind = Tree.Compose THEN
         WITH t^.Compose DO
            TreeName := Object^.Class.TypeDesc^.NodeTypes.TreeName^.TreeName.Name;
            With := MakeWith ( ) ; 
            WriteS (f, "      DECLARE -- Subcompose "); WriteNl (f);
            WriteS (f, "        "); WI ( With ) ; WriteS (f, " : "); WI ( TreeName ) ; WriteS (f, " . t"); WI ( TreeName ) ; 
            WriteS (f, "            := NEW "); WI ( TreeName ) ; 
                         WriteS (f, " . yyNode ( "); WI ( Object ^ . Class . Name ) ; WriteS (f, " ) ; "); WriteNl (f);
            WriteS (f, "      BEGIN -- DECLARE Subcompose "); 
            WriteS (f, "        "); WI ( PrevWith ) ; WriteS (f, " . ALL . "); WI ( Composer ) ; 
               WriteS (f, " . "); WI ( Formals ^ . Formal . Name ) ; WriteS (f, " := "); WI ( With ) ; WriteS (f, " ; "); WriteNl (f);

            AssignSubFormals (Exprs, Object^.Class.Formals, With , Object^.Class.Name);
            WriteS (f, "      END ; -- DECLARE Subcompose "); 
         END;
      ELSE
         AssignTempo (t);
      END;
      CASE t^.Kind OF
      | Tree.VarUse, Tree.Nil, Tree.Call, Tree.Binary, Tree.PreOperator,
        Tree.PostOperator, Tree.Index, Tree.Parents, Tree.TargetExpr, Tree.StringExpr,
        Tree.AttrDesc:
         WriteS (f, "        "); WI ( PrevWith ) ; WriteS (f, " . ALL . "); WI ( Composer ) ; 
             WriteS (f, " . "); WI ( Formals ^ . Formal . Name ) ; WriteS (f, " := "); Expression (t); WriteS (f, " ; "); WriteNl (f);
      | Tree.DontCare1Explicit , Tree.DontCare1Internal :
         WriteS (f, "begin"); PackBody (Formals^.Formal.TypeDesc); 
            WriteS (f, " ( "); WI ( PrevWith ) ; WriteS (f, " . ALL . "); WI ( Composer ) ; 
             WriteS (f, " . "); WI ( Formals ^ . Formal . Name ) ; WriteS (f, " ) ; "); WriteNl (f);
      ELSE
      END;

   END AssignSubFormal;

PROCEDURE BeginSubFormals (Formals: tTree ; PrevWith , Composer : tIdent );
   BEGIN
      IF Tree . IsType ( Formals , Tree . Formal ) 
      THEN
         WITH Formals^.Formal DO
           WriteS (f, "      begin"); PackBody (TypeDesc); 
             WriteS (f, " ( "); WI ( PrevWith ) ; WriteS (f, " . ALL . "); WI ( Composer ) ; 
             WriteS (f, " . "); WI ( Name ) ; WriteS (f, " ) ; "); WriteNl (f);
           BeginSubFormals(Next , PrevWith , Composer );
         END;
      END;
   END BeginSubFormals;

PROCEDURE ConsPatterns (t: tTree; ListCount: INTEGER): INTEGER;
   BEGIN
      IF t^.Kind = Tree.NoPattern THEN RETURN ListCount; END;
      WITH t^.OnePattern DO
         IF Tree . IsType ( Pattern , Tree.DontCare ) THEN
            RETURN ConsTempos (Pattern^.DontCare.Tempos, ListCount);
         ELSE
            IF ListCount > 0 THEN WriteS (f, ", "); END;
            WI (Pattern^.Pattern.Tempo);
            RETURN ConsPatterns (Next, ListCount + 1);
         END;
      END;
   END ConsPatterns;

PROCEDURE ConsTempos (t: tTree; ListCount: INTEGER): INTEGER;
   BEGIN
      IF Tree . IsType ( t , Tree . Formal )  
      THEN
         IF ListCount > 0 THEN WriteS (f, ", "); END;
         WI (t^.Formal.Name);
         RETURN ConsTempos (t^.Formal.Next, ListCount + 1);
      ELSE
         RETURN ListCount;
      END;
   END ConsTempos;

PROCEDURE Expressions (t: tTree; ListCount: INTEGER): INTEGER;
   BEGIN
      IF t^.Kind = Tree.NoExpr THEN RETURN ListCount; END;
      WITH t^.OneExpr DO
         IF Tree . IsType ( Expr , Tree.DontCare ) THEN
            RETURN ConsTempos (Expr^.DontCare.Tempos, ListCount);
         ELSE
            IF ListCount > 0 THEN WriteS (f, ", "); END;
            Expression (Expr);
            RETURN Expressions (Next, ListCount + 1);
         END;
      END;
   END Expressions;

PROCEDURE Expression (t: tTree);
   BEGIN
      CASE t^.Kind OF
      | Tree.Compose    : WI (t^.Compose.Tempo);

      | Tree.Nil        : WriteS (f, "NULL "); 

      | Tree.VarUse     : WITH t^.VarUse DO
            IF Object # NoTree THEN
               WritePath ( Object^.Formal.Path );
            ELSE
               WI (Name);
            END;
         END;

      | Tree.DontCare1Explicit , Tree.DontCare1Internal : WI (t^.DontCare1.Tempo);

      | Tree.Call       : WITH t^.Call DO
            Expression (Expr); 
            IF ( Exprs^.Kind = Tree.NoExpr ) 
               AND ( ( Patterns^.Kind = Tree.NoPattern ) 
                     OR ( Patterns^.Kind = Tree.NoExpr ) 
                        (* semantics can leave Patterns as a list of
                           OneExpr/NoExpr, see TransformExpr *) 
                   ) 
            THEN (* No parameters.  Omits parentheses too. *) 
            ELSE 
               WriteS (f, " ("); 
               ListCount := Expressions (Exprs, 0);
               IF Object # NoTree THEN
                  ListCount := ConsPatterns (Patterns, ListCount);
               ELSE
                  ListCount := Expressions (Patterns, ListCount);
               END;
               WriteS (f, ") "); WriteNl (f);
            END (* IF *) 
         END;

      | Tree . BinaryCompound   
        : WITH t ^ . BinaryCompound 
          DO
            Expression ( Lop ) ; WriteS (f, " "); WI ( Operator ) ; WriteS (f, " "); 
            WI ( CompoundOperator ) ; WriteS (f, " "); Expression ( Rop ) ;
          END (* t ^ . BinaryCompound *) ;

      | Tree.Binary     : WITH t^.Binary DO
            Expression (Lop); WriteS (f, " "); WI (Operator); WriteS (f, " "); Expression (Rop);
         END;

      | Tree.PreOperator        :
         WI (t^.PreOperator.Operator); WriteS (f, " "); Expression (t^.PreOperator.Expr);

      | Tree.PostOperator       :
         Expression (t^.PostOperator.Expr); WriteS (f, " "); WI (t^.PostOperator.Operator);

      | Tree.Index      :
         Expression (t^.Index.Expr); WriteS (f, " ("); ListCount := Expressions (t^.Index.Exprs, 0); WriteS (f, ")"); 

      | Tree.Parents    : WriteS (f, "("); Expression (t^.Parents.Expr); WriteS (f, ")"); 

      | Tree.TargetExpr : PackBody (t^.TargetExpr.Expr);

      | Tree.StringExpr : WriteString (f, t^.StringExpr.String);

      | Tree.AttrDesc   : WITH t^.AttrDesc DO
            WritePath ( Object^.Formal.Path ); WriteS (f, " . ALL . "); WI (Type); WriteS (f, " . "); WI (Attribute);
         END;
      END;
   END Expression;

PROCEDURE Tg2 (t, Formals: tTree)
; VAR Object : tTree 
; VAR FormalName : tIdent 
;  PROCEDURE Tg2Attrs ( AttrFormals : tTree ) 
   ; VAR LNewFormalName : tIdent 
   ; VAR LString1 , LString2 : tString 
   ; BEGIN
       IF Tree . IsType ( AttrFormals , Tree . Formal ) 
       THEN 
         IF AttrFormals ^ . Formal . Name = FormalName 
         THEN (* Rename FormalName, possibly again. *) 
           ArrayToString ( "Puma_Rename_Of_" , LString1 ) ;
           GetString ( FormalName , LString2 ) ; 
           Concatenate ( LString1 , LString2 ) ; 
           LNewFormalName := MakeIdent ( LString1 ) ; 
           WriteS (f, "      "); WI ( LNewFormalName ) ; 
           WriteS (f, " : "); PackSpec ( Formals ^ . Formal . TypeDesc ) ; 
           WriteS (f, " RENAMES "); WI ( FormalName  ) ; WriteS (f, " ; "); 
           FormalName := LNewFormalName ; 
         ELSE 
         END (* IF *) ; 
           WriteS (f, "      "); WI ( AttrFormals ^ . Formal . Name ) ; 
           WriteS (f, " : "); PackSpec ( AttrFormals ^ . Formal . TypeDesc ) ; 
           WriteS (f, " RENAMES "); WI ( FormalName ) ; 
           WriteS (f, " . ALL . "); WI ( Object ^ . Class . Name ) ; 
           WriteS (f, " . "); WI ( AttrFormals ^ . Formal . Name ) ; WriteS (f, " ; "); WriteNl (f);
         Tg2Attrs ( AttrFormals ^ . Formal . Next ) ; 
       END (* IF *) ; 
     END Tg2Attrs ;
   BEGIN (* Tg2 *) 
      IF (t^.Kind = Tree.NoPattern) OR (Formals^.Kind = Tree.NoFormal) THEN RETURN; END;
      CASE t^.OnePattern.Pattern^.Kind OF
      | Tree.Decompose:
         WriteS (f, "    DECLARE -- Renames "); WriteNl (f);
         Object := t^.OnePattern.Pattern^.Decompose.Object ; 
         FormalName := Formals ^ . Formal . Name ;  
           (* Formals ^ . Formal . Name might need to be renamed later. *) 
         Tg2Attrs ( Object ^ . Class . Formals ) ; 
         WriteS (f, "    BEGIN -- DECLARE renames "); WriteNl (f);
         Tg2 ( t^.OnePattern.Pattern^.Decompose.Patterns , Object ^ . Class . Formals ) ; 
      | Tree.VarDef, Tree.NilTest, Tree.Value, Tree.DontCare1Explicit, Tree.DontCare1Internal:
      ELSE RETURN;
      END;
      Tg2 (t^.OnePattern.Next, Formals^.Formal.Next);
   END Tg2;


































































PROCEDURE yyAbort (yyFunction: ARRAY OF CHAR);
 BEGIN
  IO.WriteS (IO.StdError, 'Error: module Ada, routine ');
  IO.WriteS (IO.StdError, yyFunction);
  IO.WriteS (IO.StdError, ' failed');
  IO.WriteNl (IO.StdError);
  Exit;
 END yyAbort;

PROCEDURE yyIsEqual (yya, yyb: ARRAY OF SYSTEM.BYTE): BOOLEAN;
 VAR yyi       : INTEGER;
 BEGIN
  FOR yyi := 0 TO INTEGER (HIGH (yya)) DO
   IF yya [yyi] # yyb [yyi] THEN RETURN FALSE; END;
  END;
  RETURN TRUE;
 END yyIsEqual;

PROCEDURE MacroAda (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Spec:
(* line 518 "" *)
     WITH t^.Spec DO
(* line 518 "" *)
      
        MacroAda (TreeNames);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TreeName:
(* line 521 "" *)
     WITH t^.TreeName DO
(* line 521 "" *)
      
        WriteS (f, "# define begint"); WI (Name); WriteS (f, "(a) ( a ) := NULL ; "); WriteNl (f);
        WriteS (f, "# define equalt"); WI (Name); WriteS (f, "(a, b)    "); WI (Name); WriteS (f, ".IsEqual"); WI (Name); WriteS (f, " (a, b)"); WriteNl (f);
        MacroAda (Next);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END MacroAda;

PROCEDURE PackSpec (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Spec:
(* line 530 "" *)
     WITH t^.Spec DO
(* line 530 "" *)
      
        WriteNl (f);
        WriteS (f, "-- This file was mechanically generated by puma. "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "WITH Text_Io "); WriteNl (f);
        PackSpec (TreeNames); WriteS (f, ";"); WriteNl (f);
        WriteLine (Codes^.Codes.SpecWithLine);
        WriteText (f, Codes^.Codes.SpecWith);
        WriteNl (f);
        WriteS (f, "PACKAGE "); WI (TrafoName); WriteS (f, ""); 
        WriteS (f, " IS "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  "); WriteLine (Codes^.Codes.ImportLine);
        WriteText (f, Codes^.Codes.Import);
        WriteNl (f);
        WriteS (f, "  "); WriteLine (Codes^.Codes.ExportLine);
        WriteText (f, Codes^.Codes.Export);
        WriteNl (f);
        PackSpec (Public);
        WriteNl (f);
        WriteS (f, "  PROCEDURE Begin"); WI (TrafoName); WriteS (f, ";"); WriteNl (f);
        WriteS (f, "  PROCEDURE Close"); WI (TrafoName); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "END "); WI (TrafoName); WriteS (f, " ;"); WriteNl (f);
        WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TreeName:
(* line 556 "" *)
     WITH t^.TreeName DO
(* line 556 "" *)
      
        WriteS (f, ", "); WI (Name);
        PackSpec (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Name:
(* line 560 "" *)
     WITH t^.Name DO
(* line 560 "" *)
      
        IF Object # NoTree 
        THEN 
           IF ( Object^.Kind = Tree.Predicate ) 
              OR ( Object^.Kind = Tree.Function ) 
           THEN
             WriteS (f, "FUNCTION "); 
           ELSE 
             WriteS (f, "PROCEDURE "); 
           END  ; 
           WI (Name); 
           IF ( Object^.Routine.InForm^.Kind = Tree.NoFormal )
              AND ( Object^.Routine.OutForm^.Kind = Tree.NoFormal )
           THEN  
           ELSE 
             WriteS (f, " ( "); 
             ListCount := 0;
             PackSpec (Object^.Routine.InForm);
             PackSpec (Object^.Routine.OutForm);
             WriteS (f, " ) "); WriteNl (f);
           END  ; 
           IF Object^.Kind = Tree.Predicate THEN
              WriteS (f, "RETURN BOOLEAN "); 
           ELSIF Object^.Kind = Tree.Function THEN
              WriteS (f, "RETURN "); PackSpec (Object^.Function.ReturnForm^.Formal.TypeDesc);
           END;
           WriteS (f, " ; "); WriteNl (f);
        END;
        PackSpec (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Formal
  , Tree.PlainFormal
  , Tree.RoutineFormal:
(* line 590 "" *)
     WITH t^.Formal DO
(* line 590 "" *)
      
        IF ListCount > 0 THEN WriteS (f, "; "); END;
        WI (Name); WriteS (f, ": "); 
        IF Path^.Var.IsOutput THEN WriteS (f, "IN OUT "); END;
        PackSpec (TypeDesc);
        INC (ListCount);
        PackSpec (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.NodeTypes:
(* line 598 "" *)
     WITH t^.NodeTypes DO
(* line 598 "" *)
      
        WI (TreeName^.TreeName.Name); WriteS (f, ".t"); WI (TreeName^.TreeName.Name);
;
      RETURN;
     END (* WITH *) ;

  | Tree.UserType:
(* line 601 "" *)
     WITH t^.UserType DO
(* line 601 "" *)
      
        WI (Type);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END PackSpec;

PROCEDURE TreeOperators (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.TreeName) THEN
(* line 607 "" *)
     WITH t^.TreeName DO
(* line 607 "" *)
      
        WriteS (f, "  USE "); WI (Name); WriteS (f, " . Operators ; "); 
      
        TreeOperators (Next);
;
      RETURN;
     END (* WITH *) ;

  END;
 END TreeOperators;

PROCEDURE ForwardDecls (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Procedure:
(* line 620 "" *)
     WITH t^.Procedure DO
(* line 620 "" *)
       
        IF NOT IsExtern 
        THEN 
        ListCount := 0;
        WriteS (f, "  PROCEDURE "); WI (Name); 
        IF ( InForm^.Kind = Tree.NoFormal ) 
           AND ( OutForm^.Kind = Tree.NoFormal ) 
        THEN  
        ELSE 
          WriteS (f, " ("); 
          PackSpec (InForm);
          PackSpec (OutForm);
          WriteS (f, ") "); 
        END  ; 
        WriteS (f, "; "); WriteNl (f);
        END  ;  
        ForwardDecls (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Function:
(* line 638 "" *)
     WITH t^.Function DO
(* line 638 "" *)
      
        IF NOT IsExtern 
        THEN 
        ListCount := 0;
        WriteS (f, "  FUNCTION "); WI (Name); 
        IF ( InForm^.Kind = Tree.NoFormal ) 
           AND ( OutForm^.Kind = Tree.NoFormal ) 
        THEN  
        ELSE 
          WriteS (f, " ("); 
          PackSpec (InForm);
          PackSpec (OutForm);
          WriteS (f, ") "); 
        END  ; 
        WriteS (f, " RETURN "); PackSpec (ReturnForm^.Formal.TypeDesc); WriteS (f, " ; "); WriteNl (f);
        END  ; 
        ForwardDecls (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Predicate:
(* line 656 "" *)
     WITH t^.Predicate DO
(* line 656 "" *)
      
        IF NOT IsExtern 
        THEN 
        ListCount := 0;
        WriteS (f, "  FUNCTION "); WI (Name); 
        IF ( InForm^.Kind = Tree.NoFormal ) 
           AND ( OutForm^.Kind = Tree.NoFormal ) 
        THEN  
        ELSE 
          WriteS (f, " ("); 
          PackSpec (InForm);
          PackSpec (OutForm);
          WriteS (f, ") "); 
        END  ; 
        WriteS (f, "RETURN BOOLEAN ; "); WriteNl (f);
        END  ; 
        ForwardDecls (Next);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ForwardDecls;

PROCEDURE NeedsDeclareRenames (t: Tree.tTree): BOOLEAN;

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN FALSE; END;
(* line 677 "" *)
   LOOP
     WITH t^.Rule DO
(* line 677 "" *)
      IF NOT (( IsElement (ORD ('w'), Options) )) THEN EXIT; END;
(* line 678 "" *)
      IF NOT (( ( Statements^.Kind <> Tree.NoStatement ) 
                 OR ( Exprs^.Kind <> Tree.NoExpr ) 
                 OR ( Expr^.Kind <> Tree.NoExpr ) 
               )) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  RETURN FALSE;
 END NeedsDeclareRenames;

PROCEDURE PackBody (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Spec:
(* line 687 "" *)
     WITH t^.Spec DO
(* line 687 "" *)
      
        WriteNl (f);
        WriteS (f, "-- This file was mechanically generated by puma. "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "WITH PumaSys , Text_Io "); WriteNl (f);
        PackSpec (TreeNames); WriteS (f, " ; "); WriteNl (f);
        WriteLine (Codes^.Codes.BodyWithLine);
        WriteText (f, Codes^.Codes.BodyWith);
        WriteNl (f);
        WriteS (f, "PACKAGE BODY "); WI (TrafoName); WriteNl (f);
        WriteS (f, "  IS "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "# define yyWrite(s) Text_Io . Put ( s ) "); WriteNl (f);
        WriteS (f, "# define yyWriteNl Text_Io . New_Line "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  "); WriteLine (Codes^.Codes.GlobalLine);
        WriteText (f, Codes^.Codes.Global);
        WriteNl (f);
        WriteS (f, '# include "yy'); WI (TrafoName); WriteS (f, '.w"'); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  -- Operator Visibility. "); WriteNl (f);
        WriteNl (f);
        TreeOperators ( TreeNames ) ; 
        WriteNl (f);
        WriteS (f, "  -- Forward declarations of routines. "); WriteNl (f);
        WriteNl (f);
        ForwardDecls ( Routines ) ; 
        WriteS (f, ""); 
        WriteS (f, "  -- Utility routines used by Puma routine bodies. "); WriteNl (f);
        WriteS (f, ""); 
        WriteS (f, "  PROCEDURE yyAbort (yyFunction: STRING ) "); WriteNl (f);
        WriteS (f, "  IS BEGIN "); WriteNl (f);
        WriteS (f, "    Text_Io . Put "); WriteNl (f);
        WriteS (f, '      (Text_Io . Standard_Output , "Error: module '); WI (TrafoName); 
        WriteS (f, ', routine " ); '); WriteNl (f);
        WriteS (f, "    Text_Io . Put ( Text_Io . Standard_Output, yyFunction); "); WriteNl (f);
        WriteS (f, '    Text_Io . Put ( Text_Io . Standard_Output, " failed"); '); WriteNl (f);
        WriteS (f, "    Text_Io . New_Line ( Text_Io . Standard_Output ) ; "); WriteNl (f);
        WriteS (f, "    RAISE PumaSys . AbortPuma ; "); WriteNl (f);
        WriteS (f, "  END yyAbort ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  -- Routine bodies. "); WriteNl (f);
        WriteS (f, ""); 
        PackBody (Routines);
        WriteS (f, ""); 
        WriteS (f, "  -- Standard routines. "); WriteNl (f);
        WriteS (f, ""); 
        WriteS (f, "  PROCEDURE Begin"); WI (TrafoName); WriteNl (f);
        WriteS (f, "  IS BEGIN "); WriteNl (f);
        WriteS (f, "    "); WriteLine (Codes^.Codes.BeginLine);
        WriteText (f, Codes^.Codes.Begin);
        WriteNl (f);
        WriteS (f, "  END Begin"); WI (TrafoName); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  PROCEDURE Close"); WI (TrafoName); WriteNl (f);
        WriteS (f, "  IS BEGIN "); WriteNl (f);
        WriteS (f, "    "); WriteLine (Codes^.Codes.CloseLine);
        WriteText (f, Codes^.Codes.Close);
        WriteNl (f);
        WriteS (f, "  END Close"); WI (TrafoName); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "BEGIN -- "); WI (TrafoName); WriteNl (f);
        WriteS (f, "  Text_Io . Set_Output ( Text_Io . Standard_Output ) ; "); WriteNl (f);
        WriteS (f, "  Begin"); WI (TrafoName); WriteS (f, ";"); WriteNl (f);
        WriteS (f, "END "); WI (TrafoName); WriteS (f, " ; "); WriteNl (f);
        WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Procedure:
(* line 754 "" *)
     WITH t^.Procedure DO
(* line 754 "" *)
      
        ListCount := 0;
        WriteS (f, "  PROCEDURE "); WI (Name); 
        IF ( InForm^.Kind = Tree.NoFormal ) 
           AND ( OutForm^.Kind = Tree.NoFormal ) 
        THEN  
        ELSE 
          WriteS (f, " ("); 
          PackSpec (InForm);
          PackSpec (OutForm);
          WriteS (f, ") "); 
        END  ; 
        WriteS (f, "  IS "); WriteNl (f);
        IF LocalLine . Line <> 0 THEN 
        WriteS (f, "    "); WriteLine (LocalLine);
        WriteText (f, Local); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  BEGIN -- "); WI ( Name ) ; WriteNl (f);
        ELSE
        WriteS (f, "BEGIN -- "); WI ( Name ) ; WriteNl (f);
        END ; 
        RoutineKind := kProcedure;
        InFormals := InForm;
        OutFormals := OutForm; 
      IF IsElement (ORD ('n'), Options) THEN
        Tg1 (InForm);
      END;
      IF IsElement (ORD ('b'), Options) THEN
        PackBody (Rules);
        IF IsElement (ORD ('f'), Options) THEN
           WriteS (f, '    yyAbort ("'); WI (Name); WriteS (f, '");'); WriteNl (f);
        END;
      ELSE
        TemposDone := FALSE;
        CommonTestElim (Decisions);
        IF IsElement (ORD ('f'), Options) AND NOT NeedsNoFinale (Decisions) THEN
           WriteS (f, '    yyAbort ("'); WI (Name); WriteS (f, '");'); WriteNl (f);
        END;
      END;
        WriteS (f, "  END "); WI (Name); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
        PackBody (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Function:
(* line 797 "" *)
     WITH t^.Function DO
(* line 797 "" *)
      
        ListCount := 0;
        WriteS (f, "  FUNCTION "); WI (Name); 
        IF ( InForm^.Kind = Tree.NoFormal ) 
           AND ( OutForm^.Kind = Tree.NoFormal ) 
        THEN  
        ELSE 
          WriteS (f, " ("); 
          PackSpec (InForm);
          PackSpec (OutForm);
          WriteS (f, ") "); 
        END  ; 
        WriteS (f, " RETURN "); PackSpec (ReturnForm^.Formal.TypeDesc); WriteNl (f);
        WriteS (f, "  IS "); 
        IF LocalLine . Line <> 0 THEN 
        WriteS (f, "    "); WriteLine (LocalLine);
        WriteText (f, Local); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  BEGIN -- "); WI ( Name ) ; WriteNl (f);
        ELSE
        WriteS (f, "BEGIN -- "); WI ( Name ) ; WriteNl (f);
        END ; 
        RoutineKind := kFunction;
        InFormals := InForm;
        OutFormals := OutForm;
        ReturnFormals := ReturnForm;
      IF IsElement (ORD ('b'), Options) THEN
        PackBody (Rules);
        WriteS (f, '    yyAbort ("'); WI (Name); WriteS (f, '");'); WriteNl (f);
      ELSE
        TemposDone := FALSE;
        CommonTestElim (Decisions);
        IF NOT NeedsNoFinale (Decisions) THEN
           WriteS (f, '    yyAbort ("'); WI (Name); WriteS (f, '");'); WriteNl (f);
        END;
      END;
        WriteS (f, "  END "); WI (Name); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
        PackBody (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Predicate:
(* line 837 "" *)
     WITH t^.Predicate DO
(* line 837 "" *)
      
        ListCount := 0;
        WriteS (f, "  FUNCTION "); WI (Name); 
        IF ( InForm^.Kind = Tree.NoFormal ) 
           AND ( OutForm^.Kind = Tree.NoFormal ) 
        THEN  
        ELSE 
          WriteS (f, " ("); 
          PackSpec (InForm);
          PackSpec (OutForm);
          WriteS (f, ") "); 
        END  ; 
        WriteS (f, "RETURN BOOLEAN "); WriteNl (f);
        WriteS (f, "  IS "); 
        IF LocalLine . Line <> 0 THEN 
        WriteS (f, "    "); WriteLine (LocalLine);
        WriteText (f, Local); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  BEGIN -- "); WI ( Name ) ; WriteNl (f);
        ELSE
        WriteS (f, "BEGIN -- "); WI ( Name ) ; WriteNl (f);
        END ; 
        RoutineKind := kPredicate;
        InFormals := InForm;
        OutFormals := OutForm;
      IF IsElement (ORD ('n'), Options) THEN
        Tg1 (InForm);
      END;
      IF IsElement (ORD ('b'), Options) THEN
        PackBody (Rules);
        WriteS (f, "    RETURN FALSE;"); WriteNl (f);
      ELSE
        TemposDone := FALSE;
        CommonTestElim (Decisions);
        IF NOT NeedsNoFinale (Decisions) THEN
           WriteS (f, "    RETURN FALSE;"); WriteNl (f);
        END;
      END;
        WriteS (f, "  END "); WI (Name); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
        PackBody (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Rule:
(* line 879 "" *)
     WITH t^.Rule DO
(* line 879 "" *)
      
        WithCount := 0; 
        WriteS (f, "    "); WriteLine (Line);
        IF HasTempos 
        THEN 
        WriteS (f, "    DECLARE -- Tempos"); WriteNl (f);
        Declare ( t ) ; 
        WriteS (f, "    BEGIN -- DECLARE Tempos"); WriteNl (f);
        END;
        WriteS (f, "      LOOP"); WriteNl (f);
        Decls := VarDecls;
        Match (Patterns, InFormals);
      IF NeedsDeclareRenames ( t ) 
      THEN 
        Tg2 (Patterns, InFormals);
      END;
        PackBody (Statements);
        IF NOT HasRejectOrFail THEN
           AssignFormals (Exprs, OutFormals);
           MatchExprs (Exprs);
           CASE RoutineKind OF
           | kProcedure: WriteS (f, "        RETURN;"); WriteNl (f);

           | kFunction :
              AssignTempo (Expr);
              IF HasPatterns AND (Expr^.Kind # Tree.Compose) 
                 AND NOT Tree . IsType ( t , Tree.DontCare1 )
              THEN
                 WriteS (f, "        "); WI (Tempo); WriteS (f, " := "); Expression (Expr); WriteS (f, ";"); WriteNl (f);
                 MatchExpr (Expr);
                 WriteS (f, "        RETURN "); WI (Tempo); WriteS (f, ";"); WriteNl (f);
              ELSE
                 MatchExpr (Expr);
                 WriteS (f, "        RETURN "); Expression (Expr); WriteS (f, ";"); WriteNl (f);
              END;

           | kPredicate: WriteS (f, "        RETURN TRUE;"); WriteNl (f);
           END;
        END;
      IF NeedsDeclareRenames ( t ) 
      THEN 
        Tg3 (Patterns);
      END;
        WriteS (f, "      END LOOP ; "); WriteNl (f);
        IF HasTempos THEN WriteS (f, "    END ; -- DECLARE Tempos"); WriteNl (f);
        END;
        WriteNl (f);
        PackBody (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.ProcCall:
(* line 928 "" *)
     WITH t^.ProcCall DO
(* line 928 "" *)
      
        WriteS (f, "        "); WriteLine (Pos);
        AssignTempo (Call);
        WriteS (f, "        "); Expression (Call); WriteS (f, ";"); WriteNl (f);
        MatchExpr (Call);
        PackBody (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Condition:
(* line 935 "" *)
     WITH t^.Condition DO
(* line 935 "" *)
      
        WriteS (f, "        "); WriteLine (Pos);
        AssignTempo (Expr);
        WriteS (f, "        IF NOT ( "); Expression (Expr); WriteS (f, " ) THEN EXIT ; END IF ;"); WriteNl (f);
        MatchExpr (Expr);
        PackBody (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Assignment:
(* line 942 "" *)
     WITH t^.Assignment DO
(* line 942 "" *)
      
        WriteS (f, "        "); WriteLine (Pos);
        AssignTempo (Adr);
        AssignTempo (Expr);
        IF Object # NoTree THEN
          WriteS (f, "        "); WritePath ( Object^.Formal.Path );
        ELSE
          WriteS (f, "        "); Expression (Adr);
        END;
        WriteS (f, " := "); Expression (Expr); WriteS (f, " ; "); WriteNl (f);
        MatchExpr (Adr);
        MatchExpr (Expr);
        PackBody (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Reject:
(* line 956 "" *)
     WITH t^.Reject DO
(* line 956 "" *)
      
        WriteS (f, "        "); WriteLine (Pos);
        WriteS (f, "        EXIT ; "); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Fail:
(* line 960 "" *)
     WITH t^.Fail DO
(* line 960 "" *)
      
        WriteS (f, "        "); WriteLine (Pos);
        WriteS (f, "        RETURN "); IF RoutineKind = kPredicate THEN WriteS (f, " FALSE "); END; WriteS (f, " ; "); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TargetStmt:
(* line 964 "" *)
     WITH t^.TargetStmt DO
(* line 964 "" *)
      
        WriteS (f, "        "); WriteLine (Pos);
        WriteS (f, "        "); PackBody (Stmt); WriteNl (f);
        PackBody (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Nl:
(* line 969 "" *)
     WITH t^.Nl DO
(* line 969 "" *)
      
        WriteS (f, "        ");WriteLine (Pos);
        WriteS (f, "        yyWriteNl;"); WriteNl (f);
        PackBody (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.WriteStr:
(* line 974 "" *)
     WITH t^.WriteStr DO
(* line 974 "" *)
      
        WriteS (f, "        "); WriteLine (Pos);
        WriteS (f, "        yyWrite ("); WriteString (f, String); WriteS (f, ");"); WriteNl (f);
        PackBody (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Ident:
(* line 979 "" *)
     WITH t^.Ident DO
(* line 980 "" *)
       IF Object # NoTree 
      THEN 
        WritePath (Object^.Formal.Path); 
      ELSE 
        WI (Attribute); 
      END;
      PackBody (Next);
    ;
      RETURN;
     END (* WITH *) ;

  | Tree.Any:
(* line 988 "" *)
     WITH t^.Any DO
(* line 988 "" *)
      
        WriteString (f, Code);
        PackBody (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Anys:
(* line 992 "" *)
     WITH t^.Anys DO
(* line 992 "" *)
      
        PackBody (Layouts);
        PackBody (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.LayoutAny:
(* line 996 "" *)
     WITH t^.LayoutAny DO
(* line 996 "" *)
      
        WriteString (f, Code);
        PackBody (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Designator:
(* line 1000 "" *)
     WITH t^.Designator DO
(* line 1000 "" *)
      
        WritePath ( Object^.Formal.Path ); WriteS (f, ". ALL . "); WI (Type); WriteS (f, " . "); WI (Attribute);
        PackBody (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Field:
(* line 1004 "" *)
     WITH t^.Field DO
(* line 1004 "" *)
      
        CantHappen ( "Ada, PackBody, Field" ) ; 
;
      RETURN;
     END (* WITH *) ;

  | Tree.ConsType:
(* line 1007 "" *)
     WITH t^.ConsType DO
(* line 1007 "" *)
      
        CantHappen ( "Ada, PackBody, ConsType" ) ; 
;
      RETURN;
     END (* WITH *) ;

  | Tree.Var:
(* line 1010 "" *)
     WITH t^.Var DO
(* line 1010 "" *)
      
        CantHappen ( "Ada, PackBody, Var" ) ; 
;
      RETURN;
     END (* WITH *) ;

  | Tree.NodeTypes:
(* line 1013 "" *)
     WITH t^.NodeTypes DO
(* line 1013 "" *)
      
        WriteS (f, "t"); WI (TreeName^.TreeName.Name);
;
      RETURN;
     END (* WITH *) ;

  | Tree.UserType:
(* line 1016 "" *)
     WITH t^.UserType DO
(* line 1016 "" *)
      
        WI (Type);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END PackBody;

PROCEDURE WritePathRecurse (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Field:
(* line 1023 "" *)
     WITH t^.Field DO
(* line 1023 "" *)
      
        WritePathRecurse (Next);
        WriteS (f, " . "); WI (Name);
;
      RETURN;
     END (* WITH *) ;

  | Tree.ConsType:
(* line 1027 "" *)
     WITH t^.ConsType DO
(* line 1027 "" *)
      
        WritePathRecurse (Next);
        WriteS (f, " . ALL . "); WI (Name);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Var:
(* line 1031 "" *)
     WITH t^.Var DO
(* line 1031 "" *)
      
        WI (Name);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END WritePathRecurse;

PROCEDURE WritePath (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.ConsType:
(* line 1038 "" *)
     WITH t^.ConsType DO
(* line 1039 "" *)
       WritePathRecurse ( Next ) ; ;
      RETURN;
     END (* WITH *) ;

  | Tree.Field:
(* line 1041 "" *)
     WITH t^.Field DO
(* line 1043 "" *)
       WritePathRecurse ( t ) ; ;
      RETURN;
     END (* WITH *) ;

  | Tree.Var:
(* line 1041 "" *)
     WITH t^.Var DO
(* line 1043 "" *)
       WritePathRecurse ( t ) ; ;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END WritePath;

PROCEDURE Declare (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 2: yyR2: RECORD
  Var: tTree;
  END;
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Formal
  , Tree.PlainFormal
  , Tree.RoutineFormal:
(* line 1047 "" *)
     WITH t^.Formal DO
(* line 1047 "" *)
      
        WriteS (f, "      "); WI (Name); WriteS (f, ": "); PackSpec (TypeDesc); WriteS (f, ";"); WriteNl (f);
        Declare (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Param:
(* line 1051 "" *)
    WITH yyTempo.yyR2 DO  
     WITH t^.Param DO
(* line 1052 "" *)
      ;
(* line 1053 "" *)
       Var := IdentifyVar (Decls, Name);
        WriteS (f, "      "); WI (Name); WriteS (f, ": "); PackSpec (Var^.Formal.TypeDesc); WriteS (f, ";"); WriteNl (f);
        Declare (Next);
      ;
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.Rule:
(* line 1057 "" *)
     WITH t^.Rule DO
(* line 1057 "" *)
      
        IF HasTempos THEN
           Decls := VarDecls;
           Declare (Patterns);
           Declare (Exprs);
           IF RoutineKind = kFunction THEN
              Declare (Expr);
              IF HasPatterns AND (Expr^.Kind # Tree.Compose) AND NOT Tree . IsType ( t , Tree.DontCare1 ) THEN
                 WriteS (f, "      "); WI (Tempo); WriteS (f, " : "); PackSpec (ReturnFormals^.Formal.TypeDesc); WriteS (f, ";"); WriteNl (f);
              END;
           END;
           Declare (Statements);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.ProcCall:
(* line 1071 "" *)
     WITH t^.ProcCall DO
(* line 1071 "" *)
      
        Declare (Call);
        Declare (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Condition:
(* line 1075 "" *)
     WITH t^.Condition DO
(* line 1075 "" *)
      
        Declare (Expr);
        Declare (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Assignment:
(* line 1079 "" *)
     WITH t^.Assignment DO
(* line 1079 "" *)
      
        Declare (Adr);
        Declare (Expr);
        Declare (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TargetStmt:
(* line 1084 "" *)
     WITH t^.TargetStmt DO
(* line 1084 "" *)
      
        Declare (Parameters);
        Declare (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Statement
  , Tree.Reject
  , Tree.Fail
  , Tree.Nl
  , Tree.WriteStr:
(* line 1088 "" *)
     WITH t^.Statement DO
(* line 1088 "" *)
      
        Declare (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.OnePattern:
(* line 1091 "" *)
     WITH t^.OnePattern DO
(* line 1091 "" *)
      
        IF (Pattern^.Pattern.Tempo # NoIdent) AND NOT Tree . IsType ( Pattern , Tree.DontCare1 ) THEN
           WriteS (f, "      "); WI (Pattern^.Pattern.Tempo); WriteS (f, " : "); PackSpec (Pattern^.Pattern.TypeDesc); WriteS (f, ";"); WriteNl (f);
        END;
        Declare (Pattern);
        Declare (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.OneExpr
  , Tree.NamedExpr:
(* line 1098 "" *)
     WITH t^.OneExpr DO
(* line 1098 "" *)
      
        Declare (Expr);
        Declare (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Decompose:
(* line 1102 "" *)
     WITH t^.Decompose DO
(* line 1102 "" *)
      
        Declare (Patterns);
;
      RETURN;
     END (* WITH *) ;

  | Tree.DontCare
  , Tree.DontCareExplicit
  , Tree.DontCareInternal:
(* line 1105 "" *)
     WITH t^.DontCare DO
(* line 1105 "" *)
      
        Declare (Tempos);
;
      RETURN;
     END (* WITH *) ;

  | Tree.DontCare1
  , Tree.DontCare1Explicit
  , Tree.DontCare1Internal:
(* line 1108 "" *)
     WITH t^.DontCare1 DO
(* line 1108 "" *)
      
        IF Tempo # NoIdent THEN
           WriteS (f, "      "); WI (Tempo); WriteS (f, " : "); PackSpec (TypeDesc); WriteS (f, ";"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Value:
(* line 1113 "" *)
     WITH t^.Value DO
(* line 1113 "" *)
      
        Declare (Expr);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Compose:
(* line 1116 "" *)
     WITH t^.Compose DO
(* line 1116 "" *)
      
        IF Tempo # NoIdent THEN
           WriteS (f, "      "); WI (Tempo); WriteS (f, ": "); PackSpec (TypeDesc); WriteS (f, ";"); WriteNl (f);
        END;
        Declare (Exprs);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Call:
(* line 1122 "" *)
     WITH t^.Call DO
(* line 1122 "" *)
      
        Declare (Expr);
        Declare (Exprs);
        Declare (Patterns);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Binary
  , Tree.yy1
  , Tree.BinaryCompound:
(* line 1127 "" *)
     WITH t^.Binary DO
(* line 1127 "" *)
      
        Declare (Lop);
        Declare (Rop);
;
      RETURN;
     END (* WITH *) ;

  | Tree.PreOperator:
(* line 1131 "" *)
     WITH t^.PreOperator DO
(* line 1133 "" *)
      
        Declare (Expr); 
;
      RETURN;
     END (* WITH *) ;

  | Tree.PostOperator:
(* line 1131 "" *)
     WITH t^.PostOperator DO
(* line 1133 "" *)
      
        Declare (Expr); 
;
      RETURN;
     END (* WITH *) ;

  | Tree.Parents:
(* line 1131 "" *)
     WITH t^.Parents DO
(* line 1133 "" *)
      
        Declare (Expr); 
;
      RETURN;
     END (* WITH *) ;

  | Tree.Index:
(* line 1136 "" *)
     WITH t^.Index DO
(* line 1136 "" *)
      
        Declare (Expr);
        Declare (Exprs);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Declare;

PROCEDURE Tg1 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Formal
  , Tree.PlainFormal
  , Tree.RoutineFormal:
(* line 1144 "" *)
     WITH t^.Formal DO
(* line 1144 "" *)
      
        TheName := Name;
        Tg1 (TypeDesc);
        Tg1 (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.NodeTypes:
(* line 1149 "" *)
     WITH t^.NodeTypes DO
(* line 1149 "" *)
      
        WriteS (f, "    IF "); WI (TheName); WriteS (f, " = "); WI (TreeName^.TreeName.Name); WriteS (f, " . No"); 
        WI (TreeName^.TreeName.Name); WriteS (f, " THEN RETURN "); IF RoutineKind = kPredicate THEN WriteS (f, " FALSE "); END; WriteS (f, "; END IF ; "); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Tg1;

PROCEDURE Tg3 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.OnePattern:
(* line 1157 "" *)
     WITH t^.OnePattern DO
(* line 1157 "" *)
      
        Tg3 (Pattern);
        Tg3 (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Decompose:
(* line 1161 "" *)
     WITH t^.Decompose DO
(* line 1161 "" *)
      
        Tg3 ( Patterns ) ; 
        WriteS (f, "    END ; -- DECLARE renames "); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Tg3;

PROCEDURE CommonTestElim2 (OneTest: Tree.tTree; yyP1: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF OneTest = Tree.NoTree THEN RETURN; END;
  IF yyP1 = Tree.NoTree THEN RETURN; END;
  IF (OneTest^.Kind = Tree.TestValue) THEN
(* line 1168 "" *)
   LOOP
     WITH OneTest^.TestValue DO
(* line 1169 "" *)
      IF NOT ((NeedsMatch (Expr))) THEN EXIT; END;
(* line 1170 "" *)
      CommonTestElim (OneTest);
(* line 1171 "" *)
      WriteS (f, "      LOOP ");
(* line 1171 "" *)
      WriteNl (f);
(* line 1172 "" *)
      MatchExpr (OneTest ^ . TestValue . Expr);
(* line 1173 "" *)
      CommonTestElim (yyP1);
(* line 1174 "" *)
      WriteS (f, "      EXIT ; ");
(* line 1174 "" *)
      WriteNl (f);
(* line 1175 "" *)
      WriteS (f, "      END LOOP ;");
(* line 1175 "" *)
      WriteNl (f);
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
(* line 1177 "" *)
(* line 1178 "" *)
      CommonTestElim (OneTest);
(* line 1179 "" *)
      CommonTestElim (yyP1);
      RETURN;

 END CommonTestElim2;

PROCEDURE CommonTestElim (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Decision:
(* line 1184 "" *)
     WITH t^.Decision DO
(* line 1184 "" *)
      
        IF Cases = 0 THEN
           IF NOT TemposDone AND (OneTest^.Kind = Tree.TestValue) AND NeedsTempo (ThenPart, rule) THEN
              WriteS (f, "    DECLARE -- Tempos "); WriteNl (f);
              Declare ( rule ) ; 
              WriteS (f, "    BEGIN -- DECLARE Tempos "); WriteNl (f);
              TemposDone := TRUE;
              CommonTestElim2 (OneTest, ThenPart);
              WriteS (f, "        END IF ; "); WriteNl (f);
               
              WriteS (f, "    END ; -- DECLARE Tempos "); WriteNl (f);
           ELSE
              GetRule (ThenPart, rule);
              Decls := rule^.Rule.VarDecls;
              CommonTestElim2 (OneTest, ThenPart);
              WriteS (f, "        END IF ; "); WriteNl (f);
                
           END;
           TemposDone := FALSE;
           CommonTestElim (ElsePart);
        ELSE
           i := Cases; Case (t);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Decided:
(* line 1208 "" *)
     WITH t^.Decided DO
(* line 1208 "" *)
      
        CommonTestElim (Rule);
        IF Rule^.Rule.HasExit THEN
           TemposDone := FALSE;
           CommonTestElim (ElsePart);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.TestKind:
(* line 1215 "" *)
     WITH t^.TestKind DO
(* line 1215 "" *)
      
        WriteS (f, "        IF ("); WritePath ( Path ); WriteS (f, ". ALL . Kind = "); 
        WI (TypeDesc^.NodeTypes.TreeName^.TreeName.Name); WriteS (f, " . "); WI (Name); WriteS (f, ") THEN"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TestIsType:
(* line 1219 "" *)
     WITH t^.TestIsType DO
(* line 1219 "" *)
      
        WriteS (f, "        IF "); WI (TypeDesc^.NodeTypes.TreeName^.TreeName.Name); WriteS (f, " . IsType ( "); WritePath ( Path ); WriteS (f, ", "); 
        WI (TypeDesc^.NodeTypes.TreeName^.TreeName.Name); WriteS (f, " . "); WI (Name); WriteS (f, " ) THEN"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TestNil:
(* line 1223 "" *)
     WITH t^.TestNil DO
(* line 1223 "" *)
      
        WriteS (f, "        IF "); WritePath ( Path ); WriteS (f, " = NULL THEN "); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TestNonlin:
(* line 1226 "" *)
     WITH t^.TestNonlin DO
(* line 1226 "" *)
      
        WriteS (f, "        IF ( equal"); PackBody ( TypeDesc); WriteS (f, " ( "); WritePath (Path );
        WriteS (f, " , "); WritePath ( Path2 ); WriteS (f, " ) ) THEN "); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TestValue:
(* line 1230 "" *)
     WITH t^.TestValue DO
(* line 1230 "" *)
      
        AssignTempo (Expr);
        WriteS (f, "        IF ( equal"); PackBody ( TypeDesc); WriteS (f, " ( "); WritePath (Path );
        WriteS (f, " , "); Expression (Expr); WriteS (f, " ) ) THEN "); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Rule:
(* line 1235 "" *)
     WITH t^.Rule DO
(* line 1235 "" *)
      
        WithCount := 0; 
        WriteS (f, "        "); WriteLine (Line);
        IF HasTempos AND NOT TemposDone THEN 
        WriteS (f, "    DECLARE -- Tempos  "); WriteNl (f);
        Declare ( t ) ; 
        WriteS (f, "    BEGIN -- DECLARE Tempos  "); WriteNl (f);
        END;
        IF HasExit THEN WriteS (f, "       LOOP"); WriteNl (f);
        END;
        Decls := VarDecls;
      IF NeedsDeclareRenames ( t ) 
      THEN 
        Tg2 (Patterns, InFormals);
      END;
        PackBody (Statements);
        IF NOT HasRejectOrFail THEN
           AssignFormals (Exprs, OutFormals);
           MatchExprs (Exprs);
           CASE RoutineKind OF
           | kProcedure: WriteS (f, "        RETURN ; "); WriteNl (f);

           | kFunction :
              AssignTempo (Expr);
              IF HasPatterns AND (Expr^.Kind # Tree.Compose) AND NOT Tree . IsType ( t , Tree.DontCare1 ) THEN
                 WriteS (f, "        "); WI (Tempo); WriteS (f, " := "); Expression (Expr); WriteS (f, " ; "); WriteNl (f);
                 MatchExpr (Expr);
                 WriteS (f, "        RETURN "); WI (Tempo); WriteS (f, " ; "); WriteNl (f);
              ELSE
                 MatchExpr (Expr);
                 WriteS (f, "        RETURN "); Expression (Expr); WriteS (f, " ; "); WriteNl (f);
              END;

           | kPredicate: WriteS (f, "        RETURN TRUE ; "); WriteNl (f);
           END;
        END;
      IF NeedsDeclareRenames ( t ) 
      THEN 
        Tg3 (Patterns);
      END;
        IF HasExit THEN WriteS (f, "     END LOOP ; "); WriteNl (f);
        END;
        IF HasTempos AND NOT TemposDone 
        THEN 
          WriteS (f, "    END ; -- DECLARE Tempos  "); WriteNl (f);
        END;
        WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END CommonTestElim;

PROCEDURE Case (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 1: yyR1: RECORD
  n: CARDINAL;
  END;
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Decision:
(* line 1287 "" *)
    WITH yyTempo.yyR1 DO  
     WITH t^.Decision DO
(* line 1288 "" *)
      ;
(* line 1289 "" *)
       WriteNl (f);
        WriteS (f, "        CASE "); WritePath ( OneTest^.OneTest.Path ); WriteS (f, " . ALL . Kind IS "); WriteNl (f);
        n := i;
        WHILE n > 0 DO
           IF NOT IsEmpty (t^.Decision.OneTest^.TestIsType.TypeDesc^.NodeTypes.Types) THEN
              Case (t^.Decision.OneTest);
              CommonTestElim (t^.Decision.ThenPart);
           END;
           t := t^.Decision.ElsePart;
           DEC (n);
        END;
        WriteS (f, "        WHEN OTHERS => NULL ; "); WriteNl (f);
        WriteS (f, "        END CASE ; "); WriteNl (f);
        WriteNl (f);
        CommonTestElim (t);
      ;
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.TestKind:
(* line 1305 "" *)
     WITH t^.TestKind DO
(* line 1305 "" *)
      
        WriteS (f, "        WHEN "); WI (TypeDesc^.NodeTypes.TreeName^.TreeName.Name); WriteS (f, " . "); WI (Name); WriteS (f, " => "); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TestIsType:
(* line 1308 "" *)
     WITH t^.TestIsType DO
(* line 1308 "" *)
      
        WITH TypeDesc^.NodeTypes DO
           TheClass := LookupClass (TreeName^.TreeName.Classes, Minimum (Types));
           WriteS (f, "        WHEN "); WI (TreeName^.TreeName.Name); WriteS (f, " . "); WI (TheClass^.Class.Name);
           Case (TypeDesc); WriteS (f, " => "); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.NodeTypes:
(* line 1315 "" *)
     WITH t^.NodeTypes DO
(* line 1315 "" *)
      
        FOR j := Minimum (Types) + 1 TO Maximum (Types) DO
           IF IsElement (j, Types) THEN
              TheClass := LookupClass (TreeName^.TreeName.Classes, j); WriteNl (f);
              WriteS (f, "        | "); WI (TreeName^.TreeName.Name); WriteS (f, " . "); WI (TheClass^.Class.Name);
           END;
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Case;

PROCEDURE BeginAda;
 BEGIN

 END BeginAda;

PROCEDURE CloseAda;
 BEGIN

 END CloseAda;

PROCEDURE yyExit;
 BEGIN
  IO.CloseIO; System.Exit (1);
 END yyExit;

BEGIN
 yyf   := IO.StdOutput;
 Exit  := yyExit;
 BeginAda;
END Ada.

