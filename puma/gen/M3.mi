
(* This file was mechanically generated by puma. *)

IMPLEMENTATION MODULE M3;








IMPORT SYSTEM, System, IO, Tree;
(* line 60 "" *)


IMPORT Positions ; 
IMPORT Errors ; 
FROM Positions  IMPORT tPosition;
FROM IO         IMPORT WriteS , WriteNl , tFile;
IMPORT StringMem ; 
IMPORT Strings ;
IMPORT Assertions ;  
FROM Strings    IMPORT ArrayToString , Concatenate ; 
FROM Idents     IMPORT tIdent, NoIdent , GetString , MakeIdent ;
FROM Texts      IMPORT WriteText;
FROM Sets       IMPORT IsElement, IsNotEqual, Minimum, Maximum, IsEmpty;
FROM Semantics  IMPORT IdentifyVar, LookupClass;
FROM Optimize   IMPORT NeedsTempo, NeedsMatch, NeedsNoFinale, GetRule;
FROM Tree       IMPORT NoTree, tTree, Options, f, SourceFile, WI, WN;
FROM IOUtils    IMPORT WriteBackslash;

VAR
   RoutineKind  : (kProcedure, kFunction, kPredicate);
   i, j         : CARDINAL;
   ListCount    : INTEGER;
   rule         ,
   TheClass     ,
   InFormals    ,
   OutFormals   ,
   ReturnFormals,
   Decls        : tTree;
   TheName      : tIdent;
   TemposDone   : BOOLEAN;
VAR TypeCaseDepth : CARDINAL; 

PROCEDURE WriteLine (Line: tPosition);
   BEGIN
      IF Line.Line # 0 THEN
         WriteS (f, "(* line "); WN (Line.Line); WriteS (f, ' "'); IO . WriteS (f, SourceFile); WriteS (f, '" *)'); WriteNl (f);
      END;
   END WriteLine;

PROCEDURE WriteString ( f : tFile ; r : StringMem . tStringRef ) 
; VAR LIn : Strings . tString 
; VAR LLength , I : CARDINAL  
; VAR LCh : CHAR 
; BEGIN
    StringMem . GetString ( r , LIn ) 
  ; LLength := Strings . Length ( LIn ) 
  ; IF LLength < 2 
    THEN 
      Strings . WriteS ( f , LIn ) 
    ELSIF Strings . Char ( LIn , 1 ) = '"' 
    THEN 
      Strings . WriteS ( f , LIn ) 
    ELSIF Strings . Char ( LIn , 1 ) = "'"
    THEN 
      IO . WriteC ( f , '"' ) 
    ; FOR I := 2 TO LLength - 1 
      DO 
        LCh := Strings . Char ( LIn , I ) 
      ; IF LCh = '"' 
        THEN 
          WriteBackslash ( f ) ; 
        END (* IF *) 
      ; IO . WriteC ( f , LCh ) 
      END (* FOR *) 
    ; IO . WriteC ( f , '"' ) 
    ELSE     
      Strings . WriteS ( f , LIn ) 
    END (* IF *) 
  END WriteString ; 

PROCEDURE CloseTypeCases ( ToDepth : CARDINAL ) 

; BEGIN 
    WHILE TypeCaseDepth > ToDepth 
    DO 
      WriteS (f, "      ELSE EXIT"); WriteNl (f);
      WriteS (f, "      END (* TYPECASE Depth "); WN ( TypeCaseDepth ) ; WriteS (f, " , CloseTypeCases *)"); WriteNl (f);
      DEC ( TypeCaseDepth ) 
    END (* WHILE *) 
  END CloseTypeCases ; 

PROCEDURE Match (t, Formals: tTree);
   VAR TreeName : tIdent;
   VAR Pattern  : tTree;
   BEGIN
      IF (t^.Kind = Tree.NoPattern) 
         OR NOT Tree . IsType ( Formals , Tree . Formal ) 
      THEN RETURN; 
      END;
      Pattern := t^.OnePattern.Pattern;
      CASE Pattern^.Kind OF
      | Tree.Decompose: WITH Pattern^.Decompose DO
            TreeName := Object^.Class.TypeDesc^.NodeTypes.TreeName^.TreeName.Name;
            IF ( Formals^.Formal.TypeDesc^.Kind 
                 = Tree.UserType (* sem will have generated an error *) 
               )
               OR IsProperlyNarrowed  
            (* OR IsNotEqual 
                    ( Object^.Class.TypeDesc^.NodeTypes.Types
                    , Formals^.Formal.TypeDesc^.NodeTypes.Types
                    ) 
            *) 
            THEN
              INC ( TypeCaseDepth ) ; 
              WriteS (f, "      TYPECASE (* Depth "); WN ( TypeCaseDepth ) ; 
              WriteS (f, " , Decompose *) "); WritePathNarrow ( Path ); WriteNl (f);
              WriteS (f, "      OF "); WI (TreeName); WriteS (f, " . "); WI (Object^.Class.Name); 
                        WriteS (f, " ( "); PathPrefix ( Path , TRUE ); 
                        WriteS (f, "_yy_"); WI (Object^.Class.Name); WriteS (f, " ) "); WriteNl (f);
              WriteS (f, "      => "); (* Not end of line *) 
            END;
            Match (Patterns, Object^.Class.Formals);
         END;

      | Tree.VarDef: WITH Pattern^.VarDef DO
            IF Object # NoTree THEN
               WITH Object^.Formal DO
                  WriteS (f, "      IF NOT (equal"); Module (TypeDesc); 
(* This could require that a user provide a _lot_ of equal<Type> macros! *) 
                  WriteS (f, " ( "); WritePathNarrow ( Path );
                  WriteS (f, " , "); WritePathNarrow (Pattern^.VarDef.Path); 
                  WriteS (f, " ) ) THEN EXIT END (* IF *) ;"); WriteNl (f);
               END;
            END;
         END;

      | Tree.NilTest:
         WriteS (f, "      IF "); WritePathWide (Pattern^.NilTest.Path); 
         WriteS (f, " # NIL THEN EXIT END (* IF *) ;"); WriteNl (f);

      | Tree.DontCare1Explicit , Tree.DontCare1Internal :
      | Tree.DontCareExplicit , Tree.DontCareInternal : RETURN;

      | Tree.Value: WITH Pattern^.Value DO
            AssignTempo (Expr);
            WriteS (f, "      IF NOT (equal"); Module (Formals^.Formal.TypeDesc);
            WriteS (f, " ( "); WritePathNarrow ( Path ); 
            WriteS (f, " , "); Expression (Expr); WriteS (f, " ) ) THEN EXIT END (* IF *) ;"); WriteNl (f);
            MatchExpr (Expr);
         END;
      END;
      Match (t^.OnePattern.Next, Formals^.Formal.Next);
   END Match;

(* MatchExprs and MatchExpr traverse over expression(s) and, for any contained
   Call of a puma routine which has out actuals (i.e. patterns), calls match 
   for the patterns. *) 

PROCEDURE MatchExprs (t: tTree);
   BEGIN
      IF t^.Kind = Tree.NoExpr THEN RETURN; END;
      IF Tree . IsType ( t^.OneExpr.Expr , Tree.DontCare ) THEN RETURN; END;
      MatchExpr (t^.OneExpr.Expr);
      MatchExprs (t^.OneExpr.Next);
   END MatchExprs;

PROCEDURE MatchExpr (t: tTree);
   BEGIN
      CASE t^.Kind OF
      | Tree.Compose:
         MatchExprs (t^.Compose.Exprs);

      | Tree.VarUse     :
      | Tree.Nil        :
      | Tree.DontCare1Explicit  :
      | Tree.DontCare1Internal  :
      | Tree.TargetExpr :
      | Tree.StringExpr :
      | Tree.AttrDesc   :

      | Tree.Call       : WITH t^.Call DO
            MatchExpr (Expr);
            MatchExprs (Exprs);
            IF Object # NoTree THEN
               Match (Patterns, Object^.Routine.OutForm);
            END;
         END;

      | Tree.Binary     : WITH t^.Binary DO
            MatchExpr (Lop);
            MatchExpr (Rop);
         END;

      | Tree.PreOperator :
         MatchExpr (t^.PreOperator.Expr);

      | Tree.PostOperator     :
         MatchExpr (t^.PostOperator.Expr);

      | Tree.Index      :
         MatchExpr (t^.Index.Expr);
         MatchExprs (t^.Index.Exprs);

      | Tree.Parents    :
         MatchExpr (t^.Parents.Expr);
      END;
   END MatchExpr;

PROCEDURE AssignTempos (t: tTree);
   BEGIN
      IF t^.Kind = Tree.NoExpr THEN RETURN; END;
      IF Tree . IsType ( t^.OneExpr.Expr , Tree.DontCare ) THEN RETURN; END;
      AssignTempo (t^.OneExpr.Expr);
      AssignTempos (t^.OneExpr.Next);
   END AssignTempos;

PROCEDURE AssignTempo (t: tTree);
   VAR TreeName : tIdent;
   BEGIN
      CASE t^.Kind OF
      | Tree.Compose: WITH t^.Compose DO
            TreeName := Object^.Class.TypeDesc^.NodeTypes.TreeName^.TreeName.Name;
            WriteS (f, "      "); WI (Tempo); WriteS (f, " := NEW ( "); WI (TreeName);      
            WriteS (f, " . "); WI (Object^.Class.Name);  WriteS (f, " ) ;"); WriteNl (f);
            IF ( Exprs ^ . Kind = Tree. OneExpr ) 
               AND NOT Tree . IsType ( Exprs ^ . OneExpr . Expr , Tree.DontCare ) 
            THEN
               AssignFormals ( Exprs , Object ^ . Class . Formals , Tempo ) ;
            END;
         END;

      | Tree.VarUse     :
      | Tree.Nil        :
      | Tree.DontCare1Explicit  :
      | Tree.DontCare1Internal  :
      | Tree.TargetExpr :
      | Tree.StringExpr :
      | Tree.AttrDesc   :

      | Tree.Call       : WITH t^.Call DO
            AssignTempo (Expr); 
            (* 

*) 
            AssignTempos (Exprs);
         END;

      | Tree.Binary     : WITH t^.Binary DO
            AssignTempo (Lop);
            AssignTempo (Rop);
         END;

      | Tree.PreOperator :
         AssignTempo (t^.PreOperator.Expr);

      | Tree.PostOperator     :
         AssignTempo (t^.PostOperator.Expr);

      | Tree.Index      :
         AssignTempo (t^.Index.Expr);
         AssignTempos (t^.Index.Exprs);

      | Tree.Parents    :
         AssignTempo (t^.Parents.Expr);
      END;
   END AssignTempo;

PROCEDURE MakeWith ( Id : tIdent ): tIdent;
   VAR String1, String2 : Strings . tString;
   BEGIN
      ArrayToString ( "yyWITH_" , String1 ) ; 
      GetString ( Id , String2 ) ; 
      Concatenate (String1, String2);
      RETURN MakeIdent (String1);
   END MakeWith;

PROCEDURE WritePrefixIdent ( Id : tIdent ) ; 
  BEGIN 
    IF Id # NoIdent 
    THEN 
      WI ( Id ) ; 
      WriteS (f, " . "); 
    END (* IF *) 
  END WritePrefixIdent ; 

(* Generate assignments to a formals list *) 

PROCEDURE AssignFormals (t, Formals: tTree ; PrefixIdent : tIdent );
   BEGIN
      IF (t^.Kind = Tree.NoExpr) 
         OR NOT Tree . IsType ( Formals , Tree . Formal ) 
      THEN RETURN; 
      END;
      IF Tree . IsType ( t^.OneExpr.Expr , Tree.DontCare ) THEN
         BeginFormals ( Formals , PrefixIdent );
         RETURN;
      END;
      AssignFormal (t^.OneExpr.Expr, Formals , PrefixIdent );
      AssignFormals (t^.OneExpr.Next, Formals^.Formal.Next , PrefixIdent );
   END AssignFormals;

PROCEDURE AssignFormal (t, Formals: tTree ; PrefixIdent : tIdent );
   VAR TreeName : tIdent;
   VAR LWithTemp : tIdent;
   BEGIN
      IF t^.Kind = Tree.Compose THEN
         WITH t^.Compose DO
            TreeName := Object^.Class.TypeDesc^.NodeTypes.TreeName^.TreeName.Name;
            IF ( Exprs ^ . Kind = Tree . OneExpr ) 
               AND NOT Tree . IsType ( Exprs ^ . OneExpr.Expr , Tree.DontCare ) 
            THEN
              LWithTemp := MakeWith ( Formals^.Formal.Name ) ; 
              WriteS (f, "      WITH "); WI ( LWithTemp ); WriteS (f, " := NEW ( "); WI (TreeName); 
              WriteS (f, " . "); WI (Object^.Class.Name); WriteS (f, " ) DO"); WriteNl (f);
              WriteS (f, "      "); WI (Formals^.Formal.Name); WriteS (f, " := "); WI ( LWithTemp ) ; WriteS (f, " ;"); WriteNl (f);
              AssignFormals (Exprs, Object^.Class.Formals , LWithTemp );
              WriteS (f, "      END (* WITH *) ;"); WriteNl (f);
            ELSE 
              WriteS (f, "      "); WI (Formals^.Formal.Name); WriteS (f, " := NEW ( "); WI (TreeName); 
              WriteS (f, " . "); WI (Object^.Class.Name); WriteS (f, " )"); WriteNl (f);
            END;
         END;
      ELSE
         AssignTempo (t);
      END;

      CASE t^.Kind OF
      | Tree.VarUse, Tree.Nil, Tree.Call, Tree.Binary, Tree.PreOperator,
        Tree.PostOperator, Tree.Index, Tree.Parents, Tree.TargetExpr
        , Tree.StringExpr, Tree.AttrDesc:
         WriteS (f, "      "); WritePrefixIdent ( PrefixIdent ) ; 
                  WI (Formals^.Formal.Name); WriteS (f, " := "); Expression (t); WriteS (f, " ;"); WriteNl (f);
      | Tree.DontCare1Explicit , Tree.DontCare1Internal :
         WriteS (f, "      begin"); Module (Formals^.Formal.TypeDesc); WriteS (f, " ( "); 
                WritePrefixIdent ( PrefixIdent ) ;  WI (Formals^.Formal.Name); WriteS (f, " ) "); WriteNl (f);
      ELSE
      END;
   END AssignFormal;

PROCEDURE BeginFormals (Formals: tTree ; PrefixIdent : tIdent );
   BEGIN
      IF Tree . IsType ( Formals , Tree . Formal ) 
      THEN
         WITH Formals^.Formal DO
            WriteS (f, "      begin"); Module (TypeDesc); 
            WriteS (f, " ( "); WritePrefixIdent ( PrefixIdent ) ; WI (Name); WriteS (f, " )"); WriteNl (f);
            BeginFormals ( Next , PrefixIdent );
         END;
      END;
   END BeginFormals;

PROCEDURE ConsPatterns (t: tTree; ListCount: INTEGER): INTEGER;
   BEGIN
      IF t^.Kind = Tree.NoPattern THEN RETURN ListCount; END;
      WITH t^.OnePattern DO
         IF Tree . IsType ( Pattern , Tree.DontCare ) THEN
            RETURN ConsTempos (Pattern^.DontCare.Tempos, ListCount);
         ELSE
            IF ListCount > 0 THEN WriteS (f, " , "); END;
            WI (Pattern^.Pattern.Tempo);
            RETURN ConsPatterns (Next, ListCount + 1);
         END;
      END;
   END ConsPatterns;

PROCEDURE ConsTempos (t: tTree; ListCount: INTEGER): INTEGER;
   BEGIN
      IF Tree . IsType ( t , Tree . Formal )
      THEN
         IF ListCount > 0 THEN WriteS (f, " , "); END;
         WI (t^.Formal.Name);
         RETURN ConsTempos (t^.Formal.Next, ListCount + 1);
      ELSE
         RETURN ListCount;
      END;
   END ConsTempos;

PROCEDURE Expressions (t: tTree; ListCount: INTEGER): INTEGER;
   BEGIN
      IF t^.Kind = Tree.NoExpr THEN RETURN ListCount; END;
      WITH t^.OneExpr DO
         IF Tree . IsType ( Expr , Tree.DontCare ) THEN
            RETURN ConsTempos (Expr^.DontCare.Tempos, ListCount);
         ELSE
            IF ListCount > 0 THEN WriteS (f, " , "); END;
            Expression (Expr);
            RETURN Expressions (Next, ListCount + 1);
         END;
      END;
   END Expressions;

PROCEDURE Expression (t: tTree);
   BEGIN
      CASE t^.Kind OF
      | Tree.Compose : WI (t^.Compose.Tempo);

      | Tree.Nil : WriteS (f, "NIL"); 

      | Tree.VarUse     
          : WITH t^.VarUse DO
              IF Object # NoTree THEN
                 WritePathNarrow (Object^.Formal.Path);
              ELSE
                 WI (Name);
              END;
            END;

      | Tree.DontCare1Explicit , Tree.DontCare1Internal 
          : WI (t^.DontCare1.Tempo);

      | Tree.Call       : WITH t^.Call DO
            Expression (Expr); WriteS (f, " ( "); 
            ListCount := Expressions (Exprs, 0);
            IF Object # NoTree THEN
               ListCount := ConsPatterns (Patterns, ListCount);
            ELSE
               ListCount := Expressions (Patterns, ListCount);
            END;
            WriteS (f, " )"); 
         END;

      | Tree.Binary : 
         (* Semantics now transforms "." constructs into "::", where
            it makes sense.  *) 
         WITH t^.Binary DO
            Expression (Lop); WriteS (f, " "); WI (Operator); WriteS (f, " "); Expression (Rop);
         END;

      | Tree.PreOperator        :
         WI (t^.PreOperator.Operator); WriteS (f, " "); Expression (t^.PreOperator.Expr);

      | Tree.PostOperator       :
         Expression (t^.PostOperator.Expr); WriteS (f, " "); WI (t^.PostOperator.Operator);

      | Tree.Index      :
         Expression (t^.Index.Expr); 
         WriteS (f, " [ "); ListCount := Expressions (t^.Index.Exprs, 0); WriteS (f, " ]"); 

      | Tree.Parents    : WriteS (f, "( "); Expression (t^.Parents.Expr); WriteS (f, " )"); 

      | Tree.TargetExpr : Module (t^.TargetExpr.Expr);

      | Tree.StringExpr : WriteString (f, t^.StringExpr.String);

      | Tree.AttrDesc   : WITH t^.AttrDesc DO
            PathPrefix ( Object^.Formal.Path , FALSE ) ; 
            WriteS (f, " . "); WI (Attribute);
         END;
      END;
   END Expression;

PROCEDURE OpenWITHRenames (t, Formals: tTree)
; VAR Object , LSubFormals , LPath : tTree 
; VAR Count : CARDINAL 
; VAR FormalName : tIdent 

;  PROCEDURE OpenWITHRenamesAttrs ( AttrFormals : tTree ) 
   ; VAR LNewFormalName : tIdent 
   ; VAR LString1 , LString2 : Strings . tString 
   ; BEGIN
       IF Tree . IsType ( AttrFormals , Tree . Formal )
       THEN 
         (* This renaming would need some work, requiring a routine 
            which does something like PathPrefix, but builds a tIdent 
            to compare to, instead of writing. Since the constructed 
            identifiers have _yy_ in them, consider it too unlikely
            they will clash with a user-defined child/field name 
            and forget the renaming. 
             IF AttrFormals ^ . Formal . Name = FormalName 
             THEN (* Rename FormalName, possibly again. *) 
               ArrayToString ( "yy_Rename_" , LString1 ) ;
               GetString ( FormalName , LString2 ) ; 
               Concatenate ( LString1 , LString2 ) ; 
               LNewFormalName := MakeIdent ( LString1 ) ; 
               WriteS (f, "      "); WI ( LNewFormalName ) ; 
               WriteS (f, " = "); WI ( FormalName  ) ; WriteS (f, " ; "); 
               FormalName := LNewFormalName ; 
             ELSE 
             END (* IF *) ; 
         *) 
         IF Count = 0 THEN WriteS (f, "        "); ELSE WriteS (f, "      , "); END (* IF *) ; 
         INC ( Count ) ; 
         WI ( AttrFormals ^ . Formal . Name ) ; 
         WriteS (f, " = "); PathPrefix ( LPath , FALSE ) ;   
               WriteS (f, "_yy_"); WI ( t ^ . OnePattern . Pattern ^ . Decompose . Object 
                           ^ . Class . Name 
                         ) ;
                 (* Its type is t ^ . OnePattern . Pattern ^ . Decompose . Object 
                    ^ . Class . Name  *)
         WriteS (f, " . "); WI ( AttrFormals ^ . Formal . Name ) ; WriteNl (f);
                 (* 
*) 
         OpenWITHRenamesAttrs ( AttrFormals ^ . Formal . Next ) ; 
       END (* IF *) ; 
     END OpenWITHRenamesAttrs ;

   BEGIN (* OpenWITHRenames *) 
      IF (t^.Kind = Tree.NoPattern) 
         OR (Formals^.Kind = Tree.NoFormal) 
      THEN RETURN; 
      END;
      CASE t^.OnePattern.Pattern^.Kind OF
      | Tree.Decompose:
         Object := t^.OnePattern.Pattern^.Decompose.Object ; 
         IF Object # NoTree 
         THEN                 
           LSubFormals := Object ^ . Class . Formals ; 
           IF Tree . IsType ( LSubFormals , Tree . Formal ) 
           THEN 
             WriteS (f, "    WITH (* Renames *) "); WriteNl (f);
             LPath := t^.OnePattern.Pattern^.Decompose.Path ; 
             Count := 0 ; 
             (* FormalName 
                  := PathPrefixIdent ( LPath , Object ^ . Class . Name ) ; *)
               (* Formals ^ . Formal . Name might need to be renamed later. *) 
             OpenWITHRenamesAttrs ( LSubFormals ) ; 
             WriteS (f, "    DO (* Renames *) "); WriteNl (f);
             OpenWITHRenames (
                t^.OnePattern.Pattern^.Decompose.Patterns , LSubFormals ) ; 
           END (* IF *) 
         END (* IF *) 
      | Tree.VarDef , Tree.NilTest , Tree.Value , Tree.DontCare1Explicit
        , Tree.DontCare1Internal :
      ELSE RETURN;
      END;
      OpenWITHRenames (t^.OnePattern.Next, Formals^.Formal.Next);
   END OpenWITHRenames;

PROCEDURE CloseWITHRenames (t, Formals: tTree)
; VAR Object , LSubFormals : tTree 
; BEGIN (* CloseWITHRenames *) 
      IF (t^.Kind = Tree.NoPattern) 
         OR (Formals^.Kind = Tree.NoFormal) 
      THEN RETURN; 
      END;
      CASE t^.OnePattern.Pattern^.Kind OF
      | Tree.Decompose:
         Object := t^.OnePattern.Pattern^.Decompose.Object ; 
         IF Object # NoTree 
         THEN                 
           LSubFormals := Object ^ . Class . Formals ; 
           IF Tree . IsType ( LSubFormals , Tree . Formal ) 
           THEN 
             CloseWITHRenames 
               ( t^.OnePattern.Pattern^.Decompose.Patterns , LSubFormals ) ; 
             WriteS (f, "    END (* WITH Renames *) "); WriteNl (f);
           END (* IF *) 
         END (* IF *) 
      | Tree.VarDef , Tree.NilTest , Tree.Value , Tree.DontCare1Explicit
        , Tree.DontCare1Internal :
      ELSE RETURN;
      END;
      CloseWITHRenames (t^.OnePattern.Next, Formals^.Formal.Next);
   END CloseWITHRenames;



































































PROCEDURE yyAbort (yyFunction: ARRAY OF CHAR);
 BEGIN
  IO.WriteS (IO.StdError, 'Error: module M3, routine ');
  IO.WriteS (IO.StdError, yyFunction);
  IO.WriteS (IO.StdError, ' failed');
  IO.WriteNl (IO.StdError);
  Exit;
 END yyAbort;

PROCEDURE yyIsEqual (yya, yyb: ARRAY OF SYSTEM.BYTE): BOOLEAN;
 VAR yyi       : INTEGER;
 BEGIN
  FOR yyi := 0 TO INTEGER (HIGH (yya)) DO
   IF yya [yyi] # yyb [yyi] THEN RETURN FALSE; END;
  END;
  RETURN TRUE;
 END yyIsEqual;

PROCEDURE MacroM3 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Spec:
(* line 609 "" *)
     WITH t^.Spec DO
(* line 609 "" *)
      
        MacroM3 (TreeNames);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TreeName:
(* line 612 "" *)
     WITH t^.TreeName DO
(* line 612 "" *)
      
        WriteS (f, "# define begint"); WI (Name); WriteS (f, "(a)       a := NIL;"); WriteNl (f);
        WriteS (f, "# define equalt"); WI (Name); WriteS (f, "(a, b)    "); WI (Name); 
        WriteS (f, ".IsEqual"); WI (Name); WriteS (f, " (a, b)"); WriteNl (f);
        MacroM3 (Next);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END MacroM3;

PROCEDURE Interface (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Spec:
(* line 622 "" *)
     WITH t^.Spec DO
(* line 622 "" *)
      
        WriteNl (f);
        WriteS (f, "(* This interface file was mechanically generated by puma. *)"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "INTERFACE "); WI (TrafoName); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "IMPORT Wr "); Interface (TreeNames); WriteS (f, " ;"); WriteNl (f);
        WriteS (f, "    "); WriteLine (Codes^.Codes.ImportLine);
        WriteText (f, Codes^.Codes.Import);
        WriteNl (f);
        WriteS (f, "    "); WriteLine (Codes^.Codes.ExportLine);
        WriteText (f, Codes^.Codes.Export);
        WriteNl (f);
        WriteS (f, "VAR yyf        : Wr . T ;"); WriteNl (f);
        WriteS (f, "VAR Exit       : PROCEDURE ( ) ;"); WriteNl (f);
        WriteNl (f);
        Interface (Public);
        WriteNl (f);
        WriteS (f, "PROCEDURE Begin"); WI (TrafoName); WriteS (f, " ( ) ;"); WriteNl (f);
        WriteS (f, "PROCEDURE Close"); WI (TrafoName); WriteS (f, " ( ) ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "END "); WI (TrafoName); WriteS (f, " ."); WriteNl (f);
        WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TreeName:
(* line 646 "" *)
     WITH t^.TreeName DO
(* line 646 "" *)
      
        WriteS (f, ", "); WI (Name);
        Interface (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Name:
(* line 650 "" *)
     WITH t^.Name DO
(* line 650 "" *)
      
        IF Object # NoTree THEN
           ListCount := 0;
           WriteS (f, "PROCEDURE "); WI (Name); WriteS (f, " ("); 
           Interface (Object^.Routine.InForm);
           Interface (Object^.Routine.OutForm);
           WriteS (f, ")"); 
           IF Object^.Kind = Tree.Predicate THEN
              WriteS (f, ": BOOLEAN"); 
           ELSIF Object^.Kind = Tree.Function THEN
              WriteS (f, ": "); Interface (Object^.Function.ReturnForm^.Formal.TypeDesc);
           END;
           WriteS (f, ";"); WriteNl (f);
        END;
        Interface (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.RoutineFormal:
  IF (t^.RoutineFormal.TypeDesc^.Kind = Tree.NodeTypes) THEN
  IF (t^.RoutineFormal.TargetClass^.Kind = Tree.Class) THEN
  IF (t^.RoutineFormal.TargetClass^.Class.TypeDesc^.Kind = Tree.NodeTypes) THEN
(* line 666 "" *)
     WITH t^.RoutineFormal DO
     WITH TypeDesc^.NodeTypes DO
     WITH TreeName^.TreeName DO
     WITH TargetClass^.Class DO
     WITH TypeDesc^.NodeTypes DO
(* line 673 "" *)
       IF ListCount > 0 THEN WriteS (f, "; "); END;
       IF Path^.Var.IsOutput THEN WriteS (f, "VAR "); END;
       WI ( t^.RoutineFormal.Name ) ; WriteS (f, " : "); 
       WI ( t^.RoutineFormal.TypeDesc^.NodeTypes.TreeName^.TreeName.Name ) ; WriteS (f, " . "); WriteNl (f);
       WI (  TargetClass ^ . Class . Name ) ;  
       INC (ListCount);
       Interface ( t^.RoutineFormal.Next);
     ;
      RETURN;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;
     END (* WITH *) ;

  END;
  END;
  END;
  ELSE END;


  CASE t^.Kind OF
  | Tree.Formal
  , Tree.PlainFormal
  , Tree.RoutineFormal:
(* line 692 "" *)
     WITH t^.Formal DO
(* line 692 "" *)
      
        IF ListCount > 0 THEN WriteS (f, "; "); END;
        IF Path^.Var.IsOutput THEN WriteS (f, "VAR "); END;
        WI (Name); WriteS (f, ": "); 
        Interface (TypeDesc);
        INC (ListCount);
        Interface (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.NodeTypes:
(* line 700 "" *)
     WITH t^.NodeTypes DO
(* line 700 "" *)
      
        WI (TreeName^.TreeName.Name); WriteS (f, " .t"); WI (TreeName^.TreeName.Name);
;
      RETURN;
     END (* WITH *) ;

  | Tree.UserType:
(* line 703 "" *)
     WITH t^.UserType DO
(* line 703 "" *)
      
        WI (Type);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Interface;

PROCEDURE NeedsWITHStmt (t: Tree.tTree): BOOLEAN;

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN FALSE; END;
(* line 710 "" *)
   LOOP
     WITH t^.Rule DO
(* line 710 "" *)
      IF NOT (( IsElement (ORD ('w'), Options) )) THEN EXIT; END;
(* line 711 "" *)
      IF NOT (( ( Statements^.Kind <> Tree.NoStatement ) 
                 OR ( Exprs^.Kind <> Tree.NoExpr ) 
                 OR ( Expr^.Kind <> Tree.NoExpr ) 
               )) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  RETURN FALSE;
 END NeedsWITHStmt;

PROCEDURE Module (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 5: yyR5: RECORD
  LTypeCaseDepth: CARDINAL;
  END;
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Spec:
(* line 721 "" *)
     WITH t^.Spec DO
(* line 721 "" *)
      
        WriteNl (f);
        WriteS (f, "(* This module file was mechanically generated by puma. *)"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "MODULE "); WI (TrafoName); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "IMPORT Wr , Stdio , Process "); Interface (TreeNames); WriteS (f, " ;"); WriteNl (f);
        WriteS (f, "# define yyWrite(s) Wr.PutText (yyf, s)"); WriteNl (f);
        WriteS (f, "# define yyWriteNl Wr.PutText(yyf,Wr.EOL)"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "    "); WriteLine (Codes^.Codes.GlobalLine);
        WriteText (f, Codes^.Codes.Global);
        WriteNl (f);
        WriteS (f, '# include "yy'); WI (TrafoName); WriteS (f, '.w"'); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyAbort ( yyFunction : TEXT )"); WriteNl (f);
        WriteS (f, "= BEGIN"); WriteNl (f);
        WriteS (f, '    Wr . PutText '); WriteNl (f);
        WriteS (f, '      (Stdio . stderr, "Error: module '); WI (TrafoName); WriteS (f, ', routine " ) ;'); WriteNl (f);
        WriteS (f, "    Wr . PutText (Stdio . stderr, yyFunction);"); WriteNl (f);
        WriteS (f, '    Wr . PutText (Stdio . stderr, " failed" ) ;'); WriteNl (f);
        WriteS (f, "    Wr . PutText (Stdio . stderr , Wr . EOL ) ;"); WriteNl (f);
        WriteS (f, "    Exit ( ) "); WriteNl (f);
        WriteS (f, "   END yyAbort ;"); WriteNl (f);
        WriteNl (f);


        Module (Routines);
        WriteS (f, "PROCEDURE Begin"); WI (TrafoName); WriteS (f, " ( )"); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteS (f, "    "); WriteLine (Codes^.Codes.BeginLine);
        WriteText (f, Codes^.Codes.Begin);
        WriteNl (f);
        WriteS (f, " END Begin"); WI (TrafoName); WriteS (f, " ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE Close"); WI (TrafoName); WriteS (f, "( )"); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteS (f, "    "); WriteLine (Codes^.Codes.CloseLine);
        WriteText (f, Codes^.Codes.Close);
        WriteNl (f);
        WriteS (f, " END Close"); WI (TrafoName); WriteS (f, " ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyExit ( )"); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteS (f, "   Process . Exit ( 1 ) ;"); WriteNl (f);
        WriteS (f, " END yyExit ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "BEGIN"); WriteNl (f);
        WriteS (f, " yyf   := Stdio . stdout ;"); WriteNl (f);
        WriteS (f, " Exit  := yyExit;"); WriteNl (f);
        WriteS (f, " Begin"); WI (TrafoName); WriteS (f, " ( ) ;"); WriteNl (f);
        WriteS (f, "END "); WI (TrafoName); WriteS (f, "."); WriteNl (f);
        WriteNl (f);
        TypeCaseDepth := 0 ; 
;
      RETURN;
     END (* WITH *) ;

  | Tree.Procedure:
(* line 785 "" *)
     WITH t^.Procedure DO
(* line 785 "" *)
      
        ListCount := 0;
        WriteS (f, "PROCEDURE "); WI (Name); WriteS (f, " ( "); 
        Interface (InForm);
        Interface (OutForm);
        WriteS (f, " ) ="); WriteNl (f);
        WriteS (f, "    "); WriteLine (LocalLine);
        WriteText (f, Local);
        WriteNl (f);
        RoutineKind := kProcedure;
        InFormals := InForm;
        OutFormals := OutForm;
        WriteS (f, " BEGIN"); WriteNl (f);
      IF IsElement (ORD ('n'), Options) THEN
        NilCheck (InForm);
      END;
      IF IsElement (ORD ('b'), Options) THEN
        Module (Rules);
        IF IsElement (ORD ('f'), Options) THEN
           WriteS (f, '  yyAbort ( "'); WI (Name); WriteS (f, '" ) ;'); WriteNl (f);
        END;
      ELSE
        TemposDone := FALSE;
        CommonTestElim (Decisions);
        IF IsElement (ORD ('f'), Options) AND NOT NeedsNoFinale (Decisions) THEN
           WriteS (f, '  yyAbort ( "'); WI (Name); WriteS (f, '" ) ;'); WriteNl (f);
        END;
      END;
        WriteS (f, " END "); WI (Name); WriteS (f, " ;"); WriteNl (f);
        WriteNl (f);
        Module (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Function:
(* line 817 "" *)
     WITH t^.Function DO
(* line 817 "" *)
      
        ListCount := 0;
        WriteS (f, "PROCEDURE "); WI (Name); WriteS (f, " ( "); 
        Interface (InForm);
        Interface (OutForm);
        WriteS (f, " ) : "); Interface (ReturnForm^.Formal.TypeDesc); WriteS (f, "="); WriteNl (f);
        WriteS (f, "    "); WriteLine (LocalLine);
        WriteText (f, Local);
        WriteNl (f);
        RoutineKind := kFunction;
        InFormals := InForm;
        OutFormals := OutForm;
        ReturnFormals := ReturnForm;
        WriteS (f, " BEGIN"); WriteNl (f);
      IF IsElement (ORD ('b'), Options) THEN
        Module (Rules);
        WriteS (f, '  yyAbort ( "'); WI (Name); WriteS (f, '" ) ;'); WriteNl (f);
      ELSE
        TemposDone := FALSE;
        CommonTestElim (Decisions);
        IF NOT NeedsNoFinale (Decisions) THEN
           WriteS (f, '  yyAbort (" '); WI (Name); WriteS (f, '" ) ;'); WriteNl (f);
        END;
      END;
        WriteS (f, " END "); WI (Name); WriteS (f, " ;"); WriteNl (f);
        WriteNl (f);
        Module (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Predicate:
(* line 845 "" *)
     WITH t^.Predicate DO
(* line 845 "" *)
      
        ListCount := 0;
        WriteS (f, "PROCEDURE "); WI (Name); WriteS (f, " ( "); 
        Interface (InForm);
        Interface (OutForm);
        WriteS (f, " ) : BOOLEAN = "); WriteNl (f);
        WriteS (f, "    "); WriteLine (LocalLine);
        WriteText (f, Local);
        WriteNl (f);
        RoutineKind := kPredicate;
        InFormals := InForm;
        OutFormals := OutForm;
        WriteS (f, " BEGIN"); WriteNl (f);
      IF IsElement (ORD ('n'), Options) THEN
        NilCheck (InForm);
      END;
      IF IsElement (ORD ('b'), Options) THEN
        Module (Rules);
        WriteS (f, "  RETURN FALSE;"); WriteNl (f);
      ELSE
        TemposDone := FALSE;
        CommonTestElim (Decisions);
        IF NOT NeedsNoFinale (Decisions) THEN
           WriteS (f, "  RETURN FALSE;"); WriteNl (f);
        END;
      END;
        WriteS (f, " END "); WI (Name); WriteS (f, " ;"); WriteNl (f);
        WriteNl (f);
        Module (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Rule:
(* line 875 "" *)
    WITH yyTempo.yyR5 DO  
     WITH t^.Rule DO
(* line 876 "" *)
      ;
(* line 877 "" *)
      
        WriteS (f, "    "); WriteLine (Line);
        IF HasTempos 
        THEN 
          WriteS (f, "    (* Tempo declarations, Module: *)"); WriteNl (f);
          Declare ( t ) ; 
          WriteS (f, "    BEGIN (* Block of Tempo declarations, Module *)"); WriteNl (f);
        END;
        WriteS (f, "   LOOP"); WriteNl (f);
        Decls := VarDecls;
        LTypeCaseDepth := TypeCaseDepth ; 
        Match (Patterns, InFormals);
      IF NeedsWITHStmt ( t ) 
      THEN 
        OpenWITHRenames (Patterns, InFormals);
      END;
        Module (Statements);
        IF NOT HasRejectOrFail THEN
           AssignFormals (Exprs, OutFormals , NoIdent );
           MatchExprs (Exprs);
           CASE RoutineKind OF
           | kProcedure: WriteS (f, "      RETURN;"); WriteNl (f);

           | kFunction :
              AssignTempo (Expr);
              IF HasPatterns 
                 AND ( Expr ^ . Kind # Tree . Compose ) 
                 AND NOT Tree . IsType ( t , Tree . DontCare1 ) 
                      
                 THEN
                 WriteS (f, "      "); WI (Tempo); WriteS (f, " := "); Expression (Expr); WriteS (f, ";"); WriteNl (f);
                 MatchExpr (Expr);
                 WriteS (f, "      RETURN "); WI (Tempo); WriteS (f, ";"); WriteNl (f);
              ELSE
                 MatchExpr (Expr);
                 WriteS (f, "      RETURN "); Expression (Expr); WriteS (f, ";"); WriteNl (f);
              END;

           | kPredicate: WriteS (f, "      RETURN TRUE;"); WriteNl (f);
           END;
        END;
        CloseTypeCases ( LTypeCaseDepth ) ; 
      IF NeedsWITHStmt ( t ) 
      THEN 
        CloseWITHRenames (Patterns, InFormals);
      END;
        WriteS (f, "   END (* LOOP *) ;"); WriteNl (f);
        IF HasTempos THEN WriteS (f, "    END (* Block of Tempo declarations, Module *) ;"); WriteNl (f);
        END;
        WriteNl (f);
        Module (Next);
;
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.ProcCall:
(* line 929 "" *)
     WITH t^.ProcCall DO
(* line 930 "" *)
      
        WriteS (f, "      "); WriteLine (Pos);
        AssignTempo (Call);
        WriteS (f, "      "); Expression (Call); WriteS (f, ";"); WriteNl (f);
        MatchExpr (Call);
        Module (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Condition:
(* line 937 "" *)
     WITH t^.Condition DO
(* line 938 "" *)
      
        WriteS (f, "      "); WriteLine (Pos);
        AssignTempo (Expr);
        WriteS (f, "      IF NOT ( "); Expression (Expr); WriteS (f, " ) THEN EXIT END (* IF *) ;"); WriteNl (f);
        MatchExpr (Expr);
        Module (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Assignment:
(* line 945 "" *)
     WITH t^.Assignment DO
(* line 946 "" *)
      
        WriteS (f, "      "); WriteLine (Pos);
        AssignTempo (Adr);
        AssignTempo (Expr);
        IF Object # NoTree THEN
           WriteS (f, "      "); WritePathWide (Object^.Formal.Path);
        ELSE
           WriteS (f, "      "); Expression (Adr);
        END;
        WriteS (f, " := "); Expression (Expr); WriteS (f, " ;"); WriteNl (f);
        MatchExpr (Adr);
        MatchExpr (Expr);
        Module (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Reject:
(* line 960 "" *)
     WITH t^.Reject DO
(* line 960 "" *)
      
        WriteS (f, "      "); WriteLine (Pos);
        WriteS (f, "      EXIT;"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Fail:
(* line 964 "" *)
     WITH t^.Fail DO
(* line 964 "" *)
      
        WriteS (f, "      "); WriteLine (Pos);
        WriteS (f, "      RETURN "); IF RoutineKind = kPredicate THEN WriteS (f, "FALSE "); END; WriteS (f, ";"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TargetStmt:
(* line 968 "" *)
     WITH t^.TargetStmt DO
(* line 968 "" *)
      
        WriteS (f, "      "); WriteLine (Pos);
        WriteS (f, "      "); Module (Stmt); WriteS (f, ";"); WriteNl (f);
        Module (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Nl:
(* line 973 "" *)
     WITH t^.Nl DO
(* line 973 "" *)
      
        WriteS (f, "      "); WriteLine (Pos);
        WriteS (f, "      yyWriteNl;"); WriteNl (f);
        Module (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.WriteStr:
(* line 978 "" *)
     WITH t^.WriteStr DO
(* line 978 "" *)
      
        WriteS (f, "      "); WriteLine (Pos);
        WriteS (f, "      yyWrite ( "); WriteString (f, String); WriteS (f, " ) ;"); WriteNl (f);
        Module (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Ident:
(* line 983 "" *)
     WITH t^.Ident DO
(* line 983 "" *)
      
        IF Object # NoTree 
        THEN 
          WritePathNarrow (Object^.Formal.Path); 
        ELSE 
          WI (Attribute); 
        END;
        Module (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Any:
(* line 992 "" *)
     WITH t^.Any DO
(* line 992 "" *)
      
        StringMem . WriteString (f, Code); 
         
        Module (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Anys:
(* line 997 "" *)
     WITH t^.Anys DO
(* line 997 "" *)
      
        Module (Layouts);
        Module (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.LayoutAny:
(* line 1001 "" *)
     WITH t^.LayoutAny DO
(* line 1001 "" *)
      
        StringMem . WriteString (f, Code); 
         
        Module (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Designator:
(* line 1006 "" *)
     WITH t^.Designator DO
(* line 1006 "" *)
      
        PathPrefix ( Object^.Formal.Path , FALSE ) ; WriteS (f, " . "); WI (Attribute);
        Module (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Field:
(* line 1010 "" *)
     WITH t^.Field DO
(* line 1010 "" *)
      
      Assertions . CantHappen ( "Module called on Field" ) ; 
;
      RETURN;
     END (* WITH *) ;

  | Tree.ConsType:
(* line 1013 "" *)
     WITH t^.ConsType DO
(* line 1013 "" *)
      
      Assertions . CantHappen ( "Module called on ConsType" ) ; 
;
      RETURN;
     END (* WITH *) ;

  | Tree.Var:
(* line 1016 "" *)
     WITH t^.Var DO
(* line 1016 "" *)
      
      Assertions . CantHappen ( "Module called on Var" ) ; 
;
      RETURN;
     END (* WITH *) ;

  | Tree.NodeTypes:
(* line 1019 "" *)
     WITH t^.NodeTypes DO
(* line 1019 "" *)
      
        WriteS (f, "t"); WI (TreeName^.TreeName.Name);
;
      RETURN;
     END (* WITH *) ;

  | Tree.UserType:
(* line 1022 "" *)
     WITH t^.UserType DO
(* line 1022 "" *)
      
        WI (Type);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Module;

PROCEDURE PathPrefix (FPath: Tree.tTree; IsNarrowed: BOOLEAN);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 2: yyR2: RECORD
  LIsNarrowed: BOOLEAN;
  END;
 END; END;
 BEGIN
  IF FPath = Tree.NoTree THEN RETURN; END;

  CASE FPath^.Kind OF
  | Tree.Field:
(* line 1028 "" *)
     WITH FPath^.Field DO
(* line 1028 "" *)
      
        PathPrefix ( Next , IsNarrowed );
        IF IsNarrowed 
        THEN WriteS (f, "_y_");   
        ELSE WriteS (f, " . ");  
        END  ;  
        WI (Name);
;
      RETURN;
     END (* WITH *) ;

  | Tree.ConsType:
(* line 1036 "" *)
    WITH yyTempo.yyR2 DO  
     WITH FPath^.ConsType DO
(* line 1037 "" *)
      ;
(* line 1038 "" *)
       LIsNarrowed := IsNarrowed OR IsProperlyNarrowed ; 
       PathPrefix ( Next , LIsNarrowed );
       IF LIsNarrowed 
       THEN 
         WriteS (f, "_yy_"); WI (Name);
       END  ; 
     ;
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.Var:
(* line 1046 "" *)
     WITH FPath^.Var DO
(* line 1046 "" *)
      
        WI (Name);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

(* line 1049 "" *)
(* line 1049 "" *)
      
      Assertions . CantHappen ( "PathPrefix, bad node kind" ) ; 
;
      RETURN;

 END PathPrefix;

PROCEDURE WritePathWide (FPath: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF FPath = Tree.NoTree THEN RETURN; END;

  CASE FPath^.Kind OF
  | Tree.ConsType:
(* line 1055 "" *)
     WITH FPath^.ConsType DO
(* line 1055 "" *)
      WritePathWide (Next);
      RETURN;
     END (* WITH *) ;

  | Tree.Field:
(* line 1058 "" *)
     WITH FPath^.Field DO
(* line 1059 "" *)
      PathPrefix (Next, FALSE);
(* line 1060 "" *)
       WriteS (f, " . "); ; 
       WI ( Name ) ; 
     ;
      RETURN;
     END (* WITH *) ;

  | Tree.Var:
(* line 1065 "" *)
     WITH FPath^.Var DO
(* line 1065 "" *)
       WI (Name); ;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END WritePathWide;

PROCEDURE WritePathNarrow (FPath: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF FPath = Tree.NoTree THEN RETURN; END;
(* line 1069 "" *)
(* line 1069 "" *)
      PathPrefix (FPath, FALSE);
      RETURN;

 END WritePathNarrow;

PROCEDURE Declare (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 2: yyR2: RECORD
  LVar: tTree;
  END;
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Formal
  , Tree.PlainFormal
  , Tree.RoutineFormal:
(* line 1073 "" *)
     WITH t^.Formal DO
(* line 1073 "" *)
      
        WriteS (f, "       VAR "); WI (Name); WriteS (f, " : "); Interface (TypeDesc); WriteS (f, " ;"); WriteNl (f);
        Declare (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Param:
(* line 1077 "" *)
    WITH yyTempo.yyR2 DO  
     WITH t^.Param DO
(* line 1078 "" *)
      ;
(* line 1079 "" *)
        LVar := IdentifyVar (Decls, Name);
        WriteS (f, "       VAR "); WI (Name); WriteS (f, " : "); Interface (LVar^.Formal.TypeDesc); WriteS (f, " ;"); WriteNl (f);
        Declare (Next);
     ;
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.Rule:
(* line 1083 "" *)
     WITH t^.Rule DO
(* line 1083 "" *)
      
        IF HasTempos THEN
           Decls := VarDecls;
           Declare (Patterns);
           Declare (Exprs);
           IF RoutineKind = kFunction THEN
              Declare (Expr);
              IF HasPatterns 
              AND ( Expr ^ . Kind # Tree . Compose ) 
                 AND NOT Tree . IsType ( t , Tree. DontCare1 ) 
              THEN
                       
                       
                 WriteS (f, "       VAR "); WI (Tempo); 
                 WriteS (f, " : "); Interface (ReturnFormals^.Formal.TypeDesc); WriteS (f, " ;"); WriteNl (f);
              END;
           END;
           Declare (Statements);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.ProcCall:
(* line 1103 "" *)
     WITH t^.ProcCall DO
(* line 1103 "" *)
      
        Declare (Call);
        Declare (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Condition:
(* line 1107 "" *)
     WITH t^.Condition DO
(* line 1107 "" *)
      
        Declare (Expr);
        Declare (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Assignment:
(* line 1111 "" *)
     WITH t^.Assignment DO
(* line 1111 "" *)
      
        Declare (Adr);
        Declare (Expr);
        Declare (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TargetStmt:
(* line 1116 "" *)
     WITH t^.TargetStmt DO
(* line 1116 "" *)
      
        Declare (Parameters);
        Declare (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Statement
  , Tree.Reject
  , Tree.Fail
  , Tree.Nl
  , Tree.WriteStr:
(* line 1120 "" *)
     WITH t^.Statement DO
(* line 1120 "" *)
      
        Declare (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.OnePattern:
(* line 1123 "" *)
     WITH t^.OnePattern DO
(* line 1123 "" *)
      
        IF ( Pattern ^ . Pattern . Tempo # NoIdent ) 
           AND NOT Tree . IsType ( Pattern , Tree . DontCare1 ) 
        THEN
                     
           WriteS (f, "       VAR "); WI (Pattern^.Pattern.Tempo); 
           WriteS (f, " : "); Interface (Pattern^.Pattern.TypeDesc); WriteS (f, " ;"); WriteNl (f);
        END;
        Declare (Pattern);
        Declare (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.OneExpr
  , Tree.NamedExpr:
(* line 1134 "" *)
     WITH t^.OneExpr DO
(* line 1134 "" *)
      
        Declare (Expr);
        Declare (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Decompose:
(* line 1138 "" *)
     WITH t^.Decompose DO
(* line 1138 "" *)
      
        Declare (Patterns);
;
      RETURN;
     END (* WITH *) ;

  | Tree.DontCare
  , Tree.DontCareExplicit
  , Tree.DontCareInternal:
(* line 1141 "" *)
     WITH t^.DontCare DO
(* line 1141 "" *)
      
        Declare (Tempos);
;
      RETURN;
     END (* WITH *) ;

  | Tree.DontCare1
  , Tree.DontCare1Explicit
  , Tree.DontCare1Internal:
(* line 1144 "" *)
     WITH t^.DontCare1 DO
(* line 1144 "" *)
      
        IF Tempo # NoIdent THEN
           WriteS (f, "       VAR "); WI (Tempo); WriteS (f, " : "); Interface (TypeDesc); WriteS (f, " ;"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Value:
(* line 1149 "" *)
     WITH t^.Value DO
(* line 1149 "" *)
      
        Declare (Expr);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Compose:
(* line 1152 "" *)
     WITH t^.Compose DO
(* line 1152 "" *)
      
        IF Tempo # NoIdent THEN
           WriteS (f, "       VAR "); WI (Tempo); WriteS (f, " : ");  
 
           WI ( Object^.Class.TypeDesc^.NodeTypes.TreeName^.TreeName.Name);
           WriteS (f, " . "); WriteNl (f);
           WI ( Object^.Class.Name ) ; 
           WriteS (f, " ;"); WriteNl (f);
        END;
        Declare (Exprs);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Call:
(* line 1164 "" *)
     WITH t^.Call DO
(* line 1164 "" *)
      
        Declare (Expr);
        Declare (Exprs);
        Declare (Patterns);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Binary
  , Tree.yy1
  , Tree.BinaryCompound:
(* line 1169 "" *)
     WITH t^.Binary DO
(* line 1169 "" *)
      
        Declare (Lop);
        Declare (Rop);
;
      RETURN;
     END (* WITH *) ;

  | Tree.PreOperator:
(* line 1173 "" *)
     WITH t^.PreOperator DO
(* line 1175 "" *)
      
        Declare (Expr); 
;
      RETURN;
     END (* WITH *) ;

  | Tree.PostOperator:
(* line 1173 "" *)
     WITH t^.PostOperator DO
(* line 1175 "" *)
      
        Declare (Expr); 
;
      RETURN;
     END (* WITH *) ;

  | Tree.Parents:
(* line 1173 "" *)
     WITH t^.Parents DO
(* line 1175 "" *)
      
        Declare (Expr); 
;
      RETURN;
     END (* WITH *) ;

  | Tree.Index:
(* line 1178 "" *)
     WITH t^.Index DO
(* line 1178 "" *)
      
        Declare (Expr);
        Declare (Exprs);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Declare;

PROCEDURE NilCheck (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Formal
  , Tree.PlainFormal
  , Tree.RoutineFormal:
(* line 1186 "" *)
     WITH t^.Formal DO
(* line 1186 "" *)
      
        TheName := Name;
        NilCheck (TypeDesc);
        NilCheck (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.NodeTypes:
(* line 1191 "" *)
     WITH t^.NodeTypes DO
(* line 1191 "" *)
      
        WriteS (f, "  IF "); WI (TheName); WriteS (f, " = "); WI (TreeName^.TreeName.Name); WriteS (f, " . No"); 
        WI (TreeName^.TreeName.Name); 
        WriteS (f, " THEN RETURN "); IF RoutineKind = kPredicate THEN WriteS (f, "FALSE "); END; 
        WriteS (f, " ; END (* IF *) ;"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END NilCheck;

PROCEDURE CommonTestElim2 (OneTest: Tree.tTree; yyP1: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 1: yyR1: RECORD
  LTypeCaseDepth: CARDINAL;
  END;
 END; END;
 BEGIN
  IF OneTest = Tree.NoTree THEN RETURN; END;
  IF yyP1 = Tree.NoTree THEN RETURN; END;
  IF (OneTest^.Kind = Tree.TestValue) THEN
(* line 1201 "" *)
    WITH yyTempo.yyR1 DO  
   LOOP
     WITH OneTest^.TestValue DO
(* line 1202 "" *)
      IF NOT ((NeedsMatch (Expr))) THEN EXIT; END;
(* line 1203 "" *)
      ;
(* line 1205 "" *)
      CommonTestElim (OneTest);
(* line 1206 "" *)
      WriteS (f, "    LOOP");
(* line 1206 "" *)
      WriteNl (f);
(* line 1207 "" *)
      LTypeCaseDepth := TypeCaseDepth;
(* line 1208 "" *)
      MatchExpr (OneTest ^ . TestValue . Expr);
(* line 1209 "" *)
      CommonTestElim (yyP1);
(* line 1210 "" *)
      CloseTypeCases (LTypeCaseDepth);
(* line 1211 "" *)
      WriteS (f, "    EXIT; END (* LOOP *) ; ");
(* line 1211 "" *)
      WriteNl (f);
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  END;
(* line 1213 "" *)
(* line 1214 "" *)
      CommonTestElim (OneTest);
(* line 1215 "" *)
      CommonTestElim (yyP1);
      RETURN;

 END CommonTestElim2;

PROCEDURE CommonTestElim (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 8: yyR8: RECORD
  LTypeCaseDepth: CARDINAL;
  LGenerateBlock: BOOLEAN;
  END;
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Decision:
(* line 1220 "" *)
     WITH t^.Decision DO
(* line 1220 "" *)
      
        IF Cases = 0 THEN
           IF NOT TemposDone 
              AND (OneTest^.Kind = Tree.TestValue) 
              AND NeedsTempo (ThenPart, rule) 
           THEN
              WriteS (f, "    (* Tempo declarations, Decision: *)"); WriteNl (f);
              Declare ( rule ) ; 
              WriteS (f, "    BEGIN (* Block of Tempo declarations, Decision *)"); WriteNl (f);
              TemposDone := TRUE;
              CommonTestElim2 (OneTest, ThenPart);
              WriteS (f, "      ELSE"); 
              WriteS (f, "      END (* Test... *) ;"); WriteNl (f);
              DEC ( TypeCaseDepth ) ;  
              WriteS (f, "    END (* Block of Tempo declarations, Decision *) ; "); WriteNl (f);
           ELSE
              GetRule (ThenPart, rule);
              Decls := rule^.Rule.VarDecls;
              CommonTestElim2 (OneTest, ThenPart);
              WriteS (f, "      ELSE"); 
              WriteS (f, "      END (* Test... *) ;"); WriteNl (f);
              DEC ( TypeCaseDepth )
           END;
           TemposDone := FALSE;
           CommonTestElim (ElsePart);
        ELSE
           i := Cases; Case (t);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Decided:
(* line 1249 "" *)
     WITH t^.Decided DO
(* line 1249 "" *)
      
        CommonTestElim (Rule);
        IF Rule^.Rule.HasExit THEN
           TemposDone := FALSE;
           CommonTestElim (ElsePart);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.TestKind:
(* line 1256 "" *)
     WITH t^.TestKind DO
(* line 1256 "" *)
      
        WriteS (f, "      TYPECASE (* TestKind *) ");  WritePathNarrow ( Path ); WriteNl (f);
        WriteS (f, "      OF "); WI (TypeDesc^.NodeTypes.TreeName^.TreeName.Name); 
        WriteS (f, " . "); WI (Name);  
                  WriteS (f, " ( "); PathPrefix ( Path , TRUE ) ; WriteS (f, "_yy_"); WI ( Name ) ; WriteS (f, " ) "); WriteNl (f);
        WriteS (f, "      => ");  
;
      RETURN;
     END (* WITH *) ;

  | Tree.TestIsType:
(* line 1263 "" *)
     WITH t^.TestIsType DO
(* line 1263 "" *)
      
        WriteS (f, "      TYPECASE (* TestIsType *) "); WritePathNarrow ( Path ); WriteNl (f);
        WriteS (f, "      OF "); WI (TypeDesc^.NodeTypes.TreeName^.TreeName.Name); 
        WriteS (f, " . "); WI (Name);  
                  WriteS (f, " ( "); PathPrefix ( Path , TRUE ) ; WriteS (f, "_yy_"); WI ( Name ) ; WriteS (f, " ) "); WriteNl (f);
        WriteS (f, "      => ");  
;
      RETURN;
     END (* WITH *) ;

  | Tree.TestNil:
(* line 1270 "" *)
     WITH t^.TestNil DO
(* line 1270 "" *)
      
        WriteS (f, "  IF "); WritePathWide ( Path ); WriteS (f, " = NIL (* TestNil *) THEN"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TestNonlin:
(* line 1273 "" *)
     WITH t^.TestNonlin DO
(* line 1273 "" *)
      
        WriteS (f, "  IF (equal"); Module (TypeDesc); WriteS (f, " ( "); WritePathNarrow ( Path );
        WriteS (f, " , "); WritePathNarrow (Path2); WriteS (f, " ) ) (* TestNonlin *) THEN"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TestValue:
(* line 1277 "" *)
     WITH t^.TestValue DO
(* line 1277 "" *)
      
        AssignTempo (Expr);
        WriteS (f, "  IF (equal"); Module (TypeDesc); WriteS (f, " ( "); WritePathNarrow ( Path );
        WriteS (f, " , "); Expression (Expr); WriteS (f, " ) ) (* TestValue *) THEN"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Rule:
(* line 1282 "" *)
    WITH yyTempo.yyR8 DO  
     WITH t^.Rule DO
(* line 1283 "" *)
      ;
(* line 1284 "" *)
      ;
(* line 1285 "" *)
      
        WriteS (f, "    "); WriteLine (Line);
        LGenerateBlock 
           := HasTempos 
              AND NOT TemposDone ;  
        IF LGenerateBlock 
        THEN 
          WriteS (f, "    (* Tempo declarations, CommonTestElim: *)"); WriteNl (f);
          Declare ( t ) ; 
          WriteS (f, "    BEGIN (* Block of Tempo declarations, CommonTestElim *)"); WriteNl (f);
        END;
        IF HasExit THEN WriteS (f, "   LOOP"); WriteNl (f);
        END;
        Decls := VarDecls;
      IF NeedsWITHStmt ( t ) 
      THEN 
        OpenWITHRenames (Patterns, InFormals);
      END;
        LTypeCaseDepth := TypeCaseDepth ; 
        Module (Statements);
        IF NOT HasRejectOrFail THEN
           AssignFormals (Exprs, OutFormals , NoIdent );
           MatchExprs (Exprs);
           CASE RoutineKind OF
           | kProcedure: WriteS (f, "      RETURN ;"); WriteNl (f);

           | kFunction :
              AssignTempo (Expr);
              IF HasPatterns 
                 AND ( Expr ^ . Kind # Tree . Compose ) 
                 AND NOT Tree . IsType ( t , Tree . DontCare1 ) 
              THEN
                 WriteS (f, "      "); WI (Tempo); WriteS (f, " := "); Expression (Expr); WriteS (f, " ;"); WriteNl (f);
                 MatchExpr (Expr);
                 WriteS (f, "      RETURN "); WI (Tempo); WriteS (f, " ;"); WriteNl (f);
              ELSE
                 MatchExpr (Expr);
                 WriteS (f, "      RETURN "); Expression (Expr); WriteS (f, " ;"); WriteNl (f);
              END;

           | kPredicate: WriteS (f, "      RETURN TRUE ;"); WriteNl (f);
           END;
        END;
        CloseTypeCases ( LTypeCaseDepth ) ; 
      IF NeedsWITHStmt ( t ) 
      THEN 
        CloseWITHRenames (Patterns, InFormals);
      END;
        IF HasExit THEN WriteS (f, "   END (* LOOP *) ;"); WriteNl (f);
        END;
        IF LGenerateBlock 
        THEN 
          WriteS (f, "    END (* Block of Tempo declarations, CommonTestElim *) ;  "); WriteNl (f);
        END;
        WriteNl (f);
;
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  ELSE END;

 END CommonTestElim;

PROCEDURE Case (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 1: yyR1: RECORD
  n: CARDINAL;
  END;
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Decision:
(* line 1345 "" *)
    WITH yyTempo.yyR1 DO  
     WITH t^.Decision DO
(* line 1346 "" *)
      ;
(* line 1347 "" *)
       WriteNl (f);
        WriteS (f, "  TYPECASE (* Decision *) "); WritePathNarrow (OneTest^.OneTest.Path); WriteS (f, " OF"); WriteNl (f);
        n := i;
        WHILE n > 0 DO
           IF NOT IsEmpty 
                    (t^.Decision.OneTest^.TestIsType.TypeDesc^.NodeTypes.Types) 
           THEN
              Case (t^.Decision.OneTest);
              CommonTestElim (t^.Decision.ThenPart);
           END;
           t := t^.Decision.ElsePart;
           DEC (n);
        END;
        WriteS (f, "  ELSE"); WriteNl (f);
        WriteS (f, "  END (* TYPECASE Decision *) ;"); WriteNl (f);
        WriteNl (f);
        CommonTestElim (t);
      ;
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.TestKind:
(* line 1365 "" *)
     WITH t^.TestKind DO
(* line 1365 "" *)
      
        WriteS (f, "  | "); WI (TypeDesc^.NodeTypes.TreeName^.TreeName.Name); WriteS (f, " . "); WI (Name); 
               WriteS (f, " ( "); PathPrefix ( Path , TRUE ) ; WriteS (f, "_yy_"); WI ( Name ); WriteS (f, " ) => "); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TestIsType:
(* line 1369 "" *)
     WITH t^.TestIsType DO
(* line 1369 "" *)
      
        WriteS (f, "  | "); WI (TypeDesc^.NodeTypes.TreeName^.TreeName.Name); WriteS (f, " . "); WI (Name); 
               WriteS (f, " ( "); PathPrefix ( Path , TRUE ) ; WriteS (f, "_yy_"); WI ( Name ); WriteS (f, " ) => "); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Case;

PROCEDURE BeginM3;
 BEGIN

 END BeginM3;

PROCEDURE CloseM3;
 BEGIN

 END CloseM3;

PROCEDURE yyExit;
 BEGIN
  IO.CloseIO; System.Exit (1);
 END yyExit;

BEGIN
 yyf   := IO.StdOutput;
 Exit  := yyExit;
 BeginM3;
END M3.

