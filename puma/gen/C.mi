
(* This file was mechanically generated by puma. *)

IMPLEMENTATION MODULE C;








IMPORT SYSTEM, System, IO, Tree;
(* line 32 "" *)


FROM Positions  IMPORT tPosition;
FROM IO         IMPORT StdOutput, WriteS, WriteNl;
FROM Strings    IMPORT tString, IntToString, Concatenate, ArrayToString;
FROM StringMem  IMPORT WriteString;
FROM Idents     IMPORT tIdent, NoIdent, MakeIdent;
FROM Texts      IMPORT WriteText;
FROM Sets       IMPORT IsElement, IsNotEqual, Minimum, Maximum, IsEmpty;
FROM Semantics  IMPORT IdentifyVar, UserTypes, LookupClass;
FROM Optimize   IMPORT NeedsTempo, NeedsMatch, NeedsNoFinale, GetRule;
FROM Tree       IMPORT NoTree, tTree, Options, f, SourceFile, WI, WN;
FROM IOUtils    IMPORT WriteBackslash;
FROM Assertions IMPORT Assert, AssertPos, CantHappen, CantHappenPos; 

VAR
   RoutineKind  : (kProcedure, kFunction, kPredicate);
   WithCount    ,
   RuleCount    ,
   ListCount    : INTEGER;
   i, j         : CARDINAL;
   rule         ,
   TheClass     ,
   InFormals    ,
   OutFormals   ,
   ReturnFormals,
   Decls        : tTree;
   TheName      : tIdent;
   TemposDone   : BOOLEAN;

PROCEDURE WriteLine (Line: tPosition);
   BEGIN
      IF Line.Line # 0 THEN
         IF IsElement (ORD ('6'), Options) THEN
            WriteS (f, "# line "); WN (Line.Line); WriteS (f, ' "'); WriteS (f, SourceFile); WriteS (f, '"'); WriteNl (f);
         ELSE
            WriteS (f, "/* line "); WN (Line.Line); WriteS (f, ' "'); WriteS (f, SourceFile); WriteS (f, '" */'); WriteNl (f);
         END;
      END;
   END WriteLine;

PROCEDURE Match (t, Formals: tTree);
   VAR TreeName : tIdent;
   VAR Pattern  : tTree;
   BEGIN
      IF (t^.Kind = Tree.NoPattern) 
         OR NOT Tree . IsType ( Formals , Tree . Formal ) 
      THEN RETURN; 
      END;
      Pattern := t^.OnePattern.Pattern;
      CASE Pattern^.Kind OF
      | Tree.Decompose: WITH Pattern^.Decompose DO
            TreeName := Object^.Class.TypeDesc^.NodeTypes.TreeName^.TreeName.Name;
            IF (Formals^.Formal.TypeDesc^.Kind = Tree.UserType) OR
               IsNotEqual (Object^.Class.TypeDesc^.NodeTypes.Types, Formals^.Formal.TypeDesc^.NodeTypes.Types) THEN
               IF Object^.Class.Extensions^.Kind = Tree.NoClass THEN    (* Low ? *)
                  WriteS (f, '   if ('); WritePath ( Path ); WriteS (f, '->Kind != k'); WI (Object^.Class.Name);
               ELSE
                  WriteS (f, '   if (! '); WI (TreeName); WriteS (f, '_IsType ('); WritePath ( Path ); WriteS (f, ', k'); WI (Object^.Class.Name); WriteS (f, ')'); 
               END;
               WriteS (f, ") goto yyL"); WN (RuleCount); WriteS (f, ";"); WriteNl (f);
            END;
            Match (Patterns, Object^.Class.Formals);
         END;

      | Tree.VarDef: WITH Pattern^.VarDef DO
            IF Object # NoTree THEN
               WITH Object^.Formal DO
                  WriteS (f, '   if (! (equal'); DefC (TypeDesc); WriteS (f, ' ('); WritePath ( Path );
                  WriteS (f, ", "); WritePath ( Pattern^.VarDef.Path ); WriteS (f, "))) goto yyL"); WN (RuleCount); WriteS (f, ";"); WriteNl (f);
               END;
            END;
         END;

      | Tree.NilTest:
         WriteS (f, "   if ("); WritePath ( Pattern^.NilTest.Path ); WriteS (f, ' != NULL) goto yyL'); WN (RuleCount); WriteS (f, ";"); WriteNl (f);

      | Tree.DontCare1Explicit , Tree.DontCare1Internal :
      | Tree.DontCareExplicit , Tree.DontCareInternal : RETURN;

      | Tree.Value: WITH Pattern^.Value DO
            AssignTempo (Expr);
            IF (Formals^.Formal.TypeDesc^.Kind = Tree.UserType) AND
               IsElement (Formals^.Formal.TypeDesc^.UserType.Type, UserTypes) THEN
               WriteS (f, "  {"); DefC (Formals^.Formal.TypeDesc); WriteS (f, " yyT; yyT = "); Expression (Expr); WriteS (f, ";"); WriteNl (f);
               WriteS (f, '   if (! (equal'); DefC (Formals^.Formal.TypeDesc);
               WriteS (f, " ("); WritePath ( Path ); WriteS (f, ", yyT))) goto yyL"); WN (RuleCount); WriteS (f, ";"); WriteNl (f);
               WriteS (f, "  }"); WriteNl (f);
            ELSE
               WriteS (f, '   if (! (equal'); DefC (Formals^.Formal.TypeDesc);
               WriteS (f, " ("); WritePath ( Path ); WriteS (f, ", "); Expression (Expr); WriteS (f, "))) goto yyL"); WN (RuleCount); WriteS (f, ";"); WriteNl (f);
            END;
            MatchExpr (Expr);
         END;
      END;
      Match (t^.OnePattern.Next, Formals^.Formal.Next);
   END Match;

PROCEDURE MatchExprs (t: tTree);
   BEGIN
      IF t^.Kind = Tree.NoExpr THEN RETURN; END;
      IF Tree . IsType ( t^.OneExpr.Expr , Tree.DontCare ) THEN RETURN; END;
      MatchExpr (t^.OneExpr.Expr);
      MatchExprs (t^.OneExpr.Next);
   END MatchExprs;

PROCEDURE MatchExpr (t: tTree);
   BEGIN
      CASE t^.Kind OF
      | Tree.Compose:
         MatchExprs (t^.Compose.Exprs);

      | Tree.VarUse     :
      | Tree.Nil        :
      | Tree.DontCare1Explicit , Tree.DontCare1Internal :
      | Tree.TargetExpr :
      | Tree.StringExpr :
      | Tree.AttrDesc   :

      | Tree.Call       : WITH t^.Call DO
            MatchExpr (Expr);
            MatchExprs (Exprs);
            IF Object # NoTree THEN
               Match (Patterns, Object^.Routine.OutForm);
            END;
         END;

      | Tree.Binary     : WITH t^.Binary DO
            MatchExpr (Lop);
            MatchExpr (Rop);
         END;

      | Tree.PreOperator, Tree.PostOperator     :
         MatchExpr (t^.PreOperator.Expr);

      | Tree.Index      :
         MatchExpr (t^.Index.Expr);
         MatchExprs (t^.Index.Exprs);

      | Tree.Parents    :
         MatchExpr (t^.Parents.Expr);
      END;
   END MatchExpr;

PROCEDURE AssignTempos (t: tTree);
   BEGIN
      IF t^.Kind = Tree.NoExpr THEN RETURN; END;
      IF Tree . IsType ( t^.OneExpr.Expr , Tree.DontCare ) THEN RETURN; END;
      AssignTempo (t^.OneExpr.Expr);
      AssignTempos (t^.OneExpr.Next);
   END AssignTempos;

PROCEDURE AssignTempo (t: tTree);
   VAR TreeName : tIdent;
   BEGIN
      CASE t^.Kind OF
      | Tree.Compose: WITH t^.Compose DO
            TreeName := Object^.Class.TypeDesc^.NodeTypes.TreeName^.TreeName.Name;
            WriteS (f, "   yyALLOC (t"); WI (TreeName); WriteS (f, ","); WI (TreeName); WriteS (f, "_PoolFreePtr,"); 
            WI (TreeName); WriteS (f, "_PoolMaxPtr,"); WI (TreeName); WriteS (f, "_Alloc,"); WI (TreeName);
            WriteS (f, "_NodeSize,Make"); WI (TreeName); WriteS (f, ","); WI (Tempo); WriteS (f, ",k"); WI (Object^.Class.Name); WriteS (f, ")"); WriteNl (f);
            AssignSubFormals (Exprs, Object^.Class.Formals, Tempo, Object^.Class.Name);
         END;

      | Tree.VarUse     :
      | Tree.Nil        :
      | Tree.DontCare1Explicit , Tree.DontCare1Internal :
      | Tree.TargetExpr :
      | Tree.StringExpr :
      | Tree.AttrDesc   :

      | Tree.Call       : WITH t^.Call DO
            AssignTempo (Expr);
            AssignTempos (Exprs);
         END;

      | Tree.Binary     : WITH t^.Binary DO
            AssignTempo (Lop);
            AssignTempo (Rop);
         END;

      | Tree.PreOperator, Tree.PostOperator     :
         AssignTempo (t^.PreOperator.Expr);

      | Tree.Index      :
         AssignTempo (t^.Index.Expr);
         AssignTempos (t^.Index.Exprs);

      | Tree.Parents    :
         AssignTempo (t^.Parents.Expr);
      END;
   END AssignTempo;

PROCEDURE AssignFormals (t, Formals: tTree);
   BEGIN
      IF (t^.Kind = Tree.NoExpr) 
         OR NOT Tree . IsType ( Formals , Tree . Formal ) 
      THEN RETURN; 
      END;
      IF Tree . IsType ( t^.OneExpr.Expr , Tree.DontCare ) THEN
         BeginFormals (Formals);
         RETURN;
      END;
      AssignFormal (t^.OneExpr.Expr, Formals);
      MatchExpr (t^.OneExpr.Expr);
      AssignFormals (t^.OneExpr.Next, Formals^.Formal.Next);
   END AssignFormals;

PROCEDURE AssignFormal (t, Formals: tTree);
   VAR TreeName, With   : tIdent;
   BEGIN
      IF t^.Kind = Tree.Compose THEN
         WITH t^.Compose DO
            TreeName := Object^.Class.TypeDesc^.NodeTypes.TreeName^.TreeName.Name;
            With := MakeWith ();
            WriteS (f, "   {register t"); WI (TreeName); WriteS (f, " "); WI (With); WriteS (f, ";"); WriteNl (f);
            WriteS (f, "    yyALLOC (t"); WI (TreeName); WriteS (f, ","); WI (TreeName); WriteS (f, "_PoolFreePtr,"); 
            WI (TreeName); WriteS (f, "_PoolMaxPtr,"); WI (TreeName); WriteS (f, "_Alloc,"); WI (TreeName);
            WriteS (f, "_NodeSize,Make"); WI (TreeName); WriteS (f, ","); WI (With); WriteS (f, ",k"); WI (Object^.Class.Name); WriteS (f, ")"); WriteNl (f);
            WriteS (f, "    * "); WI (Formals^.Formal.Name); WriteS (f, " = "); WI (With); WriteS (f, ";"); WriteNl (f);
            AssignSubFormals (Exprs, Object^.Class.Formals, With, Object^.Class.Name);
            WriteS (f, "   }"); WriteNl (f);
         END;
      ELSE
         AssignTempo (t);
      END;

      CASE t^.Kind OF
      | Tree.VarUse, Tree.Nil, Tree.Call, Tree.Binary, Tree.PreOperator,
        Tree.PostOperator, Tree.Index, Tree.Parents, Tree.TargetExpr, Tree.StringExpr,
        Tree.AttrDesc:
         WriteS (f, "   * "); WI (Formals^.Formal.Name); WriteS (f, " = "); Expression (t); WriteS (f, ";"); WriteNl (f);
      | Tree.DontCare1Explicit , Tree.DontCare1Internal :
         WriteS (f, "    begin"); DefC (Formals^.Formal.TypeDesc); WriteS (f, " (* "); WI (Formals^.Formal.Name); WriteS (f, ")"); WriteNl (f);
      ELSE
      END;
   END AssignFormal;

PROCEDURE AssignSubFormals (t, Formals: tTree; PrevWith, Composer: tIdent);
   BEGIN
      IF (t^.Kind = Tree.NoExpr) 
         OR NOT Tree . IsType ( Formals , Tree . Formal ) 
      THEN RETURN;  
      END;
      IF Tree . IsType ( t^.OneExpr.Expr , Tree.DontCare ) THEN
         BeginSubFormals (Formals, PrevWith, Composer);
         RETURN;
      END;
      AssignSubFormal (t^.OneExpr.Expr, Formals, PrevWith, Composer);
      AssignSubFormals (t^.OneExpr.Next, Formals^.Formal.Next, PrevWith, Composer);
   END AssignSubFormals;

PROCEDURE AssignSubFormal (t, Formals: tTree; PrevWith, Composer: tIdent);
   VAR TreeName, With   : tIdent;
   BEGIN
      IF t^.Kind = Tree.Compose THEN
         WITH t^.Compose DO
            TreeName := Object^.Class.TypeDesc^.NodeTypes.TreeName^.TreeName.Name;
            With := MakeWith ();
            WriteS (f, "   {register t"); WI (TreeName); WriteS (f, " "); WI (With); WriteS (f, ";"); WriteNl (f);
            WriteS (f, "    yyALLOC (t"); WI (TreeName); WriteS (f, ","); WI (TreeName); WriteS (f, "_PoolFreePtr,"); 
            WI (TreeName); WriteS (f, "_PoolMaxPtr,"); WI (TreeName); WriteS (f, "_Alloc,"); WI (TreeName);
            WriteS (f, "_NodeSize,Make"); WI (TreeName); WriteS (f, ","); WI (With); WriteS (f, ",k"); WI (Object^.Class.Name); WriteS (f, ")"); WriteNl (f);
            WriteS (f, "    "); WI (PrevWith); WriteS (f, "->"); WI (Composer); WriteS (f, "."); WI (Formals^.Formal.Name); WriteS (f, " = "); WI (With); WriteS (f, ";"); WriteNl (f);
            AssignSubFormals (Exprs, Object^.Class.Formals, With, Object^.Class.Name);
            WriteS (f, "   }"); WriteNl (f);
         END;
      ELSE
         AssignTempo (t);
      END;

      CASE t^.Kind OF
      | Tree.VarUse, Tree.Nil, Tree.Call, Tree.Binary, Tree.PreOperator,
        Tree.PostOperator, Tree.Index, Tree.Parents, Tree.TargetExpr, Tree.StringExpr,
        Tree.AttrDesc:
         WriteS (f, "    "); WI (PrevWith); WriteS (f, "->"); WI (Composer); WriteS (f, "."); WI (Formals^.Formal.Name); WriteS (f, " = "); Expression (t); WriteS (f, ";"); WriteNl (f);
      | Tree.DontCare1Explicit , Tree.DontCare1Internal :
         WriteS (f, "    begin"); DefC (Formals^.Formal.TypeDesc); WriteS (f, " ("); WI (PrevWith); WriteS (f, "->"); WI (Composer); WriteS (f, "."); WI (Formals^.Formal.Name); WriteS (f, ")"); WriteNl (f);
      ELSE
      END;
   END AssignSubFormal;

PROCEDURE BeginFormals (Formals: tTree);
   BEGIN
      IF Tree . IsType ( Formals , Tree . Formal ) 
      THEN
         WITH Formals^.Formal DO
            WriteS (f, "    begin"); DefC (TypeDesc); WriteS (f, " (* "); WI (Name); WriteS (f, ")"); WriteNl (f);
            BeginFormals (Next);
         END;
      END;
   END BeginFormals;

PROCEDURE BeginSubFormals (Formals: tTree; PrevWith, Composer: tIdent);
   BEGIN
      IF Tree . IsType ( Formals , Tree . Formal ) 
      THEN
         WITH Formals^.Formal DO
            WriteS (f, "    begin"); DefC (TypeDesc); WriteS (f, " ("); WI (PrevWith); WriteS (f, "->"); WI (Composer); WriteS (f, "."); WI (Name); WriteS (f, ")"); WriteNl (f);
            BeginSubFormals (Next, PrevWith, Composer);
         END;
      END;
   END BeginSubFormals;

PROCEDURE ConsPatterns (t: tTree; ListCount: INTEGER): INTEGER;
   BEGIN
      IF t^.Kind = Tree.NoPattern THEN RETURN ListCount; END;
      WITH t^.OnePattern DO
         IF Tree . IsType ( Pattern , Tree.DontCare ) THEN
            RETURN ConsTempos (Pattern^.DontCare.Tempos, ListCount, TRUE);
         ELSE
            IF ListCount > 0 THEN WriteS (f, ", "); END;
            WriteS (f, "& "); WI (Pattern^.Pattern.Tempo);
            RETURN ConsPatterns (Next, ListCount + 1);
         END;
      END;
   END ConsPatterns;

PROCEDURE ConsTempos (t: tTree; ListCount: INTEGER; IsRef: BOOLEAN): INTEGER;
   BEGIN
      IF Tree . IsType ( t , Tree . Formal )  
      THEN
         IF ListCount > 0 THEN WriteS (f, ", "); END;
         IF IsRef THEN WriteS (f, "& "); END;
         WI (t^.Formal.Name);
         RETURN ConsTempos (t^.Formal.Next, ListCount + 1, IsRef);
      ELSE
         RETURN ListCount;
      END;
   END ConsTempos;

PROCEDURE Expressions (t: tTree; ListCount: INTEGER): INTEGER;
   BEGIN
      IF t^.Kind = Tree.NoExpr THEN RETURN ListCount; END;
      WITH t^.OneExpr DO
         IF Tree . IsType ( Expr , Tree.DontCare ) THEN
            RETURN ConsTempos (Expr^.DontCare.Tempos, ListCount, FALSE);
         ELSE
            IF ListCount > 0 THEN WriteS (f, ", "); END;
            Expression (Expr);
            RETURN Expressions (Next, ListCount + 1);
         END;
      END;
   END Expressions;

PROCEDURE Expressions2 (t: tTree; ListCount: INTEGER; Formals: tTree): INTEGER;
   BEGIN
      IF t^.Kind = Tree.NoExpr THEN RETURN ListCount; END;
      WITH t^.OneExpr DO
         IF Tree . IsType ( Expr , Tree.DontCare ) THEN
            RETURN ConsTempos (Expr^.DontCare.Tempos, ListCount, FALSE);
         ELSE
            IF ListCount > 0 THEN WriteS (f, ", "); END;
            IF Formals^.Formal.Path^.Var.IsOutput THEN WriteS (f, "& "); END;
            Expression (Expr);
            RETURN Expressions2 (Next, ListCount + 1, Formals^.Formal.Next);
         END;
      END;
   END Expressions2;

PROCEDURE Expression (t: tTree);
   BEGIN
      CASE t^.Kind OF
      | Tree.Compose : WI (t^.Compose.Tempo);

      | Tree.Nil : WriteS (f, "NULL"); 

      | Tree.VarUse     
          : WITH t^.VarUse DO
              IF Object # NoTree THEN
                 WritePath ( Object^.Formal.Path );
              ELSE
                 WI (Name);
              END;
            END;

      | Tree.DontCare1Explicit , Tree.DontCare1Internal 
          : WI (t^.DontCare1.Tempo);

      | Tree.Call       : WITH t^.Call DO
            Expression (Expr); WriteS (f, " ("); 
            IF Object # NoTree THEN
               ListCount := Expressions2 (Exprs, 0, Object^.Routine.InForm);
               ListCount := ConsPatterns (Patterns, ListCount);
            ELSE
               ListCount := Expressions (Exprs, 0);
               ListCount := Expressions (Patterns, ListCount);
            END;
            WriteS (f, ")"); 
         END;

      | Tree.Binary     : WITH t^.Binary DO
            Expression (Lop); WriteS (f, " "); WI (Operator); WriteS (f, " "); Expression (Rop);
         END;

      | Tree.PreOperator        :
         WI (t^.PreOperator.Operator); WriteS (f, " "); Expression (t^.PreOperator.Expr);

      | Tree.PostOperator       :
         Expression (t^.PostOperator.Expr); WriteS (f, " "); WI (t^.PostOperator.Operator);

      | Tree.Index      :
         Expression (t^.Index.Expr); WriteS (f, " ["); ListCount := Expressions (t^.Index.Exprs, 0); WriteS (f, "]"); 

      | Tree.Parents    : WriteS (f, "("); Expression (t^.Parents.Expr); WriteS (f, ")"); 

      | Tree.TargetExpr : ImplC (t^.TargetExpr.Expr);

      | Tree.StringExpr : WriteString (f, t^.StringExpr.String);

      | Tree.AttrDesc   : WITH t^.AttrDesc DO
            WritePath ( Object^.Formal.Path ); WriteS (f, "->"); WI (Type); WriteS (f, "."); WI (Attribute);
         END;
      END;
   END Expression;

PROCEDURE MakeWith (): tIdent;
   VAR String1, String2 : tString;
   BEGIN
      INC (WithCount);
      ArrayToString ("yyW", String1);
      IntToString (WithCount, String2);
      Concatenate (String1, String2);
      RETURN MakeIdent (String1);
   END MakeWith;


































































PROCEDURE yyAbort (yyFunction: ARRAY OF CHAR);
 BEGIN
  IO.WriteS (IO.StdError, 'Error: module C, routine ');
  IO.WriteS (IO.StdError, yyFunction);
  IO.WriteS (IO.StdError, ' failed');
  IO.WriteNl (IO.StdError);
  Exit;
 END yyAbort;

PROCEDURE yyIsEqual (yya, yyb: ARRAY OF SYSTEM.BYTE): BOOLEAN;
 VAR yyi       : INTEGER;
 BEGIN
  FOR yyi := 0 TO INTEGER (HIGH (yya)) DO
   IF yya [yyi] # yyb [yyi] THEN RETURN FALSE; END;
  END;
  RETURN TRUE;
 END yyIsEqual;

PROCEDURE MacroC (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Spec:
(* line 461 "" *)
     WITH t^.Spec DO
(* line 461 "" *)
      
        MacroC (TreeNames);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TreeName:
(* line 464 "" *)
     WITH t^.TreeName DO
(* line 464 "" *)
      
        WriteS (f, "# define begint"); WI (Name); WriteS (f, "(a)       a = NULL;"); WriteNl (f);
        WriteS (f, "# define equalt"); WI (Name); WriteS (f, "(a, b)    IsEqual"); WI (Name); WriteS (f, " (a, b)"); WriteNl (f);
        MacroC (Next);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END MacroC;

PROCEDURE DefC (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Spec:
(* line 473 "" *)
     WITH t^.Spec DO
(* line 473 "" *)
      
        WriteNl (f);
        WriteS (f, "/* This file was mechanically generated by puma. */"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "# ifndef yy"); WI (TrafoName); WriteNl (f);
        WriteS (f, "# define yy"); WI (TrafoName); WriteNl (f);
        WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, "# define ARGS(parameters)      parameters"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, "# define ARGS(parameters)      ()"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "# ifndef bool"); WriteNl (f);
        WriteS (f, "# define bool char"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteNl (f);
        DefC (TreeNames);
        WriteNl (f);
        WriteLine (Codes^.Codes.ImportLine);
        WriteText (f, Codes^.Codes.Import);
        WriteNl (f);
        WriteLine (Codes^.Codes.ExportLine);
        WriteText (f, Codes^.Codes.Export);
        WriteNl (f);
        WriteS (f, "extern void (* "); WI (TrafoName); WriteS (f, "_Exit) ();"); WriteNl (f);
        WriteNl (f);
        DefC (Public);
        WriteNl (f);
        WriteS (f, "extern void Begin"); WI (TrafoName); WriteS (f, " ();"); WriteNl (f);
        WriteS (f, "extern void Close"); WI (TrafoName); WriteS (f, " ();"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "/* End of File */"); WriteNl (f);
        WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TreeName:
(* line 509 "" *)
     WITH t^.TreeName DO
(* line 509 "" *)
      
        WriteS (f, '# include "'); WI (Name); WriteS (f, '.h"'); WriteNl (f);
        DefC (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Name:
(* line 513 "" *)
     WITH t^.Name DO
(* line 513 "" *)
      
        IF Object # NoTree THEN
           ListCount := 0;
           WriteS (f, "extern "); 
           IF Object^.Kind = Tree.Procedure THEN
              WriteS (f, "void"); 
           ELSIF Object^.Kind = Tree.Function THEN
              DefC (Object^.Function.ReturnForm^.Formal.TypeDesc);
           ELSIF Object^.Kind = Tree.Predicate THEN
              WriteS (f, "bool"); 
           END;
           WriteS (f, " "); WI (Name); WriteS (f, " ARGS(("); 
           DefC (Object^.Routine.InForm);
           DefC (Object^.Routine.OutForm);
           WriteS (f, "));"); WriteNl (f);
        END;
        DefC (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Formal
  , Tree.PlainFormal
  , Tree.RoutineFormal:
(* line 531 "" *)
     WITH t^.Formal DO
(* line 531 "" *)
      
        IF ListCount > 0 THEN WriteS (f, ", "); END;
        DefC (TypeDesc);
        IF Path^.Var.IsOutput THEN WriteS (f, " *"); END;
        WriteS (f, " "); WI (Name);
        INC (ListCount);
        DefC (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.NodeTypes:
(* line 539 "" *)
     WITH t^.NodeTypes DO
(* line 539 "" *)
      
        WriteS (f, "t"); WI (TreeName^.TreeName.Name);
;
      RETURN;
     END (* WITH *) ;

  | Tree.UserType:
(* line 542 "" *)
     WITH t^.UserType DO
(* line 542 "" *)
      
        WI (Type);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END DefC;

PROCEDURE Forward (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Procedure:
(* line 549 "" *)
     WITH t^.Procedure DO
(* line 549 "" *)
      
        ListCount := 0;
        IF NOT IsExtern THEN WriteS (f, "static "); END;
        WriteS (f, "void "); WI (Name); WriteS (f, " ARGS(("); 
        DefC (InForm);
        DefC (OutForm);
        WriteS (f, "));"); WriteNl (f);
        Forward (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Function:
(* line 558 "" *)
     WITH t^.Function DO
(* line 558 "" *)
      
        ListCount := 0;
        IF NOT IsExtern THEN WriteS (f, "static "); END;
        DefC (ReturnForm^.Formal.TypeDesc); WriteS (f, " "); WI (Name); WriteS (f, " ARGS(("); 
        DefC (InForm);
        DefC (OutForm);
        WriteS (f, "));"); WriteNl (f);
        Forward (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Predicate:
(* line 567 "" *)
     WITH t^.Predicate DO
(* line 567 "" *)
      
        ListCount := 0;
        IF NOT IsExtern THEN WriteS (f, "static "); END;
        WriteS (f, "bool "); WI (Name); WriteS (f, " ARGS(("); 
        DefC (InForm);
        DefC (OutForm);
        WriteS (f, "));"); WriteNl (f);
        Forward (Next);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Forward;

PROCEDURE ProcHead1 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF Tree.IsType (t, Tree.Formal) THEN
(* line 580 "" *)
     WITH t^.Formal DO
(* line 580 "" *)
      
        IF ListCount > 0 THEN WriteS (f, ", "); END;
        WI (Name);
        INC (ListCount);
        ProcHead1 (Next);
;
      RETURN;
     END (* WITH *) ;

  END;
 END ProcHead1;

PROCEDURE ProcHead2 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF Tree.IsType (t, Tree.Formal) THEN
(* line 590 "" *)
     WITH t^.Formal DO
(* line 590 "" *)
      
        WriteS (f, " "); 
        IF (TypeDesc^.Kind = Tree.NodeTypes) AND Path^.Var.IsRegister THEN WriteS (f, "register "); END;
        ImplC (TypeDesc); IF Path^.Var.IsOutput THEN WriteS (f, " *"); END; WriteS (f, " "); WI (Name); WriteS (f, ";"); WriteNl (f);
        ProcHead2 (Next);
;
      RETURN;
     END (* WITH *) ;

  END;
 END ProcHead2;

PROCEDURE ProcHead3 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF Tree.IsType (t, Tree.Formal) THEN
(* line 600 "" *)
     WITH t^.Formal DO
(* line 600 "" *)
      
        IF ListCount > 0 THEN WriteS (f, ", "); END;
        IF (TypeDesc^.Kind = Tree.NodeTypes) AND Path^.Var.IsRegister THEN WriteS (f, "register "); END;
        ImplC (TypeDesc); IF Path^.Var.IsOutput THEN WriteS (f, " *"); END; WriteS (f, " "); WI (Name);
        INC (ListCount);
        ProcHead3 (Next);
;
      RETURN;
     END (* WITH *) ;

  END;
 END ProcHead3;

PROCEDURE ImplC (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Spec:
(* line 611 "" *)
     WITH t^.Spec DO
(* line 611 "" *)
      
        WriteNl (f);
        WriteS (f, "/* This file was mechanically generated by puma. */"); WriteNl (f);
        WriteNl (f);
        WriteS (f, '# include "'); WI (TrafoName); WriteS (f, '.h"'); WriteNl (f);
        WriteS (f, "# ifdef __cplusplus"); WriteNl (f);
        WriteS (f, 'extern "C" {'); WriteNl (f);
        WriteS (f, '# include "System.h"'); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, '# include "System.h"'); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "# include <stdio.h>"); WriteNl (f);
        DefC (TreeNames);
        WriteNl (f);
      IF NOT IsElement (ORD ('m'), Options) THEN
        WriteS (f, "# define yyInline"); WriteNl (f);
      END;
        WriteS (f, "# ifndef NULL"); WriteNl (f);
        WriteS (f, "# define NULL 0L"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "# ifndef false"); WriteNl (f);
        WriteS (f, "# define false 0"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "# ifndef true"); WriteNl (f);
        WriteS (f, "# define true 1"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "# ifdef yyInline"); WriteNl (f);
        WriteS (f, "# define yyALLOC(tree, free, max, alloc, nodesize, make, ptr, kind) "); WriteBackslash ( f ) ; WriteNl (f);
        WriteS (f, "  if ((ptr = (tree) free) >= (tree) max) ptr = alloc (); "); WriteBackslash ( f ) ; WriteNl (f);
        WriteS (f, "  free += nodesize [kind]; "); WriteBackslash ( f ) ; WriteNl (f);
        WriteS (f, "  ptr->yyHead.yyMark = 0; "); WriteBackslash ( f ) ; WriteNl (f);
        WriteS (f, "  ptr->Kind = kind;"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, "# define yyALLOC(tree, free, max, alloc, nodesize, make, ptr, kind) ptr = make (kind);"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "# define yyWrite(s) (void) fputs (s, yyf)"); WriteNl (f);
        WriteS (f, "# define yyWriteNl (void) fputc ('\n', yyf)"); WriteNl (f);
        WriteNl (f);
        WriteLine (Codes^.Codes.GlobalLine);
        WriteText (f, Codes^.Codes.Global);
        WriteNl (f);
        WriteS (f, '# include "yy'); WI (TrafoName); WriteS (f, '.w"'); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static void yyExit () { Exit (1); }"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "void (* "); WI (TrafoName); WriteS (f, "_Exit) () = yyExit;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static FILE * yyf = stdout;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static void yyAbort"); WriteNl (f);
        WriteS (f, "# ifdef __cplusplus"); WriteNl (f);
        WriteS (f, " (char * yyFunction)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyFunction) char * yyFunction;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, ' (void) fprintf (stderr, "Error: module '); WI (TrafoName); WriteS (f, ', routine %s failed\n", yyFunction);'); WriteNl (f);
        WriteS (f, " "); WI (TrafoName); WriteS (f, "_Exit ();"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        Forward (Routines);
        WriteNl (f);
        ImplC (Routines);
        WriteS (f, "void Begin"); WI (TrafoName); WriteS (f, " ()"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteLine (Codes^.Codes.BeginLine);
        WriteText (f, Codes^.Codes.Begin);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "void Close"); WI (TrafoName); WriteS (f, " ()"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteLine (Codes^.Codes.CloseLine);
        WriteText (f, Codes^.Codes.Close);
        WriteS (f, "}"); WriteNl (f);
        WriteS (f, "/* End of File */"); WriteNl (f);
        WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Procedure:
(* line 691 "" *)
     WITH t^.Procedure DO
(* line 691 "" *)
      
        IF NOT IsExtern THEN WriteS (f, "static "); END;
        WriteS (f, "void "); WI (Name); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        ListCount := 0;
        WriteS (f, "("); ProcHead3 (InForm); ProcHead3 (OutForm); WriteS (f, ")"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        ListCount := 0;
        WriteS (f, "("); ProcHead1 (InForm); ProcHead1 (OutForm); WriteS (f, ")"); WriteNl (f);
        ProcHead2 (InForm);
        ProcHead2 (OutForm);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteLine (LocalLine);
        WriteText (f, Local);
        WriteNl (f);
        RoutineKind := kProcedure;
        InFormals := InForm;
        OutFormals := OutForm;
      IF IsElement (ORD ('n'), Options) THEN
        Tg1 (InForm);
      END;
      IF IsElement (ORD ('b'), Options) THEN
        ImplC (Rules);
        IF IsElement (ORD ('f'), Options) THEN
           WriteS (f, ' yyAbort ("'); WI (Name); WriteS (f, '");'); WriteNl (f);
        END;
      ELSE
        TemposDone := FALSE;
        CommonTestElim (Decisions);
        IF IsElement (ORD ('f'), Options) AND NOT NeedsNoFinale (Decisions) THEN
           WriteS (f, ' yyAbort ("'); WI (Name); WriteS (f, '");'); WriteNl (f);
        END;
      END;
        WriteS (f, ";"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        ImplC (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Function:
(* line 730 "" *)
     WITH t^.Function DO
(* line 730 "" *)
      
        IF NOT IsExtern THEN WriteS (f, "static "); END;
        DefC (ReturnForm^.Formal.TypeDesc); WriteS (f, " "); WI (Name); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        ListCount := 0;
        WriteS (f, "("); ProcHead3 (InForm); ProcHead3 (OutForm); WriteS (f, ")"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        ListCount := 0;
        WriteS (f, "("); ProcHead1 (InForm); ProcHead1 (OutForm); WriteS (f, ")"); WriteNl (f);
        ProcHead2 (InForm);
        ProcHead2 (OutForm);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteLine (LocalLine);
        WriteText (f, Local);
        WriteNl (f);
        RoutineKind := kFunction;
        InFormals := InForm;
        OutFormals := OutForm;
        ReturnFormals := ReturnForm;
      IF IsElement (ORD ('b'), Options) THEN
        ImplC (Rules);
        WriteS (f, ' yyAbort ("'); WI (Name); WriteS (f, '");'); WriteNl (f);
      ELSE
        TemposDone := FALSE;
        CommonTestElim (Decisions);
        IF NOT NeedsNoFinale (Decisions) THEN
           WriteS (f, ' yyAbort ("'); WI (Name); WriteS (f, '");'); WriteNl (f);
        END;
      END;
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        ImplC (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Predicate:
(* line 764 "" *)
     WITH t^.Predicate DO
(* line 764 "" *)
      
        IF NOT IsExtern THEN WriteS (f, "static "); END;
        WriteS (f, "bool "); WI (Name); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        ListCount := 0;
        WriteS (f, "("); ProcHead3 (InForm); ProcHead3 (OutForm); WriteS (f, ")"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        ListCount := 0;
        WriteS (f, "("); ProcHead1 (InForm); ProcHead1 (OutForm); WriteS (f, ")"); WriteNl (f);
        ProcHead2 (InForm);
        ProcHead2 (OutForm);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteLine (LocalLine);
        WriteText (f, Local);
        WriteNl (f);
        RoutineKind := kPredicate;
        InFormals := InForm;
        OutFormals := OutForm;
      IF IsElement (ORD ('n'), Options) THEN
        Tg1 (InForm);
      END;
      IF IsElement (ORD ('b'), Options) THEN
        ImplC (Rules);
        WriteS (f, "  return false;"); WriteNl (f);
      ELSE
        TemposDone := FALSE;
        CommonTestElim (Decisions);
        IF NOT NeedsNoFinale (Decisions) THEN
           WriteS (f, "  return false;"); WriteNl (f);
        END;
      END;
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        ImplC (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Rule:
(* line 800 "" *)
     WITH t^.Rule DO
(* line 800 "" *)
      
        WriteLine (Line);
        IF HasTempos THEN WriteS (f, " {"); WriteNl (f);
        END;
        RuleCount := Index;
        WithCount := 0;
        Decls := VarDecls;
        Declare (Patterns);
        Declare (Exprs);
        Declare (Statements);
        Match (Patterns, InFormals);
        IF Statements^.Kind # Tree.NoStatement THEN
           WriteS (f, "  {"); WriteNl (f);
           ImplC (Statements);
           WriteS (f, "  }"); WriteNl (f);
        END;
        IF NOT HasRejectOrFail THEN
           AssignFormals (Exprs, OutFormals);
           CASE RoutineKind OF
           | kProcedure: WriteS (f, "   return;"); WriteNl (f);

           | kFunction :
              IF HasPatterns AND (Expr^.Kind # Tree.Compose) AND NOT Tree . IsType ( t , Tree.DontCare1 ) THEN
                 WriteS (f, "  {register "); DefC (ReturnFormals^.Formal.TypeDesc); WriteS (f, " "); WI (Tempo); WriteS (f, ";"); WriteNl (f);
                 Declare (Expr);
                 AssignTempo (Expr);
                 WriteS (f, "   "); WI (Tempo); WriteS (f, " = "); Expression (Expr); WriteS (f, ";"); WriteNl (f);
                 MatchExpr (Expr);
                 WriteS (f, "   return "); WI (Tempo); WriteS (f, ";"); WriteNl (f);
                 WriteS (f, "  }"); WriteNl (f);
              ELSIF HasTempos THEN
                 WriteS (f, "  {"); WriteNl (f);
                 Declare (Expr);
                 AssignTempo (Expr);
                 MatchExpr (Expr);
                 WriteS (f, "   return "); Expression (Expr); WriteS (f, ";"); WriteNl (f);
                 WriteS (f, "  }"); WriteNl (f);
              ELSE
                 WriteS (f, "   return "); Expression (Expr); WriteS (f, ";"); WriteNl (f);
              END;

           | kPredicate: WriteS (f, "   return true;"); WriteNl (f);
           END;
        END;
        IF HasTempos THEN WriteS (f, " }"); WriteNl (f);
        END;
        WriteS (f, "yyL"); WN (RuleCount); WriteS (f, ":;"); WriteNl (f);
        WriteNl (f);
        ImplC (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.ProcCall:
(* line 850 "" *)
     WITH t^.ProcCall DO
(* line 850 "" *)
      
        WriteLine (Pos);
        AssignTempo (Call);
        WriteS (f, "   "); Expression (Call); WriteS (f, ";"); WriteNl (f);
        MatchExpr (Call);
        ImplC (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Condition:
(* line 857 "" *)
     WITH t^.Condition DO
(* line 857 "" *)
      
        WriteLine (Pos);
        AssignTempo (Expr);
        WriteS (f, '   if (! ('); Expression (Expr); WriteS (f, ')) goto yyL'); WN (RuleCount); WriteS (f, ';'); WriteNl (f);
        MatchExpr (Expr);
        IF Next^.Kind # Tree.NoStatement THEN
           WriteS (f, "  {"); WriteNl (f);
           ImplC (Next);
           WriteS (f, "  }"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Assignment:
(* line 868 "" *)
     WITH t^.Assignment DO
(* line 868 "" *)
      
        WriteLine (Pos);
        AssignTempo (Adr);
        AssignTempo (Expr);
        IF Object # NoTree THEN
           WriteS (f, "   "); WritePath ( Object^.Formal.Path );
        ELSE
           WriteS (f, "   "); Expression (Adr);
        END;
        WriteS (f, " = "); Expression (Expr); WriteS (f, ";"); WriteNl (f);
        MatchExpr (Adr);
        MatchExpr (Expr);
        ImplC (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Reject:
(* line 882 "" *)
     WITH t^.Reject DO
(* line 882 "" *)
      
        WriteLine (Pos);
        WriteS (f, "   goto yyL"); WN (RuleCount); WriteS (f, ";"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Fail:
(* line 886 "" *)
     WITH t^.Fail DO
(* line 886 "" *)
      
        WriteLine (Pos);
        WriteS (f, "   return"); IF RoutineKind = kPredicate THEN WriteS (f, " false"); END; WriteS (f, ";"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TargetStmt:
(* line 890 "" *)
     WITH t^.TargetStmt DO
(* line 890 "" *)
      
        WriteLine (Pos);
        ImplC (Stmt); WriteNl (f);
        ImplC (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Nl:
(* line 895 "" *)
     WITH t^.Nl DO
(* line 895 "" *)
      
        WriteLine (Pos);
        WriteS (f, "   yyWriteNl;"); WriteNl (f);
        ImplC (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.WriteStr:
(* line 900 "" *)
     WITH t^.WriteStr DO
(* line 900 "" *)
      
        WriteLine (Pos);
        WriteS (f, "   yyWrite ("); WriteString (f, String); WriteS (f, ");"); WriteNl (f);
        ImplC (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Ident:
(* line 905 "" *)
     WITH t^.Ident DO
(* line 906 "" *)
       IF Object # NoTree 
       THEN WritePath ( Object^.Formal.Path ); 
       ELSE WI (Attribute); 
       END;
       ImplC (Next);
     ;
      RETURN;
     END (* WITH *) ;

  | Tree.Any:
(* line 912 "" *)
     WITH t^.Any DO
(* line 912 "" *)
      
        WriteString (f, Code);
        ImplC (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Anys:
(* line 916 "" *)
     WITH t^.Anys DO
(* line 916 "" *)
      
        ImplC (Layouts);
        ImplC (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.LayoutAny:
(* line 920 "" *)
     WITH t^.LayoutAny DO
(* line 920 "" *)
      
        WriteString (f, Code);
        ImplC (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Designator:
(* line 924 "" *)
     WITH t^.Designator DO
(* line 924 "" *)
      
        WritePath ( Object^.Formal.Path ); WriteS (f, "->"); WI (Type); WriteS (f, "."); WI (Attribute);
        ImplC (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Field:
(* line 928 "" *)
     WITH t^.Field DO
(* line 928 "" *)
      
        CantHappen ( "C, ImplC, Field" ) ; 
;
      RETURN;
     END (* WITH *) ;

  | Tree.ConsType:
(* line 931 "" *)
     WITH t^.ConsType DO
(* line 931 "" *)
      
        CantHappen ( "C, ImplC, ConsType" ) ; 
;
      RETURN;
     END (* WITH *) ;

  | Tree.Var:
(* line 934 "" *)
     WITH t^.Var DO
(* line 934 "" *)
      
        CantHappen ( "C, ImplC, Var" ) ; 
;
      RETURN;
     END (* WITH *) ;

  | Tree.NodeTypes:
(* line 937 "" *)
     WITH t^.NodeTypes DO
(* line 937 "" *)
      
        WriteS (f, "t"); WI (TreeName^.TreeName.Name);
;
      RETURN;
     END (* WITH *) ;

  | Tree.UserType:
(* line 940 "" *)
     WITH t^.UserType DO
(* line 940 "" *)
      
        IF NOT IsElement (Type, UserTypes) THEN WriteS (f, "register "); END; WI (Type);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ImplC;

PROCEDURE WritePathRecurse (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Field:
(* line 947 "" *)
     WITH t^.Field DO
(* line 947 "" *)
      
        WritePathRecurse (Next);
        WriteS (f, "."); WI (Name);
;
      RETURN;
     END (* WITH *) ;

  | Tree.ConsType:
(* line 951 "" *)
     WITH t^.ConsType DO
(* line 951 "" *)
      
        WritePathRecurse (Next);
        WriteS (f, "->"); WI (Name);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Var:
(* line 955 "" *)
     WITH t^.Var DO
(* line 955 "" *)
      
        IF IsOutput THEN
           WriteS (f, "(* "); WI (Name); WriteS (f, ")"); 
        ELSE
           WI (Name);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END WritePathRecurse;

PROCEDURE WritePath (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.ConsType:
(* line 966 "" *)
     WITH t^.ConsType DO
(* line 967 "" *)
       WritePathRecurse ( Next ) ; ;
      RETURN;
     END (* WITH *) ;

  | Tree.Field:
(* line 969 "" *)
     WITH t^.Field DO
(* line 971 "" *)
       WritePathRecurse ( t ) ; ;
      RETURN;
     END (* WITH *) ;

  | Tree.Var:
(* line 969 "" *)
     WITH t^.Var DO
(* line 971 "" *)
       WritePathRecurse ( t ) ; ;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END WritePath;

PROCEDURE Declare (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 2: yyR2: RECORD
  Var: tTree;
  END;
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Formal
  , Tree.PlainFormal
  , Tree.RoutineFormal:
(* line 975 "" *)
     WITH t^.Formal DO
(* line 975 "" *)
      
        WriteS (f, "  "); DefC (TypeDesc); WriteS (f, " "); WI (Name); WriteS (f, ";"); WriteNl (f);
        Declare (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Param:
(* line 979 "" *)
    WITH yyTempo.yyR2 DO  
     WITH t^.Param DO
(* line 980 "" *)
      ;
(* line 981 "" *)
       Var := IdentifyVar (Decls, Name);
       WriteS (f, "  "); DefC (Var^.Formal.TypeDesc); WriteS (f, " "); WI (Name); WriteS (f, ";"); WriteNl (f);
       Declare (Next);
     ;
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.ProcCall:
(* line 985 "" *)
     WITH t^.ProcCall DO
(* line 985 "" *)
      
        Declare (Call);
        Declare (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Condition:
(* line 989 "" *)
     WITH t^.Condition DO
(* line 989 "" *)
      
        Declare (Expr);
        Declare (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Assignment:
(* line 993 "" *)
     WITH t^.Assignment DO
(* line 993 "" *)
      
        Declare (Adr);
        Declare (Expr);
        Declare (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TargetStmt:
(* line 998 "" *)
     WITH t^.TargetStmt DO
(* line 998 "" *)
      
        Declare (Parameters);
        Declare (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Statement
  , Tree.Reject
  , Tree.Fail
  , Tree.Nl
  , Tree.WriteStr:
(* line 1002 "" *)
     WITH t^.Statement DO
(* line 1002 "" *)
      
        Declare (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.OnePattern:
(* line 1005 "" *)
     WITH t^.OnePattern DO
(* line 1005 "" *)
      
        IF (Pattern^.Pattern.Tempo # NoIdent) AND NOT Tree . IsType ( Pattern , Tree.DontCare1 ) THEN
           WriteS (f, "  "); DefC (Pattern^.Pattern.TypeDesc); WriteS (f, " "); WI (Pattern^.Pattern.Tempo); WriteS (f, ";"); WriteNl (f);
        END;
        Declare (Pattern);
        Declare (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.OneExpr
  , Tree.NamedExpr:
(* line 1012 "" *)
     WITH t^.OneExpr DO
(* line 1012 "" *)
      
        Declare (Expr);
        Declare (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Decompose:
(* line 1016 "" *)
     WITH t^.Decompose DO
(* line 1016 "" *)
      
        Declare (Patterns);
;
      RETURN;
     END (* WITH *) ;

  | Tree.DontCare
  , Tree.DontCareExplicit
  , Tree.DontCareInternal:
(* line 1019 "" *)
     WITH t^.DontCare DO
(* line 1019 "" *)
      
        Declare (Tempos);
;
      RETURN;
     END (* WITH *) ;

  | Tree.DontCare1
  , Tree.DontCare1Explicit
  , Tree.DontCare1Internal:
(* line 1022 "" *)
     WITH t^.DontCare1 DO
(* line 1022 "" *)
      
        IF Tempo # NoIdent THEN
           WriteS (f, "  "); DefC (TypeDesc); WriteS (f, " "); WI (Tempo); WriteS (f, ";"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Value:
(* line 1027 "" *)
     WITH t^.Value DO
(* line 1027 "" *)
      
        Declare (Expr);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Compose:
(* line 1030 "" *)
     WITH t^.Compose DO
(* line 1030 "" *)
      
        IF Tempo # NoIdent THEN
           WriteS (f, "  register "); DefC (TypeDesc); WriteS (f, " "); WI (Tempo); WriteS (f, ";"); WriteNl (f);
        END;
        Declare (Exprs);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Call:
(* line 1036 "" *)
     WITH t^.Call DO
(* line 1036 "" *)
      
        Declare (Expr);
        Declare (Exprs);
        Declare (Patterns);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Binary
  , Tree.yy1
  , Tree.BinaryCompound:
(* line 1041 "" *)
     WITH t^.Binary DO
(* line 1041 "" *)
      
        Declare (Lop);
        Declare (Rop);
;
      RETURN;
     END (* WITH *) ;

  | Tree.PreOperator:
(* line 1045 "" *)
     WITH t^.PreOperator DO
(* line 1047 "" *)
      
        Declare (Expr); 
;
      RETURN;
     END (* WITH *) ;

  | Tree.PostOperator:
(* line 1045 "" *)
     WITH t^.PostOperator DO
(* line 1047 "" *)
      
        Declare (Expr); 
;
      RETURN;
     END (* WITH *) ;

  | Tree.Parents:
(* line 1045 "" *)
     WITH t^.Parents DO
(* line 1047 "" *)
      
        Declare (Expr); 
;
      RETURN;
     END (* WITH *) ;

  | Tree.Index:
(* line 1050 "" *)
     WITH t^.Index DO
(* line 1050 "" *)
      
        Declare (Expr);
        Declare (Exprs);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Declare;

PROCEDURE Tg1 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Formal
  , Tree.PlainFormal
  , Tree.RoutineFormal:
(* line 1058 "" *)
     WITH t^.Formal DO
(* line 1058 "" *)
      
        TheName := Name;
        Tg1 (TypeDesc);
        Tg1 (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.NodeTypes:
(* line 1063 "" *)
     WITH t^.NodeTypes DO
(* line 1063 "" *)
      
        WriteS (f, "  if ("); WI (TheName); WriteS (f, " == No"); WI (TreeName^.TreeName.Name);
        WriteS (f, ") return"); IF RoutineKind = kPredicate THEN WriteS (f, " false"); END; WriteS (f, ";"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Tg1;

PROCEDURE CommonTestElim (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Decision:
(* line 1071 "" *)
     WITH t^.Decision DO
(* line 1071 "" *)
      
        IF Cases = 0 THEN
           IF NOT TemposDone AND (OneTest^.Kind = Tree.TestValue) AND NeedsTempo (ThenPart, rule) THEN
              WriteS (f, " {"); WriteNl (f);
              TemposDone := TRUE;
              WITH rule^.Rule DO
                 RuleCount := Index;
                 Decls := VarDecls;
                 Declare (Patterns);
                 Declare (Exprs);
                 Declare (Statements);
              END;
              CommonTestElim (OneTest);
              CommonTestElim (ThenPart);
              WriteS (f, "  }"); WriteNl (f);
              WriteS (f, " }"); WriteNl (f);
           ELSE
              GetRule (ThenPart, rule);
              Decls := rule^.Rule.VarDecls;
              CommonTestElim (OneTest);
              CommonTestElim (ThenPart);
              WriteS (f, "  }"); WriteNl (f);
           END;
           IF (OneTest^.Kind = Tree.TestValue) AND
              (OneTest^.TestValue.TypeDesc^.Kind = Tree.UserType) AND
               IsElement (OneTest^.TestValue.TypeDesc^.UserType.Type, UserTypes) THEN
              WriteS (f, "  }"); WriteNl (f);
           END;
           TemposDone := FALSE;
           CommonTestElim (ElsePart);
        ELSE
           i := Cases; Case (t);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Decided:
(* line 1105 "" *)
     WITH t^.Decided DO
(* line 1105 "" *)
      
        CommonTestElim (Rule);
        IF Rule^.Rule.HasExit THEN
           TemposDone := FALSE;
           CommonTestElim (ElsePart);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.TestKind:
(* line 1112 "" *)
     WITH t^.TestKind DO
(* line 1112 "" *)
      
        WriteS (f, "  if ("); WritePath ( Path ); WriteS (f, "->Kind == k"); WI (Name); WriteS (f, ") {"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TestIsType:
(* line 1115 "" *)
     WITH t^.TestIsType DO
(* line 1115 "" *)
      
        WriteS (f, "  if ("); WI (TypeDesc^.NodeTypes.TreeName^.TreeName.Name); WriteS (f, "_IsType ("); WritePath ( Path );
           WriteS (f, ", k"); WI (Name); WriteS (f, ")) {"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TestNil:
(* line 1119 "" *)
     WITH t^.TestNil DO
(* line 1119 "" *)
      
        WriteS (f, "  if ("); WritePath ( Path ); WriteS (f, " == NULL) {"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TestNonlin:
(* line 1122 "" *)
     WITH t^.TestNonlin DO
(* line 1122 "" *)
      
        WriteS (f, "  if (equal"); DefC (TypeDesc); WriteS (f, " ("); WritePath ( Path ); WriteS (f, ", "); WritePath ( Path2 ); WriteS (f, ")) {"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TestValue:
  IF (t^.TestValue.TypeDesc^.Kind = Tree.UserType) THEN
(* line 1125 "" *)
   LOOP
     WITH t^.TestValue DO
     WITH TypeDesc^.UserType DO
(* line 1126 "" *)
      IF NOT ((IsElement (t^.TestValue.TypeDesc^.UserType.Type, UserTypes))) THEN EXIT; END;
(* line 1127 "" *)
      
        AssignTempo (Expr);
        WriteS (f, "  {"); DefC (TypeDesc); WriteS (f, " yyT; yyT = "); Expression (Expr); WriteS (f, ";"); WriteNl (f);
        MatchExpr (Expr);
        WriteS (f, "  if (equal"); DefC (TypeDesc); WriteS (f, " ("); WritePath ( Path ); WriteS (f, ", yyT)) {"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
(* line 1133 "" *)
     WITH t^.TestValue DO
(* line 1133 "" *)
      
        AssignTempo (Expr);
        WriteS (f, "  if (equal"); DefC (TypeDesc); WriteS (f, " ("); WritePath ( Path ); WriteS (f, ", "); Expression (Expr); WriteS (f, ")) {"); WriteNl (f);
        MatchExpr (Expr);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Rule:
(* line 1138 "" *)
     WITH t^.Rule DO
(* line 1138 "" *)
      
        WriteLine (Line);
        RuleCount := Index;
        WithCount := 0;
        Decls := VarDecls;
        IF HasTempos AND NOT TemposDone THEN WriteS (f, " {"); WriteNl (f);
           Declare (Patterns);
           Declare (Exprs);
           Declare (Statements);
        END;
        IF Statements^.Kind # Tree.NoStatement THEN
           WriteS (f, "  {"); WriteNl (f);
           ImplC (Statements);
           WriteS (f, "  }"); WriteNl (f);
        END;
        IF NOT HasRejectOrFail THEN
           AssignFormals (Exprs, OutFormals);
           CASE RoutineKind OF
           | kProcedure: WriteS (f, "   return;"); WriteNl (f);

           | kFunction :
              IF HasPatterns AND (Expr^.Kind # Tree.Compose) AND NOT Tree . IsType ( t , Tree.DontCare1 ) THEN
                 WriteS (f, "  {register "); DefC (ReturnFormals^.Formal.TypeDesc); WriteS (f, " "); WI (Tempo); WriteS (f, ";"); WriteNl (f);
                 Declare (Expr);
                 AssignTempo (Expr);
                 WriteS (f, "   "); WI (Tempo); WriteS (f, " = "); Expression (Expr); WriteS (f, ";"); WriteNl (f);
                 MatchExpr (Expr);
                 WriteS (f, "   return "); WI (Tempo); WriteS (f, ";"); WriteNl (f);
                 WriteS (f, "  }"); WriteNl (f);
              ELSIF HasTempos THEN
                 WriteS (f, "  {"); WriteNl (f);
                 Declare (Expr);
                 AssignTempo (Expr);
                 MatchExpr (Expr);
                 WriteS (f, "   return "); Expression (Expr); WriteS (f, ";"); WriteNl (f);
                 WriteS (f, "  }"); WriteNl (f);
              ELSE
                 WriteS (f, "   return "); Expression (Expr); WriteS (f, ";"); WriteNl (f);
              END;

           | kPredicate: WriteS (f, "   return true;"); WriteNl (f);
           END;
        END;
        IF HasTempos AND NOT TemposDone THEN WriteS (f, " }"); WriteNl (f);
        END;
        IF HasExit OR NeedsMatch (Tests) THEN WriteS (f, "yyL"); WN (RuleCount); WriteS (f, ":;"); WriteNl (f);
        END;
        WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END CommonTestElim;

PROCEDURE Case (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 1: yyR1: RECORD
  n: CARDINAL;
  END;
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Decision:
(* line 1191 "" *)
    WITH yyTempo.yyR1 DO  
     WITH t^.Decision DO
(* line 1192 "" *)
      ;
(* line 1193 "" *)
       WriteNl (f);
       WriteS (f, "  switch ("); WritePath ( OneTest^.OneTest.Path ); WriteS (f, "->Kind) {"); WriteNl (f);
       n := i;
       WHILE n > 0 DO
          IF NOT IsEmpty (t^.Decision.OneTest^.TestIsType.TypeDesc^.NodeTypes.Types) THEN
             Case (t^.Decision.OneTest);
             CommonTestElim (t^.Decision.ThenPart);
             IF NOT NeedsNoFinale (t^.Decision.ThenPart) THEN
                WriteS (f, "  break;"); WriteNl (f);
             END;
          END;
          t := t^.Decision.ElsePart;
          DEC (n);
       END;
       WriteS (f, "  }"); WriteNl (f);
       WriteNl (f);
       CommonTestElim (t);
     ;
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.TestKind:
(* line 1211 "" *)
     WITH t^.TestKind DO
(* line 1211 "" *)
      
        WriteS (f, "  case k"); WI (Name); WriteS (f, ":"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TestIsType:
(* line 1214 "" *)
     WITH t^.TestIsType DO
(* line 1214 "" *)
      
        Case (TypeDesc);
;
      RETURN;
     END (* WITH *) ;

  | Tree.NodeTypes:
(* line 1217 "" *)
     WITH t^.NodeTypes DO
(* line 1217 "" *)
      
        FOR j := Minimum (Types) TO Maximum (Types) DO
           IF IsElement (j, Types) THEN
              TheClass := LookupClass (TreeName^.TreeName.Classes, j);
              WriteS (f, "  case k"); WI (TheClass^.Class.Name); WriteS (f, ":"); WriteNl (f);
           END;
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Case;

PROCEDURE BeginC;
 BEGIN

 END BeginC;

PROCEDURE CloseC;
 BEGIN

 END CloseC;

PROCEDURE yyExit;
 BEGIN
  IO.CloseIO; System.Exit (1);
 END yyExit;

BEGIN
 yyf   := IO.StdOutput;
 Exit  := yyExit;
 BeginC;
END C.

