
(* This file was mechanically generated by puma. *)

IMPLEMENTATION MODULE Semantics;








IMPORT SYSTEM, System, IO, Tree;
(* line 141 "../src/sem.puma" *)


FROM SYSTEM     IMPORT TSIZE, ADR;
FROM General    IMPORT Max;
FROM IO         IMPORT StdOutput, WriteN, WriteS, WriteI, WriteNl;
FROM DynArray   IMPORT MakeArray, ReleaseArray;
FROM Strings    IMPORT tString, IntToString, Append, Concatenate, 
                       ArrayToString ;
FROM StringMem  IMPORT tStringRef ; 
FROM Idents     IMPORT WriteIdent, tIdent, NoIdent, MakeIdent, MaxIdent, 
                       GetString , GetStringRef ;
FROM Texts      IMPORT MakeText;
FROM Scanner    IMPORT Error, StringError, ErrorI, 
                       Warning, StringWarning, WarningI;
FROM Positions  IMPORT tPosition, NoPosition;
FROM Assertions IMPORT Assert, AssertPos, CantHappen, CantHappenPos; 

FROM Sets       IMPORT
   tSet         , MakeSet       , ReleaseSet    , AssignEmpty   ,
   IsElement    , Include       , IsEmpty       , Extract       ,
   Select       , Difference    , Complement    , ForallDo      ,
   IsSubset     , Minimum       , Maximum       , Assign        ,
   Exclude      , Intersection  , WriteSet      , IsNotEqual    , 
   Union        ;

FROM Tree       IMPORT
   tTree        , NoTree        , TreeRoot      , mCall         ,
   mCompose     , mDecompose    , 
   mDontCareInternal            , mDontCare1Internal            ,
   mDontCare1Explicit           ,
   mNilTest     , mNoPattern    , mOnePattern   , mRule         ,
   mOnePatternAlts , mNoPatternsList , mOnePatternsList         , 
   mVarDef      , mBinary       , mClass        , mNoDesignator , 
   mNoFormal    , mPlainFormal  , mRoutineFormal , mNodeTypes   , 
   mUserType    , mAttrDesc     , mTargetExpr   , mAny          , 
   mVar         , mConsType     , mField        , mNoClass      ,
   mOneExpr     , mNoExpr       , mValue        , mDummyFormal  ,
   mWriteStr    , f             , ForallClasses , ForallAttributes,
   Options      , ReverseTree   , IsType        , Class         ,
   Test         , Dummy         , CopyTree      , Nonterminal   ;

VAR
   ExternNames  ,
   LocExternNames,
   ActTypes     ,
   ActNames     ,
   UserNames    , (* Used, but not declared as puma names. *) 
   LabelNames   , (* Includes formals too. *) 
   ParamNames   ,
   RoutineNames : tSet;
   dFormals     ,
   Parameters   ,
   Decls        ,
   Args         ,
   InFormals    ,
   OutFormals   ,
   ReturnFormal ,
   Node         ,
   Var          ,
   TreeName     ,
   ActTree      ,
   ActClass     : tTree;
   RuleCount    ,
   TempoCount   : INTEGER;
   ProcName     ,
   ParamName    ,
   IdentDot     ,
   IdentEmptyType , 
   IdentFalse   , 
   IdentTrue    ,
   IdentNil     : tIdent;
   HasLocals    ,
   IsFunction   ,
   IsOutput     ,
   Mode         ,
   Success      : BOOLEAN;
   String       ,
   String1        : tString;
   i              : CARDINAL;
   nNoFormal      : tTree;
   GlobalLUBClass : tTree ;  
   ParamPos : tPosition ;
   StringRefNil : tStringRef ;  

PROCEDURE PositionToString ( Pos : tPosition ; VAR Result : tString ) 

; VAR LString : tString 

; BEGIN
    IntToString ( VAL ( INTEGER , Pos . Line ) , Result ) 
  ; Append ( Result , ',' ) 
  ; IntToString ( VAL ( INTEGER , Pos . Column ) , LString ) 
  ; Concatenate ( Result , LString )
  END PositionToString ; 

PROCEDURE WarningIPP
  ( Text1 : ARRAY OF CHAR 
  ; Id : tIdent 
  ; Text2 : ARRAY OF CHAR 
  ; Pos2 : tPosition 
  ; Text3 : ARRAY OF CHAR 
  ; Pos3 : tPosition 
  ; Pos : tPosition (* The position the message refers to *)  
  ) 

; VAR LMessage , LString : tString 

; BEGIN 
    ArrayToString ( Text1 , LMessage ) 
  ; GetString ( Id , LString ) 
  ; Concatenate ( LMessage , LString ) 
  ; ArrayToString ( Text2 , LString ) 
  ; Concatenate ( LMessage , LString ) 
  ; PositionToString ( Pos2 , LString ) 
  ; Concatenate ( LMessage , LString ) 
  ; ArrayToString ( Text3 , LString ) 
  ; Concatenate ( LMessage , LString ) 
  ; PositionToString ( Pos3 , LString ) 
  ; Concatenate ( LMessage , LString )
  ; StringWarning ( LMessage , Pos )  
  END WarningIPP ; 

PROCEDURE LookupFormal (Ident: tIdent; Formals: tTree): INTEGER;
   VAR i        : INTEGER;
   BEGIN
      i := 0;
      WHILE IsType ( Formals , Tree . Formal ) DO
         INC (i);
         IF Formals^.Formal.Name = Ident THEN RETURN i; END;
         Formals := Formals^.Formal.Next;
      END;
      RETURN 0;
   END LookupFormal;

PROCEDURE IdentifyTree (i: tIdent): tTree;      (* is i name of a tree type ? *)
   VAR Node: tTree;
   BEGIN
      Node := TreeRoot^.Spec.TreeNames;
      WHILE Node^.Kind = Tree.TreeName DO
         IF Node^.TreeName.Name = i THEN RETURN Node; END;
         Node := Node^.TreeName.Next;
      END;
      RETURN NoTree;
   END IdentifyTree;

PROCEDURE IdentifyProc (i: tIdent): tTree;      (* is i name of a subroutine ? *)
   VAR Node: tTree;
   BEGIN
      Node := TreeRoot^.Spec.Routines;
      WHILE Node^.Kind # Tree.NoRoutine DO
         IF Node^.Routine.Name = i THEN RETURN Node; END;
         Node := Node^.Routine.Next;
      END;
      RETURN NoTree;
   END IdentifyProc;

PROCEDURE IdentifyVar (Node: tTree; i: tIdent): tTree;  (* is i name of a variable ? *)
   BEGIN
      WHILE Node^.Kind # Tree.NoFormal DO
         IF Node^.Formal.Name = i THEN RETURN Node; END;
         Node := Node^.Formal.Next;
      END;
      RETURN NoTree;
   END IdentifyVar;

PROCEDURE IdentifyClass2 (i: tIdent; VAR TreeName: tTree): tTree; (* is i a node type ? *)
   VAR Class: tTree;
   BEGIN
      TreeName := TreeRoot^.Spec.TreeNames;
      WHILE TreeName^.Kind = Tree.TreeName DO
         Class := IdentifyClass (TreeName^.TreeName.Classes, i);
         IF Class # NoTree THEN RETURN Class; END;
         TreeName := TreeName^.TreeName.Next;
      END;
      TreeName := NoTree;
      RETURN NoTree;
   END IdentifyClass2;

PROCEDURE IdentifyClass (t: tTree; Ident: tIdent): tTree;
  (* Search for a class using an identifier. *) 
   VAR class    : tTree;
   BEGIN
      WHILE t^.Kind = Class DO
         WITH t^.Class DO
            IF Name = Ident THEN RETURN t; END;
            class := IdentifyClass (Extensions, Ident);
            IF class # NoTree THEN RETURN class; END;
            t := Next;  (* RETURN IdentifyClass (Next, Ident); *)
         END;
      END;
      RETURN NoTree;
   END IdentifyClass;

PROCEDURE LookupClass (Classes: tTree; i: CARDINAL): tTree;
  (* Search for a class using an index. *) 
   VAR Class: tTree;
   BEGIN
      IF Classes^.Kind = Tree.NoClass THEN RETURN NoTree; END;
      WITH Classes^.Class DO
         IF Index = i THEN RETURN Classes; END;
         Class := LookupClass (Extensions, i);
         IF Class # NoTree THEN RETURN Class; END;
         RETURN LookupClass (Next, i);
      END;
   END LookupClass;

PROCEDURE ClassOfNodeTypes ( NodeTypes : tTree (* NodeTypes *) ) : tTree (* Class *) ; 
  BEGIN 
    RETURN 
      LookupClass 
        ( NodeTypes ^ . NodeTypes . TreeName ^ . TreeName . Classes
        , Minimum ( NodeTypes ^ . NodeTypes . Types )
        ) 
  END ClassOfNodeTypes ;  

PROCEDURE TypeIdentOfFormal ( Formal : tTree (* Formal *) ) : tIdent ; 
  VAR LClass : tTree (* Class *) ; 
  BEGIN 
    IF Formal = Tree . NoTree
    THEN 
      RETURN NoIdent 
    ELSIF IsType ( Formal , Tree . Formal ) 
    THEN
      IF Formal ^ . Formal . TypeDesc = Tree . NoTree  
      THEN 
        RETURN NoIdent 
      ELSIF IsType ( Formal ^ . Formal . TypeDesc , Tree . UserType ) 
      THEN 
        RETURN Formal ^ . Formal . TypeDesc ^ . UserType . Type 
      ELSIF IsType ( Formal ^ . Formal . TypeDesc , Tree . NodeTypes ) 
      THEN 
        IF IsType ( Formal , Tree . RoutineFormal ) 
           AND ( Formal ^ . RoutineFormal . TargetClass # NoTree ) 
        THEN 
          RETURN 
            Formal ^ . RoutineFormal . TargetClass ^ . Class . Name 
        ELSE 
          LClass := ClassOfNodeTypes ( Formal ^ . Formal . TypeDesc ) ;
          RETURN  
            LClass ^ . Class . Name
        END (* IF *) 
      ELSE 
        RETURN NoIdent 
      END (* IF *) 
    ELSE 
      RETURN NoIdent 
    END (* IF *) 
  END TypeIdentOfFormal ; 

PROCEDURE MakeTypes (Index: INTEGER; Classes: tTree; VAR Types: tSet);
   BEGIN
      ActTypes := Types;
      ForallClasses (Classes, ProcFormals);
      Include (ActTypes, Index);
      Types := ActTypes;
   END MakeTypes;

PROCEDURE CheckSubtype (t1, t2: tTree; Pos: tPosition; Reason : ARRAY OF CHAR);
   BEGIN
      IF t1^.Kind = Tree.NodeTypes THEN
         IF t2^.Kind = Tree.UserType THEN
            Warning ( Reason , Pos ) ; 
            Warning ("  user type is incompatible with formal's tree type", Pos);
         ELSIF t2^.NodeTypes.TreeName # t1^.NodeTypes.TreeName THEN
            Error ( Reason , Pos ) ; 
            Error ("  incompatible tree types from different trees", Pos);
         ELSIF NOT IsSubset (t2^.NodeTypes.Types, t1^.NodeTypes.Types) THEN
            Error ( Reason , Pos ) ; 
            Error ("  not a subset of formal node kinds", Pos);
         END;
      ELSIF t1^.Kind = Tree.UserType THEN
         IF t2^.Kind = Tree.NodeTypes THEN
            Warning ( Reason , Pos ) ; 
            Warning ("  tree type is incompatible with formal's user type", Pos);
         ELSIF t2^.UserType.Type # t1^.UserType.Type THEN
            Warning ( Reason , Pos ) ; 
            Warning ("  incompatible user types", Pos);
         END;
      END;
   END CheckSubtype;

PROCEDURE CheckType (t1, t2: tTree; Pos: tPosition);
   VAR t        : tSet;
   BEGIN
      IF t1^.Kind = Tree.NodeTypes THEN
         IF t2^.Kind = Tree.UserType THEN
            Warning ("tree-type required", Pos);
         ELSIF t2^.NodeTypes.TreeName # t1^.NodeTypes.TreeName THEN
            Error ("incompatible types from different trees", Pos);
         ELSE
            MakeSet (t, t1^.NodeTypes.TreeName^.TreeName.ClassCount);
            Assign (t, t1^.NodeTypes.Types);
            Intersection (t, t2^.NodeTypes.Types);
            IF IsEmpty (t) THEN
               Warning ("disjoint node types", Pos);
            END;
            ReleaseSet (t);
         END;
      ELSIF t1^.Kind = Tree.UserType THEN
         IF t2^.Kind = Tree.NodeTypes THEN
            Warning ("user-type required", Pos);
         ELSIF t2^.UserType.Type # t1^.UserType.Type THEN
            Warning ("incompatible user types", Pos);
         END;
      END;
   END CheckType;

PROCEDURE ComputeDepthsClasses ( t : tTree (* Class *) ; FDepth : INTEGER ) 

; VAR LC : tTree 

; BEGIN
    LC := t 
  ; WHILE ( LC <> NIL ) AND ( LC ^ . Kind = Class ) 
    DO 
      LC ^ . Class . Depth := FDepth 
    ; ComputeDepthsClasses ( LC ^ . Class . Extensions , FDepth + 1 ) 
    ; LC := LC ^ . Class . Next 
    END (* WHILE *) 
  END ComputeDepthsClasses ; 

(* Subsumed into ClassFormals: 
PROCEDURE ComputeDepths ( t : tTree (* TreeName *) ) 

; VAR LT : tTree 

; BEGIN
    LT := t 
  ; WHILE ( LT <> NIL ) AND ( LT ^ . Kind = Tree . TreeName ) 
    DO 
      ComputeDepthsClasses ( LT ^ . TreeName . Classes , 1 ) 
    ; LT := LT ^ . TreeName . Next 
    END (* WHILE *) 
  END ComputeDepths ; 
*) 

PROCEDURE ClassLUB ( Left , Right : tTree (* Class *) ) : tTree (* Class *) 

; VAR LDepth : INTEGER 

; BEGIN
    IF Left = NoTree 
    THEN RETURN Right 
    ELSIF Right = NoTree 
    THEN RETURN Left
    ELSIF Left ^ . Kind = Tree . NoClass  
    THEN RETURN Right 
    ELSIF Right ^ . Kind = Tree . NoClass  
    THEN RETURN Left 
    ELSIF Left ^ . Class . Depth = 0 
    THEN RETURN Right 
    ELSIF Right ^ . Class . Depth = 0   
    THEN RETURN Left 
    ELSE 
      LDepth := Right ^ . Class . Depth 
    ; WHILE Left ^ . Class . Depth > LDepth 
      DO Left := Left ^ . Class . BaseClass 
      END (* WHILE *) 
    ; LDepth := Left ^ . Class . Depth 
    ; WHILE Right ^ . Class . Depth > LDepth 
      DO Right := Right ^ . Class . BaseClass 
      END (* WHILE *) 
    ; WHILE Left <> Right 
      DO
        IF Left ^ . Class . Depth = 1  
        THEN 
          Left := Left ^ . Class . TypeDesc 
                  ^ . NodeTypes . TreeName 
                  ^ . TreeName . UniversalClass 
        ; Right := Left 
        ELSE 
          Left := Left ^ . Class . BaseClass
        ; Right := Right ^ . Class . BaseClass 
        END (* IF *) 
      END (* WHILE *) 
    ; RETURN Left 
    END (* IF *) 
  END ClassLUB ; 

PROCEDURE NextPatterns 
  ( Patterns : tTree ; VAR Result : tTree ; VAR CarryOut : BOOLEAN ) 

; VAR LSuffix , LCurrent : tTree 

; BEGIN 
    CASE Patterns ^ . Kind OF 
    | Tree . NoPattern 
      : CarryOut := TRUE 
      ; Result := mNoPattern ( Patterns ^ . NoPattern  . Pos )   
    | Tree . OnePattern 
      : NextPatterns 
          ( Patterns ^ . OnePattern . Next , LSuffix , CarryOut ) 
      ; Result 
          := mOnePattern 
                ( CopyTree ( Patterns ^ . OnePattern . Pattern ) , LSuffix ) 
    | Tree . OnePatternAlts  
      : NextPatterns 
          ( Patterns ^ . OnePatternAlts . Next , LSuffix , CarryOut ) 
      ; LCurrent := Patterns ^ . OnePatternAlts . Current  
      ; Assert
          ( IsType 
              ( LCurrent ^ . OnePatternsList . Patterns , Tree . Decompose )  
          , "NextPatterns, Alt not Decompose." 
          ) 
      ; Result 
          := mOnePattern 
               ( CopyTree ( LCurrent ^ . OnePatternsList . Patterns ) 
                 (* ^A Decompose node.  See ExpandDecompose. *) 
               , LSuffix 
               ) 
      ; IF CarryOut (* Actually, this is the carry in. *) 
        THEN 
          LCurrent := LCurrent ^ . OnePatternsList . Next 
        ; IF LCurrent ^ . Kind = Tree . NoPatternsList 
          THEN 
            Patterns ^ . OnePatternAlts . Current 
              := Patterns ^ . OnePatternAlts . PatternsList 
          ELSE 
            CarryOut := FALSE  
          ; Patterns ^ . OnePatternAlts . Current := LCurrent 
          END (* IF *)  
        END (* IF *) 
    END (* CASE *) 
  END NextPatterns ; 

PROCEDURE ExpandDecompose 
  ( Pos: tPosition
  ; Selector: tIdent
  ; Expr: tTree (* VarUse, Index, or Binary, a form which is a node or type *) 
                (* 1st VarUse inside must have Object field set. *) 
  ; Exprs: tTree (* Untransformed *) 
  ; Widen: BOOLEAN 
  ; VAR Result : tTree 
  ; VAR PatternCount : CARDINAL 
  )
(* POST: Either PatternCount = 1 and Result points to a Decompose node,
   or PatternCount > 1 and Result points to a list of PatternsList
   nodes, each of which points to a Decompose.  The latter case 
   violates the definition of OnePatternsList, but it is a path of
   lower coding resistance. *) 

; VAR LTreeName , LClasses , LClassVarUse , LClass , LOperands : tTree 
; VAR LDecomposeExpr , LResult , LPatterns , LSingleOperands : tTree 
; VAR LClassCount , LOperandsCount : CARDINAL 
; VAR LCarryOut , LHasExactlyOneClass : BOOLEAN 

; BEGIN
    LClassCount := 1 
  ; PatternCount := 0 
  ; LResult := mNoPatternsList ( ) 
  ; CASE Expr ^ . Kind OF 
    | Tree . Index 
      : AssertPos 
          ( Expr ^ . Index . Expr ^ . Kind = Tree . VarUse 
          , "ExpandDecompose, Index w/o 1st VarUse." 
          , Expr ^ . Index . Pos 
          ) 
      ; LTreeName := Expr ^ . Index . Expr ^ . VarUse . Object 
      ; LClasses := Expr ^ . Index . Exprs 
      ; AssertPos 
          ( LClasses ^ . Kind = Tree . OneExpr 
          , "ExpandDecompose, Index w/o Expr." 
          , Expr ^ . Index . Pos 
          ) 
      ; LClassVarUse := LClasses ^ . OneExpr . Expr 
      ; AssertPos 
          ( LClassVarUse ^ . Kind = Tree . VarUse  
          , "ExpandDecompose, Index w/o 2nd VarUse." 
          , Expr ^ . Index . Pos 
          ) 
      ; LClass 
          := IdentifyClass 
               ( LTreeName ^ . TreeName . Classes 
               , LClassVarUse ^ . VarUse . Name 
               ) 
      ; LClassVarUse ^ . VarUse . Object := LClass 
      ; LDecomposeExpr 
          := mBinary 
               ( Expr ^ . Index . Pos 
               , Expr ^ . Index . Selector 
               , Expr ^ . Index . Expr 
               , IdentDot 
               , LClassVarUse 
               , Widen 
               ) 
      ; LHasExactlyOneClass 
          := LClasses ^ . OneExpr . Next ^ . Kind = Tree . NoExpr 
    | Tree . VarUse 
      : LClassVarUse := Expr 
      ; LClass := LClassVarUse ^ . VarUse . Object 
      ; LDecomposeExpr := Expr  
      ; LHasExactlyOneClass := TRUE 
    | Tree . Binary 
      : AssertPos 
          ( Expr ^ . Binary . Operator = IdentDot 
          , "ExpandDecompose, Binary w/o dot." 
          , Expr ^ . Binary . Pos 
          ) 
      ; AssertPos 
          ( Expr ^ . Binary . Lop ^ . Kind = Tree . VarUse  
          , "ExpandDecompose, Binary w/o 1st VarUse." 
          , Expr ^ . Binary . Pos 
          ) 
      ; LTreeName := Expr ^ . Binary . Lop ^ . VarUse . Object 
      ; AssertPos 
          ( Expr ^ . Binary . Rop ^ . Kind = Tree . VarUse 
          , "ExpandDecompose, Binary w/o 2nd VarUse." 
          , Expr ^ . Binary . Pos 
          ) 
      ; LClassVarUse := Expr ^ . Binary . Rop 
      ; LClass 
          := IdentifyClass 
               ( LTreeName ^ . TreeName . Classes 
               , LClassVarUse ^ . VarUse . Name 
               ) 
      ; LClassVarUse ^ . VarUse . Object := LClass 
      ; LDecomposeExpr := Expr 
      ; LHasExactlyOneClass := TRUE 
    ELSE CantHappen ( "ExpandDecompose, Bad Kind." ) 
    END (* CASE *) 
  ; LOOP (* Thru type elements *)
    (* INVARIANT: Expr ^ . Kind = Tree . Index 
                    => LTreeName is the object for the tree name. 
                  LClassVarUse points to a VarUse node for the
                    next Class.
                  LDecomposeExpr is the Expr child of the to-be-constructed
                    Decompose node. 
                  LHasExactlyOneClass is set appropriately. 
                  LClass is the decl of the class. 
    *) 
      IF LClass = NoTree 
      THEN 
        Error ( "not a class or node of the required tree" 
              , LClassVarUse ^ . VarUse . Pos 
              ) 
      ELSE 
        AssertPos 
          ( LClass ^ . Kind = Tree . Class 
          , "ExpandDecompose, not a class. "
          , Expr ^ . Expr . Pos 
          ) 
      ; LOperands 
          := TransformKeyword ( Exprs , LClass ^ . Class . Formals ) 
      ; TransformPattern ( LOperands , LOperands , LOperandsCount ) 
      ; INC ( PatternCount , LOperandsCount ) 
      ; LOOP (* Thru cartesian product of operand patterns *) 
          IF LHasExactlyOneClass AND ( LOperandsCount = 1 ) 
          THEN (* Avoid unnecessary copying *) 
            LSingleOperands := LOperands 
          ; LCarryOut := TRUE 
          ELSE 
            NextPatterns ( LOperands , LSingleOperands , LCarryOut ) 
          END (* IF *) 
        ; LPatterns 
            := mDecompose 
                 ( Pos 
                 , Selector 
                 , LDecomposeExpr 
                 , LSingleOperands 
                 , Widen 
                 ) 
        ; LPatterns ^ . Decompose . Object := LClass  
        ; LResult 
            := mOnePatternsList ( LPatterns , LResult ) 
          (* ^This builds the result list backwards. *) 
        ; IF LCarryOut THEN EXIT END (* IF *) 
        END (* LOOP *) 
      END (* IF *) 
    (* Loop advance and termination: *) 
    ; IF Expr ^ . Kind = Tree . Index 
      THEN 
        LOOP (* Thru possibly bad type elements *) 
          LClasses := LClasses ^ . OneExpr . Next 
        ; CASE LClasses ^ . Kind OF 
          | Tree . NoExpr 
            : LClassVarUse := NoTree 
            ; EXIT (* Inner loop.  Will then exit outer loop. *) 
          | Tree . NamedExpr 
            : LClassVarUse := LClasses ^ . NamedExpr . Expr 
            ; Error 
                ( "named expression not allowed in a type" 
                , LClassVarUse ^ . Expr . Pos 
                ) 
            ; IF LClassVarUse ^ . Kind <> Tree . VarUse 
              THEN 
                Error 
                  ( "single identifier required in a type" 
                  , LClassVarUse ^ . Expr . Pos 
                  ) 
              END (* IF *) 
          | Tree .OneExpr 
            : LClassVarUse := LClasses ^ . OneExpr . Expr 
            ; IF LClassVarUse ^ . Kind <> Tree . VarUse 
              THEN 
                Error 
                  ( "single identifier required in a type" 
                  , LClassVarUse ^ . Expr . Pos 
                  ) 
              ELSE 
                INC ( LClassCount ) 
              ; LClass 
                  := IdentifyClass 
                       ( LTreeName ^ . TreeName . Classes 
                       , LClassVarUse ^ . VarUse . Name 
                       )  
              ; LClassVarUse ^ . VarUse . Object := LClass 
              ; LDecomposeExpr 
                  := mBinary 
                       ( Expr ^ . Index . Pos 
                       , Expr ^ . Index . Selector
                       , Expr ^ . Index . Expr 
                       , IdentDot 
                       , LClassVarUse 
                       , Widen 
                       ) 
              ; EXIT (* Inner loop. Will then go around outer loop *) 
              END (* IF *) 
          ELSE CantHappenPos 
                 ( "ExpandDecompose, not an expr." 
                 , LClassVarUse ^ . VarUse . Pos 
                 ) 
          END (* CASE *) 
        END (* LOOP Thru possibly bad type elements *) 
      ; IF LClassVarUse = NoTree THEN EXIT END (* IF *)  
      ELSE 
        EXIT 
      END (* IF *) 
    END (* LOOP Thru type elements *) 
  ; IF PatternCount = 1 
    THEN 
      Result := LResult ^ . OnePatternsList . Patterns 
    ELSE
      Result := ReverseTree ( LResult ) 
    END (* IF *) 
  END ExpandDecompose ; 

PROCEDURE IsAllDontCares ( t : tTree ) : BOOLEAN 

; VAR LExprs , LExpr : tTree 

; BEGIN 
    LExprs := t 
  ; LOOP 
      IF LExprs ^ . Kind = Tree . NoExpr 
      THEN 
        RETURN TRUE 
      ELSIF LExprs ^ . Kind = Tree . OneExpr 
      THEN 
        LExpr := LExprs ^ . OneExpr . Expr 
      ; IF IsType ( LExpr , Tree . DontCare ) 
        THEN 
          RETURN TRUE 
        ELSIF IsType ( LExpr , Tree . DontCare1 ) 
        THEN 
          LExprs := LExprs ^ . OneExpr . Next 
        ELSE 
          RETURN FALSE 
        END (* IF *) 
      ELSE (* Probably NamedExpr *)  
        RETURN FALSE 
      END (* IF *) 
    END (* LOOP *) 
  END IsAllDontCares ;  

PROCEDURE MakeValue ( t : tTree ) : tTree 

; VAR LSelector : tIdent 

; BEGIN 
    LSelector := t ^ . Expr . Selector 
  ; t ^ . Expr . Selector := NoIdent 
  ; RETURN mValue ( t ^ . Expr . Pos , LSelector , TransformExpr ( t ) )
  END MakeValue ; 

PROCEDURE TransformPattern 
  ( t : tTree ; VAR Result : tTree ; VAR PatternCount : CARDINAL ) 

; BEGIN 
    IF t ^ . Kind = Tree . NoExpr 
    THEN
      Result 
        := mOnePattern 
             ( mDontCareInternal ( t ^ . NoExpr . Pos ) 
             , mNoPattern ( t ^ . NoExpr . Pos )  
             ) 
    ; PatternCount := 1 
    ELSE
      TransformPatternRecurse ( t , Result , PatternCount ) 
    END (* IF *) 

  END TransformPattern ; 

PROCEDURE TransformPatternRecurse 
  ( t : tTree ; VAR Result : tTree ; VAR PatternCount : CARDINAL ) 

; VAR TreeName , s , LTreeName , LClass , LPrefixVarUse , L1stVarUse : tTree 
; VAR LTree1 , LTree2 : tTree 
; VAR LThisCount , LNextCount : CARDINAL 

; BEGIN 
    PatternCount := 1 
  ; CASE t ^ . Kind 

    OF Tree . NoExpr 
      : Result := mNoPattern ( t ^ . NoExpr . Pos ) 

    | Tree . Parents 
      : IF IsType ( t ^ . Parents . Expr , Tree . DontCare1 ) 
        THEN (* Special case to ignore parentheses around '_' *) 
          Result := t ^ . Parents . Expr 
        ; IF t ^ . Parents . Selector <> NoIdent 
          THEN
            IF ( Result ^ . DontCare1 . Selector <> NoIdent ) 
               AND ( Result ^ . DontCare1 . Selector  
                     <> t ^ . Parents . Selector ) 
            THEN 
              WarningI 
                ( "Label ignored:" 
                , t ^ . Parents . Pos 
                , t ^ . Parents . Selector 
                ) 
            ELSE 
              Result ^ . DontCare1 . Selector := t ^ . Parents . Selector 
              (* ^Move label on the parentheses into the dont care *) 
            END (* IF *)  
          END (* IF *) 
        ELSE 
          Result := MakeValue ( t )  
        END (* IF *) 

    | Tree . OneExpr 
      : WITH t ^ . OneExpr 
        DO 
          TransformPatternRecurse ( Expr , LTree1 , LThisCount ) 
        ; TransformPatternRecurse ( Next , LTree2 , LNextCount ) 
        ; IF LThisCount = 1 
          THEN 
            Result := mOnePattern ( LTree1 , LTree2 ) 
          ELSE  
            Result 
              := mOnePatternAlts 
                   ( (* PatternsList := *) LTree1 
                   , (* Next := *) LTree2 
                   , (* Current := *) LTree1 
                   ) 
          END (* IF *) 
        ; PatternCount := LThisCount * LNextCount 
        END (* WITH *) 

    | Tree . NamedExpr 
      : WITH t ^ . NamedExpr 
        DO 
          Error 
            ( "illegal context for named association" 
            , Expr ^ . Expr . Pos 
            ) 
        ; TransformPatternRecurse ( Expr , LTree1 , LThisCount ) 
        ; TransformPatternRecurse ( Next , LTree2 , LNextCount ) 
        ; IF LThisCount = 1 
          THEN 
            Result := mOnePattern ( LTree1 , LTree2 ) 
          ELSE  
            Result 
              := mOnePatternAlts 
                   ( (* PatternsList := *) LTree1 
                   , (* Next := *) LTree2 
                   , (* Current := *) LTree1 
                   ) 
          END (* IF *) 
        ; PatternCount := LThisCount * LNextCount 
        END (* WITH *) 

    | Tree . Nil 
      : WITH t ^ . Nil 
        DO
          Result := mNilTest ( Pos , Selector , Widen )
        END (* WITH *) 

    | Tree . DontCareExplicit , Tree . DontCareInternal  
    , Tree . DontCare1Explicit , Tree . DontCare1Internal  
      : Result := t 

    | Tree . DontCare1 , Tree . DontCare
      : CantHappen 
          ( 'TransformPatternRecurse, undistinguished DontCare' ) 

    | Tree . Compose 
      : WITH t ^ . Compose 
        DO 
          IF Expr ^ . Kind = Tree . Index 
          THEN 
            IF ( Expr ^ . Index . Expr ^ . Kind = Tree . VarUse ) 
               AND IsType 
                     ( Expr ^ . Index . Exprs , Tree . OneExpr ) 
               AND ( Expr ^ . Index . Exprs ^ . OneExpr . Expr ^ . Kind 
                     = Tree . VarUse 
                   ) 
            THEN (* [ <ident> ] '[' <ident> ... ']' '(' ... ')' *) 
              LPrefixVarUse := Expr ^ . Index . Expr  
            ; L1stVarUse 
                := Expr ^ . Index . Exprs ^ . OneExpr . Expr 
            ; IF LPrefixVarUse ^ . VarUse . Name = NoIdent 
              THEN (* '[' <ident> ... ']' *) 
                Object (* of Compose node *)
                  := IdentifyClass2 
                       ( L1stVarUse ^ . VarUse . Name , LTreeName ) 
              ; LPrefixVarUse ^ . VarUse . Object := LTreeName 
              ; L1stVarUse ^ . VarUse . Object := Object 
              ; IF Object = NoTree 
                THEN 
                  Error 
                    ( "node type not declared" 
                    , L1stVarUse ^ . VarUse . Pos 
                    ) 
                ; Result := mDontCareInternal ( Pos ) 
                ELSE 
                  ExpandDecompose 
                    ( Pos , Selector , Expr , Exprs , Widen 
                    , Result , PatternCount 
                    ) 
                END (* IF *) 
              ELSE (* prefix identifier is present. *) 
                LTreeName 
                  := IdentifyTree 
                       ( LPrefixVarUse ^ . VarUse . Name ) 
              ; LPrefixVarUse ^ . VarUse . Object := LTreeName 
              ; IF LTreeName = NoTree 
                THEN (* Interpret as plain target index expression. *) 
                  Result 
                    := MakeValue ( t )  
                ELSE 
                  Object 
                    := IdentifyClass 
                         ( LTreeName ^ . TreeName . Classes 
                         , L1stVarUse ^ . VarUse . Name 
                         ) 
                ; L1stVarUse ^ . VarUse . Object := Object 
                ; IF Object = NoTree 
                  THEN (* Interpret as plain target index expression. *) 
                    Result 
                      := MakeValue ( t )  
                  ELSE 
                    ExpandDecompose 
                      ( Pos , Selector , Expr , Exprs , Widen 
                      , Result , PatternCount 
                      ) 
                  END (* IF *) 
                END (* IF *) 
              END (* IF *) 
            ELSE (* Not a special form of index *) 
              Result := MakeValue ( t )  
            END (* IF special form of index *) 
          ELSIF IsAllDontCares ( Exprs ) 
                AND ( IsType ( Expr , Tree . DontCare1 ) 
                      OR ( IsType ( Expr , Tree . VarUse ) 
                           AND ( Expr ^ . VarUse . Name = NoIdent ) 
                         )  
                    ) 
          THEN (* Label and/or '_' to left of "( .. )" *) 
            Result := Expr (* Toss garbage *) 
          ELSE (* Not Index *) 
            IF Expr ^ . Kind = Tree . VarUse 
            THEN 
              Object 
                := IdentifyClass2 
                     ( Expr ^ . VarUse . Name , TreeName ) 
            ; IF Object = NoTree 
              THEN 
                Object := IdentifyProc ( Expr ^ . VarUse . Name ) 
              END 
            ; Expr ^ . VarUse . Object := Object 
            ELSIF ( Expr ^ . Kind = Tree . Binary ) 
                  AND ( Expr ^ . Binary . Operator = IdentDot ) 
                  AND ( Expr ^ . Binary . Lop ^ . Kind 
                        = Tree . VarUse 
                      ) 
                  AND ( Expr ^ . Binary . Rop ^ . Kind 
                        = Tree . VarUse 
                      ) 
            THEN 
              Object 
                := IdentifyTree 
                     ( Expr ^ . Binary . Lop ^ . VarUse . Name ) 
            ; Expr ^ . Binary . Lop ^ . VarUse . Object := Object 
            ; IF Object # NoTree 
              THEN 
                Object 
                  := IdentifyClass 
                       ( Object ^ . TreeName . Classes 
                       , Expr ^ . Binary . Rop ^ . VarUse . Name 
                       ) 
              END 
            ; Expr ^ . Binary . Rop ^ . VarUse . Object := Object 
            ELSE (* Expr is not one of the forms consistent with Decompose. 
                    Treat as a target call. *) 
              Result := MakeValue ( Expr ) 
            ; Object := NoTree 
            END 
          ; IF Object # NoTree 
            THEN 
              IF Object ^ . Kind = Class 
              THEN 
                ExpandDecompose 
                  ( Pos , Selector , Expr , Exprs , Widen 
                  , Result , PatternCount 
                  ) 
              ELSE (* Object denotes a puma-declared procedure *) 
                s := mCall 
                       ( Pos
                       , (* Selector := *) NoIdent
                       , Expr 
                       , TransformExpr ( Exprs ) 
                       , mNoPattern ( Pos ) 
                       ) 
              ; s ^ . Call . Object := Object 
              ; Result := mValue ( Pos , Selector , s ) 
              END 
            ELSE (* Object is unknown.  Treat as a target procedure call. *) 
              s := mCall 
                     ( Pos 
                     , (* Selector := *) NoIdent 
                     , Expr 
                     , TransformExpr ( Exprs ) 
                     , mNoExpr ( Pos ) 
(* ^ This violates the graph grammar. Perhaps mNoPattern? *) 
                     ) 
            ; s ^ . Call . Object := Object 
            ; Result := mValue ( Pos , Selector , s ) 
            END (* IF *) 
          END (* IF *) 
        END (* WITH t ^ . Compose *) 

    | Tree . VarUse 
      : WITH t ^ . VarUse 
        DO 
          IF Name = NoIdent 
          THEN (* <Selector> ':' *) 
            Result := mVarDef ( Pos , Selector , (* HasDelimiter := *) TRUE ) 
          ELSE 
            Object := IdentifyClass2 ( Name , TreeName ) 
          ; IF ( ( Object # NoTree ) 
                 AND IsElement ( ORD ( 'p' ) , Options ) 
                     (* ^Allow (de)constructors w/o parentheses. *) 
               ) 
            THEN (* It is a node name *) 
(*             t ^ . VarUse . Object := Object *)
(* *) 
            ; Result 
                := mDecompose 
                     ( Pos 
                     , Selector
                     , t 
                     , mOnePattern 
                         ( mDontCareInternal ( Pos ) , mNoPattern ( Pos ) ) 
                     , Widen 
                     ) 
            ; t ^ . VarUse . Selector := NoIdent 
            ; Result ^ . Decompose . Object := Object 
            ELSIF IsElement (Name, ExternNames) 
                  OR IsElement (Name, LocExternNames) 
                  OR IsElement (Name, UserNames) 
                  OR IsElement (Name, RoutineNames) 
            THEN (* Ident has a declared meaning *) 
              Result := MakeValue ( t )  
            ELSIF Selector <> NoIdent 
            THEN (* Ident : Ident *) 
              Result := MakeValue ( t )  
            ELSE (* Free identifier, no colon *)  
              Result := mVarDef ( Pos , Name , (* HasDelimiter := *) FALSE )
            END 
          END (* IF *) 
        END (* WITH *) 

    | Tree . Binary 
      : WITH t ^ . Binary 
        DO 
          IF IsElement ( ORD ( 'p' ) , Options ) 
             AND ( Operator = IdentDot ) 
             AND ( Lop ^ . Kind = Tree . VarUse ) 
             AND ( Rop ^ . Kind = Tree . VarUse ) 
          THEN (* Ident '.' Ident 
                  and (de)constructors w/o parentheses allowed. *)
            LTreeName := IdentifyTree ( Lop ^ . VarUse . Name ) 
          ; IF LTreeName # NoTree 
            THEN 
              LClass 
                := IdentifyClass 
                     ( LTreeName ^ . TreeName . Classes 
                     , Rop ^ . VarUse . Name 
                     ) 
            ; IF LClass # NoTree 
              THEN 
                Lop ^ . VarUse . Object := LTreeName 
              ; Rop ^ . VarUse . Object := LClass 
              ; Result 
                  := mDecompose 
                       ( Pos 
                       , Selector 
                       , t 
                       , mOnePattern 
                           ( mDontCareInternal ( Pos ) , mNoPattern ( Pos ) ) 
                       , Widen 
                       ) 
              ; Result ^ . Decompose . Object := LClass 
              ELSE 
                Result := MakeValue ( t )  
              END 
            ELSE 
              Result := MakeValue ( t )  
            END 
          ELSE 
            Result := MakeValue ( t )  
          END 
        END (* WITH *) 

    | Tree . Index 
      : WITH t ^ . Index 
        DO 
          IF IsElement ( ORD ( 'p' ) , Options ) 
             AND ( Expr ^ . Kind = Tree . VarUse ) 
             AND IsType ( Exprs , Tree . OneExpr ) 
             AND ( Exprs ^ . OneExpr . Expr ^ . Kind = Tree . VarUse ) 
          THEN (* [ <ident> ] [ '.' ] '[' <ident> ... ']' 
                  and (de)constructors w/o parentheses allowed. *)
            L1stVarUse := Exprs ^ . OneExpr . Expr 
          ; IF Expr ^ . VarUse . Name = NoIdent 
            THEN (* '[' <ident> ... ']' *) 
              LClass 
                := IdentifyClass2 
                     ( L1stVarUse ^ . VarUse . Name , LTreeName ) 
            ; Expr ^ . VarUse . Object := LTreeName 
            ; L1stVarUse ^ . VarUse . Object := LClass 
            ; IF LClass = NoTree 
              THEN 
                Error 
                  ( "node type not declared" 
                  , L1stVarUse ^ . VarUse . Pos 
                  ) 
              ; Result 
                  := mDontCare1Internal 
                       ( L1stVarUse ^ . VarUse . Pos , Selector ) 
              ELSE
                ExpandDecompose 
                  ( Pos 
                  , Selector 
                  , t 
                  , mOnePattern 
                      ( mDontCareInternal ( Pos ) , mNoPattern ( Pos ) ) 
                  , Widen 
                  , Result 
                  , PatternCount 
                  ) 
              END (* IF *) 
            ELSE (* prefix identifier is present. *) 
              LTreeName := IdentifyTree ( Expr ^ . VarUse . Name ) 
            ; Expr ^ . VarUse . Object := LTreeName 
            ; IF LTreeName = NoTree 
              THEN (* Interpret as target code index *) 
                Result := MakeValue ( t )  
              ELSE 
                LClass 
                  := IdentifyClass 
                       ( LTreeName ^ . TreeName . Classes 
                       , L1stVarUse ^ . VarUse . Name 
                       ) 
              ; L1stVarUse ^ . VarUse . Object := LClass 
              ; IF LClass = NoTree 
                THEN (* Interpret as target index *) 
                  Result 
                    := MakeValue ( t )  
                ELSE
                  ExpandDecompose 
                    ( Pos 
                    , Selector
                    , t 
                    , mOnePattern 
                        ( mDontCareInternal ( Pos ) , mNoPattern ( Pos ) ) 
                    , Widen
                    , Result 
                    , PatternCount 
                    ) 
                END (* IF *) 
              END (* IF *) 
            END (* IF *) 
          ELSE 
            Result := MakeValue ( t )  
          END (* IF *) 
        END (* WITH *) 

    | Tree . Call , Tree . PreOperator , Tree . PostOperator 
    , Tree . TargetExpr , Tree . StringExpr 
    , Tree . AttrDesc (* '::' in an expression *) 
      : Result := MakeValue ( t )  

    | Tree . NoPattern , Tree . OnePattern , Tree . OnePatternAlts 
      : CantHappen ( "TransformPatternRecurse, already transformed." ) 
      ; Result := t 

    END (* CASE *) 
  END TransformPatternRecurse ; 

PROCEDURE TransformExpr (t: tTree): tTree;
   VAR TreeName, s, LObject1, LObject2  : tTree;
   VAR LPatternCount : CARDINAL ; 
   BEGIN
     CASE t^.Kind OF
     | Tree.NoExpr     :

     | Tree.OneExpr    : WITH t^.OneExpr DO
           Expr        := TransformExpr (Expr);
           Next        := TransformExpr (Next);
        END;

     | Tree.NamedExpr  : WITH t^.NamedExpr DO
           Error 
             ("Keyword notation illegal in an expression"
             , t^.NamedExpr.Expr^.Expr.Pos);
           RETURN mOneExpr (TransformExpr (Expr), TransformExpr (Next));
        END;

     | Tree.Compose    : WITH t^.Compose DO
           IF Expr^.Kind = Tree.VarUse THEN
              Object := IdentifyClass2 (Expr^.VarUse.Name, TreeName);
              IF Object = NoTree 
              THEN Object := IdentifyProc (Expr^.VarUse.Name); END;
              Expr^.VarUse.Object := Object; 
           ELSIF (Expr^.Kind = Tree.Binary) AND
                 (Expr^.Binary.Lop^.Kind = Tree.VarUse) AND
                 (Expr^.Binary.Rop^.Kind = Tree.VarUse) THEN
(* Can assert Operator is a dot? *) 
              Object := IdentifyTree (Expr^.Binary.Lop^.VarUse.Name);
              (* Expr^.Binary.Lop^.VarUse.Object := Object; 
                 This seems reasonable, but breaks M2.puma`s generation of 
                 Tree.<NotAClass> M2.puma always expects a VarUse with a 
                 non-NIL Object field to have Object of kind Formal, with
                 a Path to call ImplMod on. *) 
              IF Object # NoTree THEN
                 Object := IdentifyClass (Object^.TreeName.Classes, Expr^.Binary.Rop^.VarUse.Name);
              END;
              IF Object = NoTree 
              THEN 
                Expr^.Binary.Lop^.VarUse.Object := NoTree 
              ; Expr^.Binary.Rop^.VarUse.Object := NoTree 
              END (* IF *) 
           ELSE
              Object := NoTree;
              Expr := TransformExpr (Expr);
           END;

           IF Object # NoTree THEN
              IF Object^.Kind = Class THEN
                 Exprs := TransformKeyword (Exprs, Object^.Class.Formals);
                 Exprs := TransformExpr (Exprs);
                 RETURN t;
              ELSE
                 s := mCall 
                     ( Pos 
                     , Selector 
                     , Expr 
                     , TransformExpr ( Exprs )
                     , mNoPattern ( Pos ) 
                     ) ;
                 s^.Call.Object := Object;
                 RETURN s;
              END;
           ELSE
              s := mCall 
                    ( Pos
                    , Selector
                    , Expr
                    , TransformExpr ( Exprs )
                    , mNoExpr ( Pos )
                    ) ;
(* ^ mNoExpr violates the graph grammar. Perhaps mNoPattern? *) 
              s^.Call.Object := Object;
              RETURN s;
           END;
        END;

     | Tree.VarUse     
       : WITH t ^ . VarUse 
         DO
           Object := IdentifyClass2 (Name, TreeName);
           IF IsElement ( ORD ( 'p' ) , Options ) AND ( Object # NoTree ) 
           THEN (* The -p option is pretty drastic, because it means 
                   (globally declared) node constructor meanings _always_ 
                   supercede any local meanings.  The latter can never
                   be referred to! *) 
              s := mCompose (Pos, NoIdent, t, mOneExpr (mDontCareInternal (Pos), mNoExpr (Pos)), FALSE);
              s^.Compose.Object := Object;
              RETURN s;
           ELSE
              Object := NoTree;
              RETURN t;
           END;
         END (* WITH *) 

     | Tree.Nil        :
     | Tree.DontCare1Explicit : 
     | Tree.DontCare1Internal : 
     | Tree.DontCareExplicit :  
     | Tree.DontCareInternal :

     | Tree.DontCare1, Tree.DontCare   
       : CantHappen 
           ( 'TransformExpr, undistinguished DontCare' ) 

     | Tree.Call       : WITH t^.Call DO
           IF Expr^.Kind = Tree.VarUse THEN
              Object := IdentifyProc (Expr^.VarUse.Name);
           ELSE
              Object := NoTree;
           END;
           Expr  := TransformExpr (Expr);
           Exprs := TransformExpr (Exprs);
           IF Object # NoTree THEN
             TransformPattern ( Patterns , Patterns , LPatternCount ) 
             (* ^These are the actuals of out formals of a puma routine. 
                Why don`t we do a TransformKeyword? *)
           ; IF LPatternCount > 1 
             THEN 
               Error 
                 ( 'pattern containing multi-valued types not allowed as actual to out formal' 
                 , Pos 
                 ) 
             END (* IF *) 
           ELSIF Patterns ^ . Kind = Tree . OneExpr  
                 (* Parser builds these as a list of expressions.
                    TransformPattern, if done at all, transforms
                    into a list of patterns. *) 
           THEN 
              Error 
                ( "Call on user procedure cannot have result patterns" 
(* ^Do we want to soften this? *)
                , Pos 
                ) ;
              Patterns := TransformExpr (Patterns);
           END;
        END;

     | Tree.Binary : 
        WITH t^.Binary 
        DO
          IF ( Operator = IdentDot ) 
             AND ( Lop^.Kind = Tree.VarUse ) 
             AND ( Rop^.Kind = Tree.VarUse ) 
          THEN (* <Ident> '.' <Ident> *) 
            IF IsElement (ORD ('p'), Options) 
            THEN (* Try to make this a <TreeName> . <ClassName> => Compose *) 
              LObject1 := IdentifyTree (Lop^.VarUse.Name);
              IF LObject1 # NoTree THEN
                 LObject2 
                   := IdentifyClass (LObject1^.TreeName.Classes, Rop^.VarUse.Name);
                 IF LObject2 # NoTree THEN
                    s := mCompose (Pos, NoIdent, t, mOneExpr (mDontCareInternal (Pos), mNoExpr (Pos)), FALSE);
                    s^.Compose.Object := LObject2;
                    Lop^.VarUse.Object := LObject1; 
                    Rop^.VarUse.Object := LObject2; 
                    RETURN s;
                 END;
              END;
            END (* IF *) 
          ELSE (* Ordinary binary operator *) 
            Lop         := TransformExpr (Lop);
            Rop         := TransformExpr (Rop);
          END (* IF *) ;
        END (* WITH *) 

     | Tree . BinaryCompound 
       : WITH t ^ . BinaryCompound 
         DO 
           Lop         := TransformExpr (Lop)
         ; Rop         := TransformExpr (Rop)
         END (* WITH t ^ . BinaryCompound *) ; 

     | Tree.PreOperator, Tree.PostOperator     : WITH t^.PreOperator DO
           Expr        := TransformExpr (Expr);
        END;

     | Tree.Index      : WITH t^.Index DO
           Expr        := TransformExpr (Expr);
           Exprs       := TransformExpr (Exprs);
        END;

     | Tree.Parents    : WITH t^.Parents DO
           Expr        := TransformExpr (Expr);
        END;

     | Tree.TargetExpr :
     | Tree.StringExpr :
     | Tree.AttrDesc   : (* '::' in an expression *)
     END (* CASE *) 
   ; RETURN t
   END TransformExpr ;

PROCEDURE TransformStmt (t: tTree): tTree;
   BEGIN
      CASE t^.Kind OF
      | Tree.NoStatement: RETURN t;

      | Tree.ProcCall   
         (* In statement context, parser puts ProcCall on top 
            of expression. *) 
      :  WITH t^.ProcCall DO
            Call := TransformExpr (Call);
            IF Call^.Kind = Tree.Call THEN
               WITH Call^.Call DO
                  IF (Object # NoTree) AND
                     ( (Object^.Kind = Tree.Predicate) 
                       OR (Object^.Kind = Tree.Function)
                     ) 
                  THEN (* ProcCall on most things turns into a condition. *)
                     t^.Kind := Tree.Condition;
(* Boy, is this sleazy!  It relys on ProcCall and Condition having
   the same field layout! *) 
                  END;
               END;
            ELSIF Call^.Kind = Tree.Compose THEN
              Error ("Node constructor as a statement", Pos);
            ELSIF Call^.Kind = Tree.StringExpr THEN
               t := mWriteStr (Pos, Next, Call^.StringExpr.String);
            ELSE
               t^.Kind := Tree.Condition;
(* Sleazy, as above. *) 
            END;
         END;

      | Tree.Assignment : WITH t^.Assignment DO
            Adr  := TransformExpr (Adr );
            Expr := TransformExpr (Expr);
         END;

      | Tree.Reject     :
      | Tree.Fail       :
      | Tree.TargetStmt :
      | Tree.Nl         :
      | Tree.WriteStr   :
      END;
      t^.Statement.Next := TransformStmt (t^.Statement.Next);
      RETURN t;
   END TransformStmt;

(* TransformKeyword rewrites keword associations. *)
PROCEDURE TransformKeyword (t, Formals: tTree): tTree;
   VAR
      Exprs             : tTree;
      Last              : POINTER TO tTree;
      n, i              ,
      Minimum, Maximum  : INTEGER;
      PatternsSize      : LONGINT;
      PatternsPtr       : POINTER TO ARRAY [0..50000] OF tTree;
      LHasDontCare      : BOOLEAN; 

   BEGIN
      Exprs := t;
      WHILE Exprs^.Kind = Tree.OneExpr 
      DO (* Scan thru positional associations *)  
        Exprs := Exprs^.OneExpr.Next 
      END (* WHILE *) ;
      IF Exprs^.Kind = Tree.NoExpr 
      THEN (* Positional associations only.  Nothing to do. *)  
        RETURN t
      ELSE 
        WHILE Exprs ^ . Kind = Tree . NamedExpr 
        DO (* Scan thru named associations. *) 
          Exprs := Exprs ^ . NamedExpr . Next 
        END (* WHILE *) ; 
        IF Exprs ^ . Kind = Tree . OneExpr 
        THEN (* ^This should mean there is a .. following *)
          Assert 
            ( ( Exprs ^ . OneExpr . Expr ^ . Kind = Tree . DontCareExplicit ) 
              AND ( Exprs ^ . OneExpr . Next ^ . Kind = Tree . NoExpr ) 
            , "Semantics.TransformKeyword, bad form following NamedExpr" 
            ) ; 
          LHasDontCare := TRUE 
        ELSE 
          LHasDontCare := FALSE 
        END (* IF *) 
      END (* IF *) ;
      n := 0;
      Exprs := Formals;
      WHILE IsType ( Exprs , Tree . Formal ) 
      DO INC (n); Exprs := Exprs^.Formal.Next; 
      END;
      PatternsSize := n + 1;
      MakeArray (PatternsPtr, PatternsSize, TSIZE (tTree));
      FOR i := 1 TO n DO PatternsPtr^[i] := NoTree; END;
      Last := ADR (t);
      Exprs := t;
      i := 0;
      WHILE Exprs^.Kind = Tree.OneExpr DO
         INC (i);
         PatternsPtr^[i] := Exprs^.OneExpr.Expr;
         Last := ADR (Exprs^.OneExpr.Next);
         Exprs := Exprs^.OneExpr.Next;
      END;
      Minimum := i + 1;
      Maximum := i;
      WHILE Exprs^.Kind = Tree.NamedExpr DO
         i := LookupFormal (Exprs^.NamedExpr.Name, Formals);
         IF i = 0 THEN
            ErrorI 
              ( "No such formal/child name" 
              , Exprs ^ . NamedExpr . NamePos
              , Exprs ^ . NamedExpr . Name 
              ) ;
         ELSIF PatternsPtr^[i] # NoTree THEN
            ErrorI 
              ( "this formal/child was previously supplied"
              , Exprs ^ . NamedExpr  . NamePos
              , Exprs ^ . NamedExpr  . Name
              ) ;
         ELSE
            PatternsPtr^[i] := Exprs^.NamedExpr.Expr;
         END;
         Maximum := Max (Maximum, i);
         Exprs := Exprs^.NamedExpr.Next;
      END;
      IF NOT LHasDontCare 
      THEN 
        Exprs 
          := mOneExpr 
               ( mDontCareInternal ( NoPosition ) , mNoExpr ( NoPosition ) ) 
      END (* IF *) ; 
      FOR i := Maximum TO Minimum BY -1 DO
         IF PatternsPtr^[i] = NoTree 
         THEN
           IF LHasDontCare 
           THEN 
             Exprs 
               := mOneExpr 
                    ( mDontCare1Explicit ( NoPosition , NoIdent ) , Exprs ) 
           ELSE 
             Exprs 
               := mOneExpr 
                    ( mDontCare1Internal ( NoPosition , NoIdent ) , Exprs ) 
           END (* IF *) 
         ELSE
            Exprs := mOneExpr (PatternsPtr^[i], Exprs);
         END;
      END;
      Last^ := Exprs;
      ReleaseArray (PatternsPtr, PatternsSize, TSIZE (tTree));
      RETURN t;
   END TransformKeyword;

PROCEDURE CheckExprList (t, Formals: tTree);
   BEGIN
      IF (t^.Kind = Tree.NoExpr) 
         AND NOT IsType ( Formals , Tree . Formal ) 
      THEN RETURN; 
      END;
      IF t^.Kind = Tree.NoExpr THEN
         Error ("too few expressions or arguments", t^.NoExpr.Pos); RETURN;
      END;
      WITH t^.OneExpr DO
         IF Tree . IsType ( Expr , Tree.DontCare ) THEN RETURN; END;
         IF Formals^.Kind = Tree.NoFormal THEN
            Error ("too many expressions or arguments", Expr^.Expr.Pos); RETURN;
         END;
         CheckExpr (Expr, Formals);
         CheckExprList (Next, Formals^.Formal.Next);
      END;
   END CheckExprList;

PROCEDURE CheckInParams (t, Formals: tTree);
   BEGIN
      IF (t^.Kind = Tree.NoExpr) 
         OR NOT IsType ( Formals , Tree . Formal ) 
      THEN RETURN; 
      END;
      WITH t^.OneExpr DO
         IF Tree . IsType ( Expr , Tree.DontCare ) THEN RETURN; END;
         IF Formals^.Formal.Path^.Var.IsOutput AND (Expr^.Kind = Tree.VarUse) AND
            (Expr^.VarUse.Object # NoTree) AND (Expr^.VarUse.Object^.Formal.Path^.Kind = Tree.Var) AND
            NOT Expr^.VarUse.Object^.Formal.Path^.Var.IsOutput THEN
            Expr^.VarUse.Object^.Formal.Path^.Var.IsRegister := FALSE;
         END;
         CheckInParams (Next, Formals^.Formal.Next);
      END;
   END CheckInParams;

PROCEDURE CheckCallExprs (t, Formals: tTree);
   BEGIN
      IF (t^.Kind = Tree.NoExpr) 
         AND NOT IsType ( Formals , Tree . Formal ) 
      THEN RETURN; 
      END;
      IF t^.Kind = Tree.NoExpr THEN
         Error ("too few actual parameters", t^.NoExpr.Pos); RETURN;
      END;
      WITH t^.OneExpr DO
         IF Tree . IsType ( Expr , Tree.DontCare ) THEN
            Expr^.DontCare.Tempos := MakeTempos (Formals);
            RETURN;
         END;
         IF Formals^.Kind = Tree.NoFormal THEN
            Error ("too many actual parameters", Expr^.Expr.Pos); RETURN;
         END;
         CheckExprVar (Expr, Formals);
         CheckCallExprs (Next, Formals^.Formal.Next);
      END;
   END CheckCallExprs;

PROCEDURE CheckExprVar ( VAR t : tTree ;  Formals : tTree);
(* t is VAR, so CheckExprVar can transform tree. *) 
   BEGIN
      IF t^.Kind = Tree.Compose THEN
         t^.Compose.Tempo := MakeTempoIdent ();
         IF IsType ( Formals , Tree . Formal ) 
         THEN
            t^.Compose.TypeDesc := Formals^.Formal.TypeDesc;
         ELSE
            t^.Compose.TypeDesc := t^.Compose.Object^.Class.TypeDesc;
         END;
      ELSIF Tree . IsType ( t , Tree.DontCare1 ) THEN
         t^.DontCare1.Tempo := MakeTempoIdent ();
         IF IsType ( Formals , Tree . Formal ) 
         THEN
            t^.DontCare1.TypeDesc := Formals^.Formal.TypeDesc;
         ELSE 
           Error ( "Dont care in illegal context" , t ^ . DontCare1 . Pos ) 
         END;
      END;
      CheckExpr (t, Formals);
   END CheckExprVar;

PROCEDURE CheckExpr (VAR t : tTree ;  Formals : tTree ) ;
(* t is VAR, so CheckExpr can transform tree. *) 

   VAR LAttrFormal : tTree ; 
   VAR LObject : tTree ; 
   VAR LResult : tTree ; 
   VAR LHides : tTree ; 
  
   BEGIN
     IF IsType ( t , Tree . Expr ) 
        AND ( t ^ . Expr . Selector <> NoIdent )  
     THEN
       WarningI 
         ( "Label on expression ignored" 
         , t ^ . Expr . Pos 
         , t ^ . Expr . Selector 
         ) 
     END (* IF *) 
   ; CASE t^.Kind OF

      | Tree.Compose: WITH t^.Compose DO
            IF IsType ( Formals , Tree . Formal ) 
            THEN
               CheckSubtype 
                 (Formals^.Formal.TypeDesc, Object^.Class.TypeDesc, Pos,
                  'Composed node not in formal/child type, specifically:');
            END;
            IF Object = NoTree THEN
               CheckExpr (Expr, dFormals);
            ELSE
               CheckExpr2 (Expr);
            END;
            CheckExprList (Exprs, Object^.Class.Formals);
         END;

      | Tree.VarUse: WITH t^.VarUse DO
            IF Name = NoIdent  
            THEN
              Error ( "Empty Expression" , t ^ . VarUse . Pos ) 
            ELSIF IsElement (Name, LabelNames) THEN
               Object := IdentifyVar (Decls, Name);
               IF ( Object <> NoTree ) 
                  AND IsType ( Object , Tree . Formal ) 
               THEN 
                 LHides := Object ^ . Formal . Hides 
               ; IF ( LHides <> NoTree )
                    AND IsType ( LHides , Tree . Formal )  
                 THEN 
                   WarningIPP 
                     ( 'Use of "' 
                     , Name 
                     , '", declared at ' 
                     , Object ^ . Formal . DeclPos 
                     , ', which hides a declaration at '
                     , LHides ^ . Formal . DeclPos 
                     , Pos
                     ) 
                 END (* IF *) 
               END (* IF *) ; 
               IF (Object # NoTree) 
                  AND IsType ( Formals , Tree . Formal ) 
               THEN
                  CheckSubtype 
                    (Formals^.Formal.TypeDesc, Object^.Formal.TypeDesc, Pos,
                     'Type of label reference not in formal/child type, specifically:');
               END;
            ELSIF NOT IsElement (Name, ExternNames) 
                  AND NOT IsElement (Name, LocExternNames) 
                  AND NOT IsElement (Name, UserNames) 
                  AND NOT IsElement (Name, RoutineNames) 
            THEN
               IF IsElement (ORD ('e'), Options) THEN
                  ErrorI ("identifier in expression not declared", Pos, Name);
               ELSIF IsElement (ORD ('v'), Options) AND NOT IsElement (ORD ('s'), Options) THEN
                  WarningI ("identifier in expression not declared", Pos, Name);
               END;
               Include (LabelNames, Name);
                (* ^This will suppress further messages on this identifier
                   within this rule, but at the beginning of a new rule,
                   we will start over. *) 
            END;
         END;

      | Tree.Nil: 

      | Tree.Call: WITH t^.Call DO
            IF Object = NoTree THEN
               CheckExpr (Expr, dFormals);
               IF Expr^.Kind = Tree.VarUse THEN
                  ProcName := Expr^.VarUse.Name;
               ELSIF (Expr^.Kind = Tree.Binary) AND
                     (Expr^.Binary.Lop^.Kind = Tree.VarUse) THEN
(* Can assert Expr ^ . Binary . Operator = Identdot ? *) 
                  ProcName := Expr^.Binary.Lop^.VarUse.Name;
               ELSE
                  ProcName := NoIdent;
               END;

               IF NOT IsElement (ProcName, ExternNames) AND
                  NOT IsElement (ProcName, LocExternNames) AND
                  NOT IsElement (ProcName, UserNames) 
               THEN
                  IF IsElement (ORD ('e'), Options) THEN
                     ErrorI ("subroutine identifier not declared", Pos, ProcName);
                  ELSIF IsElement (ORD ('v'), Options) AND NOT IsElement (ORD ('s'), Options) 
                  THEN
                     WarningI ("subroutine identifier not declared", Pos, ProcName);
                  END;
                  Include (UserNames, ProcName);
               END;
               CheckCallExprs (Exprs, dFormals);
               CheckCallExprs (Patterns, dFormals);
            ELSIF IsType (Object, Tree.Routine) THEN
               CheckExpr2 (Expr);
               IF (Object^.Kind = Tree.Function) 
               AND IsType ( Formals , Tree . Formal ) 
               THEN
                  CheckSubtype 
                    (Formals^.Formal.TypeDesc, 
                     Object^.Function.ReturnForm^.Formal.TypeDesc, Pos
                     , 'Result type of puma function not in formal/child type, specifically:');
               END;
               CheckCallExprs (Exprs, Object^.Routine.InForm);
               CheckCallPatterns (Patterns, Object^.Routine.OutForm);
(* ^We want this to happen for puma routines which are externally declared *) 
               CheckInParams (Exprs, Object^.Routine.InForm);
            ELSE
               Error ("subroutine identifier required", Pos);
            END;
         END;

      | Tree . Binary : 
         WITH t ^ . Binary 
         DO
           IF ( Operator = IdentDot ) 
              AND ( Lop ^ . Kind = Tree . VarUse ) 
              AND ( Rop ^ . Kind = Tree . VarUse ) 
              AND IsElement ( Lop ^ . VarUse . Name , LabelNames) 
           THEN (* <Ident> '.' <Ident> , and LHS is declared to puma *) 
             LObject := IdentifyVar ( Decls , Lop ^ . VarUse . Name ) ;
             IF ( LObject # NIL ) 
                AND ( LObject ^ . Formal . TypeDesc ^ . Kind 
                      = Tree . NodeTypes 
                    )
             THEN
                ActClass 
                  := ClassOfNodeTypes ( LObject ^ . Formal . TypeDesc ) ; 
                LAttrFormal 
                  := IdentifyVar 
                       ( ActClass ^ . Class . Formals , Rop ^ . VarUse . Name ) ; 
                IF LAttrFormal # NoTree 
                THEN (* <KnownLabelOfTreeType> '.' <ValidField>. Transform it to "::" *) 
                  LResult 
                    := mAttrDesc 
                         ( Pos 
                         , Lop ^ . VarUse . Selector
                         , Lop ^ . VarUse . Name 
                         , (* Widen := *) FALSE (* Irrelevant *)  
                         , Rop ^ . VarUse . Name 
                         , Rop ^ . VarUse . Pos 
                         ) ; 
                  LResult ^ . AttrDesc . Object := LObject ;
                  LResult ^ . AttrDesc . Type :=  ActClass ^ . Class . Name ;
                  t := LResult (* Transform tree *) 
                ELSE (* RHS is not a child of LHS *) 
                   CheckExprVar (Lop, dFormals);
                   CheckExprVar (Rop, dFormals);
                END (* IF *) ; 
             ELSE (* LHS does not have a tree type *) 
                CheckExprVar (Lop, dFormals);
                CheckExprVar (Rop, dFormals);
             END;
           ELSE (* Ordinary binary operator *) 
             CheckExprVar (Lop, dFormals);
             CheckExprVar (Rop, dFormals);
           END (* IF *) 
         END (* WITH *) ;

      | Tree . BinaryCompound 
        : WITH t ^ . BinaryCompound 
          DO
            CheckExprVar (Lop, dFormals)
          ; CheckExprVar (Rop, dFormals)
          END (* WITH t ^ . BinaryCompound *) ;

      | Tree.PreOperator, Tree.PostOperator: WITH t^.PreOperator DO
            CheckExprVar (Expr, dFormals);
         END;

      | Tree.Index: WITH t^.Index DO
            CheckExprVar (Expr, dFormals);
            CheckExprList (Exprs, dFormals);
         END;

      | Tree.Parents: WITH t^.Parents DO
            CheckExprVar (Expr, Formals);
         END;

      | Tree.AttrDesc: (* '::' in an expression *)
        (* Except for going on to Next, Designator in Check is handled the same. *) 
         WITH t^.AttrDesc DO
            IF IsElement (Name (* LHS *) , LabelNames) THEN
               Object := IdentifyVar (Decls, Name);
               IF ( Object # NIL ) 
                  AND ( Object^.Formal.TypeDesc^.Kind = Tree.NodeTypes ) 
               THEN 
                  ActClass 
                    := ClassOfNodeTypes ( Object ^ . Formal . TypeDesc ) ; 
                  Type := ActClass^.Class.Name;
                  LAttrFormal 
                    := IdentifyVar ( ActClass^.Class.Formals , Attribute ) ; 
                  IF LAttrFormal = NoTree 
                  THEN
                    ErrorI 
                      ( "No such child/attribute" 
                      , AttributePos 
                      , Attribute
                      ) ; 
                  ELSIF IsType ( Formals , Tree . Formal ) 
                  THEN  
                    CheckSubtype 
                      ( Formals ^ . Formal . TypeDesc
                      , LAttrFormal ^ . Formal . TypeDesc
                      , AttributePos
                      , 'Type of node field not in formal/child type, specifically:'
                      ) ;
                  END (* IF *) ; 
               ELSE
                  ErrorI ( "tree-type required" , Pos , Name );
               END;
            ELSE
               ErrorI ( "Identifier not declared" , Pos , Name );
            END;
         END (* WITH *) ;

      ELSE
      END (* CASE *) ;
   END CheckExpr;

PROCEDURE CheckExpr2  ( VAR t : tTree ) ;
(* t is VAR, so CheckExpr2 can transform tree. *) 
(* This is used for field Expr of Compose, Decompose, Call.
   In case of Binary, we need to do rhs lookup differently,
   could get generation bugs this way. *) 
   BEGIN
      CASE t^.Kind OF

      | Tree.VarUse: WITH t^.VarUse DO
            Object := IdentifyVar (Decls, Name);
         END;

      | Tree.Binary: WITH t^.Binary DO
            CheckExpr2 (Lop);
            CheckExpr2 (Rop);
         END;

      | Tree . BinaryCompound 
        : WITH t ^ . BinaryCompound 
          DO
            CheckExpr2 (Lop) 
          ; CheckExpr2 (Rop)
          END (* WITH t ^ . BinaryCompound *) ;

      | Tree.Compose:
            CheckExpr (t, dFormals);
      END;
   END CheckExpr2;

TYPE FormalKindTyp 
  = ( RoutineFormal (* A formal of the routine we are translating *) 
    , ChildFormal   (* A child of a matched node. *) 
    , CallFormal    (* A result formal of a puma routine we are calling *) 
    ) ; 

PROCEDURE CheckRulePatterns (t, Formals, Predecessor: tTree);

(* CheckRulePatterns is for the top-level list of a rule.  All
   the formal names are already declared, so if CheckPattern
   declares a formal, it is just a type-changing declaration
   of the same thing.  There is no need to call CheckPattern 
   for dont cares.  It would just redeclare the formal name 
   redundantly anyway. 
*)
   VAR Pattern  : tTree;
   BEGIN
      IF (t^.Kind = Tree.NoPattern) 
         AND NOT IsType ( Formals , Tree . Formal ) 
      THEN RETURN; 
      END;
      IF t^.Kind = Tree.NoPattern THEN
        IF IsElement ( ORD ( 'g' ) , Options ) (* AND ( Predecessor <> NIL ) *)
        THEN
          (* Predecessor ^ . OnePattern . Next 
            := mOnePattern ( mDontCareInternal ( NoPosition ) , t ) *) 
        ELSE 
          Error ("too few patterns for rule", t^.NoPattern.Pos); RETURN;
        END (* IF *); 
      ; RETURN 
      END;
      Pattern := t^.OnePattern.Pattern;
      IF Tree . IsType ( Pattern , Tree.DontCare ) THEN RETURN; END;
      IF Formals^.Kind = Tree.NoFormal THEN
         Error ("too many patterns for rule", Pattern^.Pattern.Pos); RETURN;
      END;
      CheckPattern 
        ( t ^ . OnePattern . Pattern
        , Formals 
        , Formals ^ . Formal . Path
        , RoutineFormal
        ) ;
      CheckRulePatterns (t^.OnePattern.Next, Formals^.Formal.Next, t);
   END CheckRulePatterns;

PROCEDURE CheckSubPatterns (t, Formals, FPath: tTree);

(* CheckSubPatterns handles a pattern list for a child of a higher
   node.  CheckPattern will be declaring a new meaning of the formal
   name. If there are dont cares in the pattern list, we
   need to call CheckPattern for each formal anyway, so it can declare 
   the name of the child.  
*) 
   VAR Lt , LFormals , LPattern : tTree; 
   BEGIN
     Lt := t; 
     LFormals := Formals; 
     LOOP 
       IF (Lt^.Kind = Tree.NoPattern) 
       THEN 
         IF IsType ( LFormals , Tree . Formal )   
            (* NoFormal or DummyFormal is OK *) 
            AND NOT IsElement ( ORD ( 'g' ) , Options ) 
         THEN
           Error ("too few child patterns", Lt^.NoPattern.Pos); 
         END;
         EXIT  
       END;
       LPattern := Lt^.OnePattern.Pattern;
       IF LFormals^.Kind = Tree.NoFormal 
       THEN 
         IF NOT Tree . IsType ( LPattern  , Tree . DontCare ) 
         THEN 
           Error ("too many child patterns", LPattern^.Pattern.Pos); 
         END (* IF *) 
       ; EXIT; 
       END;
       CheckPattern  
         ( Lt ^ . OnePattern . Pattern
         , LFormals
         , mField ( FPath , LFormals ^ . Formal . Name )
         , ChildFormal
         ) ;
       IF NOT Tree . IsType ( LPattern  , Tree . DontCare ) 
       THEN 
         Lt := Lt^.OnePattern.Next 
       END (* IF *) ; 
       LFormals := LFormals^.Formal.Next
     END (* LOOP *) 
   END CheckSubPatterns;

PROCEDURE CheckCallPatterns (t, Formals: tTree); 

(* CheckCallPatterns handles patterns corresponding to result formals
   in a call to a puma routine.   
*) 
   VAR Lt , LFormals : tTree; 
   BEGIN
     Lt := t; 
     LFormals := Formals; 
     LOOP 
       IF Lt^.Kind = Tree.NoPattern THEN
          IF IsType ( LFormals , Tree . Formal )  
             (* NoFormal or DummyFormal is OK *) 
             AND NOT IsElement ( ORD ( 'g' ) , Options ) 
          THEN 
            Error ("too few result patterns", Lt^.NoPattern.Pos); 
          END (* IF *) 
       ;  EXIT 
       END;
       WITH Lt^.OnePattern DO
         IF IsType ( Pattern , Tree.DontCare ) THEN
            Pattern^.DontCare.Tempos := MakeTempos (LFormals);
              (* MakeTempos does it for all the rest of the formals *) 
            EXIT 
         ELSE (* Not a DontCare *) 
           IF LFormals^.Kind = Tree.NoFormal THEN
              Error ("too many result patterns", Pattern^.Pattern.Pos); 
              EXIT ;
           END; 
         END; 
         Pattern^.Pattern.Tempo := MakeTempoIdent ();
         Pattern^.Pattern.TypeDesc := LFormals^.Formal.TypeDesc;
         CheckPattern 
           ( Pattern, LFormals, mVar (Pattern^.Pattern.Tempo, FALSE, TRUE)
           , CallFormal 
           );
         IF NOT Tree . IsType ( Pattern  , Tree . DontCare ) 
         THEN 
           Lt := Next; 
         END; 
         LFormals := LFormals^.Formal.Next
       END (* WITH *) 
     END (* LOOP *) 
   END CheckCallPatterns;

PROCEDURE AddHidingDecl ( FDecl : tTree (* Formal *) ) 

; BEGIN 
    IF IsElement ( FDecl ^ . Formal . Name , LabelNames )
    THEN (* This hides an earlier declaration *)  
      FDecl ^ . Formal . Hides 
        := IdentifyVar ( Decls , FDecl ^ . Formal . Name ) 
    ELSE 
      Include ( LabelNames , FDecl ^ . Formal . Name ) 
    END (* IF *) 
  ; FDecl ^ . Formal . Next := Decls 
  ; Decls := FDecl 
  END AddHidingDecl ;  

PROCEDURE DeclarePattern
  ( FormalKind : FormalKindTyp ; Name : tIdent ; TypeDesc , FPath : tTree 
  ; Pos : tPosition ) 

; BEGIN 
    CASE FormalKind 
    OF RoutineFormal 
    (* This will be a redeclaration with narrowed type *) 
    : Decls := mPlainFormal ( Decls, NoTree, Name , Pos , TypeDesc , FPath ) ;
    | ChildFormal 
    : IF IsElement ( ORD ( 'j' ) , Options ) 
      THEN 
        IF IsElement ( Name, LabelNames) 
           AND IsElement ( ORD ( 'J' ) , Options ) 
        THEN
          WarningI 
            ( "Child name hides another declaration" , Pos , Name ) 
        END (* IF *) 
      ; AddHidingDecl 
          ( mPlainFormal 
              ( NoTree , NoTree , Name , Pos , TypeDesc , FPath ) 
          ) 
      END (* IF *) 
    | CallFormal : (* Don`t declare anything *) 
    END (* CASE *) 
  END DeclarePattern ; 

PROCEDURE DeclareLabel
  ( Selector : tIdent 
  ; Pos : tPosition 
  ; Widen : BOOLEAN 
  ; Formal : tTree 
  ; NarrowTypeDesc : tTree 
  ; WidePath : tTree
  ; NarrowPath : tTree
  ) 

; VAR LTypeDesc : tTree 
; VAR LPath : tTree 

; BEGIN 
    IF Selector # NoIdent 
    THEN
      IF IsElement ( Selector, LabelNames ) 
      THEN
         Error ( "label previously declared" , Pos ) ;
      ELSE
         Include ( LabelNames, Selector );
      END (* IF *) 
    ; IF Widen AND IsType ( Formal , Tree . Formal )
      THEN
        LTypeDesc := Formal ^ . Formal . TypeDesc 
      ; LPath := WidePath 
      ELSE 
        LTypeDesc := NarrowTypeDesc 
      ; LPath := NarrowPath 
      END (* IF *)  
    ; IF Formal ^ . Kind = Tree . RoutineFormal 
      THEN 
        WITH Formal ^ . RoutineFormal 
        DO 
          Decls 
            := mRoutineFormal 
                 ( Decls , NoTree , Selector , Pos , LTypeDesc , LPath 
                 , TargetClass 
                 , DeclaredTypeIsGuaranteed 
                 ) 
        END (* WITH *) 
      ELSE 
        Decls 
          := mPlainFormal 
               ( Decls , NoTree , Selector , Pos , LTypeDesc , LPath ) 
      END (* IF *) 
    END (* IF *)
  END DeclareLabel ; 

PROCEDURE CheckPattern 
  ( VAR t : tTree ; Formals , FPath : tTree ; FormalKind : FormalKindTyp ) ; 

   VAR LParam , LTypeDesc : tTree ; 
   VAR LPath : tTree ; 
   VAR LFormalTypeDesc : tTree ; 
   VAR LWasDeclared : BOOLEAN ; 

   BEGIN
      CASE t^.Kind OF

      | Tree.Decompose 
      : WITH t^.Decompose DO
          IsProperlyNarrowed := FALSE ; 
        ; IF IsType ( Formals , Tree . Formal ) 
          THEN
            CheckSubtype 
              ( Formals^.Formal.TypeDesc, Object^.Class.TypeDesc, Pos,
                'Decompose node not in formal/child type, specifically:')
          ; IF ( Formals ^ . Formal . TypeDesc ^ . Kind = Tree . NodeTypes ) 
               AND ( Object ^ . Class . TypeDesc ^ . Kind = Tree . NodeTypes ) 
            THEN 
              IF IsType ( Formals , Tree . RoutineFormal )
                 AND ( Formals ^ . RoutineFormal . TargetClass # Tree . NoTree ) 
              THEN 
                LFormalTypeDesc 
                  := Formals ^ . RoutineFormal . TargetClass 
                     ^ . Class . TypeDesc 
              ELSE 
                LFormalTypeDesc := Formals ^ . Formal . TypeDesc
              END (* IF *)  
            ; IF IsNotEqual 
                   ( LFormalTypeDesc ^ . NodeTypes . Types 
                   , Object ^ . Class . TypeDesc ^ . NodeTypes . Types 
                   ) 
              THEN IsProperlyNarrowed := TRUE 
              END (* IF *)  
            END (* IF *)  
          ; LPath 
              := mConsType 
                   ( FPath , Object ^ . Class . Name , IsProperlyNarrowed ) 
          ; DeclarePattern 
              ( FormalKind , Formals^.Formal.Name 
              , Object^.Class.TypeDesc 
              , LPath 
              , Pos 
              ) 
          ELSE 
            LPath 
              := mConsType 
                   ( FPath , Object ^ . Class . Name , FALSE ) ; 
          END (* IF *)  
        ; IF Object = NoTree 
          THEN
             (* RMB: If this can happen, then the recursive call at the
                bottom will crash, and possibly other code here. *) 
             CheckExpr (Expr, dFormals);
          ELSE
            CheckExpr2 (Expr);
          END (* IF *) 
        ; DeclareLabel
            ( Selector
            , Pos  
            , Widen 
            , Formals  
            , Object ^ . Class . TypeDesc 
            , FPath 
            , LPath 
            ) 
        ; t ^ . Decompose . Path := FPath 
        ; CheckSubPatterns ( Patterns , Object^.Class.Formals , LPath )
        END (* WITH *) 

      | Tree.NilTest 
      : WITH t ^ . NilTest 
        DO
          Path := FPath 
        ; IF IsType ( Formals , Tree . Formal ) 
          THEN
            LTypeDesc := Formals^.Formal.TypeDesc 
          ; IF LTypeDesc^.Kind = Tree.NodeTypes 
            THEN
              IsProperlyNarrowed 
                := IsNotEqual 
                     ( LTypeDesc ^ . NodeTypes . Types 
                     , LTypeDesc ^ . NodeTypes . TreeName
                       ^ . TreeName.EmptyType ^ . NodeTypes . Types 
                     ) 
            ; LPath 
                := mConsType ( FPath , IdentEmptyType , IsProperlyNarrowed ) 
            ; LTypeDesc 
                := LTypeDesc ^ . NodeTypes . TreeName ^ . TreeName . EmptyType 
            ELSE 
              Error ( "NIL test on non-node type" , Pos )  
            ; LPath 
                := mConsType ( FPath , LTypeDesc ^ . UserType . Type , FALSE ) 
            ; t := mValue 
                     ( Pos 
                     , Selector 
                     , mTargetExpr 
                         ( Pos
                         , NoIdent  
                         , mAny ( StringRefNil , mNoDesignator ) 
                         )  
                     ) 
            END (* IF *) 
          ; DeclarePattern 
              ( FormalKind , Formals^.Formal.Name , LTypeDesc , LPath , Pos ) 
(* Do we check elsewhere that no fields of this are referenced? *)
          ELSE 
            LPath := mVar ( NoIdent , FALSE , FALSE ) 
          ; LTypeDesc := NoTree 
          END (* IF *) 
        ; DeclareLabel
            ( Selector
            , Pos  
            , Widen 
            , Formals 
            , LTypeDesc 
            , FPath 
            , LPath 
            ) 
        END (* WITH t ^ . NilTest *) 

      | Tree.VarDef
      : WITH t ^ . VarDef 
        DO
(* RMB 5-97: I decided that a child which is matched by a label only
             in a pattern will not declare the child name. Labels alone,
             but with or without ':' , ':>' , and/or '_' parse as a
             label alone.  I intend to eventually allow '_' to have a
             label on it.  This will require data structure changes.
             When that happens, this case will parse as DontCare1Explicit,
             which will declare the child name.  Presumably, if the
             programmer declares a label, she intends to use it, and
             may wish not to overlay another name with the child decl.
*) 
          LWasDeclared := IsElement  ( Name , LabelNames ) 
        ; IF HasDelimiter AND LWasDeclared 
          THEN 
            ErrorI ( "Label previously declared" , Pos , Name ) 
          ELSIF NOT HasDelimiter 
                AND NOT LWasDeclared 
                AND IsElement ( ORD ( 'u' ) , Options ) 
          THEN 
            ErrorI ( "Colon required on label" , Pos , Name ) 
          END (* IF *) 
        ; IF HasDelimiter OR NOT LWasDeclared 
          THEN (* It is a label, declare it. *) 
            IF Formals^.Kind = Tree.RoutineFormal 
            THEN
              AddHidingDecl  
                ( mRoutineFormal 
                    ( NoTree , NoTree , Name , Pos 
                    , Formals ^ . RoutineFormal . TypeDesc 
                    , FPath
                    , Formals ^ . RoutineFormal . TargetClass  
                    , Formals ^ . RoutineFormal . DeclaredTypeIsGuaranteed 
                    )
                ) 
            ELSE 
              AddHidingDecl 
                ( mPlainFormal 
                    ( NoTree , NoTree , Name , Pos  
                    , Formals ^ . Formal . TypeDesc , FPath
                    )
                ) 
            END (* IF *) 
          ; Object := NoTree;
          END (* IF *) 
        ; IF NOT HasDelimiter AND LWasDeclared  
          THEN (* A nonlinear reference *) 
            IF NOT IsElement (ORD ('k'), Options) 
            THEN
              Error ("nonlinear label reference requires -k option", Pos);
            END (* IF *) 
          ; Object := IdentifyVar (Decls, Name)
          ; IF IsType ( Formals , Tree . Formal ) 
               AND ( Object <> NIL ) 
            THEN
               CheckType 
                 ( Formals^.Formal.TypeDesc, Object^.Formal.TypeDesc, Pos )
            END (* IF *) 
          END (* IF *) 
        ; t ^ . VarDef . Path := FPath 
        END (* WITH *) 

      | Tree . DontCare1Explicit 
        : IF IsType ( Formals , Tree . Formal ) 
          THEN
            DeclarePattern 
              ( FormalKind , Formals^.Formal.Name 
              , Formals^.Formal.TypeDesc 
              , mConsType ( FPath , TypeIdentOfFormal ( Formals ) , FALSE )  
              , t ^ . DontCare . Pos 
              ) 
          ; DeclareLabel 
              ( t ^ . DontCare1Explicit . Selector 
              , t ^ . DontCare1Explicit . Pos 
              , (* Widen := *) TRUE    
              , Formals 
              , NoTree  
              , FPath 
              , FPath 
              ) 
          ; t ^ . DontCare . Path := FPath 
          END (* IF *) 

      | Tree . DontCare1Internal 
        : IF IsType ( Formals , Tree . Formal ) 
          THEN
            t ^ . DontCare . Path := FPath 
          END (* IF *) 

      | Tree . DontCareExplicit 
        : IF IsType ( Formals , Tree . Formal ) 
          THEN
            DeclarePattern 
              ( FormalKind , Formals^.Formal.Name 
              , Formals^.Formal.TypeDesc 
              , mConsType ( FPath , TypeIdentOfFormal ( Formals ) , FALSE )  
              , t ^ . DontCare . Pos 
              ) ; 
          END (* IF *) 

      | Tree . DontCareInternal 
        : (* Do not set Path, since this node can be used by many patterns. *) 

      | Tree.Value
        : CheckExprVar (t^.Value.Expr, Formals)
        ; DeclareLabel 
            ( t ^ . Value . Selector 
            , t ^ . Value . Pos 
            , (* Widen := *) TRUE    
            , Formals 
            , NoTree 
            , FPath 
            , FPath
            ) 
        ; t ^ . Value . Path := FPath 

      ELSE
        t ^ . Pattern . Path := FPath
      END;
   END CheckPattern;

PROCEDURE MakeTempoIdent (): tIdent;
   VAR String1, String2 : tString;
   BEGIN
      INC (TempoCount);
      ArrayToString ("yyV", String1);
      IntToString (TempoCount, String2);
      Concatenate (String1, String2);
      RETURN MakeIdent (String1);
   END MakeTempoIdent;

(* Copy list but assign a generated name to each formal. *) 
PROCEDURE MakeTempos (Formals: tTree): tTree;
   BEGIN
      IF IsType ( Formals , Tree . Formal ) 
      THEN
         WITH Formals^.Formal DO
            RETURN 
              mPlainFormal 
                ( MakeTempos ( Next )
                , NoTree
                , MakeTempoIdent ( )
                , DeclPos 
                , TypeDesc
                , Path
                );
         END;
      ELSE
         RETURN nNoFormal;
      END;
   END MakeTempos;

PROCEDURE InitPredefinedExtern ( ) 
; BEGIN 
    IF IsElement ( ORD  ( 'c' ) , Options ) 
       OR IsElement ( ORD  ( 'A' ) , Options ) 
    THEN
    ELSE (* Modula-2 or Modula-3 *) 
      Include ( ExternNames, IdentFalse ) 
    ; Include ( ExternNames, IdentTrue ) 
    END (* IF *) 
  END InitPredefinedExtern ; 









































































PROCEDURE yyAbort (yyFunction: ARRAY OF CHAR);
 BEGIN
  IO.WriteS (IO.StdError, 'Error: module Semantics, routine ');
  IO.WriteS (IO.StdError, yyFunction);
  IO.WriteS (IO.StdError, ' failed');
  IO.WriteNl (IO.StdError);
  Exit;
 END yyAbort;

PROCEDURE yyIsEqual (yya, yyb: ARRAY OF SYSTEM.BYTE): BOOLEAN;
 VAR yyi       : INTEGER;
 BEGIN
  FOR yyi := 0 TO INTEGER (HIGH (yya)) DO
   IF yya [yyi] # yyb [yyi] THEN RETURN FALSE; END;
  END;
  RETURN TRUE;
 END yyIsEqual;

PROCEDURE CollectRoutineNames (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Procedure:
(* line 2476 "../src/sem.puma" *)
     WITH t^.Procedure DO
(* line 2479 "../src/sem.puma" *)
       IF IsElement ( Name , RoutineNames) 
       THEN
         Error ( "routine identifier previously declared" , Pos ) ;
       ELSE
         Include ( RoutineNames , Name ) ;
       END ;
       CollectRoutineNames ( Next ) ; 
     ;
      RETURN;
     END (* WITH *) ;

  | Tree.Predicate:
(* line 2476 "../src/sem.puma" *)
     WITH t^.Predicate DO
(* line 2479 "../src/sem.puma" *)
       IF IsElement ( Name , RoutineNames) 
       THEN
         Error ( "routine identifier previously declared" , Pos ) ;
       ELSE
         Include ( RoutineNames , Name ) ;
       END ;
       CollectRoutineNames ( Next ) ; 
     ;
      RETURN;
     END (* WITH *) ;

  | Tree.Function:
(* line 2476 "../src/sem.puma" *)
     WITH t^.Function DO
(* line 2479 "../src/sem.puma" *)
       IF IsElement ( Name , RoutineNames) 
       THEN
         Error ( "routine identifier previously declared" , Pos ) ;
       ELSE
         Include ( RoutineNames , Name ) ;
       END ;
       CollectRoutineNames ( Next ) ; 
     ;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END CollectRoutineNames;

PROCEDURE Semantics (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Spec:
(* line 2490 "../src/sem.puma" *)
     WITH t^.Spec DO
(* line 2490 "../src/sem.puma" *)
      
        TypeCount := MaxIdent ();
        MakeSet (RoutineNames   , TypeCount);
        MakeSet (LabelNames     , TypeCount);
        MakeSet (ParamNames     , TypeCount);
        MakeSet (TypeNames      , TypeCount);
        MakeSet (ExternNames    , TypeCount);
        InitPredefinedExtern ( ) ; 
 
        MakeSet (LocExternNames , TypeCount);
        MakeSet (UserTypes      , TypeCount);
        MakeSet (UserNames      , TypeCount);
        ClassFormals (TreeNames);
        Semantics (Public);
        CollectExtern (Extern, ExternNames);
        ProcFormals (Routines);
        CollectRoutineNames ( Routines ) ; 
        Semantics (Routines);
      IF IsElement (ORD ('o'), Options) AND NOT IsEmpty (UserNames) THEN
        WriteNl (StdOutput);
        WriteS (StdOutput, "Undefined External Names"); WriteNl (StdOutput);
        WriteS (StdOutput, "------------------------"); WriteNl (StdOutput);
        WriteNl (StdOutput);
        FOR i := 1 TO TypeCount DO
           IF IsElement (i, UserNames) THEN
              WriteIdent (StdOutput, i); WriteNl (StdOutput);
           END;
        END;
      END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Name:
(* line 2522 "../src/sem.puma" *)
     WITH t^.Name DO
(* line 2522 "../src/sem.puma" *)
      
        Object := IdentifyProc (Name);
        IF Object = NoTree THEN
           ErrorI ("subroutine identifier not declared", Pos, Name);
        ELSE
           Object^.Routine.IsExtern := TRUE;
        END;
        Semantics (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Procedure:
(* line 2531 "../src/sem.puma" *)
     WITH t^.Procedure DO
(* line 2532 "../src/sem.puma" *)
      
        AssignEmpty (LocExternNames);
        CollectExtern (Extern, LocExternNames);
        AssignEmpty (ParamNames);
        Check (InParams);
        Check (OutParams);
        InFormals := InForm;
        OutFormals := OutForm;
        Parameters := ParamDecls;
        IsFunction := FALSE;
        RuleCount := 0;
        Check (Rules);
        Semantics (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Predicate:
(* line 2531 "../src/sem.puma" *)
     WITH t^.Predicate DO
(* line 2532 "../src/sem.puma" *)
      
        AssignEmpty (LocExternNames);
        CollectExtern (Extern, LocExternNames);
        AssignEmpty (ParamNames);
        Check (InParams);
        Check (OutParams);
        InFormals := InForm;
        OutFormals := OutForm;
        Parameters := ParamDecls;
        IsFunction := FALSE;
        RuleCount := 0;
        Check (Rules);
        Semantics (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Function:
(* line 2546 "../src/sem.puma" *)
     WITH t^.Function DO
(* line 2546 "../src/sem.puma" *)
      
        AssignEmpty (LocExternNames);
        CollectExtern (Extern, LocExternNames);
        AssignEmpty (ParamNames);
        Check (InParams);
        Check (OutParams);
        Check (ReturnParams);
        InFormals := InForm;
        OutFormals := OutForm;
        ReturnFormal := ReturnForm;
        Parameters := ParamDecls;
        IsFunction := TRUE;
        RuleCount := 0;
        Check (Rules);
        Semantics (Next);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Semantics;

PROCEDURE CollectExtern (t: Tree.tTree; VAR Names: tSet);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Name) THEN
(* line 2566 "../src/sem.puma" *)
     WITH t^.Name DO
(* line 2567 "../src/sem.puma" *)
      Include (Names, Name);
(* line 2568 "../src/sem.puma" *)
      CollectExtern (Next, Names);
      RETURN;
     END (* WITH *) ;

  END;
 END CollectExtern;

PROCEDURE ProcFormals (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Procedure:
(* line 2574 "../src/sem.puma" *)
     WITH t^.Procedure DO
(* line 2575 "../src/sem.puma" *)
      
        Args := nNoFormal;
        Decls := nNoFormal;
        AssignEmpty (ParamNames);
        IsOutput := FALSE;
        ProcFormals (InParams);
        InForm := ReverseTree (Args);
        Args := nNoFormal;
        IsOutput := TRUE;
        ProcFormals (OutParams);
        OutForm := ReverseTree (Args);
        ParamDecls := Decls;
        ProcFormals (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Predicate:
(* line 2574 "../src/sem.puma" *)
     WITH t^.Predicate DO
(* line 2575 "../src/sem.puma" *)
      
        Args := nNoFormal;
        Decls := nNoFormal;
        AssignEmpty (ParamNames);
        IsOutput := FALSE;
        ProcFormals (InParams);
        InForm := ReverseTree (Args);
        Args := nNoFormal;
        IsOutput := TRUE;
        ProcFormals (OutParams);
        OutForm := ReverseTree (Args);
        ParamDecls := Decls;
        ProcFormals (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Function:
(* line 2589 "../src/sem.puma" *)
     WITH t^.Function DO
(* line 2589 "../src/sem.puma" *)
      
        Args := nNoFormal;
        Decls := nNoFormal;
        AssignEmpty (ParamNames);
        IsOutput := FALSE;
        ProcFormals (InParams);
        InForm := ReverseTree (Args);
        Args := nNoFormal;
        IsOutput := TRUE;
        ProcFormals (OutParams);
        OutForm := ReverseTree (Args);
        Args := nNoFormal;
        IsOutput := TRUE;
        ProcFormals (ReturnParams);
        ReturnForm := ReverseTree (Args);
        ParamDecls := Decls;
        ProcFormals (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Param:
(* line 2607 "../src/sem.puma" *)
     WITH t^.Param DO
(* line 2607 "../src/sem.puma" *)
      
        IF IsElement (Name, ParamNames) THEN
           Error ("parameter identifier previously declared", Pos);
        ELSE
           Include (ParamNames, Name);
        END;
        ParamName := Name;
        ParamPos := Pos ; 
        Mode := IsRef;
        ProcFormals (Type);
        ProcFormals (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Type:
(* line 2619 "../src/sem.puma" *)
     WITH t^.Type DO
(* line 2620 "../src/sem.puma" *)
       GlobalLUBClass := NoTree ; 
       IF (Name # NoIdent) AND (Names^.Kind # Tree.NoName) 
       THEN  
          TreeName := IdentifyTree (Name);
          IF TreeName # NoTree THEN
             MakeSet (ActTypes, TreeName^.TreeName.ClassCount);
          ELSE
             Error ("tree type not declared", Pos);
          END;
       ELSIF (Name # NoIdent) AND (Names^.Kind = Tree.NoName) 
       THEN  
          TreeName := IdentifyTree (Name);
          IF TreeName # NoTree 
          THEN 
             MakeSet (ActTypes, TreeName^.TreeName.ClassCount);
             MakeTypes 
               ( TreeName^.TreeName.Classes^.Class.Index
               , TreeName^.TreeName.Classes, ActTypes
               );
             GlobalLUBClass := TreeName ^ . TreeName . UniversalClass 
          ELSE 
             ActClass := IdentifyClass2 (Name, TreeName);
             IF ActClass # NoTree 
             THEN 
                MakeSet (ActTypes, TreeName^.TreeName.ClassCount);
                MakeTypes 
                  (ActClass^.Class.Index, ActClass^.Class.Extensions, ActTypes);
                GlobalLUBClass := ActClass 
             END;
          END;
       ELSIF (Name = NoIdent) AND (Names^.Kind # Tree.NoName) 
       THEN  
          ActClass := IdentifyClass2 (Names^.Name.Name, TreeName);
          IF ActClass # NoTree THEN
             MakeSet (ActTypes, TreeName^.TreeName.ClassCount);
          ELSE
             Error ("node type not declared", Names^.Name.Pos);
          END;
       ELSE
          TreeName := NoTree;
       END;

        

       IF TreeName # NoTree THEN
          ActTree := TreeName^.TreeName.Classes;
          ProcFormals (Names);
          Node := mNodeTypes (TreeName, ActTypes);
       ELSE                                            
          IF Name = NoIdent THEN
             Error ("incorrect type", Pos);
          ELSE
             Include (TypeNames, Name);
          END;
          Node := mUserType (Name);
       END;
       Var   := mVar (ParamName, IsOutput OR Mode,  TRUE);
       Args 
         := mRoutineFormal 
              ( Args , NoTree , ParamName , ParamPos , Node , Var
              , GlobalLUBClass 
              ,  FALSE 
              ) ;
       Decls 
         := mRoutineFormal 
              ( Decls , NoTree , ParamName , ParamPos , Node , Var
              , GlobalLUBClass 
              ,  FALSE 
              ) ;
     ;
      RETURN;
     END (* WITH *) ;

  | Tree.Name:
(* line 2701 "../src/sem.puma" *)
     WITH t^.Name DO
(* line 2701 "../src/sem.puma" *)
      
        ActClass := IdentifyClass (ActTree, Name);
        IF ActClass # NoTree THEN
           Include (ActTypes, ActClass^.Class.Index);
           ForallClasses (ActClass^.Class.Extensions, ProcFormals);
           GlobalLUBClass := ClassLUB ( GlobalLUBClass , ActClass ) 
        ELSE
           Error ("Node not member of tree type", Pos);
        END;
        ProcFormals (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Class:
(* line 2712 "../src/sem.puma" *)
     WITH t^.Class DO
(* line 2712 "../src/sem.puma" *)
      
        Include (ActTypes, Index);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ProcFormals;

PROCEDURE CollectUniversalTypeDesc (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 2718 "../src/sem.puma" *)
     WITH t^.Class DO
(* line 2719 "../src/sem.puma" *)
       Union ( ActTypes , TypeDesc ^ . NodeTypes . Types ) ; 
       CollectUniversalTypeDesc ( Next ) ; 
     ;
      RETURN;
     END (* WITH *) ;

  END;
 END CollectUniversalTypeDesc;

PROCEDURE ClassFormals (t: Tree.tTree);
(* line 2733 "../src/sem.puma" *)
 VAR String1 , String2 : tString ; 

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.TreeName:
(* line 2735 "../src/sem.puma" *)
     WITH t^.TreeName DO
(* line 2735 "../src/sem.puma" *)
      
        ActTree := t;
        ClassCount := 0;
        ForallClasses (Classes, CountClasses);

        EmptyType := mNodeTypes (t, ActTypes);  
        MakeSet (EmptyType^.NodeTypes.Types, t^.TreeName.ClassCount);
        AssignEmpty(EmptyType^.NodeTypes.Types);

        ArrayToString ("t", String1);
        GetString (Name, String2);
        Concatenate (String1, String2);

        ForallClasses (Classes, ClassTypes);
        ForallClasses (Classes, ClassFormals);

        UniversalClass 
          := mClass 
               ( MakeIdent ( String1 ) , { Nonterminal } 
               , NoTree , NoTree , NoTree ) ; 
        UniversalClass ^ . Class . BaseClass := NoTree ; 
        UniversalClass ^ . Class . Formals := NoTree ; 
        UniversalClass ^ . Class . Index := 0 ; 
        MakeSet ( ActTypes , t ^ . TreeName . ClassCount ) ;
        AssignEmpty ( ActTypes ) ;
        CollectUniversalTypeDesc ( Classes ) ;
        UniversalClass ^ . Class . TypeDesc 
          := mNodeTypes ( t , ActTypes ) ; 

        ComputeDepthsClasses ( Classes , 1 ) ; 
        
        ClassFormals (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Class:
(* line 2768 "../src/sem.puma" *)
     WITH t^.Class DO
(* line 2768 "../src/sem.puma" *)
      
        Args := nNoFormal;
        ForallAttributes (t, ClassFormals);
        Formals := ReverseTree (Args);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 2773 "../src/sem.puma" *)
     WITH t^.Child DO
(* line 2773 "../src/sem.puma" *)
      
        ActClass := IdentifyClass (ActTree^.TreeName.Classes, Type);
        Args 
          := mPlainFormal 
               ( Args, NoTree, Name, NoPosition , ActClass^.Class.TypeDesc,  NoTree);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 2779 "../src/sem.puma" *)
     WITH t^.Attribute DO
(* line 2779 "../src/sem.puma" *)
      
        IF ({Test, Dummy} * Properties) = {} 
        THEN
           ActClass := IdentifyClass (ActTree^.TreeName.Classes, Type);
           IF ActClass = NoTree 
           THEN   
             Args 
               := mPlainFormal 
                    (Args, NoTree, Name, NoPosition, mUserType (Type),  NoTree);
             Include (TypeNames, Type);
           ELSE 
             Args 
               := mPlainFormal 
                     (Args, NoTree, Name, NoPosition, ActClass^.Class.TypeDesc,  NoTree);
           END  
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ClassFormals;

PROCEDURE CountClasses (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 2800 "../src/sem.puma" *)
     WITH t^.Class DO
(* line 2800 "../src/sem.puma" *)
      
        INC (ActTree^.TreeName.ClassCount);
        Index := ActTree^.TreeName.ClassCount;
;
      RETURN;
     END (* WITH *) ;

  END;
 END CountClasses;

PROCEDURE ClassTypes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 2808 "../src/sem.puma" *)
     WITH t^.Class DO
(* line 2808 "../src/sem.puma" *)
      
        TypeDesc := mNodeTypes (ActTree, ActTypes);     
        MakeSet (TypeDesc^.NodeTypes.Types, ActTree^.TreeName.ClassCount);
        MakeTypes (Index, Extensions, TypeDesc^.NodeTypes.Types);
;
      RETURN;
     END (* WITH *) ;

  END;
 END ClassTypes;

PROCEDURE Check (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 4: yyR4: RECORD
  LPatternCount: CARDINAL;
  LIsLast: BOOLEAN;
  LPatterns: Tree.tTree;
  LSinglePatterns: Tree.tTree;
  LNewRule: Tree.tTree;
  END;
 | 28: yyR28: RECORD
  LAttrFormal: tTree;
  END;
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Reject:
  IF Tree.IsType (t^.Reject.Next, Tree.Statement) THEN
(* line 2817 "../src/sem.puma" *)
   LOOP
     WITH t^.Reject DO
     WITH Next^.Statement DO
(* line 2819 "../src/sem.puma" *)
      Warning ("statement not reachable", t^.Reject.Next^.Statement.Pos);
(* line 2820 "../src/sem.puma" *)
      EXIT;
     END (* WITH *) ;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
  | Tree.Fail:
  IF Tree.IsType (t^.Fail.Next, Tree.Statement) THEN
(* line 2817 "../src/sem.puma" *)
   LOOP
     WITH t^.Fail DO
     WITH Next^.Statement DO
(* line 2819 "../src/sem.puma" *)
      Warning ("statement not reachable", t^.Fail.Next^.Statement.Pos);
(* line 2820 "../src/sem.puma" *)
      EXIT;
     END (* WITH *) ;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
(* line 2952 "../src/sem.puma" *)
     WITH t^.Fail DO
(* line 2952 "../src/sem.puma" *)
      
        IF IsFunction THEN
           Error ("FAIL not allowed in function", Pos);
        END;
        Check (Next);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;


  CASE t^.Kind OF
  | Tree.Param:
(* line 2822 "../src/sem.puma" *)
     WITH t^.Param DO
(* line 2822 "../src/sem.puma" *)
      
        Include (ParamNames, Name);
        Check (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Rule:
(* line 2826 "../src/sem.puma" *)
    WITH yyTempo.yyR4 DO  
     WITH t^.Rule DO
(* line 2827 "../src/sem.puma" *)
      ;
(* line 2828 "../src/sem.puma" *)
      ;
(* line 2829 "../src/sem.puma" *)
      ;
(* line 2830 "../src/sem.puma" *)
      ;
(* line 2831 "../src/sem.puma" *)
      ;
(* line 2832 "../src/sem.puma" *)
       LPatterns       := TransformKeyword (Patterns, InFormals);
        TransformPattern ( LPatterns , LPatterns , LPatternCount ); 
        Exprs           := TransformKeyword (Exprs, OutFormals);
        Exprs           := TransformExpr (Exprs);
        Expr            := TransformExpr (Expr); 
        Statements      := TransformStmt (Statements);
        LOOP 
          WITH t^.Rule 
           
          DO 
            IF LPatternCount = 1 
            THEN  
              t^.Rule.Patterns := LPatterns 
            ; LIsLast := TRUE ; 
            ELSE     
              NextPatterns ( LPatterns , LSinglePatterns , LIsLast ) 
            ; IF NOT LIsLast  
              THEN 
                LNewRule 
                  := mRule 
                       ( t^.Rule.Line 
                       , NoTree  
                       , CopyTree ( t^.Rule.Exprs )  
                       , CopyTree ( t^.Rule.Expr )  
                       , CopyTree ( t^.Rule.Statements )  
                       , t^.Rule.Next 
                       ) 
              ; t^.Rule.Next := LNewRule 
           
              END  
            ; t^.Rule.Patterns := LSinglePatterns 
            END  ; 
            INC (RuleCount);
            t^.Rule.Index               := RuleCount;
            TempoCount  := 0;
            HasLocals   := FALSE;
            Decls               := Parameters;
            Assign (LabelNames, ParamNames);
            CheckRulePatterns (t^.Rule.Patterns, InFormals, NIL);
             
            Check (t^.Rule.Patterns);
            Check (t^.Rule.Statements);
            CheckExprList (t^.Rule.Exprs, OutFormals);
            Check (t^.Rule.Exprs);
            IF IsFunction THEN
               IF t^.Rule.Expr^.Kind = Tree.NoExpr THEN
                  IF NOT HasReject (t^.Rule.Statements) THEN
                     Error ("function requires RETURN expression"
                           , t^.Rule.Expr^.Expr.Pos
                           );
                  END;
               ELSE
                  CheckExprVar (t^.Rule.Expr, ReturnFormal);
                  Success := FALSE;
                  Check (t^.Rule.Expr);
                  t^.Rule.HasPatterns := Success;
                  IF t^.Rule.HasPatterns 
                     AND (t^.Rule.Expr^.Kind # Tree.Compose) 
                     AND NOT Tree . IsType ( t , Tree.DontCare1) 
                          
                  THEN
                     t^.Rule.Tempo := MakeTempoIdent ();
                  END;
               END;
            END;
            IF NOT IsFunction AND (t^.Rule.Expr^.Kind # Tree.NoExpr) THEN
               Error ("RETURN in non-function", t^.Rule.Expr^.Expr.Pos);
            END;
            t^.Rule.VarDecls := Decls;
            IF IsElement (ORD ('c'), Options) THEN
              t^.Rule.HasTempos := (TempoCount > 0) OR HasLocals;
            ELSE
              t^.Rule.HasTempos := (TempoCount > 0) OR HasLocals 
                 OR t^.Rule.HasPatterns;
            END;
            CheckTargetCode (t^.Rule.Patterns);
            CheckTargetCode (t^.Rule.Exprs);
            IF IsFunction THEN
               CheckTargetCode (t^.Rule.Expr);
            END;
            CheckTargetCode (t^.Rule.Statements);
            IF LIsLast THEN EXIT 
            ELSE t := t ^ . Rule . Next 
                  
            END   
          END  
        END  ; 
        Check (t^.Rule.Next);
;
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.ProcCall:
(* line 2924 "../src/sem.puma" *)
     WITH t^.ProcCall DO
(* line 2924 "../src/sem.puma" *)
      
        CheckExprVar (Call, dFormals);
 
        Check (Call);
        Check (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Condition:
(* line 2931 "../src/sem.puma" *)
     WITH t^.Condition DO
(* line 2931 "../src/sem.puma" *)
      
        CheckExprVar (Expr, dFormals);
        Check (Expr);
        Check (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Assignment:
(* line 2936 "../src/sem.puma" *)
     WITH t^.Assignment DO
(* line 2936 "../src/sem.puma" *)
      
        IF Adr^.Kind = Tree.VarUse THEN
           Object := IdentifyVar (Decls, Adr^.VarUse.Name);
        ELSE
           Object := NoTree;
        END;
        CheckExprVar (Adr, dFormals);
        IF Object # NoTree THEN
           CheckExprVar (Expr, Object);
        ELSE
           CheckExprVar (Expr, dFormals);
        END;
        Check (Adr);
        Check (Expr);
        Check (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TargetStmt:
(* line 2958 "../src/sem.puma" *)
     WITH t^.TargetStmt DO
(* line 2958 "../src/sem.puma" *)
      
        CheckTargetCode (Parameters);
        MakeSet (UsedNames, MaxIdent ());
        ActNames := UsedNames;
        Check (Stmt);
        UsedNames := ActNames;
        Check (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Statement
  , Tree.Reject
  , Tree.Fail
  , Tree.Nl
  , Tree.WriteStr:
(* line 2966 "../src/sem.puma" *)
     WITH t^.Statement DO
(* line 2966 "../src/sem.puma" *)
      
        Check (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.OnePattern:
(* line 2969 "../src/sem.puma" *)
     WITH t^.OnePattern DO
(* line 2969 "../src/sem.puma" *)
      
        Check (Pattern);
        Check (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.OneExpr
  , Tree.NamedExpr:
(* line 2973 "../src/sem.puma" *)
     WITH t^.OneExpr DO
(* line 2973 "../src/sem.puma" *)
      
        Check (Expr);
        Check (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Decompose:
(* line 2977 "../src/sem.puma" *)
     WITH t^.Decompose DO
(* line 2977 "../src/sem.puma" *)
      
        Check (Expr);
        Success := TRUE;
        Check (Patterns);
;
      RETURN;
     END (* WITH *) ;

  | Tree.VarDef:
(* line 2982 "../src/sem.puma" *)
     WITH t^.VarDef DO
(* line 2982 "../src/sem.puma" *)
      
        IF Object # NoTree THEN Success := TRUE; END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.NilTest:
(* line 2985 "../src/sem.puma" *)
     WITH t^.NilTest DO
(* line 2985 "../src/sem.puma" *)
      
        Success := TRUE;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Value:
(* line 2988 "../src/sem.puma" *)
     WITH t^.Value DO
(* line 2988 "../src/sem.puma" *)
      
        Success := TRUE;
        Check (Expr);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Compose:
(* line 2992 "../src/sem.puma" *)
     WITH t^.Compose DO
(* line 2992 "../src/sem.puma" *)
      
        Check (Expr);
        Check (Exprs);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Call:
(* line 2996 "../src/sem.puma" *)
     WITH t^.Call DO
(* line 2996 "../src/sem.puma" *)
      
        Check (Expr);
        Check (Exprs);
        Check (Patterns);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Binary
  , Tree.yy1
  , Tree.BinaryCompound:
(* line 3001 "../src/sem.puma" *)
     WITH t^.Binary DO
(* line 3001 "../src/sem.puma" *)
       
        Check (Lop);
        Check (Rop);
;
      RETURN;
     END (* WITH *) ;

  | Tree.PreOperator:
(* line 3005 "../src/sem.puma" *)
     WITH t^.PreOperator DO
(* line 3007 "../src/sem.puma" *)
      
        Check (Expr);
;
      RETURN;
     END (* WITH *) ;

  | Tree.PostOperator:
(* line 3005 "../src/sem.puma" *)
     WITH t^.PostOperator DO
(* line 3007 "../src/sem.puma" *)
      
        Check (Expr);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Parents:
(* line 3005 "../src/sem.puma" *)
     WITH t^.Parents DO
(* line 3007 "../src/sem.puma" *)
      
        Check (Expr);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Index:
(* line 3010 "../src/sem.puma" *)
     WITH t^.Index DO
(* line 3010 "../src/sem.puma" *)
      
        Check (Expr);
        Check (Exprs);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TargetExpr:
(* line 3014 "../src/sem.puma" *)
     WITH t^.TargetExpr DO
(* line 3014 "../src/sem.puma" *)
      
        MakeSet (UsedNames, MaxIdent ());
        ActNames := UsedNames;
        Check (Expr);
        UsedNames := ActNames;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Ident:
(* line 3020 "../src/sem.puma" *)
     WITH t^.Ident DO
(* line 3020 "../src/sem.puma" *)
      
        Object := IdentifyVar (Decls, Attribute);  
 
        IF Object = NoTree 
        THEN Include (ActNames, Attribute); END;
        Check (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Any:
(* line 3027 "../src/sem.puma" *)
     WITH t^.Any DO
(* line 3028 "../src/sem.puma" *)
      
        Check (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Anys:
(* line 3027 "../src/sem.puma" *)
     WITH t^.Anys DO
(* line 3028 "../src/sem.puma" *)
      
        Check (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Designator:
(* line 3031 "../src/sem.puma" *)
    WITH yyTempo.yyR28 DO  
     WITH t^.Designator DO
(* line 3034 "../src/sem.puma" *)
      ;
(* line 3035 "../src/sem.puma" *)
      
        IF IsElement ( Selector  , LabelNames ) 
        THEN
          Object := IdentifyVar ( Decls , Selector )
        ; IF ( Object <> NIL ) 
             AND ( Object ^ . Formal . TypeDesc ^ . Kind = Tree.NodeTypes ) 
          THEN
            ActClass 
              := ClassOfNodeTypes ( Object ^ . Formal . TypeDesc )  
          ; Type := ActClass ^ . Class . Name
          ; LAttrFormal 
              := IdentifyVar ( ActClass ^ . Class . Formals , Attribute )  
          ; IF LAttrFormal = NoTree 
            THEN
              ErrorI 
                ( "D No such child/attribute" , AttributePos , Attribute ) ; 
            END  ; 
          ELSE
             ErrorI ( "D tree-type required" , Pos , Selector ) ;
          END;
        ELSE
          ErrorI (" D identifier is not declared" , Pos , Selector );
        END
      ; Check (Next);
;
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  ELSE END;

 END Check;

PROCEDURE CheckTargetCode (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Param:
(* line 3064 "../src/sem.puma" *)
     WITH t^.Param DO
(* line 3065 "../src/sem.puma" *)
      
        HasLocals := TRUE;
        ParamName := Name;
        IsOutput := FALSE;
        ProcFormals (Type);
        IF IsElement (Name, LabelNames) THEN
           Error ("identifier previously declared", Pos);
        ELSE
           Include (LabelNames, Name);
        END;
        CheckTargetCode (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.ProcCall:
(* line 3077 "../src/sem.puma" *)
     WITH t^.ProcCall DO
(* line 3077 "../src/sem.puma" *)
      
        CheckTargetCode (Call);
        CheckTargetCode (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Condition:
(* line 3081 "../src/sem.puma" *)
     WITH t^.Condition DO
(* line 3081 "../src/sem.puma" *)
      
        CheckTargetCode (Expr);
        CheckTargetCode (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Assignment:
(* line 3085 "../src/sem.puma" *)
     WITH t^.Assignment DO
(* line 3085 "../src/sem.puma" *)
      
        CheckTargetCode (Expr);
        CheckTargetCode (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TargetStmt:
(* line 3089 "../src/sem.puma" *)
     WITH t^.TargetStmt DO
(* line 3089 "../src/sem.puma" *)
      
        ActNames := UsedNames;
        CheckTargetCode (Stmt);
        ReleaseSet (UsedNames);
        CheckTargetCode (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Statement
  , Tree.Reject
  , Tree.Fail
  , Tree.Nl
  , Tree.WriteStr:
(* line 3095 "../src/sem.puma" *)
     WITH t^.Statement DO
(* line 3095 "../src/sem.puma" *)
      
        CheckTargetCode (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.OnePattern:
(* line 3098 "../src/sem.puma" *)
     WITH t^.OnePattern DO
(* line 3098 "../src/sem.puma" *)
      
        CheckTargetCode (Pattern);
        CheckTargetCode (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.OneExpr
  , Tree.NamedExpr:
(* line 3102 "../src/sem.puma" *)
     WITH t^.OneExpr DO
(* line 3102 "../src/sem.puma" *)
      
        CheckTargetCode (Expr);
        CheckTargetCode (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Decompose:
(* line 3106 "../src/sem.puma" *)
     WITH t^.Decompose DO
(* line 3106 "../src/sem.puma" *)
      
        CheckTargetCode (Expr);
        CheckTargetCode (Patterns);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Value:
(* line 3110 "../src/sem.puma" *)
     WITH t^.Value DO
(* line 3110 "../src/sem.puma" *)
      
        CheckTargetCode (Expr);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Compose:
(* line 3113 "../src/sem.puma" *)
     WITH t^.Compose DO
(* line 3113 "../src/sem.puma" *)
      
        CheckTargetCode (Expr);
        CheckTargetCode (Exprs);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Call:
(* line 3117 "../src/sem.puma" *)
     WITH t^.Call DO
(* line 3117 "../src/sem.puma" *)
      
        CheckTargetCode (Expr);
        CheckTargetCode (Exprs);
        CheckTargetCode (Patterns);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Binary
  , Tree.yy1
  , Tree.BinaryCompound:
(* line 3122 "../src/sem.puma" *)
     WITH t^.Binary DO
(* line 3122 "../src/sem.puma" *)
        
        CheckTargetCode (Lop);
        CheckTargetCode (Rop);
;
      RETURN;
     END (* WITH *) ;

  | Tree.PreOperator:
(* line 3126 "../src/sem.puma" *)
     WITH t^.PreOperator DO
(* line 3128 "../src/sem.puma" *)
      
        CheckTargetCode (Expr);
;
      RETURN;
     END (* WITH *) ;

  | Tree.PostOperator:
(* line 3126 "../src/sem.puma" *)
     WITH t^.PostOperator DO
(* line 3128 "../src/sem.puma" *)
      
        CheckTargetCode (Expr);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Parents:
(* line 3126 "../src/sem.puma" *)
     WITH t^.Parents DO
(* line 3128 "../src/sem.puma" *)
      
        CheckTargetCode (Expr);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Index:
(* line 3131 "../src/sem.puma" *)
     WITH t^.Index DO
(* line 3131 "../src/sem.puma" *)
      
        CheckTargetCode (Expr);
        CheckTargetCode (Exprs);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TargetExpr:
(* line 3135 "../src/sem.puma" *)
     WITH t^.TargetExpr DO
(* line 3135 "../src/sem.puma" *)
      
        ActNames := UsedNames;
        CheckTargetCode (Expr);
        ReleaseSet (UsedNames);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Ident:
(* line 3140 "../src/sem.puma" *)
     WITH t^.Ident DO
(* line 3140 "../src/sem.puma" *)
      
        IF IsElement (Attribute, ActNames) 
           AND (IdentifyVar (Decls, Attribute) # NoTree) 
            
        THEN
           Error ("label not computed yet", Pos);
        END;
        CheckTargetCode (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Any:
(* line 3161 "../src/sem.puma" *)
     WITH t^.Any DO
(* line 3163 "../src/sem.puma" *)
      CheckTargetCode (Next);
      RETURN;
     END (* WITH *) ;

  | Tree.Anys:
(* line 3161 "../src/sem.puma" *)
     WITH t^.Anys DO
(* line 3163 "../src/sem.puma" *)
      CheckTargetCode (Next);
      RETURN;
     END (* WITH *) ;

  | Tree.Designator:
(* line 3161 "../src/sem.puma" *)
     WITH t^.Designator DO
(* line 3163 "../src/sem.puma" *)
      CheckTargetCode (Next);
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END CheckTargetCode;

PROCEDURE RemoveTreeTypes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 2: yyR2: RECORD
  String1: tString;
  String2: tString;
  i: tIdent;
  END;
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Spec:
(* line 3167 "../src/sem.puma" *)
     WITH t^.Spec DO
(* line 3168 "../src/sem.puma" *)
      RemoveTreeTypes (TreeNames);
      RETURN;
     END (* WITH *) ;

  | Tree.TreeName:
(* line 3170 "../src/sem.puma" *)
    WITH yyTempo.yyR2 DO  
     WITH t^.TreeName DO
(* line 3171 "../src/sem.puma" *)
      ;
(* line 3172 "../src/sem.puma" *)
      ;
(* line 3173 "../src/sem.puma" *)
      ;
(* line 3174 "../src/sem.puma" *)
      
   ArrayToString ("t", String1);
   GetString (Name, String2);
   Concatenate (String1, String2);
   i := MakeIdent (String1);
   IF i <= TypeCount THEN Exclude (TypeNames, i); END;
   RemoveTreeTypes (Next);
;
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  ELSE END;

 END RemoveTreeTypes;

PROCEDURE HasReject (yyP1: Tree.tTree): BOOLEAN;

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF yyP1 = Tree.NoTree THEN RETURN FALSE; END;

  CASE yyP1^.Kind OF
  | Tree.Reject:
(* line 3185 "../src/sem.puma" *)
      RETURN TRUE;

  | Tree.Statement
  , Tree.ProcCall
  , Tree.Condition
  , Tree.Assignment
  , Tree.Fail
  , Tree.TargetStmt
  , Tree.Nl
  , Tree.WriteStr:
(* line 3186 "../src/sem.puma" *)
   LOOP
     WITH yyP1^.Statement DO
(* line 3186 "../src/sem.puma" *)
      IF NOT (HasReject (Next)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  ELSE END;

  RETURN FALSE;
 END HasReject;

PROCEDURE BeginSemantics;
 BEGIN
(* line 2452 "../src/sem.puma" *)

   dFormals := mDummyFormal (NoTree); dFormals^.DummyFormal.Next := dFormals;
   (* 
*) 
   nNoFormal := mNoFormal ();
   ArrayToString (".", String1);
   IdentDot := MakeIdent ( String1 ) ; 
   ArrayToString ("EmptyType", String1);
   IdentEmptyType := MakeIdent ( String1 ) ; 
   ArrayToString ("FALSE", String1);
   IdentFalse := MakeIdent ( String1 ) ; 
   ArrayToString ("TRUE", String1);
   IdentTrue := MakeIdent ( String1 ) ;
   ArrayToString ( "NIL" , String1 ) ; 
   IdentNil := MakeIdent ( String1 ) ;
   StringRefNil := GetStringRef ( IdentNil ) ; 



 END BeginSemantics;

PROCEDURE CloseSemantics;
 BEGIN

 END CloseSemantics;

PROCEDURE yyExit;
 BEGIN
  IO.CloseIO; System.Exit (1);
 END yyExit;

BEGIN
 yyf   := IO.StdOutput;
 Exit  := yyExit;
 BeginSemantics;
END Semantics.

