     1 
     2 (* file sem.puma of puma *) 
     3 
     4 (* Ich, Doktor Josef Grosch, Informatiker, 19.4.1991 *)
     5 
     6 (* Rodney M. Bates, modified:
c    7      2-96 allow the patterns in a rule to be too few, even when
c    8           they are only specified positionally.  (If there is any
c    9           named pattern, this already was allowed.)  Just act as if
c   10           there were a , .. following.  This is enabled by the -g
c   11           option.
c   12      6-96 Made error message texts more explicit.
c   13      7-96 Allow a label alone (i.e. which matches anything) in a pattern  
c   14           to be followed by ( ':' | ':>' ) [ '_' ]. 
c   15           Also add a switch (-u) to require the ( ':' | ':>' ) . 
c   16      7-96 Fix so when a deconstructor which applies to a routine
c   17           parameter (i.e. not a child+ of a routine parameter),
c   18           appears in a pattern, the meaning of the parameter name
c   19           is narrowed to the type of the deconstructor, for the
c   20           remainder of the rule. 
c   21      9-96 Change TransformPattern-Compose and TransformExpr-Compose
c   22           to not call TransformExpr(Expr) in cases where it already
c   23           recognized the name Expr.  The existing call produces
c   24           bad looking trees, although apparently they were not used,
c   25           so it didn't hurt yet. 
c   26     10-96 Change to allow types as decomposers in patterns. 
c   27           Do this here by expanding the full cartesian product
c   28           into separate rules.  Types with more than one node
c   29           kind in actuals to out parameters of puma routine calls
c   30           would require changes in the code generating modules
c   31           (which is not being done now), so they generate error
c   32           messages. 
c   33      3-97 Further expanded messages on type incompatibilities. 
c   34      4-97 Made it illegal for a call on a user procedure (i.e. not 
c   35           a puma routine) to have patterns following '=>' . 
c   36      5-97 Naming environment changes created by matched patterns. 
c   37           Each child name of an explicit decomposer is declared for
c   38           the remainder of the rule, EXCEPT if the corresponding
c   39           child pattern is:
c   40             a) omitted altogether (this can happen with both positional 
c   41                and named notation).
c   42             b) A label alone 
c   43             c) A label on a '_'.  
c   44           I plan to eventually eliminate exception c). 
c   45           Note that this change also makes occurrences of these
c   46           identifiers in target code as well generate full
c   47           referencing designators, so the -w option should not be
c   48           needed any more.  I guess it could break existing code
c   49           which relied on target code _not_ being interpreted in
c   50           a -w context, i.e. these identifiers had other meanings.
c   51      9-97 Filled in field Object of node Ident.  Later discovered
c   52           that the generation files (c.puma, M2.puma, ada.puma, etc.)
c   53           don't need this because they have Decls available and can
c   54           call IdentifyVar ( Decls, Attribute ) to recompute the 
c   55           value Object now has.  Still, it seems like a possibly
c   56           worthwhile idea, so I left it in. 
c   57      9-97 Fixed a bug where a statement which is a call with a dot-
c   58           qualified name had uninitialized Object fields in the two
c   59           VarUse nodes of the qualified name.  
c   60      9-97 Added an error message when a statement is a node constructor. 
c   61      1-98 Minor error message text improvements, removed some unused code,
c   62           added some comments. 
c   63      1-98 Fixed bug where CheckPattern,Value passed dummy formals instead of
c   64           the real ones to CheckExprVar, causing DontCare1:Tempo to be set but
c   65           DontCare1:TypeDesc not, so tempo decl didn't have a type in generated
c   66           code. 
c   67      1-98 In CheckExpr:PreOperator,PostOperator, changed Formals in call to
c   68           CheckExprVar to dFormals, to be consistent with binary operators. 
c   69      1-98 Changed CheckExprVar to demand a real formal on a DontCare1.  All 
c   70           cases where a dummy formal can happen look meaningless for dont care.
c   71      1-98 Added a TransformPatternRecurse to just recurse on Tree.Parents, instead
c   72           of making it a Value, which was failing when a DontCare1 was inside the
c   73           Parents.  We want to allow DontCare1 as a Value, for matching
c   74           attributes which have a label.
c   75      7-98 Changed ClassFormals:Attribute to recognize a tree type of an
c   76           attribute, so patterns can match these. 
c   77      7-98 Further fix to last change of 1-98.  It was putting a Parents node
c   78           into the pattern subtree, but this was crashing later code,
c   79           notably M2.puma.  It also broke ordinary (i.e. not DontCare)
c   80           patterns of attributes.  Eliminated the Parents in case of
c   81           DontCare1 inside the parentheses and changed back to put in 
c   82           the Value node in all other cases. 
c   83      9-98 Changed to put ConsType at the top (i.e. right end) of paths rooted
c   84           at Formal nodes, and give ConsType nodes IsProperlyNarrowed.
c   85           Object-oriented target language generation needs these changes.
c   86     10-98 Added colons on labels in this file. 
c   87     10-98 Added computation of RoutineFormal and its new fields, PlainFormal.
c   88     10-98 Misc. comments and error message text changes. 
c   89      1-99 Fixed bug to properly evaluate expressions in the presence of
c   90           DontCare[x]Internal nodes. 
c   91      1-99 Fixed to treat <KnownLableOfTreeType> '.' <ValidField>, not in
c   92           target code, as <KnownLableOfTreeType> "::" <ValidField> 
c   93      4-99 Fixed 3 places where mistakenly assumed that an ident in LabelNames
c   94           would also be found by IdentifyVar
c   95      5-99 Changes to compute IsProperlyNarrowed of Decompose and NilTest,
c   96           Properly compute field Name of ConsType node corresponding to 
c   97           a DontCare, misc. restructuring 
c   98      7-99 Misc small format and naming improvements. 
c   99      7-99 Recognize declared identifiers (other than tree/node names) in
c  100           patterns, including forward refs to puma routines. 
c  101      7-99 Add type check to AttrDesc ("::" in puma expression) against
c  102           expected type. 
c  103      7-99 Add child name to warning "child name hides another declaration"
c  104      7-99 Add and use in messages, position fields for LHS of NamedExpr
c  105           and both sides of AttrDesc and Designator. 
c  106      7-99 Change to accept Label and/or '_' followed by "( .. )", or 
c  107           "( _ , .. )", etc. as equivalent to the prefix alone.  
c  108      7-99 Add VAR to rule local decls. 
c  109      7-99 Warn when a free identifier in a pattern would have a meaning
c  110           which depends on the -u option. 
c  111      
c  112 *)
   113 
   114 TRAFO Semantics PUBLIC Semantics RemoveTreeTypes                              *     *     *     *     *
   115 
   116 EXPORT {                                                                      *
   117 FROM Idents     IMPORT tIdent;                                                *     *     *     *
   118 FROM Sets       IMPORT tSet;                                                117     *   117     *
   119 FROM Tree       IMPORT tTree;                                               118     *   118     *
   120 
   121 VAR TypeCount   : SHORTCARD;                                                  *     *     *
   122 VAR TypeNames, UserTypes        : tSet;                                     121     *     *   118
   123 
   124 PROCEDURE IdentifyVar   (node: tTree; i: tIdent): tTree;                      *     *     *   119     *   117     *
   125 PROCEDURE LookupClass   (Classes: tTree; i: CARDINAL): tTree;               124     *     *   124   124     *     *
   126 }
   127 
   128 GLOBAL {                                                                      *
   129 
   130 FROM SYSTEM     IMPORT TSIZE, ADR;                                          119     *   119     *     *
   131 FROM General    IMPORT Max;                                                 130     *   130     *
   132 FROM IO         IMPORT StdOutput, WriteN, WriteS, WriteI, WriteNl;          131     *   131     *     *     *     *     *
   133 FROM DynArray   IMPORT MakeArray, ReleaseArray;                             132     *   132     *     *
   134 FROM Strings    IMPORT tString, IntToString, Append, Concatenate, ArrayToString;        133     *   133     *     *     *
                                                                                     *     *
   135 FROM Idents     IMPORT WriteIdent, tIdent, NoIdent, MakeIdent, MaxIdent, GetString;     134   117   134     *   124     *
                                                                                     *     *     *
   136 FROM Texts      IMPORT MakeText;                                            135     *   135     *
   137 FROM Scanner    IMPORT Error, ErrorI, Warning, WarningI;                    136     *   136     *     *     *     *
   138 FROM Positions  IMPORT tPosition, NoPosition;                               137     *   137     *     *
   139 FROM Assertions IMPORT Assert, AssertPos, CantHappen, CantHappenPos;        138     *   138     *     *     *     *
   140 
   141 FROM Sets       IMPORT                                                      139   118   139
   142    tSet         , MakeSet       , ReleaseSet    , AssignEmpty   ,           122     *     *     *
   143    IsElement    , Include       , IsEmpty       , Extract       ,             *     *     *     *
   144    Select       , Difference    , Complement    , ForallDo      ,             *     *     *     *
   145    IsSubset     , Minimum       , Maximum       , Assign        ,             *     *     *     *
   146    Exclude      , Intersection  , WriteSet      , IsNotEqual    ,             *     *     *     *
   147    Union        ;                                                             *
   148 
   149 FROM Tree       IMPORT                                                      141   119   141
   150    tTree        , NoTree        , TreeRoot      , mCall         ,           125     *     *     *
   151    mCompose     , mDecompose    , mParents      ,                             *     *     *
   152    mDontCareInternal            , mDontCare1Internal            ,             *     *
   153    mNilTest     , mNoPattern    , mOnePattern   , mRule         ,             *     *     *     *
   154    mOnePatternAlts , mNoPatternsList , mOnePatternsList         ,             *     *     *
   155    mVarDef      , mBinary       , mClass        ,                             *     *     *
   156    mNoFormal    , mPlainFormal  , mRoutineFormal , mNodeTypes   ,             *     *     *     *
   157    mUserType    , mAttrDesc     ,                                             *     *
   158    mVar         , mConsType     , mField        , mNoClass      ,             *     *     *     *
   159    mOneExpr     , mNoExpr       , mValue        , mDummyFormal  ,             *     *     *     *
   160    mWriteStr    , f             , ForallClasses , ForallAttributes,           *     *     *     *
   161    Options      , ReverseTree   , IsType        , Class         ,             *     *     *     *
   162    Test         , Dummy         , CopyTree      , Nonterminal   ;             *     *     *     *
   163 
   164 VAR                                                                         122
   165    ExternNames  ,                                                             *
   166    LocExternNames,                                                            *
   167    ActTypes     ,                                                             *
   168    ActNames     ,                                                             *
   169    UserNames    , (* Used, but not declared as puma names. *)                 *
   170    LabelNames   , (* Includes formals too. *)                                 *
   171    ParamNames   ,                                                             *
   172    RoutineNames : tSet;                                                       *   142
   173    dFormals     ,                                                             *
   174    Parameters   ,                                                             *
   175    Decls        ,                                                             *
   176    Args         ,                                                             *
   177    InFormals    ,                                                             *
   178    OutFormals   ,                                                             *
   179    ReturnFormal ,                                                             *
   180    Node         ,                                                             *
   181    Var          ,                                                             *
   182    TreeName     ,                                                             *
   183    ActTree      ,                                                             *
   184    ActClass     : tTree;                                                      *   150
   185    RuleCount    ,                                                             *
   186    TempoCount   : INTEGER;                                                    *     *
   187    ProcName     ,                                                             *
   188    ParamName    ,                                                             *
   189    IdentDot     ,                                                             *
   190    IdentEmptyType ,                                                           *
   191    IdentFalse   ,                                                             *
   192    IdentTrue    : tIdent;                                                     *   135
   193    HasLocals    ,                                                             *
   194    IsFunction   ,                                                             *
   195    IsOutput     ,                                                             *
   196    Mode         ,                                                             *
   197    Success      : BOOLEAN;                                                    *     *
   198    String       ,                                                             *
   199    String1        : tString;                                                  *   134
   200    i              : CARDINAL;                                               125   125
   201    nNoFormal      : tTree;                                                    *   184
   202    GlobalLUBClass : tTree ;                                                   *   201
   203 
   204 PROCEDURE LookupFormal (Ident: tIdent; Formals: tTree): INTEGER;            125     *     *   192     *   202   186
   205    VAR i        : INTEGER;                                                  164   200   204
   206    BEGIN                                                                      *
   207       i := 0;                                                               205
   208       WHILE IsType ( Formals , Tree . Formal ) DO                             *   161   204   149     *     *
   209          INC (i);                                                             *   207
   210          IF Formals^.Formal.Name = Ident THEN RETURN i; END;                  *   208   208     *   204     *     *   209
                                                                                     *
   211          Formals := Formals^.Formal.Next;                                   210     *   210     *
   212       END;                                                                  210
   213       RETURN 0;                                                             210
   214    END LookupFormal;                                                        212   204
   215 
   216 PROCEDURE IdentifyTree (i: tIdent): tTree;      (* is i name of a tree type ? *)        204     *   210   204   204
   217    VAR Node: tTree;                                                         205   180   216
   218    BEGIN                                                                    206
   219       Node := TreeRoot^.Spec.TreeNames;                                     217   150     *     *
   220       WHILE Node^.Kind = Tree.TreeName DO                                   208   219     *   208   182   208
   221          IF Node^.TreeName.Name = i THEN RETURN Node; END;                  210   220   220   210   216   210   213     *
                                                                                   214
   222          Node := Node^.TreeName.Next;                                       221     *   221   211
   223       END;                                                                  221
   224       RETURN NoTree;                                                        221   150
   225    END IdentifyTree;                                                        223   216
   226 
   227 PROCEDURE IdentifyProc (i: tIdent): tTree;      (* is i name of a subroutine ? *)       216     *   221   216   217
   228    VAR Node: tTree;                                                         217   222   227
   229    BEGIN                                                                    218
   230       Node := TreeRoot^.Spec.Routines;                                      228   219   219     *
   231       WHILE Node^.Kind # Tree.NoRoutine DO                                  220   230   220   220     *   220
   232          IF Node^.Routine.Name = i THEN RETURN Node; END;                   221   231     *   221   227   221   224     *
                                                                                   225
   233          Node := Node^.Routine.Next;                                        232     *   232   222
   234       END;                                                                  232
   235       RETURN NoTree;                                                        232   224
   236    END IdentifyProc;                                                        234   227
   237 
   238 PROCEDURE IdentifyVar (Node: tTree; i: tIdent): tTree;  (* is i name of a variable ?\   227   124   233   228   232   227
                                                                                     *
c     \ *)
   239    BEGIN                                                                    229
   240       WHILE Node^.Kind # Tree.NoFormal DO                                   231   238   231   231     *   231
   241          IF Node^.Formal.Name = i THEN RETURN Node; END;                    232   240   211   232   238   232   235     *
                                                                                   236
   242          Node := Node^.Formal.Next;                                         241     *   241   233
   243       END;                                                                  241
   244       RETURN NoTree;                                                        241   235
   245    END IdentifyVar;                                                         243   238
   246 
   247 PROCEDURE IdentifyClass2 (i: tIdent; VAR TreeName: tTree): tTree; (* is i a node typ\   238     *   241   238   228   222
                                                                                   238     *
c     \e ? *)
   248    VAR Class: tTree;                                                        247   161   247
   249    BEGIN                                                                    239
   250       TreeName := TreeRoot^.Spec.TreeNames;                                 247   230   230   219
   251       WHILE TreeName^.Kind = Tree.TreeName DO                               240   250   240   240     *   240
   252          Class := IdentifyClass (TreeName^.TreeName.Classes, i);            248     *   251     *   125   247
   253          IF Class # NoTree THEN RETURN Class; END;                          241   252   244   241   244     *   245
   254          TreeName := TreeName^.TreeName.Next;                               252     *     *   242
   255       END;                                                                  253
   256       TreeName := NoTree;                                                   254   253
   257       RETURN NoTree;                                                        253   256
   258    END IdentifyClass2;                                                      255   247
   259 
   260 PROCEDURE IdentifyClass (t: tTree; Ident: tIdent): tTree;                   247   252     *   248   210   247     *
   261   (* Search for a class using an identifier. *) 
   262    VAR class    : tTree;                                                    248     *   260
   263    BEGIN                                                                    249
   264       WHILE t^.Kind = Class DO                                              251   260   251   253   251
   265          WITH t^.Class DO                                                     *   264   264   264
   266             IF Name = Ident THEN RETURN t; END;                             253   241   260   253   257   265   258
   267             class := IdentifyClass (Extensions, Ident);                     262   260     *   266
   268             IF class # NoTree THEN RETURN class; END;                       266   267   257   266   266     *   266
   269             t := Next;  (* RETURN IdentifyClass (Next, Ident); *)           266   254
   270          END;                                                               268
   271       END;                                                                  270
   272       RETURN NoTree;                                                        268   268
   273    END IdentifyClass;                                                       271   267
   274 
   275 PROCEDURE LookupClass (Classes: tTree; i: CARDINAL): tTree;                 260   125   252   262   252   200     *
   276   (* Search for a class using an index. *) 
   277    VAR Class: tTree;                                                        262   265   275
   278    BEGIN                                                                    263
   279       IF Classes^.Kind = Tree.NoClass THEN RETURN NoTree; END;              268   275   264   251     *   268   272   272
                                                                                   273
   280       WITH Classes^.Class DO                                                265   279   277   265
   281          IF Index = i THEN RETURN Classes; END;                             279     *   275   279   279   280   279
   282          Class := LookupClass (Extensions, i);                              280   275   267   281
   283          IF Class # NoTree THEN RETURN Class; END;                          281   282   279   281   281     *   281
   284          RETURN LookupClass (Next, i);                                      283   282   269   282
   285       END;                                                                  283
   286    END LookupClass;                                                         285   284
   287 
   288 PROCEDURE ClassOfNodeTypes ( NodeTypes : tTree (* NodeTypes *) ) : tTree (* Class *)\   275     *     *   277     *
      \ ; 
   289   BEGIN                                                                     278
   290     RETURN                                                                  284
   291       LookupClass                                                           286
   292         ( NodeTypes ^ . NodeTypes . TreeName ^ . TreeName . Classes         288     *   256     *   281
   293         , Minimum ( NodeTypes ^ . NodeTypes . Types )                       145   292     *     *
   294         ) 
   295   END ClassOfNodeTypes ;                                                    286   288
   296 
   297 PROCEDURE TypeIdentOfFormal ( Formal : tTree (* Formal *) ) : tIdent ;      288     *   242   288   260
   298   VAR LClass : tTree (* Class *) ;                                          277     *   297
   299   BEGIN                                                                     289
   300     IF Formal = Tree . NoTree                                               283   297   279   283
   301     THEN                                                                    283
   302       RETURN NoIdent                                                        290   135
   303     ELSIF IsType ( Formal , Tree . Formal )                                   *   208   300   300     *
   304     THEN                                                                    301
   305       IF Formal ^ . Formal . TypeDesc = Tree . NoTree                       300   303     *     *   303   300
   306       THEN                                                                  304
   307         RETURN NoIdent                                                      302   302
   308       ELSIF IsType ( Formal ^ . Formal . TypeDesc , Tree . UserType )       303   303   305     *   305   305     *
   309       THEN                                                                  306
   310         RETURN Formal ^ . Formal . TypeDesc ^ . UserType . Type             307   308     *   308   308     *
   311       ELSIF IsType ( Formal ^ . Formal . TypeDesc , Tree . NodeTypes )      308   308   310     *   310   308   293
   312       THEN                                                                  309
   313         IF IsType ( Formal , Tree . RoutineFormal )                         305   311   311   311     *
   314            AND ( Formal ^ . RoutineFormal . TargetClass # NoTree )            *   313   313     *   305
   315         THEN                                                                312
   316           RETURN                                                            310
   317             Formal ^ . RoutineFormal . TargetClass ^ . Class . Name         314   314   314   283   266
   318         ELSE                                                                  *
   319           LClass := ClassOfNodeTypes ( Formal ^ . Formal . TypeDesc ) ;     298   295   317     *   311
   320           RETURN                                                            316
   321             LClass ^ . Class . Name                                         319   317   317
   322         END (* IF *)                                                        295
   323       ELSE                                                                  318
   324         RETURN NoIdent                                                      320   307
   325       END (* IF *)                                                          322
   326     ELSE                                                                    323
   327       RETURN NoIdent                                                        324   324
   328     END (* IF *)                                                            325
   329   END TypeIdentOfFormal ;                                                   328   297
   330 
   331 PROCEDURE MakeTypes (Index: INTEGER; Classes: tTree; VAR Types: tSet);      297     *   281   205   292   298   298   293
                                                                                   172
   332    BEGIN                                                                    299
   333       ActTypes := Types;                                                    167   331
   334       ForallClasses (Classes, ProcFormals);                                 160   331     *
   335       Include (ActTypes, Index);                                            143   333   331
   336       Types := ActTypes;                                                    333   335
   337    END MakeTypes;                                                           329   331
   338 
   339 PROCEDURE CheckSubtype (t1, t2: tTree; Pos: tPosition; Reason : ARRAY OF CHAR);   331     *     *     *   331     *   138
                                                                                     *     *     *     *
   340    BEGIN                                                                    332
   341       IF t1^.Kind = Tree.NodeTypes THEN                                     313   339   279   313   311   315
   342          IF t2^.Kind = Tree.UserType THEN                                   341   339   341   341   310   341
   343             Warning ( Reason , Pos ) ;                                      137   339   339
   344             Warning ("  user type is incompatible with formal's tree type", Pos);       343   343
   345          ELSIF t2^.NodeTypes.TreeName # t1^.NodeTypes.TreeName THEN         311   342   341   292   341     *     *   342
   346             Error ( Reason , Pos ) ;                                        137   343   344
   347             Error ("  incompatible tree types from different trees", Pos);        346   346
   348          ELSIF NOT IsSubset (t2^.NodeTypes.Types, t1^.NodeTypes.Types) THEN       345     *   145   345   345   336   345
                                                                                     *     *   345
   349             Error ( Reason , Pos ) ;                                        347   346   347
   350             Error ("  not a subset of formal node kinds", Pos);             349   349
   351          END;                                                               337
   352       ELSIF t1^.Kind = Tree.UserType THEN                                   348   348   342   342   342   348
   353          IF t2^.Kind = Tree.NodeTypes THEN                                  342   348   352   352   348   352
   354             Warning ( Reason , Pos ) ;                                      344   349   350
   355             Warning ("  tree type is incompatible with formal's user type", Pos);       354   354
   356          ELSIF t2^.UserType.Type # t1^.UserType.Type THEN                   352   353   352   310   352     *     *   353
   357             Warning ( Reason , Pos ) ;                                      355   354   355
   358             Warning ("  incompatible user types", Pos);                     357   357
   359          END;                                                               351
   360       END;                                                                  359
   361    END CheckSubtype;                                                        360   339
   362 
   363 PROCEDURE CheckType (t1, t2: tTree; Pos: tPosition);                        339     *   356   356   339   358   339
   364    VAR t        : tSet;                                                     331   269   331
   365    BEGIN                                                                    340
   366       IF t1^.Kind = Tree.NodeTypes THEN                                     353   363   353   353   353   356
   367          IF t2^.Kind = Tree.UserType THEN                                   366   363   366   366   356   366
   368             Warning ("tree-type required", Pos);                            358   363
   369          ELSIF t2^.NodeTypes.TreeName # t1^.NodeTypes.TreeName THEN         356   367   366   345   366     *     *   367
   370             Error ("incompatible types from different trees", Pos);         350   368
   371          ELSE                                                               326
   372             MakeSet (t, t1^.NodeTypes.TreeName^.TreeName.ClassCount);       142   364   369   369   369     *     *
   373             Assign (t, t1^.NodeTypes.Types);                                145   372   372   372   348
   374             Intersection (t, t2^.NodeTypes.Types);                          146   373   369   373   373
   375             IF IsEmpty (t) THEN                                             367   143   374   369
   376                Warning ("disjoint node types", Pos);                        368   370
   377             END;                                                            361
   378             ReleaseSet (t);                                                 142   375
   379          END;                                                               377
   380       ELSIF t1^.Kind = Tree.UserType THEN                                   369   373   367   367   367   375
   381          IF t2^.Kind = Tree.NodeTypes THEN                                  375   374   380   380   374   380
   382             Warning ("user-type required", Pos);                            376   376
   383          ELSIF t2^.UserType.Type # t1^.UserType.Type THEN                   380   381   380   356   380     *     *   381
   384             Warning ("incompatible user types", Pos);                       382   382
   385          END;                                                               379
   386       END;                                                                  385
   387    END CheckType;                                                           386   363
   388 
   389 PROCEDURE ComputeDepthsClasses ( t : tTree (* Class *) ; FDepth : INTEGER )       363     *   378   363     *   331
   390 
   391 ; VAR LC : tTree                                                            364     *   389
   392 
   393 ; BEGIN                                                                     365
   394     LC := t                                                                 391   389
   395   ; WHILE ( LC <> NIL ) AND ( LC ^ . Kind = Class )                         264   394     *   314     *   381   321
   396     DO                                                                      280
   397       LC ^ . Class . Depth := FDepth                                        395   395     *   389
   398     ; ComputeDepthsClasses ( LC ^ . Class . Extensions , FDepth + 1 )       389   397   397   282   397
   399     ; LC := LC ^ . Class . Next                                             398     *   398   284
   400     END (* WHILE *)                                                         387
   401   END ComputeDepthsClasses ;                                                400   398
   402 
   403 (* Subsumed into ClassFormals: 
c  404 PROCEDURE ComputeDepths ( t : tTree (* TreeName *) ) 
c  405 
c  406 ; VAR LT : tTree 
c  407 
c  408 ; BEGIN
c  409     LT := t 
c  410   ; WHILE ( LT <> NIL ) AND ( LT ^ . Kind = Tree . TreeName ) 
c  411     DO 
c  412       ComputeDepthsClasses ( LT ^ . TreeName . Classes , 1 ) 
c  413     ; LT := LT ^ . TreeName . Next 
c  414     END (* WHILE *) 
c  415   END ComputeDepths ; 
c  416 *) 
   417 
   418 PROCEDURE ClassLUB ( Left , Right : tTree (* Class *) ) : tTree (* Class *)       389     *     *     *   391     *
   419 
   420 ; VAR LDepth : INTEGER                                                      391     *   389
   421 
   422 ; BEGIN                                                                     393
   423     IF Left = NoTree                                                        381   418   314
   424     THEN RETURN Right                                                       383   327   418
   425     ELSIF Right = NoTree                                                    383   424   423
   426     THEN RETURN Left                                                        424   424   423
   427     ELSIF Left ^ . Kind = Tree . NoClass                                    425   426   395   381   279
   428     THEN RETURN Right                                                       426   426   425
   429     ELSIF Right ^ . Kind = Tree . NoClass                                   427   428   427   427   427
   430     THEN RETURN Left                                                        428   428   427
   431     ELSIF Left ^ . Class . Depth = 0                                        429   430   399   397
   432     THEN RETURN Right                                                       430   430   429
   433     ELSIF Right ^ . Class . Depth = 0                                       431   432   431   431
   434     THEN RETURN Left                                                        432   432   431
   435     ELSE                                                                    371
   436       LDepth := Right ^ . Class . Depth                                     420   433   433   433
   437     ; WHILE Left ^ . Class . Depth > LDepth                                 395   434   436   436   436
   438       DO Left := Left ^ . Class . BaseClass                                 396   437     *   437     *
   439       END (* WHILE *)                                                       401
   440     ; LDepth := Left ^ . Class . Depth                                      437   438   438   437
   441     ; WHILE Right ^ . Class . Depth > LDepth                                437   436   440   440   440
   442       DO Right := Right ^ . Class . BaseClass                               438   441     *   441   438
   443       END (* WHILE *)                                                       439
   444     ; WHILE Left <> Right                                                   441   440   442
   445       DO                                                                    442
   446         IF Left ^ . Class . Depth = 1                                       423   444   442   441
   447         THEN                                                                434
   448           Left := Left ^ . Class . TypeDesc                                 446     *   446   319
   449                   ^ . NodeTypes . TreeName                                  381   372
   450                   ^ . TreeName . UniversalClass                             449     *
   451         ; Right := Left                                                     444   448
   452         ELSE                                                                435
   453           Left := Left ^ . Class . BaseClass                                451     *   448   442
   454         ; Right := Right ^ . Class . BaseClass                              451     *   453   453
   455         END (* IF *)                                                        443
   456       END (* WHILE *)                                                       455
   457     ; RETURN Left                                                           434   453
   458     END (* IF *)                                                            456
   459   END ClassLUB ;                                                            458   418
   460 
   461 PROCEDURE NextPatterns                                                      418     *
   462   ( Patterns : tTree ; VAR Result : tTree ; VAR CarryOut : BOOLEAN )          *   418   420     *     *     *     *   197
   463 
   464 ; VAR LSuffix , LCurrent : tTree                                            462     *     *   462
   465 
   466 ; BEGIN                                                                     422
   467     CASE Patterns ^ . Kind OF                                                 *   462   429   339
   468     | Tree . NoPattern                                                      429     *
   469       : CarryOut := TRUE                                                    462     *
   470       ; Result := mNoPattern ( Patterns ^ . NoPattern  . Pos )              462   153   467   468   384
   471     | Tree . OnePattern                                                     468     *
   472       : NextPatterns                                                        461
   473           ( Patterns ^ . OnePattern . Next , LSuffix , CarryOut )           470   471   399   464   469
   474       ; Result                                                              470
   475           := mOnePattern                                                    153
   476                 ( CopyTree ( Patterns ^ . OnePattern . Pattern ) , LSuffix )      162   473   473     *   473
   477     | Tree . OnePatternAlts                                                 471     *
   478       : NextPatterns                                                        472
   479           ( Patterns ^ . OnePatternAlts . Next , LSuffix , CarryOut )       476   477   473   476   473
   480       ; LCurrent := Patterns ^ . OnePatternAlts . Current                   464   479   479     *
   481       ; Assert                                                              139
   482           ( IsType                                                          313
   483               ( LCurrent ^ . OnePatternsList . Patterns , Tree . Decompose )      480     *   480   477     *
   484           , "NextPatterns, Alt not Decompose." 
   485           ) 
   486       ; Result                                                              474
   487           := mOnePattern                                                    475
   488                ( CopyTree ( LCurrent ^ . OnePatternsList . Patterns )       476   483   483   483
   489                  (* ^A Decompose node.  See ExpandDecompose. *) 
   490                , LSuffix                                                    479
   491                ) 
   492       ; IF CarryOut (* Actually, this is the carry in. *)                   446   479
   493         THEN                                                                447
   494           LCurrent := LCurrent ^ . OnePatternsList . Next                   488     *   488   479
   495         ; IF LCurrent ^ . Kind = Tree . NoPatternsList                      492   494   467   483     *
   496           THEN                                                              493
   497             Patterns ^ . OnePatternAlts . Current                           488   480   480
   498               := Patterns ^ . OnePatternAlts . PatternsList                 497   497     *
   499           ELSE                                                              452
   500             CarryOut := FALSE                                               492     *
   501           ; Patterns ^ . OnePatternAlts . Current := LCurrent               498   498   497   495
   502           END (* IF *)                                                      459
   503         END (* IF *)                                                        502
   504     END (* CASE *)                                                          503
   505   END NextPatterns ;                                                        504   478
   506 
   507 PROCEDURE ExpandDecompose                                                   461     *
   508   ( Pos: tPosition                                                          470   363
   509   ; Selector: tIdent                                                          *   297
   510   ; Expr: tTree (* VarUse, Index, or Binary, a form which is a node or type *)      *   464
   511                 (* 1st VarUse inside must have Object field set. *) 
   512   ; Exprs: tTree (* Untransformed *)                                          *   510
   513   ; Widen: BOOLEAN                                                            *   462
   514   ; VAR Result : tTree                                                      464   486   512
   515   ; VAR PatternCount : CARDINAL                                             514     *   275
   516   )
   517 (* POST: Either PatternCount = 1 and Result points to a Decompose node,
c  518    or PatternCount > 1 and Result points to a list of PatternsList
c  519    nodes, each of which points to a Decompose.  The latter case 
c  520    violates the definition of OnePatternsList, but it is a path of
c  521    lower coding resistance. *) 
   522 
   523 ; VAR LTreeName , LClasses , LClassVarUse , LClass , LOperands : tTree      515     *     *     *   321     *   514
   524 ; VAR LDecomposeExpr , LResult , LPatterns , LSingleOperands : tTree        523     *     *     *     *   523
   525 ; VAR LClassCount , LOperandsCount : CARDINAL                               524     *     *   515
   526 ; VAR LCarryOut , LHasExactlyOneClass : BOOLEAN                             525     *     *   513
   527 
   528 ; BEGIN                                                                     466
   529     LClassCount := 1                                                        525
   530   ; PatternCount := 0                                                       515
   531   ; LResult := mNoPatternsList ( )                                          524   154
   532   ; CASE Expr ^ . Kind OF                                                   467   510   495   467
   533     | Tree . Index                                                          495   335
   534       : AssertPos                                                           139
   535           ( Expr ^ . Index . Expr ^ . Kind = Tree . VarUse                  532   533     *   532   533     *
   536           , "ExpandDecompose, Index w/o 1st VarUse." 
   537           , Expr ^ . Index . Pos                                            535   535   508
   538           ) 
   539       ; LTreeName := Expr ^ . Index . Expr ^ . VarUse . Object              523   537   537     *   535     *
   540       ; LClasses := Expr ^ . Index . Exprs                                  523   539   539   512
   541       ; AssertPos                                                           534
   542           ( LClasses ^ . Kind = Tree . OneExpr                              540   535   535     *
   543           , "ExpandDecompose, Index w/o Expr." 
   544           , Expr ^ . Index . Pos                                            540   540   537
   545           ) 
   546       ; LClassVarUse := LClasses ^ . OneExpr . Expr                         523   542   542   544
   547       ; AssertPos                                                           541
   548           ( LClassVarUse ^ . Kind = Tree . VarUse                           546   542   542   539
   549           , "ExpandDecompose, Index w/o 2nd VarUse." 
   550           , Expr ^ . Index . Pos                                            546   544   544
   551           ) 
   552       ; LClass                                                              523
   553           := IdentifyClass                                                  273
   554                ( LTreeName ^ . TreeName . Classes                           539   450   334
   555                , LClassVarUse ^ . VarUse . Name                             548   548   321
   556                ) 
   557       ; LClassVarUse ^ . VarUse . Object := LClass                          555   555   539   552
   558       ; LDecomposeExpr                                                      524
   559           := mBinary                                                        155
   560                ( Expr ^ . Index . Pos                                       550   550   550
   561                , Expr ^ . Index . Expr                                      560   560     *
   562                , IdentDot                                                   189
   563                , LClassVarUse                                               557
   564                ) 
   565       ; LHasExactlyOneClass                                                 526
   566           := LClasses ^ . OneExpr . Next ^ . Kind = Tree . NoExpr           546   546   494   548   548     *
   567     | Tree . VarUse                                                         566   557
   568       : LClassVarUse := Expr                                                563   561
   569       ; LClass := LClassVarUse ^ . VarUse . Object                          557   568   567   557
   570       ; LDecomposeExpr := Expr                                              558   568
   571       ; LHasExactlyOneClass := TRUE                                         565   469
   572     | Tree . Binary                                                         567     *
   573       : AssertPos                                                           547
   574           ( Expr ^ . Binary . Operator = IdentDot                           570   572     *   562
   575           , "ExpandDecompose, Binary w/o dot." 
   576           , Expr ^ . Binary . Pos                                           574   574   560
   577           ) 
   578       ; AssertPos                                                           573
   579           ( Expr ^ . Binary . Lop ^ . Kind = Tree . VarUse                  576   576     *   566   572   569
   580           , "ExpandDecompose, Binary w/o 1st VarUse." 
   581           , Expr ^ . Binary . Pos                                           579   579   576
   582           ) 
   583       ; LTreeName := Expr ^ . Binary . Lop ^ . VarUse . Object              554   581   581   579   579   569
   584       ; AssertPos                                                           578
   585           ( Expr ^ . Binary . Rop ^ . Kind = Tree . VarUse                  583   583     *   579   579   583
   586           , "ExpandDecompose, Binary w/o 2nd VarUse." 
   587           , Expr ^ . Binary . Pos                                           585   585   581
   588           ) 
   589       ; LClassVarUse := Expr ^ . Binary . Rop                               569   587   587   585
   590       ; LClass                                                              569
   591           := IdentifyClass                                                  553
   592                ( LTreeName ^ . TreeName . Classes                           583   554   554
   593                , LClassVarUse ^ . VarUse . Name                             589   585   555
   594                ) 
   595       ; LClassVarUse ^ . VarUse . Object := LClass                          593   593   583   590
   596       ; LDecomposeExpr := Expr                                              570   589
   597       ; LHasExactlyOneClass := TRUE                                         571   571
   598     ELSE CantHappen ( "ExpandDecompose, Bad Kind." )                        499   139
   599     END (* CASE *)                                                          505
   600   ; LOOP (* Thru type elements *)                                             *
   601     (* INVARIANT: Expr ^ . Kind = Tree . Index 
c  602                     => LTreeName is the object for the tree name. 
c  603                   LClassVarUse points to a VarUse node for the
c  604                     next Class.
c  605                   LDecomposeExpr is the Expr child of the to-be-constructed
c  606                     Decompose node. 
c  607                   LHasExactlyOneClass is set appropriately. 
c  608                   LClass is the decl of the class. 
c  609     *) 
   610       IF LClass = NoTree                                                    495   595   425
   611       THEN                                                                  496
   612         Error ( "not a class or node of the required tree"                  370
   613               , LClassVarUse ^ . VarUse . Pos                               595   595   587
   614               ) 
   615       ELSE                                                                  598
   616         AssertPos                                                           584
   617           ( LClass ^ . Kind = Tree . Class                                  610   585   585   454
   618           , "ExpandDecompose, not a class. "
   619           , Expr ^ . Expr . Pos                                             596     *   613
   620           ) 
   621       ; LOperands                                                           523
   622           := TransformKeyword ( Exprs , LClass ^ . Class . Formals )          *   540   617   617   211
   623       ; TransformPattern ( LOperands , LOperands , LOperandsCount )           *   621     *   525
   624       ; INC ( PatternCount , LOperandsCount )                               209   530   623
   625       ; LOOP (* Thru cartesian product of operand patterns *)               600
   626           IF LHasExactlyOneClass AND ( LOperandsCount = 1 )                 610   597   395   624
   627           THEN (* Avoid unnecessary copying *)                              611
   628             LSingleOperands := LOperands                                    524   623
   629           ; LCarryOut := TRUE                                               526   597
   630           ELSE                                                              615
   631             NextPatterns ( LOperands , LSingleOperands , LCarryOut )        505   628   628   629
   632           END (* IF *)                                                      599
   633         ; LPatterns                                                         524
   634             := mDecompose                                                   151
   635                  ( Pos                                                      619
   636                  , Selector                                                 509
   637                  , LDecomposeExpr                                           596
   638                  , LSingleOperands                                          631
   639                  , Widen                                                    513
   640                  ) 
   641         ; LPatterns ^ . Decompose . Object := LClass                        633   483   595   622
   642         ; LResult                                                           531
   643             := mOnePatternsList ( LPatterns , LResult )                     154   641   642
   644           (* ^This builds the result list backwards. *) 
   645         ; IF LCarryOut THEN EXIT END (* IF *)                               626   631   627     *   632
   646         END (* LOOP *)                                                      645
   647       END (* IF *)                                                          646
   648     (* Loop advance and termination: *) 
   649     ; IF Expr ^ . Kind = Tree . Index                                       645   619   617   617   561
   650       THEN                                                                  645
   651         LOOP (* Thru possibly bad type elements *)                          625
   652           LClasses := LClasses ^ . OneExpr . Next                           566     *   566   566
   653         ; CASE LClasses ^ . Kind OF                                         532   652   649   532
   654           | Tree . NoExpr                                                   649   566
   655             : LClassVarUse := NoTree                                        613   610
   656             ; EXIT (* Inner loop.  Will then exit outer loop. *)            645
   657           | Tree . NamedExpr                                                654     *
   658             : LClassVarUse := LClasses ^ . NamedExpr . Expr                 655   653   657   649
   659             ; Error                                                         612
   660                 ( "named expression not allowed in a type" 
   661                 , LClassVarUse ^ . Expr . Pos                               658   658   635
   662                 ) 
   663             ; IF LClassVarUse ^ . Kind <> Tree . VarUse                     649   661   653   657   613
   664               THEN                                                          650
   665                 Error                                                       659
   666                   ( "single identifier required in a type" 
   667                   , LClassVarUse ^ . Expr . Pos                             663   661   661
   668                   ) 
   669               END (* IF *)                                                  647
   670           | Tree .OneExpr                                                   663   652
   671             : LClassVarUse := LClasses ^ . OneExpr . Expr                   667   658   670   667
   672             ; IF LClassVarUse ^ . Kind <> Tree . VarUse                     663   671   663   670   663
   673               THEN                                                          664
   674                 Error                                                       665
   675                   ( "single identifier required in a type" 
   676                   , LClassVarUse ^ . Expr . Pos                             672   671   667
   677                   ) 
   678               ELSE                                                          630
   679                 INC ( LClassCount )                                         624   529
   680               ; LClass                                                      641
   681                   := IdentifyClass                                          591
   682                        ( LTreeName ^ . TreeName . Classes                   592   592   592
   683                        , LClassVarUse ^ . VarUse . Name                     676   672   593
   684                        )  
   685               ; LClassVarUse ^ . VarUse . Object := LClass                  683   683   641   680
   686               ; LDecomposeExpr                                              637
   687                   := mBinary                                                559
   688                        ( Expr ^ . Index . Pos                               676   649   676
   689                        , Expr ^ . Index . Expr                              688   688     *
   690                        , IdentDot                                           574
   691                        , LClassVarUse                                       685
   692                        ) 
   693               ; EXIT (* Inner loop. Will then go around outer loop *)       656
   694               END (* IF *)                                                  669
   695           ELSE CantHappenPos                                                678   139
   696                  ( "ExpandDecompose, not an expr." 
   697                  , LClassVarUse ^ . VarUse . Pos                            691   685   688
   698                  ) 
   699           END (* CASE *)                                                    694
   700         END (* LOOP Thru possibly bad type elements *)                      699
   701       ; IF LClassVarUse = NoTree THEN EXIT END (* IF *)                     672   697   655   673   693   700
   702       ELSE                                                                  695
   703         EXIT                                                                701
   704       END (* IF *)                                                          701
   705     END (* LOOP Thru type elements *)                                       704
   706   ; IF PatternCount = 1                                                     701   624
   707     THEN                                                                    701
   708       Result := LResult ^ . OnePatternsList . Patterns                      514   643   494   501
   709     ELSE                                                                    702
   710       Result := ReverseTree ( LResult )                                     708   161   708
   711     END (* IF *)                                                            705
   712   END ExpandDecompose ;                                                     711   507
   713 
   714 PROCEDURE IsAllDontCares ( t : tTree ) : BOOLEAN                            507     *   394   524   526
   715 
   716 ; VAR LExprs , LExpr : tTree                                                526     *     *   714
   717 
   718 ; BEGIN                                                                     528
   719     LExprs := t                                                             716   714
   720   ; LOOP                                                                    651
   721       IF LExprs ^ . Kind = Tree . NoExpr                                    706   719   672   672   654
   722       THEN                                                                  707
   723         RETURN TRUE                                                         457   629
   724       ELSIF LExprs ^ . Kind = Tree . OneExpr                                433   721   721   721   671
   725       THEN                                                                  722
   726         LExpr := LExprs ^ . OneExpr . Expr                                  716   724   724   689
   727       ; IF IsType ( LExpr , Tree . DontCare )                               721   482   726   724     *
   728         THEN                                                                725
   729           RETURN TRUE                                                       723   723
   730         ELSIF IsType ( LExpr , Tree . DontCare1 )                           724   727   727   727     *
   731         THEN                                                                728
   732           LExprs := LExprs ^ . OneExpr . Next                               726     *   726   652
   733         ELSE                                                                709
   734           RETURN FALSE                                                      729   500
   735         END (* IF *)                                                        712
   736       ELSE (* Probably NamedExpr *)                                         733
   737         RETURN FALSE                                                        734   734
   738       END (* IF *)                                                          735
   739     END (* LOOP *)                                                          738
   740   END IsAllDontCares ;                                                      739   714
   741 
   742 PROCEDURE TransformPattern                                                  714   623
   743   ( t : tTree ; VAR Result : tTree ; VAR PatternCount : CARDINAL )          719   716   716   710     *     *   706   525
   744 
   745 ; BEGIN                                                                     718
   746     IF t ^ . Kind = Tree . NoExpr                                           727   743   724   730   721
   747     THEN                                                                    731
   748       Result                                                                743
   749         := mOnePattern                                                      487
   750              ( mDontCareInternal ( t ^ . NoExpr . Pos )                     152   746   746   697
   751              , mNoPattern ( t ^ . NoExpr . Pos )                            470   750   750   750
   752              ) 
   753     ; PatternCount := 1                                                     743
   754     ELSE                                                                    736
   755       TransformPatternRecurse ( t , Result , PatternCount )                   *   751   748   753
   756     END (* IF *)                                                            740
   757 
   758   END TransformPattern ;                                                    756   742
   759 
   760 PROCEDURE TransformPatternRecurse                                           742   755
   761   ( t : tTree ; VAR Result : tTree ; VAR PatternCount : CARDINAL )          755   743   743   755     *     *   755   743
   762 
   763 ; VAR TreeName , s , LTreeName , LClass , LPrefixVarUse , L1stVarUse : tTree      761   682     *   682   685     *     *
                                                                                   761
   764 ; VAR LTree1 , LTree2 : tTree                                               763     *     *   763
   765 ; VAR LThisCount , LNextCount : CARDINAL                                    764     *     *   761
   766 
   767 ; BEGIN                                                                     745
   768     PatternCount := 1                                                       761
   769   ; CASE t ^ . Kind                                                         653   761   746
   770 
   771     OF Tree . NoExpr                                                        653   746   751
   772       : Result := mNoPattern ( t ^ . NoExpr . Pos )                         761   751   769   771   751
   773 
   774     | Tree . Parents                                                        771     *
   775       : IF IsType ( t ^ . Parents . Expr , Tree . DontCare1 )               746   730   772   774   726   774   730
   776         THEN (* Ignore parentheses around '_' *)                            747
   777           TransformPatternRecurse                                           760
   778             ( t ^ . Parents . Expr , LTree1 , PatternCount )                775   775   775   764   768
   779           (* Result := mParents ( t ^ . Parents . Pos , LTree1 ) ; *) 
   780         ; Result := LTree1 ;                                                772   778
   781         ELSE                                                                754
   782           Result := mValue ( t ^ . Expr . Pos , TransformExpr ( t ) )       780   159   778   778   772     *     *
   783         END (* IF *)                                                        758
   784 
   785     | Tree . OneExpr                                                        775   732
   786       : WITH t ^ . OneExpr                                                  280   782   785
   787         DO                                                                  445
   788           TransformPatternRecurse ( Expr , LTree1 , LThisCount )            777   782   780   765
   789         ; TransformPatternRecurse ( Next , LTree2 , LNextCount )            788   732   764   765
   790         ; IF LThisCount = 1                                                 775   788
   791           THEN                                                              776
   792             Result := mOnePattern ( LTree1 , LTree2 )                       782   749   788   789
   793           ELSE                                                              781
   794             Result                                                          792
   795               := mOnePatternAlts                                            154
   796                    ( (* PatternsList := *) LTree1                           792
   797                    , (* Next := *) LTree2                                   792
   798                    , (* Current := *) LTree1                                796
   799                    ) 
   800           END (* IF *)                                                      783
   801         ; PatternCount := LThisCount * LNextCount                           778   790   789
   802         END (* WITH *)                                                      800
   803 
   804     | Tree . NamedExpr                                                      785   658
   805       : WITH t ^ . NamedExpr                                                786   786   804
   806         DO                                                                  787
   807           Error                                                             674
   808             ( "illegal context for named association" 
   809             , Expr ^ . Expr . Pos                                           788     *   782
   810             ) 
   811         ; TransformPatternRecurse ( Expr , LTree1 , LThisCount )            789   809   798   801
   812         ; TransformPatternRecurse ( Next , LTree2 , LNextCount )            811   789   797   801
   813         ; IF LThisCount = 1                                                 790   811
   814           THEN                                                              791
   815             Result := mOnePattern ( LTree1 , LTree2 )                       794   792   811   812
   816           ELSE                                                              793
   817             Result                                                          815
   818               := mOnePatternAlts                                            795
   819                    ( (* PatternsList := *) LTree1                           815
   820                    , (* Next := *) LTree2                                   815
   821                    , (* Current := *) LTree1                                819
   822                    ) 
   823           END (* IF *)                                                      802
   824         ; PatternCount := LThisCount * LNextCount                           801   813   812
   825         END (* WITH *)                                                      823
   826 
   827     | Tree . Nil                                                            804     *
   828       : Result                                                              817
   829           := mNilTest ( t ^ . Nil . Pos , t ^ . Nil . Selector )            153   805   827   809     *     *   636
   830 
   831     | Tree . DontCareExplicit , Tree . DontCareInternal                     827     *     *     *
   832     , Tree . DontCare1Explicit , Tree . DontCare1Internal                   831     *     *     *
   833       : Result := t                                                         828   829
   834 
   835     | Tree . DontCare1 , Tree . DontCare                                    832   775     *   727
   836       : CantHappen                                                          598
   837           ( 'TransformPatternRecurse, undistinguished DontCare' ) 
   838 
   839     | Tree . Compose                                                        835     *
   840       : WITH t ^ . Compose                                                  805   833   839
   841         DO                                                                  806
   842           IF Expr ^ . Kind = Tree . Index                                   813   811   769   839   689
   843           THEN                                                              814
   844             IF ( Expr ^ . Index . Expr ^ . Kind = Tree . VarUse )           842   842   842     *   842   842   697
   845                AND IsType                                                   626   775
   846                      ( Expr ^ . Index . Exprs , Tree . OneExpr )            844   844   622   844   786
   847                AND ( Expr ^ . Index . Exprs ^ . OneExpr . Expr ^ . Kind     845   846   846   846   846     *   844
   848                      = Tree . VarUse                                        846   844
   849                    ) 
   850             THEN (* [ <ident> ] '[' <ident> ... ']' '(' ... ')' *)          843
   851               LPrefixVarUse := Expr ^ . Index . Expr                        763   847   847     *
   852             ; L1stVarUse                                                    763
   853                 := Expr ^ . Index . Exprs ^ . OneExpr . Expr                851   851   847   847     *
   854             ; IF LPrefixVarUse ^ . VarUse . Name = NoIdent                  844   851   848   683   327
   855               THEN (* '[' <ident> ... ']' *)                                850
   856                 Object (* of Compose node *)                                685
   857                   := IdentifyClass2                                         258
   858                        ( L1stVarUse ^ . VarUse . Name , LTreeName )         852   854   854   763
   859               ; LPrefixVarUse ^ . VarUse . Object := LTreeName              854   858   856   858
   860               ; L1stVarUse ^ . VarUse . Object := Object                    858   859   859     *
   861               ; IF Object = NoTree                                          854   860   701
   862                 THEN                                                        855
   863                   Error                                                     807
   864                     ( "node type not declared" 
   865                     , L1stVarUse ^ . VarUse . Pos                           860   860   829
   866                     ) 
   867                 ; Result := mDontCareInternal ( Pos )                       833   750   865
   868                 ELSE                                                        816
   869                   ExpandDecompose                                           712
   870                     ( Pos , Selector , Expr , Exprs , Widen                 867   829   853   853   639
   871                     , Result , PatternCount                                 867   824
   872                     ) 
   873                 END (* IF *)                                                825
   874               ELSE (* prefix identifier is present. *)                      868
   875                 LTreeName                                                   859
   876                   := IdentifyTree                                           225
   877                        ( LPrefixVarUse ^ . VarUse . Name )                  859   865   858
   878               ; LPrefixVarUse ^ . VarUse . Object := LTreeName              877   877   861   875
   879               ; IF LTreeName = NoTree                                       861   878   861
   880                 THEN (* Interpret as plain target index expression. *)      862
   881                   Result                                                    871
   882                     := mValue                                               782
   883                          ( t ^ . Expr . Pos , TransformExpr ( t ) )         840   870   870   782     *
   884                 ELSE                                                        874
   885                   Object                                                    878
   886                     := IdentifyClass                                        681
   887                          ( LTreeName ^ . TreeName . Classes                 879   763   682
   888                          , L1stVarUse ^ . VarUse . Name                     865   878   877
   889                          ) 
   890                 ; L1stVarUse ^ . VarUse . Object := Object                  888   888   885     *
   891                 ; IF Object = NoTree                                        879   890   879
   892                   THEN (* Interpret as plain target index expression. *)    880
   893                     Result                                                  881
   894                       := mValue                                             882
   895                            ( t ^ . Expr . Pos , TransformExpr ( t ) )       883   883   883   883     *
   896                   ELSE                                                      884
   897                     ExpandDecompose                                         869
   898                       ( Pos , Selector , Expr , Exprs , Widen               895   870   895   870   870
   899                       , Result , PatternCount                               893   871
   900                       ) 
   901                   END (* IF *)                                              873
   902                 END (* IF *)                                                901
   903               END (* IF *)                                                  902
   904             ELSE (* Not a special form of index *)                          896
   905               Result                                                        899
   906                 := mValue ( t ^ . Expr . Pos , TransformExpr ( t ) )        894   895   898   898   895     *
   907             END (* IF special form of index *)                              903
   908           ELSIF IsAllDontCares ( Exprs )                                    730   740   898
   909                 AND ( IsType ( Expr , Tree . DontCare1 )                    847   845   906   848   835
   910                       OR ( IsType ( Expr , Tree . VarUse )                    *   909   909   909   890
   911                            AND Expr ^ . VarUse . MustBeLabel                909   910   910     *
   912                          )  
   913                     ) 
   914           THEN (* Label and/or '_' to left of "( .. )" *)                   892
   915             Result := Expr (* Toss garbage *)                               905   911
   916           ELSE (* Not Index *)                                              904
   917             IF Expr ^ . Kind = Tree . VarUse                                891   915   847   910   911
   918             THEN                                                            914
   919               Object                                                        891
   920                 := IdentifyClass2                                           857
   921                      ( Expr ^ . VarUse . Name , TreeName )                  917   917   888   887
   922             ; IF Object = NoTree                                            917   919   891
   923               THEN                                                          918
   924                 Object := IdentifyProc ( Expr ^ . VarUse . Name )           922   236   921   921   921
   925               END                                                           907
   926             ; Expr ^ . VarUse . Object := Object                            924   924   924     *
   927             ELSIF ( Expr ^ . Kind = Tree . Binary )                         908   926   917   917   589
   928                   AND ( Expr ^ . Binary . Operator = IdentDot )             911   927   927   574   690
   929                   AND ( Expr ^ . Binary . Lop ^ . Kind                      928   928   928   583   927
   930                         = Tree . VarUse                                     927   926
   931                       ) 
   932                   AND ( Expr ^ . Binary . Rop ^ . Kind                      929   929   929   589   929
   933                         = Tree . VarUse                                     930   930
   934                       ) 
   935             THEN                                                            923
   936               Object                                                        926
   937                 := IdentifyTree                                             876
   938                      ( Expr ^ . Binary . Lop ^ . VarUse . Name )            932   932   929   933   924
   939             ; Expr ^ . Binary . Lop ^ . VarUse . Object := Object           938   938   938   938   936     *
   940             ; IF Object # NoTree                                            922   939   922
   941               THEN                                                          935
   942                 Object                                                      940
   943                   := IdentifyClass                                          886
   944                        ( Object ^ . TreeName . Classes                      942   921   887
   945                        , Expr ^ . Binary . Rop ^ . VarUse . Name            939   939   932   939   938
   946                        ) 
   947               END                                                           925
   948             ; Expr ^ . Binary . Rop ^ . VarUse . Object := Object           945   945   945   945   944     *
   949             ELSE (* Expr is not one of the forms consistent with Decompose.       916
c  950                     Treat as a target call. *) 
   951               Expr := TransformExpr ( Expr )                                948   906     *
   952             ; Object := NoTree                                              948   940
   953             END                                                             947
   954           ; IF Object # NoTree                                              940   952   952
   955             THEN                                                            941
   956               IF Object ^ . Kind = Class                                    954   954   932   622
   957               THEN                                                          955
   958                 ExpandDecompose                                             897
   959                   ( Pos , Selector , Expr , Exprs , Widen                   906   898   951   908   898
   960                   , Result , PatternCount                                   915   899
   961                   ) 
   962               ELSE (* Object denotes a puma-declared procedure *)           949
   963                 s := mCall                                                  763   150
   964                        ( Pos                                                959
   965                        , Expr                                               959
   966                        , TransformExpr ( Exprs )                            951   959
   967                        , mNoPattern ( Pos )                                 772   964
   968                        ) 
   969               ; s ^ . Call . Object := Object                               963     *   956     *
   970               ; Result := mValue ( Pos , s )                                960   906   967   969
   971               END                                                           953
   972             ELSE (* Object is unknown.  Treat as a target procedure call. *)      962
   973               s := mCall                                                    970   963
   974                      ( Pos                                                  970
   975                      , Expr                                                 965
   976                      , TransformExpr ( Exprs )                              966   966
   977                      , mNoExpr ( Pos )                                      159   974
   978 (* ^ This violates the graph grammar. Perhaps mNoPattern? *) 
   979                      ) 
   980             ; s ^ . Call . Object := Object                                 973   969   969     *
   981 (* What if there is a label on this call? *) 
   982             ; Result := mValue ( Pos , s )                                  970   970   977   980
   983             END (* IF *)                                                    971
   984           END (* IF *)                                                      983
   985         END (* WITH t^.Compose *)                                           984
   986 
   987     | Tree . VarUse                                                         933   948
   988       : WITH t ^ . VarUse                                                   840   906   987
   989         DO                                                                  841
   990           IF MustBeLabel                                                    956   911
   991           THEN (* It had ':' or ':>' after it. *)                           957
   992             Result := mVarDef ( Pos , Name )                                982   155   982   945
   993           ELSE                                                              972
   994             Object := IdentifyClass2 ( Name , TreeName )                    980   920   992   944
   995           ; IF ( ( Object # NoTree )                                        990   994   954
   996                  AND IsElement ( ORD ( 'p' ) , Options )                    932   143     *   161
   997                ) 
   998                 (* Allow (de)constructors w/o parentheses. *) 
   999             THEN (* It is a node name *)                                    991
  1000               t ^ . VarUse . Object := Object                               988   988   995     *
  1001 (*/* ^Aren't these identical? */*) 
  1002             ; Result                                                        992
  1003                 := mDecompose                                               634
  1004                      ( Pos                                                  992
  1005                      , NoIdent                                              854
  1006                      , t                                                   1000
  1007                      , mOnePattern                                          815
  1008                          ( mDontCareInternal ( Pos ) , mNoPattern ( Pos ) )       867  1004   967     *
  1009                      , FALSE                                                737
  1010                      ) 
  1011             ; Result ^ . Decompose . Object := Object                      1002   641  1000     *
  1012             ELSIF IsElement (Name, ExternNames)                             927   996   994   165
  1013                   OR IsElement (Name, LocExternNames)                       910  1012  1012   166
  1014                   OR IsElement (Name, UserNames)                           1013  1013  1013   169
  1015                   OR IsElement (Name, RoutineNames)                        1014  1014  1014   172
  1016             THEN (* Ident has a declared meaning *)                         999
  1017               Result := mValue ( Pos , TransformExpr ( t ) )               1011   982  1008   976  1006
  1018             ELSE (* Free identifier, no colon *)                            993
  1019               IF IsElement ( ORD ( 'u' ) , Options )                        995  1015   996   996
  1020                  (* ^Colon, etc. required on labels *)  
  1021               THEN                                                         1016
  1022                 ErrorI ( "Colon required on label" , Pos , Name )           137  1017  1015
  1023               ELSE (* Treat as a label declaration. *)                     1018
  1024 (* ; WarningI ( "undeclared, made label because no -u" , Pos , Name ) *)
  1025               END                                                           985
  1026             ; Result := mVarDef ( Pos , Name )                             1017   992  1022  1022
  1027             END                                                            1025
  1028           END (* IF *)                                                     1027
  1029         END (* WITH *)                                                     1028
  1030 
  1031     | Tree . Binary                                                         987   948
  1032       : WITH t ^ . Binary                                                   988  1017  1031
  1033         DO                                                                  989
  1034           IF IsElement ( ORD ( 'p' ) , Options )                           1019  1019  1019  1019
  1035              AND ( Operator = IdentDot )                                    996   928   928
  1036              AND ( Lop ^ . Kind = Tree . VarUse )                          1035   939   956  1031  1000
  1037              AND ( Rop ^ . Kind = Tree . VarUse )                          1036   948  1036  1036  1036
  1038           THEN (* Ident '.' Ident                                          1021
c 1039                   and (de)constructors w/o parentheses allowed. *)
  1040             LTreeName := IdentifyTree ( Lop ^ . VarUse . Name )             887   937  1036  1037  1026
  1041           ; IF LTreeName # NoTree                                          1034  1040   995
  1042             THEN                                                           1038
  1043               LClass                                                        763
  1044                 := IdentifyClass                                            943
  1045                      ( LTreeName ^ . TreeName . Classes                    1041   994   944
  1046                      , Rop ^ . VarUse . Name                               1037  1040  1040
  1047                      ) 
  1048             ; IF LClass # NoTree                                           1041  1043  1041
  1049               THEN                                                         1042
  1050                 Lop ^ . VarUse . Object := LTreeName                       1040  1046  1011  1045
  1051               ; Rop ^ . VarUse . Object := LClass                          1046  1050  1050  1048
  1052               ; Result                                                     1026
  1053                   := mDecompose                                            1003
  1054                        ( Pos                                               1026
  1055                        , (* Selector := *) NoIdent                         1005
  1056                        , t                                                 1032
  1057                        , mOnePattern                                       1007
  1058                            ( mDontCareInternal ( Pos ) , mNoPattern ( Pos ) )    1008  1054  1008     *
  1059                        , FALSE                                             1009
  1060                        ) 
  1061               ; Result ^ . Decompose . Object := LClass                    1052  1011  1051  1051
  1062               ELSE                                                         1023
  1063                 Result := mValue ( Pos , TransformExpr ( t ) )             1061  1017  1058  1017  1056
  1064               END                                                          1029
  1065             ELSE                                                           1062
  1066               Result := mValue ( Pos , TransformExpr ( t ) )               1063  1063  1063  1063  1063
  1067             END                                                            1064
  1068           ELSE                                                             1065
  1069             Result := mValue ( Pos , TransformExpr ( t ) )                 1066  1066  1066  1066  1066
  1070           END                                                              1067
  1071         END (* WITH *)                                                     1070
  1072 
  1073     | Tree . Index                                                         1037   853
  1074       : WITH t ^ . Index                                                   1032  1069  1073
  1075         DO                                                                 1033
  1076           IF IsElement ( ORD ( 'p' ) , Options )                           1048  1034  1034  1034
  1077              AND ( Expr ^ . Kind = Tree . VarUse )                         1037   975  1037  1073  1051
  1078              AND IsType ( Exprs , Tree . OneExpr )                         1077   910   976  1077   853
  1079              AND ( Exprs ^ . OneExpr . Expr ^ . Kind = Tree . VarUse )     1078  1078  1078  1077  1077  1078  1077
  1080           THEN (* [ <ident> ] [ '.' ] '[' <ident> ... ']'                  1049
c 1081                   and (de)constructors w/o parentheses allowed. *)
  1082             L1stVarUse := Exprs ^ . OneExpr . Expr                          890  1079  1079  1079
  1083           ; IF Expr ^ . VarUse . Name = NoIdent                            1076  1082  1079  1046  1055
  1084             THEN (* '[' <ident> ... ']' *)                                 1080
  1085               LClass                                                       1061
  1086                 := IdentifyClass2                                           994
  1087                      ( L1stVarUse ^ . VarUse . Name , LTreeName )          1082  1083  1083  1050
  1088             ; Expr ^ . VarUse . Object := LTreeName                        1083  1087  1061  1087
  1089             ; L1stVarUse ^ . VarUse . Object := LClass                     1087  1088  1088  1085
  1090             ; IF LClass = NoTree                                           1083  1089  1048
  1091               THEN                                                         1084
  1092                 Error                                                       863
  1093                   ( "node type not declared" 
  1094                   , L1stVarUse ^ . VarUse . Pos                            1089  1089  1069
  1095                   ) 
  1096               ; Result := mDontCareInternal ( L1stVarUse ^ . VarUse . Pos )      1069  1058  1094  1094  1094
  1097               ELSE                                                         1068
  1098                 ExpandDecompose                                             958
  1099                   ( Pos                                                    1096
  1100                   , NoIdent (* Selector, i.e. label *)                     1083
  1101                   , t                                                      1074
  1102                   , mOnePattern                                            1057
  1103                       ( mDontCareInternal ( Pos ) , mNoPattern ( Pos ) )   1096  1099  1058     *
  1104                   , FALSE                                                  1059
  1105                   , Result                                                 1096
  1106                   , PatternCount                                            960
  1107                   ) 
  1108               END (* IF *)                                                 1071
  1109             ELSE (* prefix identifier is present. *)                       1097
  1110               LTreeName := IdentifyTree ( Expr ^ . VarUse . Name )         1088  1040  1088  1096  1087
  1111             ; Expr ^ . VarUse . Object := LTreeName                        1110  1110  1089  1110
  1112             ; IF LTreeName = NoTree                                        1090  1111  1090
  1113               THEN (* Interpret as target code index *)                    1091
  1114                 Result := mValue                                           1105  1069
  1115                   ( t ^ . Expr . Pos , TransformExpr ( t ) )               1101  1111  1103  1069     *
  1116               ELSE                                                         1109
  1117                 LClass                                                     1090
  1118                   := IdentifyClass                                         1044
  1119                        ( LTreeName ^ . TreeName . Classes                  1112  1045  1045
  1120                        , L1stVarUse ^ . VarUse . Name                      1096  1111  1110
  1121                        ) 
  1122               ; L1stVarUse ^ . VarUse . Object := LClass                   1120  1120  1111  1117
  1123               ; IF LClass = NoTree                                         1112  1122  1112
  1124                 THEN (* Interpret as target index *)                       1113
  1125                   Result                                                   1114
  1126                     := mValue                                              1114
  1127                          ( t ^ . Expr . Pos , TransformExpr ( t ) )        1115  1115  1115  1115     *
  1128                 ELSE                                                       1116
  1129                   ExpandDecompose                                          1098
  1130                     ( Pos                                                  1127
  1131                     , NoIdent (* Selector, i.e. label *)                   1100
  1132                     , t                                                    1127
  1133                     , mOnePattern                                          1102
  1134                         ( mDontCareInternal ( Pos ) , mNoPattern ( Pos ) )       1103  1130  1103     *
  1135                     , FALSE                                                1104
  1136                     , Result                                               1125
  1137                     , PatternCount                                         1106
  1138                     ) 
  1139                 END (* IF *)                                               1108
  1140               END (* IF *)                                                 1139
  1141             END (* IF *)                                                   1140
  1142           ELSE                                                             1128
  1143             Result                                                         1136
  1144               := mValue ( t ^ . Expr . Pos , TransformExpr ( t ) )         1126  1132  1127  1134  1127     *
  1145           END (* IF *)                                                     1141
  1146         END (* WITH *)                                                     1145
  1147 
  1148     | Tree . Call , Tree . PreOperator , Tree . PostOperator               1079   980     *     *     *     *
  1149     , Tree . TargetExpr , Tree . StringExpr                                1148     *     *     *
  1150     , Tree . AttrDesc (* '::' in an expression *)                          1149     *
  1151       : Result := mValue ( t ^ . Expr . Pos , TransformExpr ( t ) )        1143  1144  1144  1144  1144  1144     *
  1152 
  1153     | Tree . NoPattern , Tree . OnePattern , Tree . OnePatternAlts         1150   470     *   476     *   501
  1154       : CantHappen ( "TransformPatternRecurse, already transformed." )      836
  1155       ; Result := t                                                        1151  1151
  1156 
  1157     END (* CASE *)                                                         1146
  1158   END TransformPatternRecurse ;                                            1157   812
  1159 
  1160 PROCEDURE TransformExpr (t: tTree): tTree;                                  760  1151  1155   764     *
  1161    VAR TreeName, s, LObject1, LObject2  : tTree;                            765  1119   982     *     *  1160
  1162    VAR LPatternCount : CARDINAL ;                                          1161     *   765
  1163    BEGIN                                                                    767
  1164       CASE t^.Kind OF                                                       769  1160  1079   771
  1165       | Tree.NoExpr     :                                                  1153   772
  1166 
  1167       | Tree.OneExpr    : WITH t^.OneExpr DO                               1165  1082  1074  1164     *  1075
  1168             Expr        := TransformExpr (Expr);                           1151  1160     *
  1169             Next        := TransformExpr (Next);                            812  1168     *
  1170          END;                                                              1158
  1171 
  1172       | Tree.NamedExpr  : WITH t^.NamedExpr DO                             1167   805  1167  1167     *  1167
  1173             Error                                                          1092
  1174               ("Keyword notation illegal in an expression"
  1175               , t^.NamedExpr.Expr^.Expr.Pos);                              1172  1172  1168     *  1151
  1176             RETURN mOneExpr (TransformExpr (Expr), TransformExpr (Next));   737   159  1169  1175     *  1169
  1177          END;                                                              1170
  1178 
  1179       | Tree.Compose    : WITH t^.Compose DO                               1172   840  1172  1175     *  1172
  1180             IF Expr^.Kind = Tree.VarUse THEN                               1123  1176  1164  1179  1122  1124
  1181                Object := IdentifyClass2 (Expr^.VarUse.Name, TreeName);     1122  1086  1180  1180  1120  1161
  1182                IF Object = NoTree                                          1180  1181  1123
  1183                THEN Object := IdentifyProc (Expr^.VarUse.Name); END;       1180  1182   924  1181  1181  1181  1177
  1184                Expr^.VarUse.Object := Object;                              1183  1183  1183     *
  1185             ELSIF (Expr^.Kind = Tree.Binary) AND                           1012  1184  1180  1180  1032  1079
  1186                   (Expr^.Binary.Lop^.Kind = Tree.VarUse) AND               1185  1185  1050  1185  1185  1184  1185
  1187                   (Expr^.Binary.Rop^.Kind = Tree.VarUse) THEN              1186  1186  1051  1186  1186  1186  1183
  1188 (* Can assert Operator is a dot? *) 
  1189                Object := IdentifyTree (Expr^.Binary.Lop^.VarUse.Name);     1184  1110  1187  1187  1186  1187  1183
  1190                (* Expr^.Binary.Lop^.VarUse.Object := Object; 
c 1191                   This seems reasonable, but breaks M2.puma`s generation of 
c 1192                   Tree.<NotAClass> M2.puma always expects a VarUse with a 
c 1193                   non-NIL Object field to have Object of kind Formal, with
c 1194                   a Path to call ImplMod on. *) 
  1195                IF Object # NoTree THEN                                     1182  1189  1182  1187
  1196                   Object := IdentifyClass (Object^.TreeName.Classes, Expr^.Binary.Ro\  1195  1118     *  1181  1119  1189
                                                                                  1189
      \p^.VarUse.Name);                                                           1187  1189  1189
  1197                END;                                                        1183
  1198                IF Object = NoTree                                          1195  1196  1195
  1199                THEN                                                        1195
  1200                  Expr^.Binary.Lop^.VarUse.Object := NoTree                 1196  1196  1189  1196  1198  1198
  1201                ; Expr^.Binary.Rop^.VarUse.Object := NoTree                 1200  1200  1196  1200  1200  1200
  1202                END (* IF *)                                                1197
  1203             ELSE                                                           1142
  1204                Object := NoTree;                                           1201  1201
  1205                Expr := TransformExpr (Expr);                               1201  1176     *
  1206             END;                                                           1202
  1207 
  1208             IF Object # NoTree THEN                                        1198  1204  1204  1199
  1209                IF Object^.Kind = Class THEN                                1208  1208  1187   956  1208
  1210                   Exprs := TransformKeyword (Exprs, Object^.Class.Formals);      1082   622     *  1209  1209   622
  1211                   Exprs := TransformExpr (Exprs);                          1210  1205     *
  1212                   RETURN t;                                                1176  1179
  1213                ELSE                                                        1203
  1214                   s := mCall (Pos, Expr, TransformExpr (Exprs), mNoPattern (Pos));     1161   973  1175  1205  1211  1211
                                                                                  1134     *
  1215                   s^.Call.Object := Object;                                1214  1148  1210     *
  1216                   RETURN s;                                                1212  1215
  1217                END;                                                        1206
  1218             ELSE                                                           1213
  1219                s := mCall (Pos, Expr, TransformExpr (Exprs), mNoExpr (Pos));     1216  1214  1214  1214  1214  1214   977
                                                                                     *
  1220 (* ^ mNoExpr violates the graph grammar. Perhaps mNoPattern? *) 
  1221                s^.Call.Object := Object;                                   1219  1215  1215     *
  1222                RETURN s;                                                   1216  1221
  1223             END;                                                           1217
  1224          END;                                                              1223
  1225 
  1226       | Tree.VarUse     : WITH t^.VarUse DO                                1187  1201  1179  1212     *  1179
  1227             Object := IdentifyClass2 (Name, TreeName);                     1221  1181  1196  1196
  1228             IF IsElement ( ORD ( 'p' ) , Options ) AND ( Object # NoTree )       1209  1076  1076  1076  1186  1227  1208
  1229             THEN (* The -p option is pretty drastic, because it means      1209
c 1230                     (globally declared) node constructor meanings _always_ 
c 1231                     supercede any local meanings.  The latter can never
c 1232                     be referred to! *) 
  1233                s := mCompose (Pos, NoIdent, t, mOneExpr (mDontCareInternal (Pos), mN\  1222   151  1219  1131  1226  1176
                                                                                  1134     *
      \oExpr (Pos)), FALSE);                                                      1219     *  1135
  1234                s^.Compose.Object := Object;                                1233  1179  1228     *
  1235                RETURN s;                                                   1222  1234
  1236             ELSE                                                           1218
  1237                Object := NoTree;                                           1234  1228
  1238                RETURN t;                                                   1235  1233
  1239             END;                                                           1224
  1240          END;                                                              1239
  1241 
  1242       | Tree.Nil        :                                                  1226   829
  1243       | Tree.DontCare1Explicit :                                           1242   832
  1244       | Tree.DontCare1Internal :                                           1243   832
  1245       | Tree.DontCareExplicit :                                            1244   831
  1246       | Tree.DontCareInternal :                                            1245   831
  1247 
  1248       | Tree.DontCare1, Tree.DontCare                                      1246   909     *   835
  1249         : CantHappen                                                       1154
  1250             ( 'TransformExpr, undistinguished DontCare' ) 
  1251 
  1252       | Tree.Call       : WITH t^.Call DO                                  1248  1221  1226  1238     *  1226
  1253             IF Expr^.Kind = Tree.VarUse THEN                               1228  1219  1209  1252  1226  1229
  1254                Object := IdentifyProc (Expr^.VarUse.Name);                 1237  1183  1253  1253  1227
  1255             ELSE                                                           1236
  1256                Object := NoTree;                                           1254  1237
  1257             END;                                                           1240
  1258             Expr  := TransformExpr (Expr);                                 1254  1219     *
  1259             Exprs := TransformExpr (Exprs);                                1219  1258     *
  1260             IF Object # NoTree THEN                                        1253  1256  1256  1253
  1261               TransformPattern ( Patterns , Patterns , LPatternCount )      758   708     *  1162
  1262               (* ^These are the actuals of out formals of a puma routine. 
c 1263                  Why don`t we do a TransformKeyword? *)
  1264             ; IF LPatternCount > 1                                         1260  1261
  1265               THEN                                                         1260
  1266                 Error                                                      1173
  1267                   ( 'pattern containing multi-valued types not allowed as actual to \
      \out formal' 
  1268                   , Pos                                                    1233
  1269                   ) 
  1270               END (* IF *)                                                 1257
  1271             ELSIF Patterns ^ . Kind = Tree . OneExpr                       1185  1261  1253  1253  1167
  1272                   (* Parser builds these as a list of expressions.
c 1273                      TransformPattern, if done at all, transforms
c 1274                      into a list of patterns. *) 
  1275             THEN                                                           1265
  1276                Error                                                       1266
  1277                  ( "Call on user procedure cannot have result patterns" 
  1278 (* ^Do we want to soften this? *)
  1279                  , Pos                                                     1268
  1280                  ) ;
  1281                Patterns := TransformExpr (Patterns);                       1271  1259     *
  1282             END;                                                           1270
  1283          END;                                                              1282
  1284 
  1285       | Tree.Binary :                                                      1271  1201
  1286          WITH t^.Binary                                                    1252  1252  1285
  1287          DO                                                                1252
  1288            IF ( Operator = IdentDot )                                      1264  1035  1035
  1289               AND ( Lop^.Kind = Tree.VarUse )                              1228  1200  1271  1285  1254
  1290               AND ( Rop^.Kind = Tree.VarUse )                              1289  1201  1289  1289  1289
  1291            THEN (* <Ident> '.' <Ident> *)                                  1275
  1292              IF IsElement (ORD ('p'), Options)                             1288  1228  1228  1228
  1293              THEN (* Try to make this a <TreeName> . <ClassName> => Compose *)   1291
  1294                LObject1 := IdentifyTree (Lop^.VarUse.Name);                1161  1189  1289  1290  1254
  1295                IF LObject1 # NoTree THEN                                   1292  1294  1260  1293
  1296                   LObject2                                                 1161
  1297                     := IdentifyClass (LObject1^.TreeName.Classes, Rop^.VarUse.Name);   1196  1295  1227  1196  1290  1294
                                                                                  1294
  1298                   IF LObject2 # NoTree THEN                                1295  1296  1295  1295
  1299                      s := mCompose (Pos, NoIdent, t, mOneExpr (mDontCareInternal (Po\  1235  1233  1279  1233  1286  1233
                                                                                  1233
      \s), mNoExpr (Pos)), FALSE);                                                   *  1233     *  1233
  1300                      s^.Compose.Object := LObject2;                        1299  1234  1260  1298
  1301                      Lop^.VarUse.Object := LObject1;                       1294  1297  1300  1297
  1302                      Rop^.VarUse.Object := LObject2;                       1297  1301  1301  1300
  1303                      RETURN s;                                             1238  1300
  1304                   END;                                                     1283
  1305                END;                                                        1304
  1306              END (* IF *)                                                  1305
  1307            ELSE (* Ordinary binary operator *)                             1255
  1308              Lop         := TransformExpr (Lop);                           1301  1281     *
  1309              Rop         := TransformExpr (Rop);                           1302  1308     *
  1310            END (* IF *) ;                                                  1306
  1311          END (* WITH *)                                                    1310
  1312 
  1313       | Tree . BinaryCompound                                              1290     *
  1314         : WITH t ^ . BinaryCompound                                        1286  1299  1313
  1315           DO                                                               1287
  1316             Lop         := TransformExpr (Lop)                             1308  1309     *
  1317           ; Rop         := TransformExpr (Rop)                             1309  1316     *
  1318           END (* WITH t ^ . BinaryCompound *) ;                            1311
  1319 
  1320       | Tree.PreOperator, Tree.PostOperator     : WITH t^.PreOperator DO   1313  1148     *  1148  1314  1314     *  1315
  1321             Expr        := TransformExpr (Expr);                           1258  1317     *
  1322          END;                                                              1318
  1323 
  1324       | Tree.Index      : WITH t^.Index DO                                 1320  1074  1320  1320     *  1320
  1325             Expr        := TransformExpr (Expr);                           1321  1321     *
  1326             Exprs       := TransformExpr (Exprs);                          1259  1325     *
  1327          END;                                                              1322
  1328 
  1329       | Tree.Parents    : WITH t^.Parents DO                               1324   778  1324  1324     *  1324
  1330             Expr        := TransformExpr (Expr);                           1325  1326     *
  1331          END;                                                              1327
  1332 
  1333       | Tree.TargetExpr :                                                  1329  1149
  1334       | Tree.StringExpr :                                                  1333  1149
  1335       | Tree.AttrDesc   : (* '::' in an expression *)                      1334  1150
  1336       END;                                                                 1331
  1337       RETURN t;                                                            1303  1329
  1338    END TransformExpr;                                                      1336  1330
  1339 
  1340 PROCEDURE TransformStmt (t: tTree): tTree;                                 1160     *  1337  1161     *
  1341    BEGIN                                                                   1163
  1342       CASE t^.Kind OF                                                      1164  1340  1290  1164
  1343       | Tree.NoStatement: RETURN t;                                        1335     *  1337  1342
  1344 
  1345       | Tree.ProcCall                                                      1343     *
  1346          (* In statement context, parser puts ProcCall on top 
c 1347             of expression. *) 
  1348       :  WITH t^.ProcCall DO                                               1329  1343  1345  1329
  1349             Call := TransformExpr (Call);                                  1252  1338     *
  1350             IF Call^.Kind = Tree.Call THEN                                 1298  1349  1342  1345     *  1298
  1351                WITH Call^.Call DO                                          1348  1350     *  1348
  1352                   IF (Object # NoTree) AND                                 1350  1302  1298  1290
  1353                      ( (Object^.Kind = Tree.Predicate)                     1352  1350  1350     *
  1354                        OR (Object^.Kind = Tree.Function)                   1015  1353  1353  1353     *
  1355                      ) 
  1356                   THEN (* ProcCall on most things turns into a condition. *)     1350
  1357                      t^.Kind := Tree.Condition;                            1348  1354  1354     *
  1358 (* Boy, is this sleazy!  It relys on ProcCall and Condition having
c 1359    the same field layout! *) 
  1360                   END;                                                     1338
  1361                END;                                                        1360
  1362             ELSIF Call^.Kind = Tree.Compose THEN                           1271  1351  1357  1357  1300  1356
  1363               Error ("Node constructor as a statement", Pos);              1276  1299
  1364             ELSIF Call^.Kind = Tree.StringExpr THEN                        1362  1362  1362  1362  1334  1362
  1365                t := mWriteStr (Pos, Next, Call^.StringExpr.String);        1357   160  1363  1176  1364  1364   198
  1366             ELSE                                                           1307
  1367                t^.Kind := Tree.Condition;                                  1365  1364  1364  1357
  1368             END;                                                           1361
  1369          END;                                                              1368
  1370 
  1371       | Tree.Assignment : WITH t^.Assignment DO                            1367     *  1351  1367     *  1351
  1372             Adr  := TransformExpr (Adr );                                     *  1349     *
  1373             Expr := TransformExpr (Expr);                                  1330  1372     *
  1374          END;                                                              1369
  1375 
  1376       | Tree.Reject     :                                                  1371     *
  1377       | Tree.Fail       :                                                  1376     *
  1378       | Tree.TargetStmt :                                                  1377     *
  1379       | Tree.Nl         :                                                  1378     *
  1380       | Tree.WriteStr   :                                                  1379     *
  1381       END;                                                                 1374
  1382       t^.Statement.Next := TransformStmt (t^.Statement.Next);              1371     *  1365  1340     *     *     *
  1383       RETURN t;                                                            1343  1382
  1384    END TransformStmt;                                                      1381  1382
  1385 
  1386 (* TransformKeyword rewrites keword associations. *)
  1387 PROCEDURE TransformKeyword (t, Formals: tTree): tTree;                     1340  1210  1383  1210  1340     *
  1388    VAR                                                                     1162
  1389       Exprs             : tTree;                                           1326  1387
  1390       Last              : POINTER TO tTree;                                   *     *     *  1389
  1391       n, i              ,                                                     *   284
  1392       Minimum, Maximum  : INTEGER;                                          293   145   420
  1393       PatternsSize      : LONGINT;                                            *     *
  1394       PatternsPtr       : POINTER TO ARRAY [0..50000] OF tTree;               *  1390  1390   339  1342  1390
  1395 
  1396    BEGIN                                                                   1341
  1397       Exprs := t;                                                          1389  1387
  1398       WHILE Exprs^.Kind = Tree.OneExpr DO Exprs := Exprs^.OneExpr.Next; END;      444  1397  1367  1380  1271  1371     *
                                                                                     *     *  1382  1384
  1399       IF Exprs^.Kind = Tree.NoExpr THEN RETURN t; END;                     1352  1398  1398  1398  1165  1364  1383  1397
                                                                                  1398
  1400       n := 0;                                                              1391
  1401       Exprs := Formals;                                                    1399  1387
  1402       WHILE IsType ( Exprs , Tree . Formal )                               1398  1078  1401  1399   319
  1403       DO INC (n); Exprs := Exprs^.Formal.Next;                             1398   679  1400  1402     *  1402  1398
  1404       END;                                                                 1399
  1405       PatternsSize := n + 1;                                               1393  1403
  1406       MakeArray (PatternsPtr, PatternsSize, TSIZE (tTree));                 133  1394  1405   130  1394
  1407       FOR i := 1 TO n DO PatternsPtr^[i] := NoTree; END;                      *  1391  1394  1405  1403  1406     *  1352
                                                                                  1404
  1408       Last := ADR (t);                                                     1390   130  1399
  1409       Exprs := t;                                                          1403  1408
  1410       i := 0;                                                              1407
  1411       WHILE Exprs^.Kind = Tree.OneExpr DO                                  1402  1409  1399  1402  1398  1407
  1412          INC (i);                                                          1403  1410
  1413          PatternsPtr^[i] := Exprs^.OneExpr.Expr;                           1407  1412  1411  1411  1373
  1414          Last := ADR (Exprs^.OneExpr.Next);                                1408  1408  1413  1413  1403
  1415          Exprs := Exprs^.OneExpr.Next;                                     1414     *  1414  1414
  1416       END;                                                                 1407
  1417       Minimum := i + 1;                                                    1392  1413
  1418       Maximum := i;                                                        1392  1417
  1419       WHILE Exprs^.Kind = Tree.NamedExpr DO                                1411  1415  1411  1411  1175  1411
  1420          i := LookupFormal (Exprs^.NamedExpr.Name, Formals);               1418   214  1419  1419  1297  1401
  1421          IF i = 0 THEN                                                     1399  1420  1399
  1422             ErrorI                                                         1022
  1423               ( "No such formal/child name" 
  1424               , Exprs ^ . NamedExpr . NamePos                              1420  1420     *
  1425               , Exprs ^ . NamedExpr . Name                                 1424  1424  1420
  1426               ) ;
  1427 (* Add a Pos field to NamedExpr, set it in parser, and use it here. *)
  1428          ELSIF PatternsPtr^[i] # NoTree THEN                               1364  1413  1421  1407  1421
  1429             ErrorI                                                         1422
  1430               ( "this formal/child was previously supplied"
  1431               , Exprs ^ . NamedExpr  . NamePos                             1425  1425  1424
  1432               , Exprs ^ . NamedExpr  . Name                                1431  1431  1425
  1433               ) ;
  1434          ELSE                                                              1366
  1435             PatternsPtr^[i] := Exprs^.NamedExpr.Expr;                      1428  1428  1432  1432  1413
  1436          END;                                                              1416
  1437          Maximum := Max (Maximum, i);                                      1418   131     *  1435
  1438          Exprs := Exprs^.NamedExpr.Next;                                   1435     *  1435  1415
  1439       END;                                                                 1436
  1440       Exprs := mOneExpr (mDontCareInternal (NoPosition), mNoExpr (NoPosition));  1438  1299  1299   138  1299     *
  1441       FOR i := Maximum TO Minimum BY -1 DO                                 1407  1437  1437  1407  1417     *  1419
  1442          IF PatternsPtr^[i] = NoTree THEN                                  1421  1435  1441  1428  1428
  1443             Exprs := mOneExpr (mDontCare1Internal (NoPosition), Exprs);    1440  1440   152  1440     *
  1444          ELSE                                                              1434
  1445             Exprs := mOneExpr (PatternsPtr^[i], Exprs);                    1443  1443  1442  1442     *
  1446          END;                                                              1439
  1447       END;                                                                 1446
  1448       Last^ := Exprs;                                                      1414  1445
  1449       ReleaseArray (PatternsPtr, PatternsSize, TSIZE (tTree));              133  1445  1406  1406  1406
  1450       RETURN t;                                                            1399  1409
  1451    END TransformKeyword;                                                   1447  1387
  1452 
  1453 PROCEDURE CheckExprList (t, Formals: tTree);                               1387     *  1450  1420  1449
  1454    BEGIN                                                                   1396
  1455       IF (t^.Kind = Tree.NoExpr)                                           1442  1453  1419  1419  1399
  1456          AND NOT IsType ( Formals , Tree . Formal )                        1352   348  1402  1453  1455  1403
  1457       THEN RETURN;                                                         1442  1450
  1458       END;                                                                 1451
  1459       IF t^.Kind = Tree.NoExpr THEN                                        1455  1455  1455  1456  1455  1457
  1460          Error ("too few expressions or arguments", t^.NoExpr.Pos); RETURN;      1363  1459  1459  1365  1457
  1461       END;                                                                 1458
  1462       WITH t^.OneExpr DO                                                   1371  1460  1415  1441
  1463          IF Tree . IsType ( Expr , Tree.DontCare ) THEN RETURN; END;       1459  1459  1456  1435     *  1248  1459  1460
                                                                                  1461
  1464          IF Formals^.Kind = Tree.NoFormal THEN                             1463  1456  1459  1463   240  1463
  1465             Error ("too many expressions or arguments", Expr^.Expr.Pos); RETURN;       1460  1463     *  1460  1463
  1466          END;                                                              1463
  1467          CheckExpr (Expr, Formals);                                           *  1465  1464
  1468          CheckExprList (Next, Formals^.Formal.Next);                       1453  1438  1467  1456     *
  1469       END;                                                                 1466
  1470    END CheckExprList;                                                      1469  1468
  1471 
  1472 PROCEDURE CheckInParams (t, Formals: tTree);                               1453     *  1462  1468  1453
  1473    BEGIN                                                                   1454
  1474       IF (t^.Kind = Tree.NoExpr)                                           1464  1472  1464  1464  1460
  1475          OR NOT IsType ( Formals , Tree . Formal )                         1354  1456  1463  1472  1474  1468
  1476       THEN RETURN;                                                         1464  1465
  1477       END;                                                                 1470
  1478       WITH t^.OneExpr DO                                                   1462  1474  1462  1462
  1479          IF Tree . IsType ( Expr , Tree.DontCare ) THEN RETURN; END;       1474  1475  1475  1467     *  1463  1476  1476
                                                                                  1477
  1480          IF Formals^.Formal.Path^.Var.IsOutput AND (Expr^.Kind = Tree.VarUse) AND      1479  1475  1475     *   181   195
                                                                                  1456  1479  1474  1479  1302     *
  1481             (Expr^.VarUse.Object # NoTree) AND (Expr^.VarUse.Object^.Formal.Path^.Ki\  1480  1480  1354  1442  1480     *
                                                                                     *     *  1480  1480
      \nd = Tree.Var) AND                                                         1480  1480  1480     *
  1482             NOT Expr^.VarUse.Object^.Formal.Path^.Var.IsOutput THEN        1475  1481  1481  1481  1481  1481  1481  1480
                                                                                  1479
  1483             Expr^.VarUse.Object^.Formal.Path^.Var.IsRegister := FALSE;     1482  1482  1482  1482  1482  1482     *  1299
  1484          END;                                                              1479
  1485          CheckInParams (Next, Formals^.Formal.Next);                       1472  1468  1480  1483     *
  1486       END;                                                                 1484
  1487    END CheckInParams;                                                      1486  1485
  1488 
  1489 PROCEDURE CheckCallExprs (t, Formals: tTree);                              1472     *  1478  1485  1472
  1490    BEGIN                                                                   1473
  1491       IF (t^.Kind = Tree.NoExpr)                                           1480  1489  1481  1481  1474
  1492          AND NOT IsType ( Formals , Tree . Formal )                        1481  1482  1479  1489  1491  1485
  1493       THEN RETURN;                                                         1482  1479
  1494       END;                                                                 1487
  1495       IF t^.Kind = Tree.NoExpr THEN                                        1491  1491  1491  1492  1491  1493
  1496          Error ("too few actual parameters", t^.NoExpr.Pos); RETURN;       1465  1495  1495  1465  1493
  1497       END;                                                                 1494
  1498       WITH t^.OneExpr DO                                                   1478  1496  1478  1478
  1499          IF Tree . IsType ( Expr , Tree.DontCare ) THEN                    1495  1495  1492  1483     *  1479  1495
  1500             Expr^.DontCare.Tempos := MakeTempos (Formals);                 1499  1499     *     *  1492
  1501             RETURN;                                                        1496
  1502          END;                                                              1497
  1503          IF Formals^.Kind = Tree.NoFormal THEN                             1499  1500  1495  1499  1464  1499
  1504             Error ("too many actual parameters", Expr^.Expr.Pos); RETURN;  1496  1500     *  1496  1501
  1505          END;                                                              1502
  1506          CheckExprVar (Expr, Formals);                                        *  1504  1503
  1507          CheckCallExprs (Next, Formals^.Formal.Next);                      1489  1485  1506  1492     *
  1508       END;                                                                 1505
  1509    END CheckCallExprs;                                                     1508  1507
  1510 
  1511 PROCEDURE CheckExprVar ( VAR t : tTree ;  Formals : tTree);                1489  1506  1388  1498  1489  1507     *
  1512 (* t is VAR, so CheckExprVar can transform tree. *) 
  1513    BEGIN                                                                   1490
  1514       IF t^.Kind = Tree.Compose THEN                                       1503  1511  1503  1503  1362  1503
  1515          t^.Compose.Tempo := MakeTempoIdent ();                            1514  1514     *     *
  1516          IF IsType ( Formals , Tree . Formal )                             1514  1499  1511  1514  1507
  1517          THEN                                                              1514
  1518             t^.Compose.TypeDesc := Formals^.Formal.TypeDesc;               1515  1515   448  1516  1516     *
  1519          ELSE                                                              1444
  1520             t^.Compose.TypeDesc := t^.Compose.Object^.Class.TypeDesc;      1518  1518  1518     *     *  1483  1210     *
  1521          END;                                                              1509
  1522       ELSIF Tree . IsType ( t , Tree.DontCare1 ) THEN                      1428  1516  1516  1520     *  1248  1517
  1523          t^.DontCare1.Tempo := MakeTempoIdent ();                          1522  1522  1515  1515
  1524          IF IsType ( Formals , Tree . Formal )                             1516  1522  1518  1522  1518
  1525          THEN                                                              1522
  1526             t^.DontCare1.TypeDesc := Formals^.Formal.TypeDesc;             1523  1523  1520  1524  1524     *
  1527          ELSE                                                              1519
  1528            Error ( "Dont care in illegal context" , t ^ . DontCare1 . Pos )      1504  1526  1526  1504
  1529          END;                                                              1521
  1530       END;                                                                 1529
  1531       CheckExpr (t, Formals);                                              1467  1528  1526
  1532    END CheckExprVar;                                                       1530  1511
  1533 
  1534 PROCEDURE CheckExpr (VAR t : tTree ;  Formals : tTree ) ;                  1511  1531  1511  1531  1511  1531     *
  1535 (* t is VAR, so CheckExpr can transform tree. *) 
  1536 
  1537    VAR LAttrFormal : tTree ;                                               1534     *  1534
  1538    VAR LObject : tTree ;                                                   1537     *  1537
  1539    VAR LResult : tTree ;                                                   1538   710  1538
  1540   
  1541    BEGIN                                                                   1513
  1542       CASE t^.Kind OF                                                      1342  1534  1514  1394
  1543 
  1544       | Tree.Compose: WITH t^.Compose DO                                   1524  1520  1498  1542     *  1498
  1545             IF Selector # NoIdent THEN                                     1524   959  1299  1525
  1546                Warning ("label ignored on compose in expression", Pos);     384  1528
  1547             END;                                                           1532
  1548             IF IsType ( Formals , Tree . Formal )                          1545  1524  1534  1544  1526
  1549             THEN                                                           1545
  1550                CheckSubtype                                                 361
  1551                  (Formals^.Formal.TypeDesc, Object^.Class.TypeDesc, Pos,   1548  1548  1526  1520  1520     *  1546
  1552                   'Composed node not in formal/child type, specifically:');
  1553             END;                                                           1547
  1554             IF Object = NoTree THEN                                        1548  1551  1481  1549
  1555                CheckExpr (Expr, dFormals);                                 1534  1506   173
  1556             ELSE                                                           1527
  1557                CheckExpr2 (Expr);                                             *  1555
  1558             END;                                                           1553
  1559             CheckExprList (Exprs, Object^.Class.Formals);                  1470  1448  1554  1551  1551
  1560          END;                                                              1558
  1561 
  1562       | Tree.VarUse: WITH t^.VarUse DO                                     1548  1483  1544  1544     *  1544
  1563             IF IsElement (Name, LabelNames) THEN                           1554  1292  1432   170  1554
  1564                Object := IdentifyVar (Decls, Name);                        1559   245   175  1563
  1565                IF (Object # NoTree)                                        1563  1564  1554
  1566                   AND IsType ( Formals , Tree . Formal )                   1492  1548  1559  1562  1551
  1567                THEN                                                        1563
  1568                   CheckSubtype                                             1550
  1569                     (Formals^.Formal.TypeDesc, Object^.Formal.TypeDesc, Pos,     1566  1566  1551  1565     *     *  1551
  1570                      'Type of label reference not in formal/child type, specifically\
      \:');
  1571                END;                                                        1560
  1572             ELSIF NOT IsElement (Name, ExternNames)                        1522  1492  1563  1564  1012
  1573                   AND NOT IsElement (Name, LocExternNames)                 1566  1572  1572  1572  1013
  1574                   AND NOT IsElement (Name, UserNames)                      1573  1573  1573  1573  1014
  1575                   AND NOT IsElement (Name, RoutineNames)                   1574  1574  1574  1574  1015
  1576             THEN                                                           1567
  1577                IF IsElement (ORD ('e'), Options) THEN                      1565  1575  1292  1292  1576
  1578                   ErrorI ("identifier in expression not declared", Pos, Name);   1429  1569  1575
  1579                ELSIF IsElement (ORD ('v'), Options) AND NOT IsElement (ORD ('s'), Op\  1572  1577  1577  1577  1575  1575
                                                                                     *     *
      \tions) THEN                                                                   *  1577
  1580                   WarningI ("identifier in expression not declared", Pos, Name);        137  1578  1578
  1581                END;                                                        1571
  1582                Include (LabelNames, Name);                                  335  1563  1580
  1583                 (* ^This will suppress further messages on this identifier
c 1584                    within this rule, but at the beginning of a new rule,
c 1585                    we will start over. *) 
  1586             END;                                                           1581
  1587          END;                                                              1586
  1588 
  1589       | Tree.Nil: WITH t^.Nil DO                                           1566  1242  1562  1562     *  1562
  1590             IF Selector # NoIdent THEN                                     1577  1545  1545  1579
  1591                Warning ("label ignored on NIL in expr", Pos);              1546  1580
  1592             END;                                                           1587
  1593          END;                                                              1592
  1594 
  1595       | Tree.Call: WITH t^.Call DO                                         1589  1365  1589  1589     *  1589
  1596             IF Object = NoTree THEN                                        1590  1569  1565  1590
  1597                CheckExpr (Expr, dFormals);                                 1555  1557  1555
  1598                IF Expr^.Kind = Tree.VarUse THEN                            1596  1597  1542  1595  1562  1596
  1599                   ProcName := Expr^.VarUse.Name;                            187  1598  1598  1582
  1600                ELSIF (Expr^.Kind = Tree.Binary) AND                        1579  1599  1598  1598  1286  1579
  1601                      (Expr^.Binary.Lop^.Kind = Tree.VarUse) THEN           1600  1600  1316  1600  1600  1599  1598
  1602 (* Can assert Expr ^ . Binary . Operator = Identdot ? *) 
  1603                   ProcName := Expr^.Binary.Lop^.VarUse.Name;               1599  1601  1601  1601  1601  1599
  1604                ELSE                                                        1556
  1605                   ProcName := NoIdent;                                     1603  1590
  1606                END;                                                        1593
  1607 
  1608                IF NOT IsElement (ProcName, ExternNames) AND                1598  1579  1579  1605  1572  1600
  1609                   NOT IsElement (ProcName, LocExternNames) AND             1608  1608  1608  1573  1608
  1610                   NOT IsElement (ProcName, UserNames)                      1609  1609  1609  1574
  1611                THEN                                                        1601
  1612                   IF IsElement (ORD ('e'), Options) THEN                   1608  1610  1579  1579  1611
  1613                      ErrorI ("subroutine identifier not declared", Pos, ProcName);     1578  1591  1610
  1614                   ELSIF IsElement (ORD ('v'), Options) AND NOT IsElement (ORD ('s'),\  1600  1612  1612  1612  1609  1610
                                                                                     *     *
      \ Options)                                                                     *
  1615                   THEN                                                     1612
  1616                      WarningI ("subroutine identifier not declared", Pos, ProcName);   1580  1613  1613
  1617                   END;                                                     1606
  1618                   Include (UserNames, ProcName);                           1582  1610  1616
  1619                END;                                                        1617
  1620                CheckCallExprs (Exprs, dFormals);                           1509  1559  1597
  1621                CheckCallExprs (Patterns, dFormals);                        1620  1281  1620
  1622             ELSIF IsType (Object, Tree.Routine) THEN                       1614  1566  1596  1601   233  1615
  1623                CheckExpr2 (Expr);                                          1557  1603
  1624                IF (Object^.Kind = Tree.Function)                           1612  1622  1601  1622  1354
  1625                AND IsType ( Formals , Tree . Formal )                      1614  1622  1569  1624  1569
  1626                THEN                                                        1622
  1627                   CheckSubtype                                             1568
  1628                     (Formals^.Formal.TypeDesc,                             1625  1625  1569
  1629                      Object^.Function.ReturnForm^.Formal.TypeDesc, Pos     1624  1624     *  1628  1628  1616
  1630                      , 'Result type of puma function not in formal/child type, speci\
      \fically:');
  1631                END;                                                        1619
  1632                CheckCallExprs (Exprs, Object^.Routine.InForm);             1621  1620  1629  1622     *
  1633                CheckCallPatterns (Patterns, Object^.Routine.OutForm);         *  1621  1632  1632     *
  1634 (* ^We want this to happen for puma routines which are externally declared *) 
  1635                CheckInParams (Exprs, Object^.Routine.InForm);              1487  1632  1633  1633  1632
  1636             ELSE                                                           1604
  1637                Error ("subroutine identifier required", Pos);              1528  1629
  1638             END;                                                           1631
  1639          END;                                                              1638
  1640 
  1641       | Tree . Binary :                                                    1625  1603
  1642          WITH t ^ . Binary                                                 1595  1595  1641
  1643          DO                                                                1595
  1644            IF ( Operator = IdentDot )                                      1624  1288  1288
  1645               AND ( Lop ^ . Kind = Tree . VarUse )                         1625  1603  1624  1641  1603
  1646               AND ( Rop ^ . Kind = Tree . VarUse )                         1645  1317  1645  1645  1645
  1647               AND IsElement ( Lop ^ . VarUse . Name , LabelNames)          1646  1614  1645  1646  1603  1582
  1648            THEN (* <Ident> '.' <Ident> , and LHS is declared to puma *)    1626
  1649              LObject := IdentifyVar ( Decls , Lop ^ . VarUse . Name ) ;    1538  1564  1564  1647  1647  1647
  1650              IF ( LObject # NIL )                                          1644  1649   395
  1651                 AND ( LObject ^ . Formal . TypeDesc ^ . Kind               1647  1650  1629  1629  1646
  1652                       = Tree . NodeTypes                                   1646   449
  1653                     )
  1654              THEN                                                          1648
  1655                 ActClass                                                    184
  1656                   := ClassOfNodeTypes ( LObject ^ . Formal . TypeDesc ) ;         319  1651  1651  1651
  1657                 LAttrFormal                                                1537
  1658                   := IdentifyVar                                           1649
  1659                        ( ActClass ^ . Class . Formals , Rop ^ . VarUse . Name ) ;      1655  1559  1628  1646  1649  1649
  1660                 IF LAttrFormal # NoTree                                    1650  1657  1596
  1661                 THEN (* <KnownLableOfTreeType> '.' <ValidField>. Transform it to "::\  1654
c     \" *) 
  1662                   LResult                                                  1539
  1663                     := mAttrDesc                                            157
  1664                          ( Pos                                             1637
  1665                          , Lop ^ . VarUse . Name                           1649  1659  1659
  1666                          , (* MustBeLabel := *) FALSE (* Irrelevant *)     1483
  1667                          , Rop ^ . VarUse . Name                           1659  1665  1665
  1668                          , Rop ^ . VarUse . Pos                            1667  1667  1664
  1669                          ) ; 
  1670                   LResult ^ . AttrDesc . Object := LObject ;               1662  1335  1635  1656
  1671                   LResult ^ . AttrDesc . Type :=  ActClass ^ . Class . Name ;    1670  1670   383  1659  1659  1667
  1672                   t := LResult (* Transform tree *)                        1642  1671
  1673                 ELSE (* RHS is not a child of LHS *)                       1636
  1674                    CheckExprVar (Lop, dFormals);                           1532  1665  1621
  1675                    CheckExprVar (Rop, dFormals);                           1674  1668  1674
  1676                 END (* IF *) ;                                             1639
  1677              ELSE (* LHS does not have a tree type *)                      1673
  1678                 CheckExprVar (Lop, dFormals);                              1675  1674  1675
  1679                 CheckExprVar (Rop, dFormals);                              1678  1675  1678
  1680              END;                                                          1676
  1681            ELSE (* Ordinary binary operator *)                             1677
  1682              CheckExprVar (Lop, dFormals);                                 1679  1678  1679
  1683              CheckExprVar (Rop, dFormals);                                 1682  1679  1682
  1684            END (* IF *)                                                    1680
  1685          END (* WITH *) ;                                                  1684
  1686 
  1687       | Tree . BinaryCompound                                              1652  1314
  1688         : WITH t ^ . BinaryCompound                                        1642  1672  1687
  1689           DO                                                               1643
  1690             CheckExprVar (Lop, dFormals)                                   1683  1682  1683
  1691           ; CheckExprVar (Rop, dFormals)                                   1690  1683  1690
  1692           END (* WITH t ^ . BinaryCompound *) ;                            1685
  1693 
  1694       | Tree.PreOperator, Tree.PostOperator: WITH t^.PreOperator DO        1687  1320     *  1320  1688  1688     *  1689
  1695             CheckExprVar (Expr, dFormals);                                 1691  1623  1691
  1696            (*/* This used to be ^ Formals, but I can't imagine why. */*)
  1697          END;                                                              1692
  1698 
  1699       | Tree.Index: WITH t^.Index DO                                       1694  1324  1694  1694     *  1694
  1700             CheckExprVar (Expr, dFormals);                                 1695  1695  1695
  1701             CheckExprList (Exprs, dFormals);                               1559  1635  1700
  1702          END;                                                              1697
  1703 
  1704       | Tree.Parents: WITH t^.Parents DO                                   1699  1329  1699  1699     *  1699
  1705             CheckExprVar (Expr, Formals);                                  1700  1700  1659
  1706          END;                                                              1702
  1707 
  1708       | Tree.AttrDesc: (* '::' in an expression *)                         1704  1671
  1709         (* Except for going on to Next, Designator in Check is handled the same. *) 
  1710          WITH t^.AttrDesc DO                                               1704  1704  1708  1704
  1711             IF IsElement (Name (* LHS *) , LabelNames) THEN                1660  1647  1671  1647  1661
  1712                Object := IdentifyVar (Decls, Name);                        1670  1658  1649  1711
  1713                IF ( Object # NIL )                                         1711  1712  1650
  1714                   AND ( Object^.Formal.TypeDesc^.Kind = Tree.NodeTypes )   1651  1713  1656  1656  1651  1708  1652
  1715                THEN                                                        1711
  1716                   ActClass                                                 1671
  1717                     := ClassOfNodeTypes ( Object ^ . Formal . TypeDesc ) ;       1656  1714  1714  1714
  1718                   Type := ActClass^.Class.Name;                            1671  1716  1671  1712
  1719                   LAttrFormal                                              1660
  1720                     := IdentifyVar ( ActClass^.Class.Formals , Attribute ) ;     1712  1718  1718  1705     *
  1721                   IF LAttrFormal = NoTree                                  1713  1719  1660
  1722                   THEN                                                     1715
  1723                     ErrorI                                                 1613
  1724                       ( "No such child/attribute" 
  1725                       , AttributePos                                          *
  1726                       , Attribute                                          1720
  1727                       ) ; 
  1728                   ELSE                                                     1681
  1729                     CheckSubtype                                           1627
  1730                       ( Formals ^ . Formal . TypeDesc                      1720  1717  1717
  1731                       , LAttrFormal ^ . Formal . TypeDesc                  1721  1730  1730
  1732                       , AttributePos                                       1725
  1733                       , 'Type of node field not in formal/child type, specifically:'
  1734                       ) ;
  1735                   END (* IF *) ;                                           1706
  1736                ELSE                                                        1728
  1737                   ErrorI ( "tree-type required" , Pos , Name );            1723  1668  1718
  1738                END;                                                        1735
  1739             ELSE                                                           1736
  1740                ErrorI ( "Identifier not declared" , Pos , Name );          1737  1737  1737
  1741             END;                                                           1738
  1742          END (* WITH *) ;                                                  1741
  1743 
  1744       ELSE                                                                 1739
  1745       END (* CASE *) ;                                                     1742
  1746    END CheckExpr;                                                          1745  1597
  1747 
  1748 PROCEDURE CheckExpr2  ( VAR t : tTree ) ;                                  1534  1623  1539  1710  1539
  1749 (* t is VAR, so CheckExpr2 can transform tree. *) 
  1750 (* This is used for field Expr of Compose, Decompose, Call.
c 1751    In case of Binary, we need to do rhs lookup differently,
c 1752    could get generation bugs this way. *) 
  1753    BEGIN                                                                   1541
  1754       CASE t^.Kind OF                                                      1542  1748  1714  1542
  1755 
  1756       | Tree.VarUse: WITH t^.VarUse DO                                     1714  1668  1710  1754     *  1710
  1757             Object := IdentifyVar (Decls, Name);                           1717  1720  1712  1740
  1758          END;                                                              1746
  1759 
  1760       | Tree.Binary: WITH t^.Binary DO                                     1756  1642  1756  1756     *  1756
  1761             CheckExpr2 (Lop);                                              1748  1690
  1762             CheckExpr2 (Rop);                                              1761  1691
  1763          END;                                                              1758
  1764 
  1765       | Tree . BinaryCompound                                              1760  1688
  1766         : WITH t ^ . BinaryCompound                                        1760  1760  1765
  1767           DO                                                               1760
  1768             CheckExpr2 (Lop)                                               1762  1761
  1769           ; CheckExpr2 (Rop)                                               1768  1762
  1770           END (* WITH t ^ . BinaryCompound *) ;                            1763
  1771 
  1772       | Tree.Compose:                                                      1765  1544
  1773             CheckExpr (t, dFormals);                                       1746  1766  1701
  1774       END;                                                                 1770
  1775    END CheckExpr2;                                                         1774  1769
  1776 
  1777 TYPE FormalKindTyp                                                            *     *
  1778   = ( RoutineFormal (* A formal of the routine we are translating *)        317
  1779     , ChildFormal   (* A child of a matched node. *)                          *
  1780     , CallFormal    (* A result formal of a puma routine we are calling *)          *
  1781     ) ; 
  1782 
  1783 PROCEDURE CheckRulePatterns (t, Formals, Predecessor: tTree);              1748     *  1773  1730     *  1748
  1784 
  1785 (* CheckRulePatterns is for the top-level list of a rule.  All
c 1786    the formal names are already declared, so if CheckPattern
c 1787    declares a formal, it is just a type-changing declaration
c 1788    of the same thing.  There is no need to call CheckPattern 
c 1789    for dont cares.  It would just redeclare the formal name 
c 1790    redundantly anyway. 
c 1791 *)
  1792    VAR Pattern  : tTree;                                                   1748   476  1783
  1793    BEGIN                                                                   1753
  1794       IF (t^.Kind = Tree.NoPattern)                                        1721  1783  1754  1772  1153
  1795          AND NOT IsType ( Formals , Tree . Formal )                        1714  1614  1625  1783  1794  1731
  1796       THEN RETURN;                                                         1722  1504
  1797       END;                                                                 1775
  1798       IF t^.Kind = Tree.NoPattern THEN                                     1794  1794  1794  1795  1794  1796
  1799         IF IsElement ( ORD ( 'g' ) , Options ) (* AND ( Predecessor <> NIL ) *)  1798  1711  1614  1614
  1800         THEN                                                               1798
  1801           (* Predecessor ^ . OnePattern . Next 
c 1802             := mOnePattern ( mDontCareInternal ( NoPosition ) , t ) *) 
  1803         ELSE                                                               1744
  1804           Error ("too few patterns for rule", t^.NoPattern.Pos); RETURN;   1637  1798  1798  1740  1796
  1805         END (* IF *);                                                      1797
  1806       ; RETURN                                                             1804
  1807       END;                                                                 1805
  1808       Pattern := t^.OnePattern.Pattern;                                    1792  1804  1153     *
  1809       IF Tree . IsType ( Pattern , Tree.DontCare ) THEN RETURN; END;       1799  1798  1795  1808     *  1500  1800  1806
                                                                                  1807
  1810       IF Formals^.Kind = Tree.NoFormal THEN                                1809  1795  1798  1809  1503  1809
  1811          Error ("too many patterns for rule", Pattern^.Pattern.Pos); RETURN;     1804  1809     *  1804  1809
  1812       END;                                                                 1809
  1813       CheckPattern (Pattern, Formals, Formals^.Formal.Path, RoutineFormal);         *  1811  1810     *  1795  1483  1778
  1814       CheckRulePatterns (t^.OnePattern.Next, Formals^.Formal.Next, t);     1783  1808  1808  1507  1813  1813     *     *
  1815    END CheckRulePatterns;                                                  1812  1814
  1816 
  1817 PROCEDURE CheckSubPatterns (t, Formals, FPath: tTree);                     1783     *  1814  1814     *  1792
  1818 
  1819 (* CheckSubPatterns handles a pattern list for a child of a higher
c 1820    node.  CheckPattern will be declaring a new meaning of the formal
c 1821    name. If there are dont cares in the pattern list, we
c 1822    need to call CheckPattern for each formal anyway, so it can declare 
c 1823    the name of the child.  
c 1824 *) 
  1825    VAR Lt , LFormals , LPattern : tTree;                                   1792     *     *     *  1817
  1826    BEGIN                                                                   1793
  1827      Lt := t;                                                              1825  1817
  1828      LFormals := Formals;                                                  1825  1817
  1829      LOOP                                                                   720
  1830        IF (Lt^.Kind = Tree.NoPattern)                                      1810  1827  1810  1810  1804
  1831        THEN                                                                1810
  1832          IF IsType ( LFormals , Tree . Formal )                            1830  1809  1828  1830  1814
  1833             (* NoFormal or DummyFormal is OK *) 
  1834             AND NOT IsElement ( ORD ( 'g' ) , Options )                    1795  1795  1799  1799  1799
  1835          THEN                                                              1831
  1836            Error ("too few child patterns", Lt^.NoPattern.Pos);            1811  1830  1830  1811
  1837          END;                                                              1815
  1838          EXIT                                                               703
  1839        END;                                                                1837
  1840        LPattern := Lt^.OnePattern.Pattern;                                 1825  1836  1814  1813
  1841        IF LFormals^.Kind = Tree.NoFormal                                   1832  1832  1830  1832  1810
  1842        THEN                                                                1835
  1843          IF NOT Tree . IsType ( LPattern  , Tree . DontCare )              1841  1834  1841  1832  1840     *  1809
  1844          THEN                                                              1842
  1845            Error ("too many child patterns", LPattern^.Pattern.Pos);       1836  1843  1840  1836
  1846          END (* IF *)                                                      1839
  1847        ; EXIT;                                                             1838
  1848        END;                                                                1846
  1849        CheckPattern                                                        1813
  1850          (LPattern, LFormals, mField (FPath, LFormals^.Formal.Name), ChildFormal);     1845  1841   158  1817     *  1832
                                                                                  1757  1779
  1851        IF NOT Tree . IsType ( LPattern  , Tree . DontCare )                1843  1843  1843  1843  1850     *  1843
  1852        THEN                                                                1844
  1853          Lt := Lt^.OnePattern.Next                                         1840     *  1840  1814
  1854        END (* IF *) ;                                                      1848
  1855        LFormals := LFormals^.Formal.Next                                   1850     *  1850  1853
  1856      END (* LOOP *)                                                        1854
  1857    END CheckSubPatterns;                                                   1856  1817
  1858 
  1859 PROCEDURE CheckCallPatterns (t, Formals: tTree);                           1817  1633  1827  1828  1825
  1860 
  1861 (* CheckCallPatterns handles patterns corresponding to result formals
c 1862    in a call to a puma routine.   
c 1863 *) 
  1864    VAR Lt , LFormals : tTree;                                              1825  1853  1855  1859
  1865    BEGIN                                                                   1826
  1866      Lt := t;                                                              1864  1859
  1867      LFormals := Formals;                                                  1864  1859
  1868      LOOP                                                                  1829
  1869        IF Lt^.Kind = Tree.NoPattern THEN                                   1851  1866  1841  1851  1836  1852
  1870           IF IsType ( LFormals , Tree . Formal )                           1869  1851  1867  1869  1855
  1871              (* NoFormal or DummyFormal is OK *) 
  1872              AND NOT IsElement ( ORD ( 'g' ) , Options )                   1834  1851  1834  1834  1834
  1873           THEN                                                             1869
  1874             Error ("too few result patterns", Lt^.NoPattern.Pos);          1845  1869  1869  1845
  1875           END (* IF *)                                                     1857
  1876        ;  EXIT                                                             1847
  1877        END;                                                                1875
  1878        WITH Lt^.OnePattern DO                                              1766  1874  1853  1767
  1879          IF IsType ( Pattern , Tree.DontCare ) THEN                        1870  1870  1845  1870  1851  1873
  1880             Pattern^.DontCare.Tempos := MakeTempos (LFormals);             1879  1879  1500  1500  1870
  1881               (* MakeTempos does it for all the rest of the formals *) 
  1882             EXIT                                                           1876
  1883          ELSE (* Not a DontCare *)                                         1803
  1884            IF LFormals^.Kind = Tree.NoFormal THEN                          1879  1880  1869  1879  1841  1879
  1885               Error ("too many result patterns", Pattern^.Pattern.Pos);    1874  1880     *  1874
  1886               EXIT ;                                                       1882
  1887            END;                                                            1877
  1888          END;                                                              1887
  1889          Pattern^.Pattern.Tempo := MakeTempoIdent ();                      1885     *  1523  1523
  1890          Pattern^.Pattern.TypeDesc := LFormals^.Formal.TypeDesc;           1889     *  1731  1884  1870     *
  1891          CheckPattern                                                      1849
  1892            ( Pattern, LFormals, mVar (Pattern^.Pattern.Tempo, FALSE, TRUE)       1890  1890   158     *     *  1889  1666
                                                                                   729
  1893            , CallFormal                                                    1780
  1894            );
  1895          IF NOT Tree . IsType ( Pattern  , Tree . DontCare )               1884  1872  1884  1879  1892     *  1880
  1896          THEN                                                              1884
  1897            Lt := Next;                                                     1878  1855
  1898          END;                                                              1888
  1899          LFormals := LFormals^.Formal.Next                                 1892     *  1890  1897
  1900        END (* WITH *)                                                      1898
  1901      END (* LOOP *)                                                        1900
  1902    END CheckCallPatterns;                                                  1901  1859
  1903 
  1904 PROCEDURE AddDecl                                                          1859     *
  1905   ( FormalKind : FormalKindTyp ; Name : tIdent ; TypeDesc , FPath : tTree           *  1777  1850   509  1890  1850  1864
  1906   ; Pos : tPosition )                                                      1885   508
  1907 
  1908 ; BEGIN                                                                    1865
  1909     CASE FormalKind                                                        1754  1905
  1910     OF RoutineFormal                                                       1754  1813
  1911     (* This will be a redeclaration with narrowed type *) 
  1912     : Decls := mPlainFormal ( Decls, Name , TypeDesc , FPath ) ;           1757   156     *  1905  1905  1905
  1913     | ChildFormal                                                          1850
  1914     : IF IsElement ( ORD ( 'j' ) , Options )                               1895  1872  1872  1872
  1915       THEN                                                                 1896
  1916         IF IsElement ( Name, LabelNames)                                   1914  1914  1912  1711
  1917            AND IsElement ( ORD ( 'J' ) , Options )                         1872  1916  1914  1914
  1918         THEN                                                               1915
  1919           WarningI                                                         1616
  1920             ( "Child name hides another declaration" , Pos , Name )        1906  1916
  1921         END (* IF *)                                                       1902
  1922       ; Include ( LabelNames , Name )                                      1618  1916  1920
  1923       ; Decls := mPlainFormal ( Decls, Name , TypeDesc , FPath ) ;         1912  1912     *  1922  1912  1912
  1924       END (* IF *)                                                         1921
  1925     | CallFormal : (* Don`t declare anything *)                            1893
  1926     END (* CASE *)                                                         1924
  1927   END AddDecl ;                                                            1926  1904
  1928 
  1929 PROCEDURE CheckPattern                                                     1904  1891
  1930   (t, Formals, FPath: tTree; FormalKind : FormalKindTyp );                 1866  1867  1923  1905  1909  1905
  1931    VAR LParam , LTypeDesc : tTree;                                         1864     *     *  1930
  1932    VAR LPath : tTree ;                                                     1931     *  1931
  1933    VAR LFormalTypeDesc : tTree ;                                           1932     *  1932
  1934    BEGIN                                                                   1908
  1935       CASE t^.Kind OF                                                      1909  1930  1884  1910
  1936 
  1937       | Tree.Decompose: WITH t^.Decompose DO                               1895  1061  1878  1935     *  1878
  1938             IsProperlyNarrowed := FALSE ;                                     *  1892
  1939             IF IsType ( Formals , Tree . Formal )                          1916  1895  1930  1937  1899
  1940             THEN                                                           1918
  1941                CheckSubtype                                                1729
  1942                  (Formals^.Formal.TypeDesc, Object^.Class.TypeDesc, Pos,   1939  1939  1923  1757  1720     *  1920
  1943                   'Decompose node not in formal/child type, specifically:');
  1944                IF ( Formals ^ . Formal . TypeDesc ^ . Kind = Tree . NodeTypes )        1939  1942  1942  1942  1935  1939
                                                                                  1714
  1945                   AND ( Object ^ . Class . TypeDesc ^ . Kind = Tree . NodeTypes )      1917  1942  1942  1944  1944  1944
                                                                                  1944
  1946                THEN                                                        1940
  1947                  IF IsType ( Formals , Tree . RoutineFormal )              1944  1939  1944  1945  1910
  1948                     AND ( Formals ^ . RoutineFormal . TargetClass # Tree . NoTree )    1945  1947  1947   317  1947  1721
  1949                  THEN                                                      1946
  1950                    LFormalTypeDesc                                         1933
  1951                      := Formals ^ . RoutineFormal . TargetClass            1948  1948  1948
  1952                         ^ . Class . TypeDesc                               1945  1945
  1953                  ELSE                                                      1883
  1954                    LFormalTypeDesc := Formals ^ . Formal . TypeDesc        1950  1951  1944  1952
  1955                  END (* IF *) ;                                            1927
  1956                  IF IsNotEqual                                             1947   146
  1957                       ( LFormalTypeDesc ^ . NodeTypes . Types              1954  1945   374
  1958                       , Object ^ . Class . TypeDesc ^ . NodeTypes . Types        1945  1952  1954  1957  1957
  1959                       ) 
  1960                  THEN IsProperlyNarrowed := TRUE                           1949  1938  1892
  1961                  END (* IF *) ;                                            1955
  1962                END (* IF *) ;                                              1961
  1963                LPath                                                       1932
  1964                  := mConsType                                               158
  1965                       ( FPath , Object ^ . Class . Name , IsProperlyNarrowed ) ;       1930  1958  1958  1923  1960
  1966                AddDecl                                                     1927
  1967                  ( FormalKind , Formals^.Formal.Name                       1930  1954  1954  1965
  1968                  , Object^.Class.TypeDesc                                  1965  1965  1958
  1969                  , LPath                                                   1963
  1970                  , Pos                                                     1942
  1971                  ) 
  1972             ELSE                                                           1953
  1973                LPath                                                       1969
  1974                  := mConsType                                              1964
  1975                       ( FPath , Object ^ . Class . Name , FALSE ) ;        1965  1968  1968  1967  1938
  1976             END ;                                                          1962
  1977             IF Object = NoTree THEN                                        1956  1975  1948  1960
  1978                (* RMB: If this can happen, then the recursive call at the
c 1979                   bottom will crash, and possibly other code here. *) 
  1980                CheckExpr (Expr, dFormals);                                 1773  1705  1773
  1981             ELSE                                                           1972
  1982                CheckExpr2 (Expr);                                          1775  1980
  1983             END ;                                                          1976
  1984             IF Selector # NoIdent THEN                                     1977  1590  1605  1977
  1985                IF IsElement (Selector, LabelNames) THEN                    1984  1917  1984  1922  1984
  1986                   Error ("label on deconstructor previously declared", Pos);     1885  1970
  1987                ELSE                                                        1981
  1988                   Include (LabelNames, Selector);                          1922  1985  1985
  1989                END;                                                        1983
  1990                IF Widen AND (Formals^.Kind = Tree.RoutineFormal) THEN      1985   959  1948  1967  1945  1948  1951  1985
  1991                   Decls                                                    1923
  1992                     := mRoutineFormal                                       156
  1993                          (Decls, Selector, Formals^.Formal.TypeDesc, FPath);     1991  1988  1990  1967  1968  1975
  1994                   Decls ^ . RoutineFormal . DeclaredTypeIsGuaranteed       1993  1990     *
  1995                     := Formals ^ . RoutineFormal . DeclaredTypeIsGuaranteed ;    1993  1994  1994
  1996                   Decls ^ . RoutineFormal . TargetClass                    1994  1995  1951
  1997                     := Formals ^ . RoutineFormal . TargetClass ;           1995  1996  1996
  1998                ELSE                                                        1987
  1999                   Decls                                                    1996
  2000                     := mPlainFormal                                        1923
  2001                          (Decls, Selector, Object^.Class.TypeDesc, LPath);       1999  1993  1977  1975  1993  1973
  2002                END;                                                        1989
  2003             END;                                                           2002
  2004             t ^ . Decompose . Path := FPath ;                              1937  1937  1813  1993
  2005             CheckSubPatterns ( Patterns , Object^.Class.Formals , LPath ) ;      1857  1633  2001  2001  1997  2001
  2006          END;                                                              2003
  2007 
  2008       | Tree.NilTest:                                                      1990     *
  2009           WITH t^.NilTest                                                  1937  2004  2008
  2010           DO                                                               1937
  2011             IF IsType ( Formals , Tree . Formal )                          1990  1947  2005  2008  1993
  2012             THEN                                                           1990
  2013               LTypeDesc := Formals^.Formal.TypeDesc                        1931  2011  2011  2001
  2014             ; IF LTypeDesc^.Kind = Tree.NodeTypes                          2011  2013  1990  2011  1958
  2015               THEN                                                         2012
  2016                 IsProperlyNarrowed                                         1965
  2017                   := IsNotEqual                                            1956
  2018                        ( LTypeDesc ^ . NodeTypes . Types                   2014  2014  1958
  2019                        , LTypeDesc ^ . NodeTypes . TreeName                2018  2018  1297
  2020                          ^ . TreeName.EmptyType ^ . NodeTypes . Types      2019     *  2019  2018
  2021                        ) 
  2022               ; LPath := mConsType ( FPath , IdentEmptyType , IsProperlyNarrowed )     2005  1974  2004   190  2016
  2023               ; LTypeDesc                                                  2019
  2024                   := LTypeDesc ^ . NodeTypes . TreeName ^ . TreeName . EmptyType       2023  2020  2020     *  2020
  2025               ELSE                                                         1998
  2026                 Error ( "NIL test on non-node type" , Pos )                1986  1986
  2027               ; LPath := mConsType ( FPath , LTypeDesc ^ . UserType . Type , FALSE )\  2022  2022  2022  2024   383  1718
                                                                                  1975
      \ 
  2028               ; LTypeDesc := NoTree                                        2027  1977
  2029               END (* IF *)                                                 2006
  2030             ; AddDecl                                                      1966
  2031                 ( FormalKind , Formals^.Formal.Name , LTypeDesc , LPath , Pos )        1967  2013  2013  1975  2028  2027
                                                                                  2026
  2032 (* Do we check elsewhere that no fields of this are referenced? *)
  2033             ELSE                                                           2025
  2034               LPath := mVar ( NoIdent , FALSE , FALSE )                    2031  1892  1984  2027     *
  2035             ; LTypeDesc := NoTree                                          2031  2028
  2036             END (* IF *)                                                   2029
  2037           ; IF Selector # NoIdent THEN                                     2014  2001  2034  2015
  2038                IF IsElement (Selector, LabelNames)                         2037  1985  2037  1988
  2039                THEN                                                        2037
  2040                   Error ("label on NIL previously declared", Pos)          2026  2031
  2041                ELSE                                                        2033
  2042                  Include (LabelNames, Selector)                            1988  2038  2038
  2043                ; Decls := mPlainFormal (Decls, Selector, LTypeDesc, LPath)       2001  2000     *  2042  2035  2034
  2044                END                                                         2036
  2045             END ;                                                          2044
  2046             t ^ . NilTest . Path := FPath                                  2009  2009  2004  2027
  2047           END (* WITH *)                                                   2045
  2048 
  2049       | Tree.VarDef: WITH t^.VarDef DO                                     2014     *  2009  2046     *  2010
  2050 (* RMB 5-97: I decided that a child which is matched by a label only
c 2051              in a pattern will not declare the child name. Labels alone,
c 2052              but with or without ':' , ':>' , and/or '_' parse as a
c 2053              label alone.  I intend to eventually allow '_' to have a
c 2054              label on it.  This will require data structure changes.
c 2055              When that happens, this case will parse as DontCare1Explicit,
c 2056              which will declare the child name.  Presumably, if the
c 2057              programmer declares a label, she intends to use it, and
c 2058              may wish not to overlay another name with the child decl.
c 2059 *) 
  2060             IF IsElement (Name, LabelNames)                                2038  2038  2031  2042
  2061             THEN (* A second occurrence, nonlinear pattern. *)             2039
  2062 (* What if this was previously declared as a formal/child? *) 
  2063                IF NOT IsElement (ORD ('k'), Options) THEN                  2060  1895  2060  1917  1917  2061
  2064                   Error ("stand alone label previously declared", Pos);    2040  2040
  2065                END;                                                        2047
  2066                Object := IdentifyVar (Decls, Name);                        2005  1757  2043  2060
  2067                IF ( Object # NIL )                                         2063  2066  1713
  2068                   AND IsType ( Formals , Tree . Formal )                   1990  2011  2031  2049  2031
  2069                THEN                                                        2063
  2070                   CheckType (Formals^.Formal.TypeDesc, Object^.Formal.TypeDesc, Pos)\   387  2068  2068  2013  2067     *
                                                                                     *  2064
      \;
  2071                END;                                                        2065
  2072             ELSE (* Newly declared label *)                                2041
  2073                Include (LabelNames, Name);                                 2042  2060  2066
  2074                IF Formals^.Kind = Tree.RoutineFormal THEN                  2067  2070  2014  2068  1997  2069
  2075                   Decls                                                    2066
  2076                     := mRoutineFormal                                      1992
  2077                          (Decls, Name, Formals^.Formal.TypeDesc, FPath);   2075  2073  2074  2070  2070  2046
  2078                   Decls ^ . RoutineFormal . DeclaredTypeIsGuaranteed       2077  2074  1995
  2079                     := Formals ^ . RoutineFormal . DeclaredTypeIsGuaranteed ;    2077  2078  2078
  2080                   Decls ^ . RoutineFormal . TargetClass                    2078  2079  1997
  2081                     := Formals ^ . RoutineFormal . TargetClass ;           2079  2080  2080
  2082                ELSE                                                        2072
  2083                  Decls                                                     2080
  2084                    := mPlainFormal                                         2043
  2085                         ( Decls , Name, Formals^.Formal.TypeDesc, FPath);  2083  2077  2081  2077  2077  2077
  2086                END;                                                        2071
  2087                Object := NoTree;                                           2070  2035
  2088             END;                                                           2086
  2089             t ^ . VarDef . Path := FPath                                   2049  2049  2046  2085
  2090          END;                                                              2088
  2091 
  2092       | Tree . DontCareExplicit                                            2074  1245
  2093       , Tree . DontCareInternal                                            2092  1246
  2094       , Tree . DontCare1Explicit                                           2093  1243
  2095       , Tree . DontCare1Internal                                           2094  1244
  2096         : LPath := mConsType ( FPath , TypeIdentOfFormal ( Formals ) , FALSE ) ;       2043  2027  2089   329  2085  2034
  2097           IF IsType ( Formals , Tree . Formal )                            2074  2068  2096  2095  2085
  2098           THEN                                                             2074
  2099             AddDecl                                                        2030
  2100               ( FormalKind , Formals^.Formal.Name                          2031  2097  2097  2085
  2101               , Formals^.Formal.TypeDesc                                   2100  2100  2085
  2102               , LPath                                                      2096
  2103               , t ^ . DontCare . Pos                                       2089  1895  2070
  2104               ) ; 
  2105             t ^ . DontCare . Path := FPath                                 2103  2103  2089  2096
  2106 (*/* ^I don't think this always makes sense, since a DontCareExplicit can
c 2107    be reused for multiple formals, at least for call patterns. 
c 2108    But it appears Path is unused for DontCare. */*) 
  2109           END (* IF *)                                                     2090
  2110 
  2111       | Tree.Value                                                         2097     *
  2112           : CheckExprVar (t^.Value.Expr, Formals);                         1705  2105  2111  1982  2101
  2113             t ^ . Value . Path := FPath                                    2112  2112  2105  2105
  2114 
  2115       ELSE                                                                 2082
  2116         t ^ . Pattern . Path := FPath                                      2113  1895  2113  2113
  2117       END;                                                                 2109
  2118    END CheckPattern;                                                       2117  1929
  2119 
  2120 PROCEDURE MakeTempoIdent (): tIdent;                                       1929  1889  1905
  2121    VAR String1, String2 : tString;                                         1933   199     *   199
  2122    BEGIN                                                                   1934
  2123       INC (TempoCount);                                                    1412   186
  2124       ArrayToString ("yyV", String1);                                       134  2121
  2125       IntToString (TempoCount, String2);                                    134  2123  2121
  2126       Concatenate (String1, String2);                                       134  2124  2125
  2127       RETURN MakeIdent (String1);                                          1811   135  2126
  2128    END MakeTempoIdent;                                                     2118  2120
  2129 
  2130 (* Copy list but assign a generated name to each formal. *) 
  2131 PROCEDURE MakeTempos (Formals: tTree): tTree;                              2120  1880  2112  1933     *
  2132    BEGIN                                                                   2122
  2133       IF IsType ( Formals , Tree . Formal )                                2097  2097  2131  2111  2101
  2134       THEN                                                                 2098
  2135          WITH Formals^.Formal DO                                           2049  2133  2133  2049
  2136             RETURN                                                         2127
  2137               mPlainFormal                                                 2084
  2138                 (MakeTempos (Next), MakeTempoIdent (), TypeDesc, Path);    2131  1899  2128  2101  2116
  2139          END;                                                              2128
  2140       ELSE                                                                 2115
  2141          RETURN nNoFormal;                                                 2136   201
  2142       END;                                                                 2139
  2143    END MakeTempos;                                                         2142  2138
  2144 
  2145 PROCEDURE InitPredefinedExtern ( )                                         2131     *
  2146 ; BEGIN                                                                    2132
  2147     IF IsElement ( ORD  ( 'c' ) , Options )                                2133  2063  2063  2063
  2148        OR IsElement ( ORD  ( 'A' ) , Options )                             1475  2147  2147  2147
  2149     THEN                                                                   2134
  2150     ELSE (* Modula-2 or Modula-3 *)                                        2140
  2151       Include ( ExternNames, IdentFalse )                                  2073  1608   191
  2152     ; Include ( ExternNames, IdentTrue )                                   2151  2151   192
  2153     END (* IF *)                                                           2143
  2154   END InitPredefinedExtern ;                                               2153  2145
  2155 
  2156 }
  2157 
  2158 BEGIN {                                                                    2146
  2159    dFormals := mDummyFormal (NoTree); dFormals^.DummyFormal.Next := dFormals;    1980   159  2087     *     *  2138     *
  2160    (*/* Circular list, so routines can "iterate" down it and
c 2161         keep getting "another" DummyFormal". */*) 
  2162    nNoFormal := mNoFormal ();                                              2141   156
  2163    ArrayToString (".", String1);                                           2124  2127
  2164    IdentDot := MakeIdent ( String1 ) ;                                     1644  2127  2163
  2165    ArrayToString ("EmptyType", String1);                                   2163  2164
  2166    IdentEmptyType := MakeIdent ( String1 ) ;                               2022  2164  2165
  2167    ArrayToString ("FALSE", String1);                                       2165  2166
  2168    IdentFalse := MakeIdent ( String1 ) ;                                   2151  2166  2167
  2169    ArrayToString ("TRUE", String1);                                        2167  2168
  2170    IdentTrue := MakeIdent ( String1 ) ;                                    2152  2168  2169
  2171 
  2172 }
  2173 
  2174 PROCEDURE CollectRoutineNames ( t : Tree )                                 2145     *  2116  2133
  2175 (* This is so forward references to routine names in
c 2176    puma (i.e. non-target-code) expressions will be
c 2177    recognized, without generating error messages *) 
  2178 
  2179 Procedure ( .. )                                                              *
  2180 ; Predicate ( .. )                                                         1353
  2181 ; Function ( .. )                                                          1629
  2182   :- { IF IsElement ( Name , RoutineNames)                                 2147  2148  2100  1575
  2183        THEN                                                                2149
  2184          Error ( "routine identifier previously declared" , Pos ) ;        2064  2103
  2185        ELSE                                                                2150
  2186          Include ( RoutineNames , Name ) ;                                 2152  2182  2182
  2187        END ;                                                               2154
  2188        CollectRoutineNames ( Next ) ;                                      2174  2159
  2189      } ; .
  2190 
  2191 PROCEDURE Semantics (t: Tree)                                              2174   114  2174  2174
  2192 
  2193 Spec (..) :- {                                                              250
  2194         TypeCount := MaxIdent ();                                           121   135
  2195         MakeSet (RoutineNames   , TypeCount);                               372  2186  2194
  2196         MakeSet (LabelNames     , TypeCount);                              2195  2073  2195
  2197         MakeSet (ParamNames     , TypeCount);                              2196   171  2196
  2198         MakeSet (TypeNames      , TypeCount);                              2197   122  2197
  2199         MakeSet (ExternNames    , TypeCount);                              2198  2152  2198
  2200         InitPredefinedExtern ( ) ;                                         2154
  2201 (* Do we want to put FALSE, TRUE, NULL, as preknown ExternNames? *) 
  2202         MakeSet (LocExternNames , TypeCount);                              2199  1609  2199
  2203         MakeSet (UserTypes      , TypeCount);                              2202   122  2202
  2204         MakeSet (UserNames      , TypeCount);                              2203  1618  2203
  2205         ClassFormals (TreeNames);                                             *   250
  2206         Semantics (Public);                                                2191     *
  2207         CollectExtern (Extern, ExternNames);                                  *     *  2199
  2208         ProcFormals (Routines);                                             334   230
  2209         CollectRoutineNames ( Routines ) ;                                 2188  2208
  2210         Semantics (Routines);                                              2206  2209
  2211       IF IsElement (ORD ('o'), Options) AND NOT IsEmpty (UserNames) THEN   2182  2182  2148  2148  2068  2063   375  2204
                                                                                  2183
  2212         WriteNl (StdOutput);                                                132   132
  2213         WriteS (StdOutput, "Undefined External Names"); WriteNl (StdOutput);      132  2212  2212     *
  2214         WriteS (StdOutput, "------------------------"); WriteNl (StdOutput);     2213  2213  2213     *
  2215         WriteNl (StdOutput);                                               2214  2214
  2216         FOR i := 1 TO TypeCount DO                                         1441  1445  1441  2204  2135
  2217            IF IsElement (i, UserNames) THEN                                2211  2211  2216  2211  2211
  2218               WriteIdent (StdOutput, i); WriteNl (StdOutput);               135  2215  2217  2215     *
  2219            END;                                                            2187
  2220         END;                                                               2219
  2221       END;                                                                 2220
  2222 }; .
  2223 (* Apparently, Semantics on Name will only happen for idents in the PUBLIC
c 2224    list. *) 
  2225 Name (..) :- {                                                             2186
  2226         Object := IdentifyProc (Name);                                     2087  1254  2225
  2227         IF Object = NoTree THEN                                            2217  2226  2159  2217
  2228            ErrorI ("subroutine identifier not declared", Pos, Name);       1740  2184  2226
  2229         ELSE                                                               2185
  2230            Object^.Routine.IsExtern := TRUE;                               2227  1635     *  1960
  2231         END;                                                               2221
  2232         Semantics (Next);                                                  2210  2188
  2233 }; .
  2234 Procedure (..) ;                                                           2179
  2235 Predicate (..) :- {                                                        2180
  2236         AssignEmpty (LocExternNames);                                       142  2202
  2237         CollectExtern (Extern, LocExternNames);                            2207  2207  2236
  2238         AssignEmpty (ParamNames);                                          2236  2197
  2239         Check (InParams);                                                     *     *
  2240         Check (OutParams);                                                 2239     *
  2241         InFormals := InForm;                                                177  1635
  2242         OutFormals := OutForm;                                              178  1633
  2243         Parameters := ParamDecls;                                           174     *
  2244         IsFunction := FALSE;                                                194  2096
  2245         RuleCount := 0;                                                     185
  2246         Check (Rules);                                                     2240     *
  2247         Semantics (Next);                                                  2232  2232
  2248 }; .
  2249 Function (..) :- {                                                         2181
  2250         AssignEmpty (LocExternNames);                                      2238  2237
  2251         CollectExtern (Extern, LocExternNames);                            2237  2237  2250
  2252         AssignEmpty (ParamNames);                                          2250  2238
  2253         Check (InParams);                                                  2246  2239
  2254         Check (OutParams);                                                 2253  2240
  2255         Check (ReturnParams);                                              2254     *
  2256         InFormals := InForm;                                               2241  2241
  2257         OutFormals := OutForm;                                             2242  2242
  2258         ReturnFormal := ReturnForm;                                         179  1629
  2259         Parameters := ParamDecls;                                          2243  2243
  2260         IsFunction := TRUE;                                                2244  2230
  2261         RuleCount := 0;                                                    2245
  2262         Check (Rules);                                                     2255  2246
  2263         Semantics (Next);                                                  2247  2247
  2264 }; .
  2265 
  2266 
  2267 PROCEDURE CollectExtern (t: Tree, REF Names: tSet)                         2191  2251  2191  2191     *     *   364
  2268 
  2269 Name (..), _ :-                                                            2228     *
  2270         Include (Names, Name (* An attribute of Name node! *) );           2186  2267  2269
  2271         CollectExtern (Next, Names);                                       2267  2263  2270
  2272         .
  2273 
  2274 
  2275 PROCEDURE ProcFormals (t: Tree)                                            2267  2208  2267  2267
  2276 
  2277 Procedure (..) ;                                                           2234
  2278 Predicate (..) :- {                                                        2235
  2279         Args := nNoFormal;                                                  176  2162
  2280         Decls := nNoFormal;                                                2085  2279
  2281         AssignEmpty (ParamNames);                                          2252  2252
  2282         IsOutput := FALSE;                                                 1482  2244
  2283         ProcFormals (InParams);                                            2275  2253
  2284         InForm := ReverseTree (Args);                                      2256   710  2279
  2285         Args := nNoFormal;                                                 2284  2280
  2286         IsOutput := TRUE;                                                  2282  2260
  2287         ProcFormals (OutParams);                                           2283  2254
  2288         OutForm := ReverseTree (Args);                                     2257  2284  2285
  2289         ParamDecls := Decls;                                               2259  2280
  2290         ProcFormals (Next);                                                2287  2271
  2291 }; .
  2292 Function (..) :- {                                                         2249
  2293         Args := nNoFormal;                                                 2288  2285
  2294         Decls := nNoFormal;                                                2289  2293
  2295         AssignEmpty (ParamNames);                                          2281  2281
  2296         IsOutput := FALSE;                                                 2286  2282
  2297         ProcFormals (InParams);                                            2290  2283
  2298         InForm := ReverseTree (Args);                                      2284  2288  2293
  2299         Args := nNoFormal;                                                 2298  2294
  2300         IsOutput := TRUE;                                                  2296  2286
  2301         ProcFormals (OutParams);                                           2297  2287
  2302         OutForm := ReverseTree (Args);                                     2288  2298  2299
  2303         Args := nNoFormal;                                                 2302  2299
  2304         IsOutput := TRUE;                                                  2300  2300
  2305         ProcFormals (ReturnParams);                                        2301  2255
  2306         ReturnForm := ReverseTree (Args);                                  2258  2302  2303
  2307         ParamDecls := Decls;                                               2289  2294
  2308         ProcFormals (Next);                                                2305  2290
  2309 }; .
  2310 Param (..) :- {                                                               *
  2311         IF IsElement (Name, ParamNames) THEN                               2227  2217  2270  2295  2227
  2312            Error ("parameter identifier previously declared", Pos);        2184  2228
  2313         ELSE                                                               2229
  2314            Include (ParamNames, Name);                                     2270  2311  2311
  2315         END;                                                               2231
  2316         ParamName := Name;                                                  188  2314
  2317         Mode := IsRef;                                                      196     *
  2318         ProcFormals (Type);                                                2308  2027
  2319         ProcFormals (Next);                                                2318  2308
  2320 }; .
  2321 Type (..)                                                                  2318
  2322   :- { GlobalLUBClass := NoTree ;                                           202  2227
  2323        IF (Name # NoIdent) AND (Names^.Kind # Tree.NoName)                 2311  2316  2037  2211  2271  2074  2275     *
  2324        THEN (* T . N or T . [ N1 , ... , NN ] *)                           2311
  2325           TreeName := IdentifyTree (Name);                                 2024  1294  2323
  2326           IF TreeName # NoTree THEN                                        2323  2325  2322  2324
  2327              MakeSet (ActTypes, TreeName^.TreeName.ClassCount);            2204   336  2326     *   372
  2328           ELSE                                                             2313
  2329              Error ("tree type not declared", Pos);                        2312  2312
  2330           END;                                                             2315
  2331        ELSIF (Name # NoIdent) AND (Names^.Kind = Tree.NoName)              1622  2325  2323  2323  2323  2323  2323  2323
  2332        THEN (* T *)                                                        2326
  2333           TreeName := IdentifyTree (Name);                                 2327  2325  2331
  2334           IF TreeName # NoTree                                             2326  2333  2326
  2335           THEN (* T is a tree name *)                                      2332
  2336              MakeSet (ActTypes, TreeName^.TreeName.ClassCount);            2327  2327  2334     *  2327
  2337              MakeTypes                                                      337
  2338                ( TreeName^.TreeName.Classes^.Class.Index                   2336     *  1297  2005  1699
  2339                , TreeName^.TreeName.Classes, ActTypes                      2338     *  2338  2336
  2340                );
  2341              GlobalLUBClass := TreeName ^ . TreeName . UniversalClass      2322  2339     *   450
  2342           ELSE (* not a tree name *)                                       2328
  2343              ActClass := IdentifyClass2 (Name, TreeName);                  1720  1227  2333  2341
  2344              IF ActClass # NoTree                                          2334  2343  2334
  2345              THEN (* T is a node name *)                                   2335
  2346                 MakeSet (ActTypes, TreeName^.TreeName.ClassCount);         2336  2339  2343     *  2336
  2347                 MakeTypes                                                  2337
  2348                   (ActClass^.Class.Index, ActClass^.Class.Extensions, ActTypes);       2344  2338  2338     *     *   398
                                                                                  2346
  2349                 GlobalLUBClass := ActClass                                 2341  2348
  2350              END;                                                          2330
  2351           END;                                                             2350
  2352        ELSIF (Name = NoIdent) AND (Names^.Kind # Tree.NoName)              2331  2343  2331  2331  2331  2331  2331  2331
  2353        THEN (* [ N1 , ... , NN ] *)                                        2345
  2354           ActClass := IdentifyClass2 (Names^.Name.Name, TreeName);         2349  2343  2352  2352     *  2346
  2355           IF ActClass # NoTree THEN                                        2344  2354  2344  2353
  2356              MakeSet (ActTypes, TreeName^.TreeName.ClassCount);            2346  2348  2354     *  2346
  2357           ELSE                                                             2342
  2358              Error ("node type not declared", Names^.Name.Pos);            2329  2354  2354  2329
  2359           END;                                                             2351
  2360        ELSE                                                                2357
  2361           TreeName := NoTree;                                              2356  2355
  2362        END;                                                                2359
  2363 
  2364        (* ASSERT: IF TreeName # NoTree 
c 2365                   THEN The type belongs to tree TreeName
c 2366                        ActTypes is an allocated set
c 2367                        IF Names is empty
c 2368                        THEN ActTypes and GlobalLUBClass have been computed 
c 2369                        ELSE ActTypes is empty (and needs to be filled in)
c 2370                             GlobalLUBClass is initialized to NIL and needs 
c 2371                             to be computed
c 2372                        END
c 2373                   ELSE Not a tree type, Name is the type ident
c 2374                   END
c 2375        *) 
  2376 
  2377        IF TreeName # NoTree THEN                                           2355  2361  2361  2355
  2378           ActTree := TreeName^.TreeName.Classes;                            183  2377     *  2339
  2379           ProcFormals (Names);                                             2319  2358
  2380           Node := mNodeTypes (TreeName, ActTypes);                          242   156  2378  2356
  2381        ELSE                                            (* assume user type *)    2360
  2382           IF Name = NoIdent THEN                                           2377  2358  2352  2377
  2383              Error ("incorrect type", Pos);                                2358  2358
  2384           ELSE                                                             2381
  2385              Include (TypeNames, Name);                                    2314  2198  2382
  2386           END;                                                             2362
  2387           Node := mUserType (Name);                                        2380   157  2385
  2388        END;                                                                2386
  2389        Var   := mVar (ParamName, IsOutput OR Mode, (* IsRegister := *) TRUE);    1483  2034  2316  2304  2148  2317  2304
  2390        (* Args  := mPlainFormal (Args , ParamName, Node, Var); *) 
  2391        Args := mRoutineFormal (Args, ParamName, Node, Var);                2306  2076     *  2389  2387  2389
  2392        Args ^ . RoutineFormal . DeclaredTypeIsGuaranteed := FALSE ;        2391  2081  2079  2296
  2393        Args ^ . RoutineFormal . TargetClass := GlobalLUBClass ;            2392  2392  2081  2349
  2394        Decls := mRoutineFormal (Decls, ParamName, Node, Var);              2307  2391     *  2391  2391  2391
  2395        Decls ^ . RoutineFormal . DeclaredTypeIsGuaranteed := FALSE ;       2394  2393  2392  2392
  2396        Decls ^ . RoutineFormal . TargetClass := GlobalLUBClass ;           2395  2395  2393  2393
  2397      } ; .
  2398 Name (..) :- {                                                             2387
  2399         ActClass := IdentifyClass (ActTree, Name);                         2355  1297  2378  2398
  2400         IF ActClass # NoTree THEN                                          2382  2399  2377  2382
  2401            Include (ActTypes, ActClass^.Class.Index);                      2385  2380  2400  2348  2348
  2402            ForallClasses (ActClass^.Class.Extensions, ProcFormals);         334  2401  2401  2348  2379
  2403            GlobalLUBClass := ClassLUB ( GlobalLUBClass , ActClass )        2396   459     *  2402
  2404         ELSE                                                               2384
  2405            Error ("Node not member of tree type", Pos);                    2383  2383
  2406         END;                                                               2388
  2407         ProcFormals (Next);                                                2402  2319
  2408 }; .
  2409 Class (..) :- {                                                            2402
  2410         Include (ActTypes, Index);                                         2401  2401  2401
  2411 }; .
  2412 
  2413 PROCEDURE CollectUniversalTypeDesc ( t : Classes )                         2275     *  2275  2378
  2414 
  2415 Class ( .. )                                                               2409
  2416   :- { Union ( ActTypes , TypeDesc ^ . NodeTypes . Types ) ;                147  2410  2138  2024  2020
  2417        CollectUniversalTypeDesc ( Next ) ;                                 2413  2407
  2418      } ; . 
  2419 
  2420 
  2421 PROCEDURE ClassFormals (t: Tree)                                           2413  2205  2413  2352
  2422 (* Along with callees, compute:
c 2423    TreeName . ClassCount
c 2424    TreeName . EmptyType
c 2425    Class . Index
c 2426    Class . TypeDesc
c 2427    Class . Formals 
c 2428 *)
  2429 
  2430 LOCAL { VAR String1 , String2 : tString ; }                                   *  2121  2170  2126  2121
  2431 
  2432 TreeName (..) :- {                                                         2380
  2433         ActTree := t;                                                      2399  2421
  2434         ClassCount := 0;                                                   2356
  2435         ForallClasses (Classes, CountClasses);                             2402  2413     *
  2436 
  2437         EmptyType := mNodeTypes (t, ActTypes);  (* 2nd arg is dummy *)     2024  2380  2433  2416
  2438         MakeSet (EmptyType^.NodeTypes.Types, t^.TreeName.ClassCount);      2356  2437  2416  2416  2437  2432  2434
  2439         AssignEmpty(EmptyType^.NodeTypes.Types);                           2295  2438  2438  2438
  2440 
  2441         ArrayToString ("t", String1);                                      2169  2430
  2442         GetString (Name, String2);                                          135  2399  2430
  2443         Concatenate (String1, String2);                                    2126  2441  2442
  2444 
  2445         ForallClasses (Classes, ClassTypes);                               2435  2435     *
  2446         ForallClasses (Classes, ClassFormals);                             2445  2445  2421
  2447 
  2448         UniversalClass                                                     2341
  2449           := mClass                                                         155
  2450                ( MakeIdent ( String1 ) , { Nonterminal }                   2170  2443   162
  2451                , NoTree , NoTree , NoTree ) ;                              2400     *     *
  2452         UniversalClass ^ . Class . BaseClass := NoTree ;                   2448  2415   454  2451
  2453         UniversalClass ^ . Class . Formals := NoTree ;                     2452  2452  2135  2452
  2454         UniversalClass ^ . Class . Index := 0 ;                            2453  2453  2410
  2455         MakeSet ( ActTypes , t ^ . TreeName . ClassCount ) ;               2438  2437  2438  2438  2438
  2456         AssignEmpty ( ActTypes ) ;                                         2439  2455
  2457         CollectUniversalTypeDesc ( Classes ) ;                             2417  2446
  2458         UniversalClass ^ . Class . TypeDesc                                2454  2454  2416
  2459           := mNodeTypes ( t , ActTypes ) ;                                 2437  2455  2456
  2460 
  2461         ComputeDepthsClasses ( Classes , 1 ) ;                              401  2457
  2462         
  2463         ClassFormals (Next);                                               2446  2417
  2464 }; .
  2465 Class (..) :- {                                                            2458
  2466         Args := nNoFormal;                                                 2393  2303
  2467         ForallAttributes (t, ClassFormals);                                 160  2459  2463
  2468         Formals := ReverseTree (Args);                                     2453  2306  2466
  2469 }; .
  2470 Child (..) :- {                                                               *
  2471         ActClass := IdentifyClass (ActTree^.TreeName.Classes, Type);       2403  2399  2433  2455  2461  2321
  2472         Args                                                               2468
  2473           := mPlainFormal                                                  2137
  2474                ( Args, Name, ActClass^.Class.TypeDesc, (* Path := *) NoTree);    2472  2442  2471  2465  2458  2453
  2475 }; .
  2476 Attribute (..) :- {                                                        1726
  2477         IF ({Test, Dummy} * Properties) = {}                               2400   162   162     *
  2478         THEN                                                               2400
  2479            ActClass := IdentifyClass (ActTree^.TreeName.Classes, Type);    2474  2471  2471  2471  2471  2471
  2480            IF ActClass = NoTree                                            2477  2479  2474
  2481            THEN                                                            2478
  2482              Args                                                          2474
  2483                := mPlainFormal                                             2473
  2484                     (Args, Name, mUserType (Type), (* Path := *) NoTree);  2482  2474  2387  2479  2480
  2485              Include (TypeNames, Type);                                    2410  2385  2484
  2486            ELSE                                                            2404
  2487              Args                                                          2484
  2488                := mPlainFormal                                             2483
  2489                      (Args, Name, ActClass^.Class.TypeDesc, (* Path := *) NoTree);     2487  2484  2480  2474  2474  2484
  2490            END (* IF *)                                                    2406
  2491         END;                                                               2490
  2492 }; .
  2493 
  2494 
  2495 PROCEDURE CountClasses (t: Tree)                                           2421  2435  2467  2421
  2496 
  2497 Class (..) :- {                                                            2489
  2498         INC (ActTree^.TreeName.ClassCount);                                2123  2479  2479  2455
  2499         Index := ActTree^.TreeName.ClassCount;                             2454  2498  2498  2498
  2500 }; .
  2501 
  2502 
  2503 PROCEDURE ClassTypes (t: Tree)                                             2495  2445  2495  2495
  2504 
  2505 Class (..) :- {                                                            2497
  2506         TypeDesc := mNodeTypes (ActTree, ActTypes);     (* 2nd arg is dummy *)   2489  2459  2499  2459
  2507         MakeSet (TypeDesc^.NodeTypes.Types, ActTree^.TreeName.ClassCount);       2455  2506  2439  2439  2506  2499  2499
  2508         MakeTypes (Index, Extensions, TypeDesc^.NodeTypes.Types);          2347  2499  2402  2507  2507  2507
  2509 }; .
  2510 
  2511 
  2512 PROCEDURE Check (t: Tree)                                                  2503  2262  2503  2503
  2513 
  2514 Reject  (_, Statement (Pos:_, _)) ;                                        1376  2269  1382  2405     *     *
  2515 Fail    (_, Statement (Pos:_, _)) :-                                       1377  2514  2514  2514     *     *
  2516         Warning ("statement not reachable", Pos);                          1591  2515
  2517         REJECT                                                                *
  2518         .
  2519 Param (..) :- {                                                            2310
  2520         Include (ParamNames, Name);                                        2485  2314  2489
  2521         Check (Next);                                                      2512  2463
  2522 }; .
  2523 Rule (..) :-                                                                  *
  2524       VAR LPatternCount : CARDINAL ;                                       2430  1264  1162
  2525       VAR LIsLast : BOOLEAN ;                                              2524     *   714
  2526       VAR LPatterns : Tree ;                                               2525   643  2512
  2527       VAR LSinglePatterns : Tree ;                                         2526     *  2526
  2528       VAR LNewRule : Tree ;                                                2527     *  2527
  2529       { LPatterns       := TransformKeyword (Patterns, InFormals);         2526  1451  2005  2256
  2530         TransformPattern ( LPatterns , LPatterns , LPatternCount );        1261  2529     *  2524
  2531         Exprs           := TransformKeyword (Exprs, OutFormals);           1701  2529     *  2257
  2532         Exprs           := TransformExpr (Exprs);                          2531  1373     *
  2533         Expr            := TransformExpr (Expr); (* Return value *)        2112  2532     *
  2534         Statements      := TransformStmt (Statements);                        *  1384     *
  2535         LOOP                                                               1868
  2536           WITH t^.Rule (* This duplicates the WITH generated by puma,      2135  2512  2523
c 2537                           but that one won't reflect the assignment to
c 2538                           t that can occur at the end of this loop. *)
  2539           (* Attempt to put in "t^.Rule." everywhere, so this WITH
c 2540              statement is not used anyway. *) 
  2541           DO                                                               2216
  2542             IF LPatternCount = 1                                           2480  2530
  2543             THEN (* Avoid unnecessary copy of LPatterns *)                 2481
  2544               t^.Rule.Patterns := LPatterns                                2536  2536  2529  2530
  2545             ; LIsLast := TRUE ;                                            2525  2389
  2546             ELSE                                                           2486
  2547               NextPatterns ( LPatterns , LSinglePatterns , LIsLast )        631  2544  2527  2545
  2548             ; IF NOT LIsLast                                               2542  2211  2547
  2549               THEN                                                         2543
  2550                 LNewRule                                                   2528
  2551                   := mRule                                                  153
  2552                        ( t^.Rule.Line                                      2544  2544     *
  2553                        , NoTree (* Will be supplied next time around. *)   2489
  2554                        , CopyTree ( t^.Rule.Exprs )                         488  2552  2552  2532
  2555                        , CopyTree ( t^.Rule.Expr )                         2554  2554  2554  2533
  2556                        , CopyTree ( t^.Rule.Statements )                   2555  2555  2555  2534
  2557                        , t^.Rule.Next                                      2556  2556  2521
  2558                        ) 
  2559               ; t^.Rule.Next := LNewRule                                   2557  2557  2557  2550
  2560            (* ELSE Avoid unnecessary copy of Rule and some of its subtrees. *)
  2561               END (* IF *)                                                 2491
  2562             ; t^.Rule.Patterns := LSinglePatterns                          2559  2559  2544  2547
  2563             END (* IF *) ;                                                 2561
  2564             INC (RuleCount);                                               2498  2261
  2565             t^.Rule.Index               := RuleCount;                      2562  2562  2508  2564
  2566             TempoCount  := 0;                                              2125
  2567             HasLocals   := FALSE;                                           193  2395
  2568             Decls               := Parameters;                             2396  2259
  2569             Assign (LabelNames, ParamNames);                                373  2196  2520
  2570             CheckRulePatterns (t^.Rule.Patterns, InFormals, NIL);          1815  2565  2565  2562  2529  2067
  2571             (* ^Adds decls to InFormals *) 
  2572             Check (t^.Rule.Patterns);                                      2521  2570  2570  2570
  2573             Check (t^.Rule.Statements);                                    2572  2572  2572  2556
  2574             CheckExprList (t^.Rule.Exprs, OutFormals);                     1701  2573  2573  2554  2531
  2575             Check (t^.Rule.Exprs);                                         2573  2574  2574  2574
  2576             IF IsFunction THEN                                             2548  2260  2549
  2577                IF t^.Rule.Expr^.Kind = Tree.NoExpr THEN                    2576  2575  2575  2555  2352  2528  1496  2576
  2578                   IF NOT HasReject (t^.Rule.Statements) THEN               2577  2548     *  2577  2577  2573  2577
  2579                      Error ("function requires RETURN expression"          2405
  2580                            , t^.Rule.Expr^.Expr.Pos                        2578  2578  2577     *  2516
  2581                            );
  2582                   END;                                                     2563
  2583                ELSE                                                        2546
  2584                   CheckExprVar (t^.Rule.Expr, ReturnFormal);               2112  2580  2580  2580  2258
  2585                   Success := FALSE;                                         197  2567
  2586                   Check (t^.Rule.Expr);                                    2575  2584  2584  2584
  2587                   t^.Rule.HasPatterns := Success;                          2586  2586     *  2585
  2588                   IF t^.Rule.HasPatterns                                   2578  2587  2587  2587
  2589                      AND (t^.Rule.Expr^.Kind # Tree.Compose)               2352  2588  2588  2586  2577  2577  1772
  2590                      AND NOT Tree . IsType ( t , Tree.DontCare1)           2589  2578  2589  2133  2589     *  1528
  2591                          (* ^Isnt this identically true here? *) 
  2592                   THEN                                                     2578
  2593                      t^.Rule.Tempo := MakeTempoIdent ();                   2590  2589  1892  2138
  2594                   END;                                                     2582
  2595                END;                                                        2594
  2596             END;                                                           2595
  2597             IF NOT IsFunction AND (t^.Rule.Expr^.Kind # Tree.NoExpr) THEN  2588  2590  2576  2590  2593  2593  2589  2589
                                                                                  2590  2577  2592
  2598                Error ("RETURN in non-function", t^.Rule.Expr^.Expr.Pos);   2579  2597  2597  2597     *  2580
  2599             END;                                                           2596
  2600             t^.Rule.VarDecls := Decls;                                     2598  2598     *  2568
  2601             IF IsElement (ORD ('c'), Options) THEN                         2597  2311  2211  2211  2597
  2602               t^.Rule.HasTempos := (TempoCount > 0) OR HasLocals;          2600  2600     *  2566  2389  2567
  2603             ELSE                                                           2583
  2604               t^.Rule.HasTempos := (TempoCount > 0) OR HasLocals           2602  2602  2602  2602  2602  2602
  2605                  OR t^.Rule.HasPatterns;                                   2604  2604  2604  2588
  2606             END;                                                           2599
  2607             CheckTargetCode (t^.Rule.Patterns);                               *  2605  2605  2572
  2608             CheckTargetCode (t^.Rule.Exprs);                               2607  2607  2607  2575
  2609             IF IsFunction THEN                                             2601  2597  2601
  2610                CheckTargetCode (t^.Rule.Expr);                             2608  2608  2608  2598
  2611             END;                                                           2606
  2612             CheckTargetCode (t^.Rule.Statements);                          2610  2610  2610  2578
  2613             IF LIsLast THEN EXIT                                           2609  2548  2609  1886
  2614             ELSE t := t ^ . Rule . Next                                    2603  2612     *  2612  2559
  2615                  (* Which is a copy made at the top of this iteration. *) 
  2616             END (* IF *)                                                   2611
  2617           END (* WITH *)                                                   2616
  2618         END (* LOOP *) ;                                                   2617
  2619         Check (t^.Rule.Next);                                              2586  2614  2614  2614
  2620 }; .
  2621 ProcCall (..) :- {                                                         1348
  2622         CheckExprVar (Call, dFormals);                                     2584  1595  2159
  2623 (* Assuming graph grammar is not violated, Call is a Call node,
c 2624    and this degenerates to CheckExpr ( Call , dFormals ) *) 
  2625         Check (Call);                                                      2619  2622
  2626         Check (Next);                                                      2625  2619
  2627 }; .
  2628 Condition (..) :- {                                                        1367
  2629         CheckExprVar (Expr, dFormals);                                     2622  2610  2622
  2630         Check (Expr);                                                      2626  2629
  2631         Check (Next);                                                      2630  2626
  2632 }; .
  2633 Assignment (..) :- {                                                       1371
  2634         IF Adr^.Kind = Tree.VarUse THEN                                    2613  1372  2597  2597  1756  2613
  2635            Object := IdentifyVar (Decls, Adr^.VarUse.Name);                2230  2066  2600  2634  2634  2520
  2636         ELSE                                                               2614
  2637            Object := NoTree;                                               2635  2553
  2638         END;                                                               2618
  2639         CheckExprVar (Adr, dFormals);                                      2629  2635  2629
  2640         IF Object # NoTree THEN                                            2634  2637  2637  2634
  2641            CheckExprVar (Expr, Object);                                    2639  2630  2640
  2642         ELSE                                                               2636
  2643            CheckExprVar (Expr, dFormals);                                  2641  2641  2639
  2644         END;                                                               2638
  2645         Check (Adr);                                                       2631  2639
  2646         Check (Expr);                                                      2645  2643
  2647         Check (Next);                                                      2646  2631
  2648 }; .
  2649 Fail (..) :- {                                                             2515
  2650         IF IsFunction THEN                                                 2640  2609  2640
  2651            Error ("FAIL not allowed in function", Pos);                    2598  2598
  2652         END;                                                               2644
  2653         Check (Next);                                                      2647  2647
  2654 }; .
  2655 TargetStmt (..) :- {                                                       1378
  2656         CheckTargetCode (Parameters);                                      2612  2568
  2657         MakeSet (UsedNames, MaxIdent ());                                  2507     *  2194
  2658         ActNames := UsedNames;                                              168  2657
  2659         Check (Stmt);                                                      2653     *
  2660         UsedNames := ActNames;                                             2658  2658
  2661         Check (Next);                                                      2659  2653
  2662 }; .
  2663 Statement (..) :- {                                                        2515
  2664         Check (Next);                                                      2661  2661
  2665 }; .
  2666 OnePattern (..) :- {                                                       1878
  2667         Check (Pattern);                                                   2664  2116
  2668         Check (Next);                                                      2667  2664
  2669 }; .
  2670 OneExpr (..) :- {                                                          1498
  2671         Check (Expr);                                                      2668  2646
  2672         Check (Next);                                                      2671  2668
  2673 }; .
  2674 Decompose (..) :- {                                                        2004
  2675         Check (Expr);                                                      2672  2671
  2676         Success := TRUE;                                                   2587  2545
  2677         Check (Patterns);                                                  2675  2607
  2678 }; .
  2679 VarDef (..) :- {                                                           2089
  2680         IF Object # NoTree THEN Success := TRUE; END;                      2650  2641  2640  2650  2676  2676  2652
  2681 }; .
  2682 NilTest (..) :- {                                                          2046
  2683         Success := TRUE;                                                   2680  2680
  2684 }; .
  2685 Value (..) :- {                                                            2113
  2686         Success := TRUE;                                                   2683  2683
  2687         Check (Expr);                                                      2677  2675
  2688 }; .
  2689 Compose (..) :- {                                                          2589
  2690         Check (Expr);                                                      2687  2687
  2691         Check (Exprs);                                                     2690  2608
  2692 }; .
  2693 Call (..) :- {                                                             2625
  2694         Check (Expr);                                                      2691  2690
  2695         Check (Exprs);                                                     2694  2691
  2696         Check (Patterns);                                                  2695  2677
  2697 }; .
  2698 Binary (..) :- { (* Dot construct in non-target code *)                    1760
  2699         Check (Lop);                                                       2696  1768
  2700         Check (Rop);                                                       2699  1769
  2701 }; .
  2702 PreOperator (..) ;                                                         1694
  2703 PostOperator (..) ;                                                        1694
  2704 Parents (..) :- {                                                          1704
  2705         Check (Expr);                                                      2700  2694
  2706 }; .
  2707 Index (..) :- {                                                            2565
  2708         Check (Expr);                                                      2705  2705
  2709         Check (Exprs);                                                     2708  2695
  2710 }; .
  2711 TargetExpr (..) :- {                                                       1333
  2712         MakeSet (UsedNames, MaxIdent ());                                  2657  2660  2657
  2713         ActNames := UsedNames;                                             2660  2712
  2714         Check (Expr);                                                      2709  2708
  2715         UsedNames := ActNames;                                             2713  2713
  2716 }; .
  2717 Ident (..) :- {                                                             267
  2718         Object := IdentifyVar (Decls, Attribute);                          2680  2635  2635  2476
  2719 (* No check of local names? *) 
  2720         IF Object = NoTree                                                 2680  2718  2680
  2721         THEN Include (ActNames, Attribute); END;                           2680  2520  2715  2718  2680
  2722         Check (Next);                                                      2714  2672
  2723 }; .
  2724 Any (..) ;                                                                    *
  2725 Anys (..) :- {                                                                *
  2726         Check (Next);                                                      2722  2722
  2727 }; .
  2728 Designator (..) (* '::' in target code *)                                     *
  2729 
  2730 (* Except for not going on to Next, AttrDesc in CheckExpr is handled the same. *) 
  2731    :- VAR LAttrFormal : tTree ;                                            2528  1731  2131
  2732       {
  2733         IF IsElement (Selector, LabelNames) THEN                           2720  2601  2043  2569  2721
  2734            Object := IdentifyVar (Decls, Selector);                        2720  2718  2718  2733
  2735            IF Object^.Formal.TypeDesc^.Kind = Tree.NodeTypes THEN          2733  2734  2135  2508  2634  2634  2508  2733
  2736               ActClass                                                     2489
  2737                 := ClassOfNodeTypes ( Object ^ . Formal . TypeDesc ) ;     1717  2735  2735  2735
  2738               Type := ActClass^.Class.Name;                                2485  2736  2505  2635
  2739               LAttrFormal                                                  2731
  2740                 := IdentifyVar ( ActClass^.Class.Formals , Attribute ) ;   2734  2738  2738  2468  2721
  2741               IF LAttrFormal = NoTree                                      2735  2739  2720
  2742               THEN                                                         2735
  2743                 ErrorI                                                     2228
  2744                   ( "D No such child/attribute" , AttributePos , Attribute ) ;   1732  2740
  2745               END (* IF *) ;                                               2721
  2746            ELSE                                                            2642
  2747               ErrorI ( "D tree-type required" , Pos , Selector ) ;         2743  2651  2734
  2748            END;                                                            2745
  2749         ELSE                                                               2746
  2750            ErrorI (" D identifier is not declared" , Pos , Selector );     2747  2747  2747
  2751         END;                                                               2748
  2752         Check (Next);                                                      2726  2726
  2753 }; .
  2754 
  2755 
  2756 PROCEDURE CheckTargetCode (t: Tree)                                        2512  2656  2619  2735
  2757 
  2758 Param (..) (* This is a local declaration *)                               2519
  2759    :- {
  2760         HasLocals := TRUE;                                                 2604  2686
  2761         ParamName := Name;                                                 2394  2738
  2762         IsOutput := FALSE;                                                 2389  2585
  2763         ProcFormals (Type);                                                2407  2738
  2764         IF IsElement (Name, LabelNames) THEN                               2741  2733  2761  2733  2742
  2765            Error ("identifier previously declared", Pos);                  2651  2750
  2766         ELSE                                                               2749
  2767            Include (LabelNames, Name);                                     2721  2764  2764
  2768         END;                                                               2751
  2769         CheckTargetCode (Next);                                            2756  2752
  2770 }; .
  2771 ProcCall (..) :- {                                                         2621
  2772         CheckTargetCode (Call);                                            2769  2693
  2773         CheckTargetCode (Next);                                            2772  2769
  2774 }; .
  2775 Condition (..) :- {                                                        2628
  2776         CheckTargetCode (Expr);                                            2773  2714
  2777         CheckTargetCode (Next);                                            2776  2773
  2778 }; .
  2779 Assignment (..) :- {                                                       2633
  2780         CheckTargetCode (Expr);                                            2777  2776
  2781         CheckTargetCode (Next);                                            2780  2777
  2782 }; .
  2783 TargetStmt (..) :- {                                                       2655
  2784         ActNames := UsedNames;                                             2721  2715
  2785         CheckTargetCode (Stmt);                                            2781  2659
  2786         ReleaseSet (UsedNames);                                             378  2784
  2787         CheckTargetCode (Next);                                            2785  2781
  2788 }; .
  2789 Statement (..) :- {                                                        2663
  2790         CheckTargetCode (Next);                                            2787  2787
  2791 }; .
  2792 OnePattern (..) :- {                                                       2666
  2793         CheckTargetCode (Pattern);                                         2790  2667
  2794         CheckTargetCode (Next);                                            2793  2790
  2795 }; .
  2796 OneExpr (..) :- {                                                          2670
  2797         CheckTargetCode (Expr);                                            2794  2780
  2798         CheckTargetCode (Next);                                            2797  2794
  2799 }; .
  2800 Decompose (..) :- {                                                        2674
  2801         CheckTargetCode (Expr);                                            2798  2797
  2802         CheckTargetCode (Patterns);                                        2801  2696
  2803 }; .
  2804 Value (..) :- {                                                            2685
  2805         CheckTargetCode (Expr);                                            2802  2801
  2806 }; .
  2807 Compose (..) :- {                                                          2689
  2808         CheckTargetCode (Expr);                                            2805  2805
  2809         CheckTargetCode (Exprs);                                           2808  2709
  2810 }; .
  2811 Call (..) :- {                                                             2772
  2812         CheckTargetCode (Expr);                                            2809  2808
  2813         CheckTargetCode (Exprs);                                           2812  2809
  2814         CheckTargetCode (Patterns);                                        2813  2802
  2815 }; .
  2816 Binary (..) :- { (* Dot construct in target code. *)                       2698
  2817         CheckTargetCode (Lop);                                             2814  2699
  2818         CheckTargetCode (Rop);                                             2817  2700
  2819 }; .
  2820 PreOperator (..) ;                                                         2702
  2821 PostOperator (..) ;                                                        2703
  2822 Parents (..) :- {                                                          2704
  2823         CheckTargetCode (Expr);                                            2818  2812
  2824 }; .
  2825 Index (..) :- {                                                            2707
  2826         CheckTargetCode (Expr);                                            2823  2823
  2827         CheckTargetCode (Exprs);                                           2826  2813
  2828 }; .
  2829 TargetExpr (..) :- {                                                       2711
  2830         ActNames := UsedNames;                                             2784  2786
  2831         CheckTargetCode (Expr);                                            2827  2826
  2832         ReleaseSet (UsedNames);                                            2786  2830
  2833 }; .
  2834 Ident (..) :- {                                                            2717
  2835         IF IsElement (Attribute, ActNames)                                 2764  2764  2744  2830
  2836            AND (IdentifyVar (Decls, Attribute) # NoTree)                   2597  2740  2734  2835  2741
  2837            (* RMB: The handling of Ident in Check is the only place where
c 2838                    an identifier gets added to ActNames (=UsedNames), and
c 2839                    only if an identical call on IdentifyVar returns NoTree, so
c 2840                    the only way this could happen is if Attribute got
c 2841                    added to Decls between the call on Check and the call
c 2842                    on CheckTargetCode, which I don't think can happen.
c 2843                    Should this perhaps be intended to check 
c 2844                    IsElement(Attribute, LabelNames) ? 
c 2845                    What does this message mean anyway?  It should be
c 2846                    legal for a target code identifier to not be a 
c 2847                    declared label.  And if it is declared, then the
c 2848                    message is not true anyway. ????? 
c 2849            *) 
  2850         THEN                                                               2764
  2851            Error ("label not computed yet", Pos);                          2765  2765
  2852         END;                                                               2768
  2853         CheckTargetCode (Next);                                            2831  2798
  2854 }; .
  2855 Any (..) ;                                                                 2724
  2856 Anys (..) ;                                                                2725
  2857 Designator (..) (* '::' in target code *) :- CheckTargetCode (Next); .     2728  2853  2853
  2858 
  2859 PROCEDURE RemoveTreeTypes (t: Tree)                                        2756   114  2756  2756
  2860 
  2861 Spec (..) :-                                                               2193
  2862    RemoveTreeTypes (TreeNames);                                            2859  2205
  2863    .
  2864 TreeName (..) :-                                                           2507
  2865 VAR String1 : tString ;                                                    2731  2450  2430
  2866 VAR String2 : tString ;                                                    2865  2443  2865
  2867 VAR i : tIdent ;                                                           2866  2218  2120
  2868 {
  2869    ArrayToString ("t", String1);                                           2441  2865
  2870    GetString (Name, String2);                                              2442  2767  2866
  2871    Concatenate (String1, String2);                                         2443  2869  2870
  2872    i := MakeIdent (String1);                                               2867  2450  2871
  2873    IF i <= TypeCount THEN Exclude (TypeNames, i); END;                     2835  2872  2216  2850   146  2485     *  2852
  2874    RemoveTreeTypes (Next);                                                 2862  2857
  2875 }; .
  2876 
  2877 PREDICATE HasReject (Statements)                                              *  2578  2612
  2878 
  2879 Reject (..) :- .                                                           2514
  2880 Statement (..) :- HasReject (Next); .                                      2789  2877  2874
  2881 
  2882 (* end of file sem.puma of puma *) 
Cross reference: 

-"-
 "  incompatible tree types fr\  347 
   om different trees"
 "  incompatible user types"     358 
 "  not a subset of formal nod\  350 
   e kinds"
 "  tree type is incompatible \  355 
   with formal's user type"
 "  user type is incompatible \  344 
   with formal's tree type"
 " D identifier is not declare\ 2750 
   d"
 "------------------------"     2214 
 "."                            2163 
 "Call on user procedure canno\ 1277 
   t have result patterns"
 "Child name hides another dec\ 1920 
   laration"
 "Colon required on label"      1022 
 "D No such child/attribute"    2744 
 "D tree-type required"         2747 
 "disjoint node types"           376 
 "Dont care in illegal context" 1528 
 "EmptyType"                    2165 
 "ExpandDecompose, Bad Kind."    598 
 "ExpandDecompose, Binary w/o \  580 
   1st VarUse."
 "ExpandDecompose, Binary w/o \  586 
   2nd VarUse."
 "ExpandDecompose, Binary w/o \  575 
   dot."
 "ExpandDecompose, Index w/o 1\  536 
   st VarUse."
 "ExpandDecompose, Index w/o 2\  549 
   nd VarUse."
 "ExpandDecompose, Index w/o E\  543 
   xpr."
 "ExpandDecompose, not a class\  618 
   . "
 "ExpandDecompose, not an expr\  696 
   ."
 "FAIL not allowed in function" 2651 
 "FALSE"                        2167 
 "function requires RETURN exp\ 2579 
   ression"
 "identifier in expression not\ 1578  1580 
    declared"
 "Identifier not declared"      1740 
 "identifier previously declar\ 2765 
   ed"
 "illegal context for named as\  808 
   sociation"
 "incompatible types from diff\  370 
   erent trees"
 "incompatible user types"       384 
 "incorrect type"               2383 
 "Keyword notation illegal in \ 1174 
   an expression"
 "label ignored on compose in \ 1546 
   expression"
 "label ignored on NIL in expr" 1591 
 "label not computed yet"       2851 
 "label on deconstructor previ\ 1986 
   ously declared"
 "label on NIL previously decl\ 2040 
   ared"
 "named expression not allowed\  660 
    in a type"
 "NextPatterns, Alt not Decomp\  484 
   ose."
 "NIL test on non-node type"    2026 
 "No such child/attribute"      1724 
 "No such formal/child name"    1423 
 "Node constructor as a statem\ 1363 
   ent"
 "Node not member of tree type" 2405 
 "node type not declared"        864  1093  2358 
 "not a class or node of the r\  612 
   equired tree"
 "parameter identifier previou\ 2312 
   sly declared"
 "RETURN in non-function"       2598 
 "routine identifier previousl\ 2184 
   y declared"
 "single identifier required i\  666   675 
   n a type"
 "stand alone label previously\ 2064 
    declared"
 "statement not reachable"      2516 
 "subroutine identifier not de\ 1613  1616  2228 
   clared"
 "subroutine identifier requir\ 1637 
   ed"
 "t"                            2441  2869 
 "this formal/child was previo\ 1430 
   usly supplied"
 "too few actual parameters"    1496 
 "too few child patterns"       1836 
 "too few expressions or argum\ 1460 
   ents"
 "too few patterns for rule"    1804 
 "too few result patterns"      1874 
 "too many actual parameters"   1504 
 "too many child patterns"      1845 
 "too many expressions or argu\ 1465 
   ments"
 "too many patterns for rule"   1811 
 "too many result patterns"     1885 
 "TransformPatternRecurse, alr\ 1154 
   eady transformed."
 "tree type not declared"       2329 
 "tree-type required"            368  1737 
 "TRUE"                         2169 
 "Undefined External Names"     2213 
 "user-type required"            382 
 "yyV"                          2124 

-'-
 'A'                            2148 
 'c'                            2147  2601 
 'Composed node not in formal/\ 1552 
   child type, specifically:'
 'Decompose node not in formal\ 1943 
   /child type, specifically:'
 'e'                            1577  1612 
 'g'                            1799  1834  1872 
 'J'                            1917 
 'j'                            1914 
 'k'                            2063 
 'o'                            2211 
 'p'                             996  1034  1076  1228  1292 
 'pattern containing multi-val\ 1267 
   ued types not allowed as actual t
 'Result type of puma function\ 1630 
    not in formal/child type, specif
 's'                            1579  1614 
 'TransformExpr, undistinguish\ 1250 
   ed DontCare'
 'TransformPatternRecurse, und\  837 
   istinguished DontCare'
 'Type of label reference not \ 1570 
   in formal/child type, specificall
 'Type of node field not in fo\ 1733 
   rmal/child type, specifically:'
 'u'                            1019 
 'v'                            1579  1614 

-0-
 0                               207   213   431   433   530  1394  1400  1410 
                                1421  2245  2261  2434  2454  2566  2602  2604 

-1-
 1                               398   446   529   626   706   753   768   790 
                                 813  1264  1405  1407  1417  1441  2216  2461 
                                2542 

-5-
 50000                          1394 

-A-
 ActClass                        184  1655  1659  1671  1716  1718  1720  2343 
                                2344  2348  2348  2349  2354  2355  2399  2400 
                                2401  2402  2403  2471  2474  2479  2480  2489 
                                2736  2738  2740 
 ActNames                        168  2658  2660  2713  2715  2721  2784  2830 
                                2835 
 ActTree                         183  2378  2399  2433  2471  2479  2498  2499 
                                2506  2507 
 ActTypes                        167   333   335   336  2327  2336  2339  2346 
                                2348  2356  2380  2401  2410  2416  2437  2455 
                                2456  2459  2506 
 AddDecl                        1904  1927  1966  2030  2099 
 ADR                             130  1408  1414 
 Adr                            1372  1372  2634  2635  2639  2645 
 AND                             314   395   626   845   847   909   911   928 
                                 929   932   996  1035  1036  1037  1077  1078 
                                1079  1185  1186  1228  1289  1290  1352  1456 
                                1480  1480  1481  1481  1492  1566  1573  1574 
                                1575  1579  1600  1608  1609  1614  1625  1645 
                                1646  1647  1651  1714  1795  1834  1872  1917 
                                1945  1948  1990  2068  2211  2323  2331  2352 
                                2589  2590  2597  2836 
 Any                            2724  2855 
 Anys                           2725  2856 
 Append                          134 
 Args                            176  2279  2284  2285  2288  2293  2298  2299 
                                2302  2303  2306  2391  2391  2392  2393  2466 
                                2468  2472  2474  2482  2484  2487  2489 
 ARRAY                           339  1394 
 ArrayToString                   134  2124  2163  2165  2167  2169  2441  2869 
 Assert                          139   481 
 Assertions                      139 
 AssertPos                       139   534   541   547   573   578   584   616 
 Assign                          145   373  2569 
 AssignEmpty                     142  2236  2238  2250  2252  2281  2295  2439 
                                2456 
 Assignment                     1371  1371  2633  2779 
 AttrDesc                       1150  1335  1670  1671  1708  1710 
 Attribute                      1720  1726  2476  2718  2721  2740  2744  2835 
                                2836 
 AttributePos                   1725  1732  2744 

-B-
 BaseClass                       438   442   453   454  2452 
 BEGIN                           206   218   229   239   249   263   278   289 
                                 299   332   340   365   393   422   466   528 
                                 718   745   767  1163  1341  1396  1454  1473 
                                1490  1513  1541  1753  1793  1826  1865  1908 
                                1934  2122  2132  2146  2158 
 Binary                          572   574   576   579   581   583   585   587 
                                 589   927   928   929   932   938   939   945 
                                 948  1031  1032  1185  1186  1187  1189  1196 
                                1200  1201  1285  1286  1600  1601  1603  1641 
                                1642  1760  1760  2698  2816 
 BinaryCompound                 1313  1314  1687  1688  1765  1766 
 BOOLEAN                         197   462   513   526   714  2525 
 BY                             1441 

-C-
 Call                            969   980  1148  1215  1221  1252  1252  1349 
                                1349  1350  1350  1351  1351  1362  1364  1365 
                                1595  1595  2622  2625  2693  2772  2811 
 CallFormal                     1780  1893  1925 
 CantHappen                      139   598   836  1154  1249 
 CantHappenPos                   139   695 
 CARDINAL                        125   200   275   515   525   743   761   765 
                                1162  2524 
 CarryOut                        462   469   473   479   492   500 
 CASE                            467   532   653   769  1164  1342  1542  1754 
                                1909  1935 
 CHAR                            339 
 Check                          2239  2240  2246  2253  2254  2255  2262  2512 
                                2521  2572  2573  2575  2586  2619  2625  2626 
                                2630  2631  2645  2646  2647  2653  2659  2661 
                                2664  2667  2668  2671  2672  2675  2677  2687 
                                2690  2691  2694  2695  2696  2699  2700  2705 
                                2708  2709  2714  2722  2726  2752 
 CheckCallExprs                 1489  1507  1509  1620  1621  1632 
 CheckCallPatterns              1633  1859  1902 
 CheckExpr                      1467  1531  1534  1555  1597  1746  1773  1980 
 CheckExpr2                     1557  1623  1748  1761  1762  1768  1769  1775 
                                1982 
 CheckExprList                  1453  1468  1470  1559  1701  2574 
 CheckExprVar                   1506  1511  1532  1674  1675  1678  1679  1682 
                                1683  1690  1691  1695  1700  1705  2112  2584 
                                2622  2629  2639  2641  2643 
 CheckInParams                  1472  1485  1487  1635 
 CheckPattern                   1813  1849  1891  1929  2118 
 CheckRulePatterns              1783  1814  1815  2570 
 CheckSubPatterns               1817  1857  2005 
 CheckSubtype                    339   361  1550  1568  1627  1729  1941 
 CheckTargetCode                2607  2608  2610  2612  2656  2756  2769  2772 
                                2773  2776  2777  2780  2781  2785  2787  2790 
                                2793  2794  2797  2798  2801  2802  2805  2808 
                                2809  2812  2813  2814  2817  2818  2823  2826 
                                2827  2831  2853  2857 
 CheckType                       363   387  2070 
 Child                          2470 
 ChildFormal                    1779  1850  1913 
 Class                           161   248   252   253   253   264   265   277 
                                 280   282   283   283   317   321   395   397 
                                 398   399   431   433   436   437   438   440 
                                 441   442   446   448   453   454   617   622 
                                 956  1209  1210  1520  1551  1559  1659  1671 
                                1718  1720  1942  1945  1952  1958  1965  1968 
                                1975  2001  2005  2338  2348  2348  2401  2402 
                                2409  2415  2452  2453  2454  2458  2465  2474 
                                2489  2497  2505  2738  2740 
 class                           262   267   268   268 
 ClassCount                      372  2327  2336  2346  2356  2434  2438  2455 
                                2498  2499  2507 
 Classes                         125   252   275   279   280   281   292   331 
                                 334   554   592   682   887   944  1045  1119 
                                1196  1297  2338  2339  2378  2413  2435  2445 
                                2446  2457  2461  2471  2479 
 ClassFormals                   2205  2421  2446  2463  2467 
 ClassLUB                        418   459  2403 
 ClassOfNodeTypes                288   295   319  1656  1717  2737 
 ClassTypes                     2445  2503 
 CollectExtern                  2207  2237  2251  2267  2271 
 CollectRoutineNames            2174  2188  2209 
 CollectUniversalTypeDesc       2413  2417  2457 
 Complement                      144 
 Compose                         839   840  1179  1179  1234  1300  1362  1514 
                                1515  1518  1520  1520  1544  1544  1772  2589 
                                2689  2807 
 ComputeDepthsClasses            389   398   401  2461 
 Concatenate                     134  2126  2443  2871 
 Condition                      1357  1367  2628  2775 
 CopyTree                        162   476   488  2554  2555  2556 
 CountClasses                   2435  2495 
 Current                         480   497   501 

-D-
 DeclaredTypeIsGuaranteed       1994  1995  2078  2079  2392  2395 
 Decls                           175  1564  1649  1712  1757  1912  1912  1923 
                                1923  1991  1993  1994  1996  1999  2001  2043 
                                2043  2066  2075  2077  2078  2080  2083  2085 
                                2280  2289  2294  2307  2394  2394  2395  2396 
                                2568  2600  2635  2718  2734  2836 
 Decompose                       483   641  1011  1061  1937  1937  2004  2674 
                                2800 
 Depth                           397   431   433   436   437   440   441   446 
 Designator                     2728  2857 
 dFormals                        173  1555  1597  1620  1621  1674  1675  1678 
                                1679  1682  1683  1690  1691  1695  1700  1701 
                                1773  1980  2159  2159  2159  2622  2629  2639 
                                2643 
 Difference                      144 
 DO                              208   220   231   240   251   264   265   280 
                                 396   438   442   445   787   806   841   989 
                                1033  1075  1167  1172  1179  1226  1252  1287 
                                1315  1320  1324  1329  1348  1351  1371  1398 
                                1403  1407  1411  1419  1441  1462  1478  1498 
                                1544  1562  1589  1595  1643  1689  1694  1699 
                                1704  1710  1756  1760  1767  1878  1937  2010 
                                2049  2135  2216  2541 
 DontCare                        727   835  1248  1463  1479  1499  1500  1809 
                                1843  1851  1879  1880  1895  2103  2105 
 DontCare1                       730   775   835   909  1248  1522  1523  1526 
                                1528  2590 
 DontCare1Explicit               832  1243  2094 
 DontCare1Internal               832  1244  2095 
 DontCareExplicit                831  1245  2092 
 DontCareInternal                831  1246  2093 
 Dummy                           162  2477 
 DummyFormal                    2159 
 DynArray                        133 

-E-
 ELSE                            318   323   326   371   435   452   499   598 
                                 615   630   678   695   702   709   733   736 
                                 754   781   793   816   868   874   884   896 
                                 904   916   949   962   972   993  1018  1023 
                                1062  1065  1068  1097  1109  1116  1128  1142 
                                1203  1213  1218  1236  1255  1307  1366  1434 
                                1444  1519  1527  1556  1604  1636  1673  1677 
                                1681  1728  1736  1739  1744  1803  1883  1953 
                                1972  1981  1987  1998  2025  2033  2041  2072 
                                2082  2115  2140  2150  2185  2229  2313  2328 
                                2342  2357  2360  2381  2384  2404  2486  2546 
                                2583  2603  2614  2636  2642  2746  2749  2766 
 ELSIF                           303   308   311   345   348   352   356   369 
                                 380   383   425   427   429   431   433   724 
                                 730   908   927  1012  1185  1271  1362  1364 
                                1428  1522  1572  1579  1600  1614  1622  2331 
                                2352 
 EmptyType                      2020  2024  2437  2438  2439 
 END                             210   212   214   221   223   225   232   234 
                                 236   241   243   245   253   255   258   266 
                                 268   270   271   273   279   281   283   285 
                                 286   295   322   325   328   329   337   351 
                                 359   360   361   377   379   385   386   387 
                                 400   401   439   443   455   456   458   459 
                                 502   503   504   505   599   632   645   646 
                                 647   669   694   699   700   701   704   705 
                                 711   712   735   738   739   740   756   758 
                                 783   800   802   823   825   873   901   902 
                                 903   907   925   947   953   971   983   984 
                                 985  1025  1027  1028  1029  1064  1067  1070 
                                1071  1108  1139  1140  1141  1145  1146  1157 
                                1158  1170  1177  1183  1197  1202  1206  1217 
                                1223  1224  1239  1240  1257  1270  1282  1283 
                                1304  1305  1306  1310  1311  1318  1322  1327 
                                1331  1336  1338  1360  1361  1368  1369  1374 
                                1381  1384  1398  1399  1404  1407  1416  1436 
                                1439  1446  1447  1451  1458  1461  1463  1466 
                                1469  1470  1477  1479  1484  1486  1487  1494 
                                1497  1502  1505  1508  1509  1521  1529  1530 
                                1532  1547  1553  1558  1560  1571  1581  1586 
                                1587  1592  1593  1606  1617  1619  1631  1638 
                                1639  1676  1680  1684  1685  1692  1697  1702 
                                1706  1735  1738  1741  1742  1745  1746  1758 
                                1763  1770  1774  1775  1797  1805  1807  1809 
                                1812  1815  1837  1839  1846  1848  1854  1856 
                                1857  1875  1877  1887  1888  1898  1900  1901 
                                1902  1921  1924  1926  1927  1955  1961  1962 
                                1976  1983  1989  2002  2003  2006  2029  2036 
                                2044  2045  2047  2065  2071  2086  2088  2090 
                                2109  2117  2118  2128  2139  2142  2143  2153 
                                2154  2187  2219  2220  2221  2231  2315  2330 
                                2350  2351  2359  2362  2386  2388  2406  2490 
                                2491  2561  2563  2582  2594  2595  2596  2599 
                                2606  2611  2616  2617  2618  2638  2644  2652 
                                2680  2721  2745  2748  2751  2768  2852  2873 
 Error                           137   346   347   349   350   370   612   659 
                                 665   674   807   863  1092  1173  1266  1276 
                                1363  1460  1465  1496  1504  1528  1637  1804 
                                1811  1836  1845  1874  1885  1986  2026  2040 
                                2064  2184  2312  2329  2358  2383  2405  2579 
                                2598  2651  2765  2851 
 ErrorI                          137  1022  1422  1429  1578  1613  1723  1737 
                                1740  2228  2743  2747  2750 
 Exclude                         146  2873 
 EXIT                            645   656   693   701   703  1838  1847  1876 
                                1882  1886  2613 
 ExpandDecompose                 507   712   869   897   958  1098  1129 
 EXPORT                          116 
 Expr                            510   532   535   535   537   539   539   540 
                                 544   546   550   560   561   561   568   570 
                                 574   576   579   581   583   585   587   589 
                                 596   619   619   649   658   661   667   671 
                                 676   688   689   689   726   775   778   782 
                                 788   809   809   811   842   844   844   846 
                                 847   847   851   851   853   853   870   883 
                                 895   898   906   909   910   911   915   917 
                                 921   924   926   927   928   929   932   938 
                                 939   945   948   951   951   959   965   975 
                                1077  1079  1082  1083  1088  1110  1111  1115 
                                1127  1144  1151  1168  1168  1175  1175  1176 
                                1180  1181  1183  1184  1185  1186  1187  1189 
                                1196  1200  1201  1205  1205  1214  1219  1253 
                                1254  1258  1258  1321  1321  1325  1325  1330 
                                1330  1373  1373  1413  1435  1463  1465  1465 
                                1467  1479  1480  1481  1481  1482  1483  1499 
                                1500  1504  1504  1506  1555  1557  1597  1598 
                                1599  1600  1601  1603  1623  1695  1700  1705 
                                1980  1982  2112  2533  2533  2555  2577  2580 
                                2580  2584  2586  2589  2597  2598  2598  2610 
                                2629  2630  2641  2643  2646  2671  2675  2687 
                                2690  2694  2705  2708  2714  2776  2780  2797 
                                2801  2805  2808  2812  2823  2826  2831 
 Exprs                           512   540   622   846   847   853   870   898 
                                 908   959   966   976  1078  1079  1082  1210 
                                1210  1211  1211  1214  1219  1259  1259  1326 
                                1326  1389  1397  1398  1398  1398  1399  1401 
                                1402  1403  1403  1409  1411  1413  1414  1415 
                                1415  1419  1420  1424  1425  1431  1432  1435 
                                1438  1438  1440  1443  1443  1445  1445  1448 
                                1559  1620  1632  1635  1701  2531  2531  2532 
                                2532  2554  2574  2575  2608  2691  2695  2709 
                                2809  2813  2827 
 Extensions                      267   282   398  2348  2402  2508 
 Extern                         2207  2237  2251 
 ExternNames                     165  1012  1572  1608  2151  2152  2199  2207 
 Extract                         143 

-F-
 f                               160 
 Fail                           1377  2515  2649 
 FALSE                           500   734   737  1009  1059  1104  1135  1233 
                                1299  1483  1666  1892  1938  1975  2027  2034 
                                2034  2096  2244  2282  2296  2392  2395  2567 
                                2585  2762 
 FDepth                          389   397   398 
 FOR                            1407  1441  2216 
 ForallAttributes                160  2467 
 ForallClasses                   160   334  2402  2435  2445  2446 
 ForallDo                        144 
 Formal                          208   210   211   241   242   297   300   303 
                                 303   305   305   308   308   310   310   311 
                                 311   313   314   317   319   319  1402  1403 
                                1456  1468  1475  1480  1481  1482  1483  1485 
                                1492  1507  1516  1518  1524  1526  1548  1551 
                                1566  1569  1569  1625  1628  1629  1651  1656 
                                1714  1717  1730  1731  1795  1813  1814  1832 
                                1850  1855  1870  1890  1899  1939  1942  1944 
                                1954  1967  1993  2011  2013  2031  2068  2070 
                                2070  2077  2085  2097  2100  2101  2133  2135 
                                2735  2737 
 FormalKind                     1905  1909  1930  1967  2031  2100 
 FormalKindTyp                  1777  1905  1930 
 Formals                         204   208   210   211   211   622  1210  1387 
                                1401  1420  1453  1456  1464  1467  1468  1472 
                                1475  1480  1485  1489  1492  1500  1503  1506 
                                1507  1511  1516  1518  1524  1526  1531  1534 
                                1548  1551  1559  1566  1569  1625  1628  1659 
                                1705  1720  1730  1783  1795  1810  1813  1813 
                                1814  1817  1828  1859  1867  1930  1939  1942 
                                1944  1947  1948  1951  1954  1967  1990  1993 
                                1995  1997  2005  2011  2013  2031  2068  2070 
                                2074  2077  2079  2081  2085  2096  2097  2100 
                                2101  2112  2131  2133  2135  2453  2468  2740 
 FPath                          1817  1850  1905  1912  1923  1930  1965  1975 
                                1993  2004  2022  2027  2046  2077  2085  2089 
                                2096  2105  2113  2116 
 FROM                            117   118   119   130   131   132   133   134 
                                 135   136   137   138   139   141   149 
 Function                       1354  1624  1629  2181  2249  2292 

-G-
 General                         131 
 GetString                       135  2442  2870 
 GLOBAL                          128 
 GlobalLUBClass                  202  2322  2341  2349  2393  2396  2403  2403 

-H-
 HasLocals                       193  2567  2602  2604  2760 
 HasPatterns                    2587  2588  2605 
 HasReject                      2578  2877  2880 
 HasTempos                      2602  2604 

-I-
 i                               124   125   200   205   207   209   210   216 
                                 221   227   232   238   241   247   252   275 
                                 281   282   284  1391  1407  1407  1410  1412 
                                1413  1417  1418  1420  1421  1428  1435  1437 
                                1441  1442  1445  2216  2217  2218  2867  2872 
                                2873  2873 
 Ident                           204   210   260   266   267  2717  2834 
 IdentDot                        189   562   574   690   928  1035  1288  1644 
                                2164 
 IdentEmptyType                  190  2022  2166 
 IdentFalse                      191  2151  2168 
 IdentifyClass                   252   260   267   273   553   591   681   886 
                                 943  1044  1118  1196  1297  2399  2471  2479 
 IdentifyClass2                  247   258   857   920   994  1086  1181  1227 
                                2343  2354 
 IdentifyProc                    227   236   924  1183  1254  2226 
 IdentifyTree                    216   225   876   937  1040  1110  1189  1294 
                                2325  2333 
 IdentifyVar                     124   238   245  1564  1649  1658  1712  1720 
                                1757  2066  2635  2718  2734  2740  2836 
 Idents                          117   135 
 IdentTrue                       192  2152  2170 
 IF                              210   221   232   241   253   266   268   279 
                                 281   283   300   305   313   341   342   353 
                                 366   367   375   381   423   446   492   495 
                                 610   626   645   649   663   672   701   706 
                                 721   727   746   775   790   813   842   844 
                                 854   861   879   891   917   922   940   954 
                                 956   990   995  1019  1034  1041  1048  1076 
                                1083  1090  1112  1123  1180  1182  1195  1198 
                                1208  1209  1228  1253  1260  1264  1288  1292 
                                1295  1298  1350  1352  1399  1421  1442  1455 
                                1459  1463  1464  1474  1479  1480  1491  1495 
                                1499  1503  1514  1516  1524  1545  1548  1554 
                                1563  1565  1577  1590  1596  1598  1608  1612 
                                1624  1644  1650  1660  1711  1713  1721  1794 
                                1798  1799  1809  1810  1830  1832  1841  1843 
                                1851  1869  1870  1879  1884  1895  1914  1916 
                                1939  1944  1947  1956  1977  1984  1985  1990 
                                2011  2014  2037  2038  2060  2063  2067  2074 
                                2097  2133  2147  2182  2211  2217  2227  2311 
                                2323  2326  2334  2344  2355  2377  2382  2400 
                                2477  2480  2542  2548  2576  2577  2578  2588 
                                2597  2601  2609  2613  2634  2640  2650  2680 
                                2720  2733  2735  2741  2764  2835  2873 
 IMPORT                          117   118   119   130   131   132   133   134 
                                 135   136   137   138   139   141   149 
 INC                             209   624   679  1403  1412  2123  2498  2564 
 Include                         143   335  1582  1618  1922  1988  2042  2073 
                                2151  2152  2186  2270  2314  2385  2401  2410 
                                2485  2520  2721  2767 
 Index                           281   331   335   533   535   537   539   540 
                                 544   550   560   561   649   688   689   842 
                                 844   846   847   851   853  1073  1074  1324 
                                1324  1699  1699  2338  2348  2401  2410  2454 
                                2499  2508  2565  2707  2825 
 InForm                         1632  1635  2241  2256  2284  2298 
 InFormals                       177  2241  2256  2529  2570 
 InitPredefinedExtern           2145  2154  2200 
 InParams                       2239  2253  2283  2297 
 INTEGER                         186   204   205   331   389   420  1392 
 Intersection                    146   374 
 IntToString                     134  2125 
 IO                              132 
 IsAllDontCares                  714   740   908 
 IsElement                       143   996  1012  1013  1014  1015  1019  1034 
                                1076  1228  1292  1563  1572  1573  1574  1575 
                                1577  1579  1579  1608  1609  1610  1612  1614 
                                1614  1647  1711  1799  1834  1872  1914  1916 
                                1917  1985  2038  2060  2063  2147  2148  2182 
                                2211  2217  2311  2601  2733  2764  2835 
 IsEmpty                         143   375  2211 
 IsExtern                       2230 
 IsFunction                      194  2244  2260  2576  2597  2609  2650 
 IsNotEqual                      146  1956  2017 
 IsOutput                        195  1480  1482  2282  2286  2296  2300  2304 
                                2389  2762 
 IsProperlyNarrowed             1938  1960  1965  2016  2022 
 IsRef                          2317 
 IsRegister                     1483 
 IsSubset                        145   348 
 IsType                          161   208   303   308   311   313   482   727 
                                 730   775   845   909   910  1078  1402  1456 
                                1463  1475  1479  1492  1499  1516  1522  1524 
                                1548  1566  1622  1625  1795  1809  1832  1843 
                                1851  1870  1879  1895  1939  1947  2011  2068 
                                2097  2133  2590 

-K-
 Kind                            220   231   240   251   264   279   341   342 
                                 352   353   366   367   380   381   395   427 
                                 429   467   495   532   535   542   548   566 
                                 579   585   617   649   653   663   672   721 
                                 724   746   769   842   844   847   917   927 
                                 929   932   956  1036  1037  1077  1079  1164 
                                1180  1185  1186  1187  1209  1253  1271  1289 
                                1290  1342  1350  1353  1354  1357  1362  1364 
                                1367  1398  1399  1411  1419  1455  1459  1464 
                                1474  1480  1481  1491  1495  1503  1514  1542 
                                1598  1600  1601  1624  1645  1646  1651  1714 
                                1754  1794  1798  1810  1830  1841  1869  1884 
                                1935  1944  1945  1990  2014  2074  2323  2331 
                                2352  2577  2589  2597  2634  2735 

-L-
 L1stVarUse                      763   852   858   860   865   888   890  1082 
                                1087  1089  1094  1096  1120  1122 
 LabelNames                      170  1563  1582  1647  1711  1916  1922  1985 
                                1988  2038  2042  2060  2073  2196  2569  2733 
                                2764  2767 
 Last                           1390  1408  1414  1448 
 LAttrFormal                    1537  1657  1660  1719  1721  1731  2731  2739 
                                2741 
 LC                              391   394   395   395   397   398   399   399 
 LCarryOut                       526   629   631   645 
 LClass                          298   319   321   523   552   557   569   590 
                                 595   610   617   622   641   680   685   763 
                                1043  1048  1051  1061  1085  1089  1090  1117 
                                1122  1123 
 LClassCount                     525   529   679 
 LClasses                        523   540   542   546   566   652   652   653 
                                 658   671 
 LClassVarUse                    523   546   548   555   557   563   568   569 
                                 589   593   595   613   655   658   661   663 
                                 667   671   672   676   683   685   691   697 
                                 701 
 LCurrent                        464   480   483   488   494   494   495   501 
 LDecomposeExpr                  524   558   570   596   637   686 
 LDepth                          420   436   437   440   441 
 Left                            418   423   426   427   430   431   434   437 
                                 438   438   440   444   446   448   448   451 
                                 453   453   457 
 LExpr                           716   726   727   730 
 LExprs                          716   719   721   724   726   732   732 
 LFormals                       1825  1828  1832  1841  1850  1850  1855  1855 
                                1864  1867  1870  1880  1884  1890  1892  1899 
                                1899 
 LFormalTypeDesc                1933  1950  1954  1957 
 LHasExactlyOneClass             526   565   571   597   626 
 Line                           2552 
 LIsLast                        2525  2545  2547  2548  2613 
 LNewRule                       2528  2550  2559 
 LNextCount                      765   789   801   812   824 
 LObject                        1538  1649  1650  1651  1656  1670 
 LObject1                       1161  1294  1295  1297  1301 
 LObject2                       1161  1296  1298  1300  1302 
 LOCAL                          2430 
 LocExternNames                  166  1013  1573  1609  2202  2236  2237  2250 
                                2251 
 LONGINT                        1393 
 LookupClass                     125   275   282   284   286   291 
 LookupFormal                    204   214  1420 
 LOOP                            600   625   651   720  1829  1868  2535 
 Lop                             579   583   929   938   939  1036  1040  1050 
                                1186  1189  1200  1289  1294  1301  1308  1308 
                                1316  1316  1601  1603  1645  1647  1649  1665 
                                1674  1678  1682  1690  1761  1768  2699  2817 
 LOperands                       523   621   623   623   628   631 
 LOperandsCount                  525   623   624   626 
 LParam                         1931 
 LPath                          1932  1963  1969  1973  2001  2005  2022  2027 
                                2031  2034  2043  2096  2102 
 LPattern                       1825  1840  1843  1845  1850  1851 
 LPatternCount                  1162  1261  1264  2524  2530  2542 
 LPatterns                       524   633   641   643  2526  2529  2530  2530 
                                2544  2547 
 LPrefixVarUse                   763   851   854   859   877   878 
 LResult                         524   531   642   643   708   710  1539  1662 
                                1670  1671  1672 
 LSingleOperands                 524   628   631   638 
 LSinglePatterns                2527  2547  2562 
 LSuffix                         464   473   476   479   490 
 Lt                             1825  1827  1830  1836  1840  1853  1853  1864 
                                1866  1869  1874  1878  1897 
 LThisCount                      765   788   790   801   811   813   824 
 LTree1                          764   778   780   788   792   796   798   811 
                                 815   819   821 
 LTree2                          764   789   792   797   812   815   820 
 LTreeName                       523   539   554   583   592   682   763   858 
                                 859   875   878   879   887  1040  1041  1045 
                                1050  1087  1088  1110  1111  1112  1119 
 LTypeDesc                      1931  2013  2014  2018  2019  2023  2024  2027 
                                2028  2031  2035  2043 

-M-
 MakeArray                       133  1406 
 MakeIdent                       135  2127  2164  2166  2168  2170  2450  2872 
 MakeSet                         142   372  2195  2196  2197  2198  2199  2202 
                                2203  2204  2327  2336  2346  2356  2438  2455 
                                2507  2657  2712 
 MakeTempoIdent                 1515  1523  1889  2120  2128  2138  2593 
 MakeTempos                     1500  1880  2131  2138  2143 
 MakeText                        136 
 MakeTypes                       331   337  2337  2347  2508 
 mAttrDesc                       157  1663 
 Max                             131  1437 
 MaxIdent                        135  2194  2657  2712 
 Maximum                         145  1392  1418  1437  1437  1441 
 mBinary                         155   559   687 
 mCall                           150   963   973  1214  1219 
 mClass                          155  2449 
 mCompose                        151  1233  1299 
 mConsType                       158  1964  1974  2022  2027  2096 
 mDecompose                      151   634  1003  1053 
 mDontCare1Internal              152  1443 
 mDontCareInternal               152   750   867  1008  1058  1096  1103  1134 
                                1233  1299  1440 
 mDummyFormal                    159  2159 
 mField                          158  1850 
 Minimum                         145   293  1392  1417  1441 
 mNilTest                        153   829 
 mNoClass                        158 
 mNodeTypes                      156  2380  2437  2459  2506 
 mNoExpr                         159   977  1219  1233  1299  1440 
 mNoFormal                       156  2162 
 mNoPattern                      153   470   751   772   967  1008  1058  1103 
                                1134  1214 
 mNoPatternsList                 154   531 
 Mode                            196  2317  2389 
 mOneExpr                        159  1176  1233  1299  1440  1443  1445 
 mOnePattern                     153   475   487   749   792   815  1007  1057 
                                1102  1133 
 mOnePatternAlts                 154   795   818 
 mOnePatternsList                154   643 
 mParents                        151 
 mPlainFormal                    156  1912  1923  2000  2043  2084  2137  2473 
                                2483  2488 
 mRoutineFormal                  156  1992  2076  2391  2394 
 mRule                           153  2551 
 mUserType                       157  2387  2484 
 MustBeLabel                     911   990 
 mValue                          159   782   882   894   906   970   982  1017 
                                1063  1066  1069  1114  1126  1144  1151 
 mVar                            158  1892  2034  2389 
 mVarDef                         155   992  1026 
 mWriteStr                       160  1365 

-N-
 n                              1391  1400  1403  1405  1407 
 Name                            210   221   232   241   266   317   321   555 
                                 593   683   854   858   877   888   921   924 
                                 938   945   992   994  1012  1013  1014  1015 
                                1022  1026  1040  1046  1083  1087  1110  1120 
                                1181  1183  1189  1196  1227  1254  1294  1297 
                                1420  1425  1432  1563  1564  1572  1573  1574 
                                1575  1578  1580  1582  1599  1603  1647  1649 
                                1659  1665  1667  1671  1711  1712  1718  1737 
                                1740  1757  1850  1905  1912  1916  1920  1922 
                                1923  1965  1967  1975  2031  2060  2066  2073 
                                2077  2085  2100  2182  2186  2225  2226  2228 
                                2269  2270  2311  2314  2316  2323  2325  2331 
                                2333  2343  2352  2354  2354  2358  2382  2385 
                                2387  2398  2399  2442  2474  2484  2489  2520 
                                2635  2738  2761  2764  2767  2870 
 NamedExpr                       657   658   804   805  1172  1172  1175  1419 
                                1420  1424  1425  1431  1432  1435  1438 
 NamePos                        1424  1431 
 Names                          2267  2270  2271  2323  2331  2352  2354  2358 
                                2379 
 Next                            211   222   233   242   254   269   284   399 
                                 473   479   494   566   652   732   789   812 
                                1169  1169  1176  1365  1382  1382  1398  1403 
                                1414  1415  1438  1468  1468  1485  1485  1507 
                                1507  1814  1814  1853  1855  1897  1899  2138 
                                2159  2188  2232  2247  2263  2271  2290  2308 
                                2319  2407  2417  2463  2521  2557  2559  2614 
                                2619  2626  2631  2647  2653  2661  2664  2668 
                                2672  2722  2726  2752  2769  2773  2777  2781 
                                2787  2790  2794  2798  2853  2857  2874  2880 
 NextPatterns                    461   472   478   505   631  2547 
 NIL                             395  1650  1713  2067  2570 
 Nil                             827   829   829  1242  1589  1589 
 NilTest                        2008  2009  2046  2682 
 Nl                             1379 
 nNoFormal                       201  2141  2162  2279  2280  2285  2293  2294 
                                2299  2303  2466 
 NoClass                         279   427   429 
 Node                            180   217   219   220   221   221   222   222 
                                 228   230   231   232   232   233   233   238 
                                 240   241   241   242   242  2380  2387  2391 
                                2394 
 node                            124 
 NodeTypes                       288   292   292   293   293   311   341   345 
                                 345   348   348   353   366   369   369   372 
                                 373   374   381   449  1652  1714  1944  1945 
                                1957  1958  2014  2018  2019  2020  2024  2416 
                                2438  2439  2507  2508  2735 
 NoExpr                          566   654   721   746   750   751   771   772 
                                1165  1399  1455  1459  1460  1474  1491  1495 
                                1496  2577  2597 
 NoFormal                        240  1464  1503  1810  1841  1884 
 NoIdent                         135   302   307   324   327   854  1005  1055 
                                1083  1100  1131  1233  1299  1545  1590  1605 
                                1984  2034  2037  2323  2331  2352  2382 
 NoName                         2323  2331  2352 
 Nonterminal                     162  2450 
 NoPattern                       468   470  1153  1794  1798  1804  1830  1836 
                                1869  1874 
 NoPatternsList                  495 
 NoPosition                      138  1440  1440  1443 
 NoRoutine                       231 
 NoStatement                    1343 
 NOT                             348  1456  1475  1482  1492  1572  1573  1574 
                                1575  1579  1608  1609  1610  1614  1795  1834 
                                1843  1851  1872  1895  2063  2211  2548  2578 
                                2590  2597 
 NoTree                          150   224   235   244   253   256   257   268 
                                 272   279   283   300   305   314   423   425 
                                 610   655   701   861   879   891   922   940 
                                 952   954   995  1041  1048  1090  1112  1123 
                                1182  1195  1198  1200  1201  1204  1208  1228 
                                1237  1256  1260  1295  1298  1352  1407  1428 
                                1442  1481  1554  1565  1596  1660  1721  1948 
                                1977  2028  2035  2087  2159  2227  2322  2326 
                                2334  2344  2355  2361  2377  2400  2451  2451 
                                2451  2452  2453  2474  2480  2484  2489  2553 
                                2637  2640  2680  2720  2741  2836 

-O-
 Object                          539   557   569   583   595   641   685   856 
                                 859   860   860   861   878   885   890   890 
                                 891   919   922   924   926   926   936   939 
                                 939   940   942   944   948   948   952   954 
                                 956   969   969   980   980   994   995  1000 
                                1000  1011  1011  1050  1051  1061  1088  1089 
                                1111  1122  1181  1182  1183  1184  1184  1189 
                                1195  1196  1196  1198  1200  1201  1204  1208 
                                1209  1210  1215  1215  1221  1221  1227  1228 
                                1234  1234  1237  1254  1256  1260  1300  1301 
                                1302  1352  1353  1354  1481  1481  1482  1483 
                                1520  1551  1554  1559  1564  1565  1569  1596 
                                1622  1624  1629  1632  1633  1635  1670  1712 
                                1713  1714  1717  1757  1942  1945  1958  1965 
                                1968  1975  1977  2001  2005  2066  2067  2070 
                                2087  2226  2227  2230  2635  2637  2640  2641 
                                2680  2718  2720  2734  2735  2737 
 OF                              339   467   532   653   771  1164  1342  1394 
                                1542  1754  1910  1935 
 OneExpr                         542   546   566   652   670   671   724   726 
                                 732   785   786   846   847   853  1078  1079 
                                1082  1167  1167  1271  1398  1398  1411  1413 
                                1414  1415  1462  1478  1498  2670  2796 
 OnePattern                      471   473   476  1153  1808  1814  1840  1853 
                                1878  2666  2792 
 OnePatternAlts                  477   479   480   497   498   501  1153 
 OnePatternsList                 483   488   494   708 
 Operator                        574   928  1035  1288  1644 
 Options                         161   996  1019  1034  1076  1228  1292  1577 
                                1579  1579  1612  1614  1614  1799  1834  1872 
                                1914  1917  2063  2147  2148  2211  2601 
 OR                              910  1013  1014  1015  1354  1475  2148  2389 
                                2602  2604  2605 
 ORD                             996  1019  1034  1076  1228  1292  1577  1579 
                                1579  1612  1614  1614  1799  1834  1872  1914 
                                1917  2063  2147  2148  2211  2601 
 OutForm                        1633  2242  2257  2288  2302 
 OutFormals                      178  2242  2257  2531  2574 
 OutParams                      2240  2254  2287  2301 

-P-
 Param                          2310  2519  2758 
 ParamDecls                     2243  2259  2289  2307 
 Parameters                      174  2243  2259  2568  2656 
 ParamName                       188  2316  2389  2391  2394  2761 
 ParamNames                      171  2197  2238  2252  2281  2295  2311  2314 
                                2520  2569 
 Parents                         774   775   778  1329  1329  1704  1704  2704 
                                2822 
 Path                           1480  1481  1482  1483  1813  2004  2046  2089 
                                2105  2113  2116  2138 
 Pattern                         476  1792  1808  1808  1809  1811  1811  1813 
                                1840  1845  1879  1880  1885  1885  1889  1889 
                                1890  1890  1892  1892  1892  1895  2116  2667 
                                2793 
 PatternCount                    515   530   624   706   743   753   755   761 
                                 768   778   801   824   871   899   960  1106 
                                1137 
 Patterns                        462   467   470   473   476   479   480   483 
                                 488   497   498   501   708  1261  1261  1271 
                                1281  1281  1621  1633  2005  2529  2544  2562 
                                2570  2572  2607  2677  2696  2802  2814 
 PatternsList                    498 
 PatternsPtr                    1394  1406  1407  1413  1428  1435  1442  1445 
                                1449 
 PatternsSize                   1393  1405  1406  1449 
 POINTER                        1390  1394 
 Pos                             339   343   344   346   347   349   350   354 
                                 355   357   358   363   368   370   376   382 
                                 384   470   508   537   544   550   560   576 
                                 581   587   613   619   635   661   667   676 
                                 688   697   750   751   772   782   809   829 
                                 865   867   870   883   895   898   906   959 
                                 964   967   970   974   977   982   992  1004 
                                1008  1008  1017  1022  1026  1054  1058  1058 
                                1063  1066  1069  1094  1096  1099  1103  1103 
                                1115  1127  1130  1134  1134  1144  1151  1175 
                                1214  1214  1219  1219  1233  1233  1233  1268 
                                1279  1299  1299  1299  1363  1365  1460  1465 
                                1496  1504  1528  1546  1551  1569  1578  1580 
                                1591  1613  1616  1629  1637  1664  1668  1737 
                                1740  1804  1811  1836  1845  1874  1885  1906 
                                1920  1942  1970  1986  2026  2031  2040  2064 
                                2070  2103  2184  2228  2312  2329  2358  2383 
                                2405  2514  2515  2516  2580  2598  2651  2747 
                                2750  2765  2851 
 Positions                       138 
 PostOperator                   1148  1320  1694  2703  2821 
 Predecessor                    1783 
 PREDICATE                      2877 
 Predicate                      1353  2180  2235  2278 
 PreOperator                    1148  1320  1320  1694  1694  2702  2820 
 ProcCall                       1345  1348  2621  2771 
 PROCEDURE                       124   125   204   216   227   238   247   260 
                                 275   288   297   331   339   363   389   418 
                                 461   507   714   742   760  1160  1340  1387 
                                1453  1472  1489  1511  1534  1748  1783  1817 
                                1859  1904  1929  2120  2131  2145  2174  2191 
                                2267  2275  2413  2421  2495  2503  2512  2756 
                                2859 
 Procedure                      2179  2234  2277 
 ProcFormals                     334  2208  2275  2283  2287  2290  2297  2301 
                                2305  2308  2318  2319  2379  2402  2407  2763 
 ProcName                        187  1599  1603  1605  1608  1609  1610  1613 
                                1616  1618 
 Properties                     2477 
 PUBLIC                          114 
 Public                         2206 

-R-
 Reason                          339   343   346   349   354   357 
 REF                            2267 
 REJECT                         2517 
 Reject                         1376  2514  2879 
 ReleaseArray                    133  1449 
 ReleaseSet                      142   378  2786  2832 
 RemoveTreeTypes                 114  2859  2862  2874 
 Result                          462   470   474   486   514   708   710   743 
                                 748   755   761   772   780   782   792   794 
                                 815   817   828   833   867   871   881   893 
                                 899   905   915   960   970   982   992  1002 
                                1011  1017  1026  1052  1061  1063  1066  1069 
                                1096  1105  1114  1125  1136  1143  1151  1155 
 RETURN                          210   213   221   224   232   235   241   244 
                                 253   257   266   268   272   279   281   283 
                                 284   290   302   307   310   316   320   324 
                                 327   424   426   428   430   432   434   457 
                                 723   729   734   737  1176  1212  1216  1222 
                                1235  1238  1303  1337  1343  1383  1399  1450 
                                1457  1460  1463  1465  1476  1479  1493  1496 
                                1501  1504  1796  1804  1806  1809  1811  2127 
                                2136  2141 
 ReturnForm                     1629  2258  2306 
 ReturnFormal                    179  2258  2584 
 ReturnParams                   2255  2305 
 ReverseTree                     161   710  2284  2288  2298  2302  2306  2468 
 Right                           418   424   425   428   429   432   433   436 
                                 441   442   442   444   451   454   454 
 Rop                             585   589   932   945   948  1037  1046  1051 
                                1187  1196  1201  1290  1297  1302  1309  1309 
                                1317  1317  1646  1659  1667  1668  1675  1679 
                                1683  1691  1762  1769  2700  2818 
 Routine                         232   233  1622  1632  1633  1635  2230 
 RoutineFormal                   313   314   317  1778  1813  1910  1947  1948 
                                1951  1990  1994  1995  1996  1997  2074  2078 
                                2079  2080  2081  2392  2393  2395  2396 
 RoutineNames                    172  1015  1575  2182  2186  2195 
 Routines                        230  2208  2209  2210 
 Rule                           2523  2536  2544  2552  2554  2555  2556  2557 
                                2559  2562  2565  2570  2572  2573  2574  2575 
                                2577  2578  2580  2584  2586  2587  2588  2589 
                                2593  2597  2598  2600  2602  2604  2605  2607 
                                2608  2610  2612  2614  2619 
 RuleCount                       185  2245  2261  2564  2565 
 Rules                          2246  2262 

-S-
 s                               763   963   969   970   973   980   982  1161 
                                1214  1215  1216  1219  1221  1222  1233  1234 
                                1235  1299  1300  1303 
 Scanner                         137 
 Select                          144 
 Selector                        509   636   829   870   898   959  1545  1590 
                                1984  1985  1988  1993  2001  2037  2038  2042 
                                2043  2733  2734  2747  2750 
 Semantics                       114   114  2191  2206  2210  2232  2247  2263 
 Sets                            118   141 
 SHORTCARD                       121 
 Spec                            219   230   250  2193  2861 
 Statement                      1382  1382  2514  2515  2663  2789  2880 
 Statements                     2534  2534  2556  2573  2578  2612  2877 
 StdOutput                       132  2212  2213  2213  2214  2214  2215  2218 
                                2218 
 Stmt                           2659  2785 
 String                          198  1365 
 String1                         199  2121  2124  2126  2127  2163  2164  2165 
                                2166  2167  2168  2169  2170  2430  2441  2443 
                                2450  2865  2869  2871  2872 
 String2                        2121  2125  2126  2430  2442  2443  2866  2870 
                                2871 
 StringExpr                     1149  1334  1364  1365 
 Strings                         134 
 Success                         197  2585  2587  2676  2680  2683  2686 
 SYSTEM                          130 

-T-
 t                               260   264   265   266   269   364   372   373 
                                 374   375   378   389   394   714   719   743 
                                 746   750   751   755   761   769   772   775 
                                 778   782   782   786   805   829   829   833 
                                 840   883   883   895   895   906   906   988 
                                1000  1006  1017  1032  1056  1063  1066  1069 
                                1074  1101  1115  1115  1127  1127  1132  1144 
                                1144  1151  1151  1155  1160  1164  1167  1172 
                                1175  1179  1212  1226  1233  1238  1252  1286 
                                1299  1314  1320  1324  1329  1337  1340  1342 
                                1343  1348  1357  1365  1367  1371  1382  1382 
                                1383  1387  1397  1399  1408  1409  1450  1453 
                                1455  1459  1460  1462  1472  1474  1478  1489 
                                1491  1495  1496  1498  1511  1514  1515  1518 
                                1520  1520  1522  1523  1526  1528  1531  1534 
                                1542  1544  1562  1589  1595  1642  1672  1688 
                                1694  1699  1704  1710  1748  1754  1756  1760 
                                1766  1773  1783  1794  1798  1804  1808  1814 
                                1814  1817  1827  1859  1866  1930  1935  1937 
                                2004  2009  2046  2049  2089  2103  2105  2112 
                                2113  2116  2174  2191  2267  2275  2413  2421 
                                2433  2437  2438  2455  2459  2467  2495  2503 
                                2512  2536  2544  2552  2554  2555  2556  2557 
                                2559  2562  2565  2570  2572  2573  2574  2575 
                                2577  2578  2580  2584  2586  2587  2588  2589 
                                2590  2593  2597  2598  2600  2602  2604  2605 
                                2607  2608  2610  2612  2614  2614  2619  2756 
                                2859 
 t1                              339   341   345   348   352   356   363   366 
                                 369   372   373   380   383 
 t2                              339   342   345   348   353   356   363   367 
                                 369   374   381   383 
 TargetClass                     314   317  1948  1951  1996  1997  2080  2081 
                                2393  2396 
 TargetExpr                     1149  1333  2711  2829 
 TargetStmt                     1378  2655  2783 
 Tempo                          1515  1523  1889  1892  2593 
 TempoCount                      186  2123  2125  2566  2602  2604 
 Tempos                         1500  1880 
 Test                            162  2477 
 Texts                           136 
 THEN                            210   221   232   241   253   266   268   279 
                                 281   283   301   304   306   309   312   315 
                                 341   342   345   348   352   353   356   366 
                                 367   369   375   380   381   383   424   426 
                                 428   430   432   434   447   493   496   611 
                                 627   645   650   664   673   701   707   722 
                                 725   728   731   747   776   791   814   843 
                                 850   855   862   880   892   914   918   923 
                                 935   941   955   957   991   999  1016  1021 
                                1038  1042  1049  1080  1084  1091  1113  1124 
                                1180  1183  1187  1195  1199  1208  1209  1229 
                                1253  1260  1265  1275  1291  1293  1295  1298 
                                1350  1356  1362  1364  1399  1421  1428  1442 
                                1457  1459  1463  1464  1476  1479  1482  1493 
                                1495  1499  1503  1514  1517  1522  1525  1545 
                                1549  1554  1563  1567  1576  1577  1579  1590 
                                1596  1598  1601  1611  1612  1615  1622  1626 
                                1648  1654  1661  1711  1715  1722  1796  1798 
                                1800  1809  1810  1831  1835  1842  1844  1852 
                                1869  1873  1879  1884  1896  1915  1918  1940 
                                1946  1949  1960  1977  1984  1985  1990  2012 
                                2015  2037  2039  2061  2063  2069  2074  2098 
                                2134  2149  2183  2211  2217  2227  2311  2324 
                                2326  2332  2335  2345  2353  2355  2377  2382 
                                2400  2478  2481  2543  2549  2576  2577  2578 
                                2592  2597  2601  2609  2613  2634  2640  2650 
                                2680  2721  2733  2735  2742  2764  2850  2873 
 tIdent                          117   124   135   192   204   216   227   238 
                                 247   260   297   509  1905  2120  2867 
 TO                             1390  1394  1407  1441  2216 
 tPosition                       138   339   363   508  1906 
 TRAFO                           114 
 TransformExpr                   782   883   895   906   951   966   976  1017 
                                1063  1066  1069  1115  1127  1144  1151  1160 
                                1168  1169  1176  1176  1205  1211  1214  1219 
                                1258  1259  1281  1308  1309  1316  1317  1321 
                                1325  1326  1330  1338  1349  1372  1373  2532 
                                2533 
 TransformKeyword                622  1210  1387  1451  2529  2531 
 TransformPattern                623   742   758  1261  2530 
 TransformPatternRecurse         755   760   777   788   789   811   812  1158 
 TransformStmt                  1340  1382  1384  2534 
 Tree                            119   149   208   220   231   240   251   279 
                                 300   303   305   308   311   313   341   342 
                                 352   353   366   367   380   381   427   429 
                                 468   471   477   483   495   533   535   542 
                                 548   566   567   572   579   585   617   649 
                                 654   657   663   670   672   721   724   727 
                                 730   746   771   774   775   785   804   827 
                                 831   831   832   832   835   835   839   842 
                                 844   846   848   909   910   917   927   930 
                                 933   987  1031  1036  1037  1073  1077  1078 
                                1079  1148  1148  1148  1149  1149  1150  1153 
                                1153  1153  1165  1167  1172  1179  1180  1185 
                                1186  1187  1226  1242  1243  1244  1245  1246 
                                1248  1248  1252  1253  1271  1285  1289  1290 
                                1313  1320  1320  1324  1329  1333  1334  1335 
                                1343  1345  1350  1353  1354  1357  1362  1364 
                                1367  1371  1376  1377  1378  1379  1380  1398 
                                1399  1402  1411  1419  1455  1456  1459  1463 
                                1463  1464  1474  1475  1479  1479  1480  1481 
                                1491  1492  1495  1499  1499  1503  1514  1516 
                                1522  1522  1524  1544  1548  1562  1566  1589 
                                1595  1598  1600  1601  1622  1624  1625  1641 
                                1645  1646  1652  1687  1694  1694  1699  1704 
                                1708  1714  1756  1760  1765  1772  1794  1795 
                                1798  1809  1809  1810  1830  1832  1841  1843 
                                1843  1851  1851  1869  1870  1879  1884  1895 
                                1895  1937  1939  1944  1945  1947  1948  1990 
                                2008  2011  2014  2049  2068  2074  2092  2093 
                                2094  2095  2097  2111  2133  2174  2191  2267 
                                2275  2323  2331  2352  2421  2495  2503  2512 
                                2526  2527  2528  2577  2589  2590  2590  2597 
                                2634  2735  2756  2859 
 TreeName                        182   220   221   222   247   250   251   251 
                                 252   252   254   254   254   256   292   292 
                                 345   345   369   369   372   372   449   450 
                                 554   592   682   763   887   921   944   994 
                                1045  1119  1161  1181  1196  1227  1297  2019 
                                2020  2024  2024  2325  2326  2327  2327  2333 
                                2334  2336  2336  2338  2338  2339  2339  2341 
                                2341  2343  2346  2346  2354  2356  2356  2361 
                                2377  2378  2378  2380  2432  2438  2455  2471 
                                2479  2498  2499  2507  2864 
 TreeNames                       219   250  2205  2862 
 TreeRoot                        150   219   230   250 
 TRUE                            469   571   597   629   723   729  1892  1960 
                                2230  2260  2286  2300  2304  2389  2545  2676 
                                2680  2683  2686  2760 
 tSet                            118   122   142   172   331   364  2267 
 TSIZE                           130  1406  1449 
 tString                         134   199  2121  2430  2865  2866 
 tTree                           119   124   124   125   125   150   184   201 
                                 202   204   216   217   227   228   238   238 
                                 247   247   248   260   260   262   275   275 
                                 277   288   288   297   298   331   339   363 
                                 389   391   418   418   462   462   464   510 
                                 512   514   523   524   714   716   743   743 
                                 761   761   763   764  1160  1160  1161  1340 
                                1340  1387  1387  1389  1390  1394  1406  1449 
                                1453  1472  1489  1511  1511  1534  1534  1537 
                                1538  1539  1748  1783  1792  1817  1825  1859 
                                1864  1905  1930  1931  1932  1933  2131  2131 
                                2731 
 TYPE                           1777 
 Type                            310   356   356   383   383  1671  1718  2027 
                                2318  2321  2471  2479  2484  2485  2738  2763 
 TypeCount                       121  2194  2195  2196  2197  2198  2199  2202 
                                2203  2204  2216  2873 
 TypeDesc                        305   308   310   311   319   448  1518  1518 
                                1520  1520  1526  1526  1551  1551  1569  1569 
                                1628  1629  1651  1656  1714  1717  1730  1731 
                                1890  1890  1905  1912  1923  1942  1942  1944 
                                1945  1952  1954  1958  1968  1993  2001  2013 
                                2070  2070  2077  2085  2101  2138  2416  2458 
                                2474  2489  2506  2507  2508  2735  2737 
 TypeIdentOfFormal               297   329  2096 
 TypeNames                       122  2198  2385  2485  2873 
 Types                           293   331   333   336   348   348   373   374 
                                1957  1958  2018  2020  2416  2438  2439  2507 
                                2508 

-U-
 Union                           147  2416 
 UniversalClass                  450  2341  2448  2452  2453  2454  2458 
 UsedNames                      2657  2658  2660  2712  2713  2715  2784  2786 
                                2830  2832 
 UserNames                       169  1014  1574  1610  1618  2204  2211  2217 
 UserType                        308   310   342   352   356   356   367   380 
                                 383   383  2027 
 UserTypes                       122  2203 

-V-
 Value                          2111  2112  2113  2685  2804 
 VAR                             121   122   164   205   217   228   247   248 
                                 262   277   298   331   364   391   420   462 
                                 462   464   514   515   523   524   525   526 
                                 716   743   743   761   761   763   764   765 
                                1161  1162  1388  1511  1534  1537  1538  1539 
                                1748  1792  1825  1864  1931  1932  1933  2121 
                                2430  2524  2525  2526  2527  2528  2731  2865 
                                2866  2867 
 Var                             181  1480  1481  1482  1483  2389  2391  2394 
 VarDecls                       2600 
 VarDef                         2049  2049  2089  2679 
 VarUse                          535   539   548   555   557   567   569   579 
                                 583   585   593   595   613   663   672   683 
                                 685   697   844   848   854   858   859   860 
                                 865   877   878   888   890   910   911   917 
                                 921   924   926   930   933   938   939   945 
                                 948   987   988  1000  1036  1037  1040  1046 
                                1050  1051  1077  1079  1083  1087  1088  1089 
                                1094  1096  1110  1111  1120  1122  1180  1181 
                                1183  1184  1186  1187  1189  1196  1200  1201 
                                1226  1226  1253  1254  1289  1290  1294  1297 
                                1301  1302  1480  1481  1481  1482  1483  1562 
                                1562  1598  1599  1601  1603  1645  1646  1647 
                                1649  1659  1665  1667  1668  1756  1756  2634 
                                2635 

-W-
 Warning                         137   343   344   354   355   357   358   368 
                                 376   382   384  1546  1591  2516 
 WarningI                        137  1580  1616  1919 
 WHILE                           208   220   231   240   251   264   395   437 
                                 441   444  1398  1402  1411  1419 
 Widen                           513   639   870   898   959  1990 
 WITH                            265   280   786   805   840   988  1032  1074 
                                1167  1172  1179  1226  1252  1286  1314  1320 
                                1324  1329  1348  1351  1371  1462  1478  1498 
                                1544  1562  1589  1595  1642  1688  1694  1699 
                                1704  1710  1756  1760  1766  1878  1937  2009 
                                2049  2135  2536 
 WriteI                          132 
 WriteIdent                      135  2218 
 WriteN                          132 
 WriteNl                         132  2212  2213  2214  2215  2218 
 WriteS                          132  2213  2214 
 WriteSet                        146 
 WriteStr                       1380 

-_-
 _                              2269  2514  2514  2514  2515  2515  2515 

end cross reference, 6495 occurrences of 534 identifiers.
