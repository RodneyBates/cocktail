
(* File opt.puma puma optimization of tests in rules. *) 

(* Ich, Doktor Josef Grosch, Informatiker, 10.12.1991 *)

(* Rodney M. Bates Modifications: 

   RMB Nov 96 made the minimum number of alternatives for conversion
              of IF statments to a CASE statement a named constant
              (MinCases) and set the value to 2. 

   RMB Dec 96 fixed bug in ElimDeadTests. It was changing the Types
              in the test in the original Tests list, while leaving
              Types in the new test in the Decisions tree unchanged,
              which is backwards.  Tests is not used after this, while
              Decisions is. 
   RMB May 97 Minor changes to match changes to puma.cg, name change
              of Mod to M2
   RMB Jun 97 Rename 'Then' to 'ThenPart' and 'Else' to 'ElsePart',
              to avoid conflicts with new case-insensitive recognition
              of Ada operators THEN and ELSE 
   RMB Sep 98 Changed to match added ConsType field IsProperlyNarrowed
   RMB Sep 98 Temporarily made it always narrow for Modula-3 
   RMB Oct 98 Changed to match new field UniversalClass of TreeName 
   RMB Oct 98 Added ':' after all labels 
   RMB May 99 Added Dontcares to match added IsProperlyNarrowed fields 
   RMB July 99 Added 'VAR' to local declarations of rules and one "(..)"
   RMB Aug 99 Removed temporary always narrow for Modula-3 (Sep 98) 
   RMB Aug 99 Small changes to positional patterns to match node
              changes for more flexible labels on patterns. 
   RMB Aug 99 Changed some nonlinear refs which had ':_' to just ':'
              in IsSameType 

*)

TRAFO Optimize 
PUBLIC Optimize RuleProperties NeedsTempo NeedsMatch NeedsNoFinale GetRule

GLOBAL {

FROM IO         IMPORT StdOutput, WriteB, WriteS, WriteI, WriteNl;
FROM Idents     IMPORT WriteIdent;
FROM M2         IMPORT ImplMod;
FROM Tree       IMPORT tTree, NoTree, mTestIsType, mNodeTypes, Options;
FROM Scanner    IMPORT Warning;
FROM Positions  IMPORT tPosition;

FROM Sets       IMPORT
   tSet         , MakeSet       , ReleaseSet    , AssignEmpty   ,
   IsEmpty      , Difference    , IsSubset      , Assign        ,
   IsEqual      , IsNotEqual    , Intersection  , Union         ,
   Size         , WriteSet      , IsElement ;

IMPORT Sets;

CONST MinCases = 2 ; 

VAR
   gHasExit : BOOLEAN;
   gHasAssign : BOOLEAN;
   gHasTargetCode : BOOLEAN;
   gHasRejectOrFail: BOOLEAN; 
   gRule, nNoDecision, nNoTest  : tTree;

PROCEDURE IsDisjoint (s1, s2: tSet): BOOLEAN;
   VAR s: tSet; Result: BOOLEAN;
   BEGIN
      MakeSet (s, Size (s1));
      Assign (s, s1);
      Intersection (s, s2);
      Result := IsEmpty (s);
      ReleaseSet (s);
      RETURN Result;
   END IsDisjoint;
}

PROCEDURE Optimize (t: Tree)

Spec (..) 
:- nNoDecision  := NoDecision ();
   nNoTest      := NoTest ();
   Optimize (Routines);
.

Routine (..) 
:- RuleProperties (Rules);
   CollectTests (Rules, InForm);
   BuildTree (Rules, nNoDecision => decisions:_);
   Decisions := decisions;
   ElimDeadTests (Decisions, _, (FALSE), _);
   FindCases (Decisions => _, n:_, s2:_);
   MarkCases (Decisions, n, s2);
   Optimize (Next);
.

PROCEDURE RuleProperties (Tree)
  (* Gets called for each routine.  If Optimize is not called,
     This must be called directly. *) 

Spec (..) 
:-  RuleProperties (Routines);  .

Routine (..) 
:- RuleProperties (Rules);
   RuleProperties (Next);
.

Rule (..) 
:- gHasExit       := FALSE;
   gHasAssign     := FALSE;
   gHasTargetCode := FALSE;
   gHasRejectOrFail := FALSE;
   RuleProperties (Statements);
   RuleProperties (Exprs);
   RuleProperties (Expr);
   HasExit        := gHasExit;
   HasAssign      := gHasAssign;
   HasTargetCode  := gHasTargetCode;
   HasRejectOrFail := gHasRejectOrFail;
   RuleProperties (Next);
.

ProcCall (..) 
:- RuleProperties (Call);
   RuleProperties (Next);
.

Assignment (..) 
:- gHasAssign     := TRUE;
   RuleProperties (Adr);
   RuleProperties (Expr);
   RuleProperties (Next);
.

Condition (..) 
:- gHasExit       := TRUE;
   RuleProperties (Next);
.

Reject (..) (* Reject terminates rule *) 
:- gHasExit       := TRUE;
   gHasRejectOrFail := TRUE;
   RuleProperties (Next);
.

Fail (..) (* Fail terminates subprogram *) 
:- gHasRejectOrFail := TRUE;
   RuleProperties (Next);
.

TargetStmt (..) 
:- gHasTargetCode := TRUE;
   RuleProperties (Next);
.

Statement (..) 
:-  RuleProperties (Next); .

OneExpr (..) 
:- RuleProperties (Expr);
   RuleProperties (Next);
.

Expr:Expr (..) 
:- gHasExit := gHasExit OR NeedsMatch (Expr); .

PREDICATE NeedsMatch ([Tests, Exprs, Expr])
  (* Contains a call on a puma routine with out parameters to 
     be matched, or contains a nonlinear pattern match. *) 

TestValue (..) :- NeedsMatch (Expr) OR NeedsMatch (Next);
   .
OneTest (..) :- NeedsMatch (Next);
   .
OneExpr (..) :- NeedsMatch (Expr) OR NeedsMatch (Next);
   .
Compose (..) :- NeedsMatch (Exprs);
   .
Call    (..) :- NeedsMatch (Expr) 
                OR NeedsMatch (Exprs) 
                OR (Object # NoTree) 
                   AND NeedsMatch2 (Patterns, Object^.Routine.OutForm);
   .
Binary  (..) :- NeedsMatch (Lop) OR NeedsMatch (Rop);
   .
Parents (..) ;
PreOperator     (..) ;
PostOperator    (..) :- NeedsMatch (Expr);
   .
Index   (..) :- NeedsMatch (Expr) OR NeedsMatch (Exprs);
   .

PREDICATE NeedsMatch2 ([Patterns, Pattern], Formal)

OnePattern (..), Formals:_ :-
   NeedsMatch2 (Pattern, Formals) OR
   NeedsMatch2 (Next, Formals^.Formal.Next);
   .
Decompose (..), Formal (_, _, _, _, typeDesc:_, _) :-
   (typeDesc^.Kind = Tree.UserType) 
   (* OR IsElement ( ORD ( 'K' ) , Options ) *) 
      (* Modula-3 temporarily needs all cases narrowed *) 
   OR IsNotEqual 
        (Object^.Class.TypeDesc^.NodeTypes.Types
(* Can Object be NIL and segfault if there was a semantic error? *) 
        , typeDesc^.NodeTypes.Types
        ) 
   OR NeedsMatch2 (Patterns, Object^.Class.Formals);
   .
VarDef  (..), _ :- Object # NoTree; . 
  (* VarDef is subsequent (i.e. to be matched) occurrence of a label. *) 
NilTest (..), _ :- .
Value   (..), _ :- .

PREDICATE NeedsTempo (Decisions => Rule)

Decision (ThenPart:_, ..) => Rule 
:- NeedsTempo (ThenPart => Rule:_); .

Decided (_, rule:Rule (HasTempos := (TRUE))) => rule 
:- .

PREDICATE NeedsNoFinale (Decisions)

Decision (_, ElsePart:_, ..) :- NeedsNoFinale (ElsePart); .

Decided (_, Rule (HasExit := (FALSE))) :- .

Decided (ElsePart:_ , _) :- NeedsNoFinale (ElsePart); .

PROCEDURE GetRule (Decisions => Rule)

Decision (ThenPart:_ , ..) => Rule :- GetRule (ThenPart => Rule:_); .

Decided (_, Rule:_ ) => Rule :- .

PROCEDURE CollectTests (Rules, Formals)
  (* For each rule, create a linear list of tests (OneTest) for its
     patterns only.  Store root in Rule::Tests *) 

Rule (..), Formals:_ :-
   CollectTests2 (Patterns, Formals, nNoTest => tests:_);
   Tests := tests;
   CollectTests (Next, Formals);
   .

PROCEDURE CollectTests2 (Tree (* patterns *) , Formals, Tests => Tests)

OnePattern (Pattern:_, NextP:_), Formals:Formal (NextF:_, ..),
   TestsIn:_ => TestsOut (* build backwards *) :-
   CollectTests2 (NextP, NextF, TestsIn => Tests:_);
   CollectTests2 (Pattern, Formals, Tests => TestsOut:_);
   .

(* Type of decomposer identically equals type of formal, just
   recurse on subformals: *) 
Decompose (..), Formal (_, _, _, _, typeDesc:_, _),
   TestsIn:_  => TestsOut :-
   (typeDesc^.Kind # Tree.UserType) 
   (* AND NOT IsElement ( ORD ( 'K' ) , Options ) *) 
           (* Modula-3 temporarily needs all cases narrowed *) 
   AND IsEqual 
         ( Object^.Class.TypeDesc^.NodeTypes.Types
         , typeDesc^.NodeTypes.Types
         );
   CollectTests2 (Patterns, Object^.Class.Formals, TestsIn => TestsOut:_);
   .

(* Decomposer is a leaf type: *) 
Decompose 
  (_, _, _, Path:_, _, _, Patterns:_, _, Object:_, _)
, Formal (_, _, _, _, typeDesc:_, _)
, TestsIn:_ 
=> TestKind (TestsOut, Path, Object^.Class.TypeDesc, Object^.Class.Name) :-
   Object^.Class.Extensions^.Kind = Tree.NoClass;       (* Low ? *)
   CollectTests2 
     (Patterns, Object^.Class.Formals, TestsIn => TestsOut:_);
   .
(* Decomponser is a nonleaf type: *) 
Decompose (_, _, _, Path:_, _, _, Patterns:_, _, Object:_, _)
, _
, TestsIn:_ 
=> TestIsType 
     (TestsOut, Path, Object^.Class.TypeDesc, Object^.Class.Name) :-
   CollectTests2 
     (Patterns, Object^.Class.Formals, TestsIn => TestsOut:_);
   .
VarDef (Path := path:_)
, _
, Tests :_
=> TestNonlin 
     (Tests, Object^.Formal.Path, path, Object^.Formal.TypeDesc) :-
   Object # NoTree;
   .
NilTest (_, _, _, Path:_, _, _, _)
, _
, Tests:_ => TestNil (Tests, Path) :-
   .
Value (_, _, _, Path:_, _, Expr:_)
, Formals:Formal(..)
, Tests:_ 
(* Also check that Expr is not a don't care? *) 
=> TestValue (Tests, Path, Expr, Formals^.Formal.TypeDesc) :-
   .
_, _, Tests:_ => Tests :-
   .

PREDICATE IsSamePath (Path, Path)

Var (Name:_, ..)          , Var (Name:(*NonlinearReference*), ..)        :- .
ConsType (Path1:_, Name:_ , _ )  , ConsType (Path2:_, Name:(*NonlinearReference*) , _ ) 
; Field (Path1:_, Name:_)     , Field (Path2:_, Name:(*NonlinearReference*))   
  :- IsSamePath (Path1, Path2); .

PREDICATE IsSameType (TypeDesc, TypeDesc)

NodeTypes (TreeName (Name:, ..), Types:)
, NodeTypes (TreeName (Name:, ..), Types:) 
  :- .
UserType (Type:), UserType (Type:(*NonlinearReference*)) :- .

PREDICATE IsSameTest (Tests, Tests)
  (* No attempt to merge IsValue tests, because can't tell if
     as assignment changes value. *) 

TestKind   (_, Path1:_, TypeDesc1:_, _), TestKind   (_, Path2:_, TypeDesc2:_, _) ;
(* This can have Path1 NIL in the presence of misspelled decompose node
   names in combination with other things.  see puma/test/t8 *) 
TestIsType (_, Path1:_, TypeDesc1:_, _), TestIsType (_, Path2:_, TypeDesc2:_, _) :-
   IsSamePath (Path1, Path2);
   IsSameType (TypeDesc1, TypeDesc2);
   .
TestNil (_, Path1:_), TestNil (_, Path2:_) :-
   IsSamePath (Path1, Path2);
   .
TestNonlin (_, Path11:_, Path12:_, _), TestNonlin (_, Path21:_, Path22:_, _) :-
   IsSamePath (Path11, Path21);
   IsSamePath (Path12, Path22);
   .

PROCEDURE BuildTree (Rules, Decisions => Decisions)

r:Rule (..), DecisionsIn:_ => DecisionsOut :-
   gRule := r;
   BuildTree2 (Tests, DecisionsIn => Decisions:_);
   UpdateChange (Decisions, gRule);
   BuildTree (Next, Decisions => DecisionsOut:_);
   .
NoRule (..), Decisions:_ => Decisions :-
   .

PROCEDURE BuildTree2 (t: Tests, d: Decisions => Decisions)
  (* Only NoDecision, when passed in to BuildTree2, can be changed--
     to either Decision or Decided. 
     ThenPart can never be NoDecision. *) 

o:OneTest (Next:_, _), NoDecision () => Decision (Decisions, d, o, 0, TRUE) :-
   BuildTree2 (Next, d => Decisions:_);
   UpdateChange (Decisions, gRule);
   .
(* An optimization case: *) 
OneTest (Next:_, _)
, Decision (ThenPart:_, ElsePart:_, Test:_, _, (TRUE)) 
=> d (* Decision (Decisions, ElsePart, Test, 0, TRUE) *) :-
   IsSameTest (t, Test);
   NOT HasInterference (t, ElsePart);
   BuildTree2 (Next, ThenPart => Decisions:_);
(* Should be able to replace the following by assert ThenPart = Decisions *) 
   ThenPart := Decisions;
   UpdateChange (Decisions, gRule);
   .
OneTest (..)
, Decision (ThenPart:_, ElsePart:_, Test:_, _, _) 
=> d (* Decision (ThenPart, Decisions, Test, 0, TRUE) *) :-
   BuildTree2 (t, ElsePart => Decisions:_);
   ElsePart := Decisions;
   UpdateChange (Decisions, gRule);
   .
OneTest (..)
, Decided (ElsePart:_, Rule:_) 
=> d (* Decided (Decisions, Rule) *) :-
   BuildTree2 (t, ElsePart => Decisions:_);
   ElsePart := Decisions;
   UpdateChange (Decisions, gRule);
   .
NoTest (), NoDecision () => Decided (d, gRule) :-
   .
NoTest ()
, Decision (ThenPart:_, ElsePart:_, Test:_, _, _) 
=> d (* Decision (ThenPart, Decisions, Test, 0, TRUE) *) :-
   BuildTree2 (t, ElsePart => Decisions:_);
   ElsePart := Decisions;
   .
NoTest (), Decided (ElsePart:_, Rule:_) => d (* Decided (Decisions, Rule) *) :-
   BuildTree2 (t, ElsePart => Decisions:_);
   ElsePart := Decisions;
   .

PREDICATE HasInterference (Tests, Decisions)


  (* TestKind/TestIsType are disjoint with NilTest *) 

_, Decided (..) :- . (* Decided interferes with anything. *) 
                   TestKind   (_, Path1:_, NodeTypes (_, Types1:_), _),
   Decision (_, _, TestKind   (_, Path2:_, NodeTypes (_, Types2:_), _), ..) ;
                   TestKind   (_, Path1:_, NodeTypes (_, Types1:_), _),
   Decision (_, _, TestIsType (_, Path2:_, NodeTypes (_, Types2:_), _), ..) ;
                   TestIsType (_, Path1:_, NodeTypes (_, Types1:_), _),
   Decision (_, _, TestKind   (_, Path2:_, NodeTypes (_, Types2:_), _), ..) ;
                   TestIsType (_, Path1:_, NodeTypes (_, Types1:_), _),
   Decision (_, _, TestIsType (_, Path2:_, NodeTypes (_, Types2:_), _), ..) :-
   IsSamePath (Path1, Path2);
   NOT IsDisjoint (Types1, Types2);
   .
t:_, Decision (_, ElsePart:_, ..) :- HasInterference (t, ElsePart); .
   (* Other cases can't happen. *) 

PROCEDURE UpdateChange (Decisions, Rule)

Decision (_, _, TestKind (_, Path:_, ..), _, IsUnchanged:_),
   Rule (HasExit := (TRUE), HasAssign := (TRUE), Statements := s:_) ;
Decision (_, _, TestIsType (_, Path:_, ..), _, IsUnchanged:_),
   Rule (HasExit := (TRUE), HasAssign := (TRUE), Statements := s:_) :-
   IsChanged (Path, s);
   IsUnchanged := FALSE;
   .

PREDICATE IsChanged (Path, Statements)
  (*( Do Statements contain an assignment to Path? *) 

path:_, Assignment (Object := Object:_) 
  :- Object # NIL; IsSamePath (path, Object^.Formal.Path); .
Path:_, Statement (_, Next:_) :- IsChanged (Path, Next); .

PROCEDURE FindCases (Decisions => Path, SHORTCARD, tSet)
  (* Param 3 = 0 IMPLIES params 2 and 4 are meaningless.
     Otherwise, there is an ELSIF chain of param 3 case alternatives,
     all testing path param 2 and all having disjoint value sets.  
     Param 4 is the union value set. *) 

Decision 
  ( ThenPart:_, ElsePart:_
  , TestKind 
       ( _
       , Path:_
       , NodeTypes
           ( TreeName (_, _, _, _, ClassCount:_, _, _)
           , Types:_
           )
       , _
       )
   , _
   , _
   ) ;
Decision 
  ( ThenPart:_, ElsePart:_
  , TestIsType 
      ( _ 
      , Path:_
      , NodeTypes 
          ( TreeName (_, _, _, _, ClassCount:_, _, _)
          , Types:_
          )
      , _
      )
   , _
   , _
   ) 
=> Path, k, s 
:-  FindCases (ThenPart => _, m:_, s1:_);
    MarkCases (ThenPart, m, s1);
    FindCases (ElsePart => Path2:_, n:_, s2:_);
    VAR k : SHORTCARD ;
    VAR  s : tSet ;
    {
       IF n = 0 THEN
          k := 1;
          MakeSet (s, ClassCount);
          Assign (s, Types);
       ELSIF IsSamePath (Path, Path2) AND IsDisjoint (s2, Types) THEN
          k := n + 1;
          s := s2;
          Union (s, Types);
       ELSE
          MarkCases (ElsePart, n, s2);
          k := 1;
          MakeSet (s, ClassCount);
          Assign (s, Types);
       END;
    };
   .
Decision (ThenPart:_, ElsePart:_, _, _, _) => _, 0, _ :-
   FindCases (ThenPart => _, m:_, s1:_);
   MarkCases (ThenPart, m, s1);
   FindCases (ElsePart => _, n:_, s2:_);
   MarkCases (ElsePart, n, s2);
   .
Decided (ElsePart:_, _) => _, 0, _ :-
   FindCases (ElsePart => _, n:_, s2:_);
   MarkCases (ElsePart, n, s2);
   .
NoDecision () => _, 0, _ :- .

PROCEDURE MarkCases (Decisions, SHORTCARD, tSet)

Decision (_, _, _, Cases:_, _), n:_, s:_ 
   :- n >= ( MinCases ) ; Cases := n; ReleaseSet (s); .

PROCEDURE ElimDeadTests (Decisions, Path, BOOLEAN, tSet)

Decision (ThenPart:_, ElsePart:_, TestKind (_, Path:_, NodeTypes (
   TreeName (_, _, _, _, ClassCount:_, _, _), Types:_), _), _, _), _, (FALSE), _ ;
Decision (ThenPart:_, ElsePart:_, TestIsType (_, Path:_, NodeTypes (
   TreeName (_, _, _, _, ClassCount:_, _, _), Types:_), _), _, _), _, (FALSE), _ :-

   VAR s : tSet ;
   {  MakeSet (s, ClassCount); IF IsDeadEnd (ThenPart) THEN Assign (s, Types); END; };
   ElimDeadTests (ElsePart, Path, (TRUE), s);
   ElimDeadTests (ThenPart, _, (FALSE), _);
   .

(* These patterns differ from those above only in having b:_ instead of (FALSE) and
   lots more labels. *) 
Decision (ThenPart:_, ElsePart:_, Test:TestKind (Next:_, Path:_, NodeTypes (
   Tree:TreeName (_, _, _, _, ClassCount:_, _, _), Types:_), Name:_), _, _), Path2:_, b:_, s:_ ;
Decision (ThenPart:_, ElsePart:_, Test:TestIsType (Next:_, Path:_, NodeTypes (
   Tree:TreeName (_, _, _, _, ClassCount:_, _, _), Types:_), Name:_), _, _), Path2:_, b:_, s:_ :-

   VAR LTypes : tSet ;
   VAR s2 : tSet ;
   {
      s2 := s;
      IF IsSamePath (Path, Path2) THEN
         IF NOT IsDisjoint (Types, s) THEN
            MakeSet (LTypes, ClassCount);
            Assign (LTypes, Types);
            Difference (LTypes, s);
            Test := mTestIsType (Next, Path, mNodeTypes (Tree, LTypes), Name);
         END;
      ELSE
         AssignEmpty (s2);
      END;
      IF IsDeadEnd (ThenPart) THEN Union (s2, Types); END;
   (* 
      s2 := s;
      IF IsSamePath (Path, Path2) THEN
         IF NOT IsDisjoint (Types, s) THEN
            types := Types;
            Test := mTestIsType (Next, Path, mNodeTypes (Tree, types), Name);
            MakeSet (Types, ClassCount);
            Assign (Types, types);
            Difference (Types, s);
         END;
      ELSE
         AssignEmpty (s2);
      END;
      IF IsDeadEnd (ThenPart) THEN Union (s2, Types); END;
   *)
   };
   ElimDeadTests (ElsePart, Path, (TRUE), s2);
   ElimDeadTests (ThenPart, _, (FALSE), _);
   .
Decision (ThenPart:_, ElsePart:_, _, _, _), _, b:_, s:_ :-
   {  IF b THEN ReleaseSet (s); END; };
   ElimDeadTests (ElsePart, _, (FALSE), _);
   ElimDeadTests (ThenPart, _, (FALSE), _);
   .
Decided (ElsePart:_, Rule (HasExit := HasExit:_)), _, b:_, s:_ :-
   {  IF b THEN ReleaseSet (s); END; };
   {  IF NOT HasExit THEN ReportWarning (ElsePart); END; };
   ElimDeadTests (ElsePart, _, (FALSE), _);
   .
NoDecision (), _, (TRUE), s:_ :-
   ReleaseSet (s);
   .

PREDICATE IsDeadEnd (Decisions)

Decided (ElsePart:_, Rule (HasExit := HasExit:_)) :- NOT HasExit OR IsDeadEnd (ElsePart); .

PROCEDURE ReportWarning (Decisions)

Decided (ElsePart:_, Rule (Pos:_, ..)) :-
   Warning ("unreachable code", Pos);
   ReportWarning (ElsePart);
   .
Decision (ThenPart:_, ElsePart:_, ..) :-
   ReportWarning (ThenPart);
   ReportWarning (ElsePart);
   .

(*
PROCEDURE WriteTests (Tests)

o:OneTest (Next, _) :- WriteTest (o); WriteTests (Next); .

PROCEDURE WriteTest (OneTest)

TestKind (Next, Path, TypeDesc, _) :-
   "TestKind    "; ImplMod (Path); "    "; WriteType (TypeDesc); NL .
TestIsType (Next, Path, TypeDesc, _) :-
   "TestIsType  "; ImplMod (Path); "    "; WriteType (TypeDesc); NL .
TestNil (Next, Path) :-
   "TestNil     "; ImplMod (Path); "    "; NL .
TestNonlin (Next, Path, Path2, _) :-
   "TestNonlin  "; ImplMod (Path); "    "; ImplMod (Path2); NL .
TestValue (Next, ..) :-
   "TestValue   "; NL .

PROCEDURE WriteType (TypeDesc)

NodeTypes (TreeName (Name, ..), Types) :-
   WriteIdent (StdOutput, Name); WriteSet (StdOutput, Types); .
UserType (Type) :-
   WriteIdent (StdOutput, Type); .

PROCEDURE WriteDecisions (Decisions, SHORTCARD) LOCAL { VAR i: SHORTCARD; }

Decision (ThenPart, ElsePart, Test, _, _), n :-
   { FOR i := 1 TO n DO WriteS (StdOutput, "    "); END; };
   WriteTest (Test);
   WriteDecisions (ThenPart, n + 1);
   WriteDecisions (ElsePart, n);
   .
Decided (ElsePart, rule), n :-
   { FOR i := 1 TO n DO WriteS (StdOutput, "    "); END; };
   WriteI (StdOutput, rule^.Rule.Line, 3); NL
   WriteDecisions (ElsePart, n);
   .
*)

(* End of file opt.puma *) 





