
(* This file was mechanically generated by puma. *)

IMPLEMENTATION MODULE Semantics;








IMPORT SYSTEM, System, IO, Tree;
(* line 104 "sem.puma" *)


FROM SYSTEM     IMPORT TSIZE, ADR;
FROM General    IMPORT Max;
FROM IO         IMPORT StdOutput, WriteN, WriteS, WriteI, WriteNl;
FROM DynArray   IMPORT MakeArray, ReleaseArray;
FROM Strings    IMPORT tString, IntToString, Append, Concatenate, ArrayToString;
FROM Idents     IMPORT WriteIdent, tIdent, NoIdent, MakeIdent, MaxIdent, GetString;
FROM Texts      IMPORT MakeText;
FROM Scanner    IMPORT Error, ErrorI, Warning, WarningI;
FROM Positions  IMPORT tPosition, NoPosition;
FROM Assertions IMPORT Assert, AssertPos, CantHappen, CantHappenPos; 

FROM Sets       IMPORT
   tSet         , MakeSet       , ReleaseSet    , AssignEmpty   ,
   IsElement    , Include       , IsEmpty       , Extract       ,
   Select       , Difference    , Complement    , ForallDo      ,
   IsSubset     , Minimum       , Maximum       , Assign        ,
   Exclude      , Intersection  , WriteSet      , IsNotEqual    , 
   Union        ;

FROM Tree       IMPORT
   tTree        , NoTree        , TreeRoot      , mCall         ,
   mCompose     , mDecompose    , mParents      , 
   mDontCareInternal            , mDontCare1Internal            ,
   mNilTest     , mNoPattern    , mOnePattern   , mRule         ,
   mOnePatternAlts , mNoPatternsList , mOnePatternsList         , 
   mVarDef      , mBinary       , 
   mNoFormal    , mFormal       , mNodeTypes    , mUserType     ,
   mVar         , mConsType     , mField        , mNoClass      ,
   mOneExpr     , mNoExpr       , mValue        , mDummyFormal  ,
   mWriteStr    , f             , ForallClasses , ForallAttributes,
   Options      , ReverseTree   , IsType        , Class         ,
   Test         , Dummy         , CopyTree      , Nonterminal   ;

VAR
   ExternNames  ,
   LocExternNames,
   ActTypes     ,
   ActNames     ,
   UserNames    ,
   LabelNames   , (* Includes formals too. *) 
   ParamNames   ,
   RoutineNames : tSet;
   dFormals     ,
   Parameters   ,
   Decls        ,
   Args         ,
   InFormals    ,
   OutFormals   ,
   ReturnFormal ,
   Node         ,
   Var          ,
   TreeName     ,
   ActTree      ,
   ActClass     : tTree;
   RuleCount    ,
   TempoCount   : INTEGER;
   ProcName     ,
   ParamName    ,
   IdentDot     ,
   IdentEmptyType : tIdent;
   HasLocals    ,
   IsFunction   ,
   IsOutput     ,
   Mode         ,
   Success      : BOOLEAN;
   String       ,
   String1      : tString;
   i            : CARDINAL;
   nNoFormal    : tTree;

PROCEDURE LookupFormal (Ident: tIdent; Formals: tTree): INTEGER;
   VAR i        : INTEGER;
   BEGIN
      i := 0;
      WHILE Formals^.Kind = Tree.Formal DO
         INC (i);
         IF Formals^.Formal.Name = Ident THEN RETURN i; END;
         Formals := Formals^.Formal.Next;
      END;
      RETURN 0;
   END LookupFormal;

PROCEDURE IdentifyTree (i: tIdent): tTree;      (* is i name of a tree type ? *)
   VAR Node: tTree;
   BEGIN
      Node := TreeRoot^.Spec.TreeNames;
      WHILE Node^.Kind = Tree.TreeName DO
         IF Node^.TreeName.Name = i THEN RETURN Node; END;
         Node := Node^.TreeName.Next;
      END;
      RETURN NoTree;
   END IdentifyTree;

PROCEDURE IdentifyProc (i: tIdent): tTree;      (* is i name of a subroutine ? *)
   VAR Node: tTree;
   BEGIN
      Node := TreeRoot^.Spec.Routines;
      WHILE Node^.Kind # Tree.NoRoutine DO
         IF Node^.Routine.Name = i THEN RETURN Node; END;
         Node := Node^.Routine.Next;
      END;
      RETURN NoTree;
   END IdentifyProc;

PROCEDURE IdentifyVar (Node: tTree; i: tIdent): tTree;  (* is i name of a variable ? *)
   BEGIN
      WHILE Node^.Kind # Tree.NoFormal DO
         IF Node^.Formal.Name = i THEN RETURN Node; END;
         Node := Node^.Formal.Next;
      END;
      RETURN NoTree;
   END IdentifyVar;

PROCEDURE IdentifyClass2 (i: tIdent; VAR TreeName: tTree): tTree; (* is i a node type ? *)
   VAR Class: tTree;
   BEGIN
      TreeName := TreeRoot^.Spec.TreeNames;
      WHILE TreeName^.Kind = Tree.TreeName DO
         Class := IdentifyClass (TreeName^.TreeName.Classes, i);
         IF Class # NoTree THEN RETURN Class; END;
         TreeName := TreeName^.TreeName.Next;
      END;
      TreeName := NoTree;
      RETURN NoTree;
   END IdentifyClass2;

PROCEDURE IdentifyClass (t: tTree; Ident: tIdent): tTree;
  (* Search for a class using an identifier. *) 
   VAR class    : tTree;
   BEGIN
      WHILE t^.Kind = Class DO
         WITH t^.Class DO
            IF Name = Ident THEN RETURN t; END;
            class := IdentifyClass (Extensions, Ident);
            IF class # NoTree THEN RETURN class; END;
            t := Next;  (* RETURN IdentifyClass (Next, Ident); *)
         END;
      END;
      RETURN NoTree;
   END IdentifyClass;

PROCEDURE LookupClass (Classes: tTree; i: CARDINAL): tTree;
  (* Search for a class using an index. *) 
   VAR Class: tTree;
   BEGIN
      IF Classes^.Kind = Tree.NoClass THEN RETURN NoTree; END;
      WITH Classes^.Class DO
         IF Index = i THEN RETURN Classes; END;
         Class := LookupClass (Extensions, i);
         IF Class # NoTree THEN RETURN Class; END;
         RETURN LookupClass (Next, i);
      END;
   END LookupClass;

PROCEDURE MakeTypes (Index: INTEGER; Classes: tTree; VAR Types: tSet);
   BEGIN
      ActTypes := Types;
      ForallClasses (Classes, ProcFormals);
      Include (ActTypes, Index);
      Types := ActTypes;
   END MakeTypes;

PROCEDURE CheckSubtype (t1, t2: tTree; Pos: tPosition; Reason : ARRAY OF CHAR);
   BEGIN
      IF t1^.Kind = Tree.NodeTypes THEN
         IF t2^.Kind = Tree.UserType THEN
            Warning ( Reason , Pos ) ; 
            Warning ("  user type is incompatible with formal's tree type", Pos);
         ELSIF t2^.NodeTypes.TreeName # t1^.NodeTypes.TreeName THEN
            Error ( Reason , Pos ) ; 
            Error ("  incompatible tree types from different trees", Pos);
         ELSIF NOT IsSubset (t2^.NodeTypes.Types, t1^.NodeTypes.Types) THEN
            Error ( Reason , Pos ) ; 
            Error ("  not a subset of formal node kinds", Pos);
         END;
      ELSIF t1^.Kind = Tree.UserType THEN
         IF t2^.Kind = Tree.NodeTypes THEN
            Warning ( Reason , Pos ) ; 
            Warning ("  tree type is incompatible with formal's user type", Pos);
         ELSIF t2^.UserType.Type # t1^.UserType.Type THEN
            Warning ( Reason , Pos ) ; 
            Warning ("  incompatible user types", Pos);
         END;
      END;
   END CheckSubtype;

PROCEDURE CheckType (t1, t2: tTree; Pos: tPosition);
   VAR t        : tSet;
   BEGIN
      IF t1^.Kind = Tree.NodeTypes THEN
         IF t2^.Kind = Tree.UserType THEN
            Warning ("tree-type required", Pos);
         ELSIF t2^.NodeTypes.TreeName # t1^.NodeTypes.TreeName THEN
            Error ("incompatible types from different trees", Pos);
         ELSE
            MakeSet (t, t1^.NodeTypes.TreeName^.TreeName.ClassCount);
            Assign (t, t1^.NodeTypes.Types);
            Intersection (t, t2^.NodeTypes.Types);
            IF IsEmpty (t) THEN
               Warning ("disjoint node types", Pos);
            END;
            ReleaseSet (t);
         END;
      ELSIF t1^.Kind = Tree.UserType THEN
         IF t2^.Kind = Tree.NodeTypes THEN
            Warning ("user-type required", Pos);
         ELSIF t2^.UserType.Type # t1^.UserType.Type THEN
            Warning ("incompatible user types", Pos);
         END;
      END;
   END CheckType;

PROCEDURE ComputeDepthsClasses ( t : tTree (* Class *) ; FDepth : INTEGER ) 

; VAR LC : tTree 

; BEGIN
    LC := t 
  ; WHILE ( LC <> NIL ) AND ( LC ^ . Kind = Class ) 
    DO 
      LC ^ . Class . Depth := FDepth 
    ; ComputeDepthsClasses ( LC ^ . Class . Extensions , FDepth + 1 ) 
    ; LC := LC ^ . Class . Next 
    END (* WHILE *) 
  END ComputeDepthsClasses ; 

PROCEDURE ComputeDepths ( t : tTree (* TreeName *) ) 

; VAR LT : tTree 

; BEGIN
    LT := t 
  ; WHILE ( LT <> NIL ) AND ( LT ^ . Kind = TreeName ) 
    DO 
      ComputeDepthsClasses ( LT ^ . TreeName . Classes , 0 ) 
    ; LT := LT ^ . TreeName . Next 
    END (* WHILE *) 
  END ComputeDepths ; 

PROCEDURE ClassLUB ( Left , Right : tTree (* Class *) ) : tTree (* Class *) 

; VAR LDepth : INTEGER 

; BEGIN
    LDepth := Right ^ . Class . Depth 
  ; WHILE Left ^ . Class . Depth > LDepth 
    DO Left := Left ^ . Class . BaseClass 
    END (* WHILE *) 
  ; LDepth := Left ^ . Class . Depth 
  ; WHILE Right ^ . Class . Depth > LDepth 
    DO Right := Right ^ . Class . BaseClass 
    END (* WHILE *) 
  ; WHILE Left <> Right 
    DO
      IF Left ^ . Class . Depth = 1  
      THEN 
        Left := Left ^ . Class . TypeDesc 
                ^ . NodeTypes . TreeName 
                ^ . TreeName . UniversalClass 
      ; Right := Left 
      ELSE 
        Left := Left ^ . Class . BaseClass
      ; Right := Right ^ . Class . BaseClass 
      END (* IF *) 
    END (* WHILE *) 
  ; RETURN Left 
  END ClassLUB ; 

PROCEDURE NextPatterns 
  ( Patterns : tTree ; VAR Result : tTree ; VAR CarryOut : BOOLEAN ) 

; VAR LSuffix , LCurrent : tTree 

; BEGIN 
    CASE Patterns ^ . Kind OF 
    | Tree . NoPattern 
      : CarryOut := TRUE 
      ; Result := mNoPattern ( Patterns ^ . NoPattern  . Pos )   
    | Tree . OnePattern 
      : NextPatterns 
          ( Patterns ^ . OnePattern . Next , LSuffix , CarryOut ) 
      ; Result 
          := mOnePattern 
                ( CopyTree ( Patterns ^ . OnePattern . Pattern ) , LSuffix ) 
    | Tree . OnePatternAlts  
      : NextPatterns 
          ( Patterns ^ . OnePatternAlts . Next , LSuffix , CarryOut ) 
      ; LCurrent := Patterns ^ . OnePatternAlts . Current  
      ; Assert
          ( IsType 
              ( LCurrent ^ . OnePatternsList . Patterns , Tree . Decompose )  
          , "NextPatterns, Alt not Decompose." 
          ) 
      ; Result 
          := mOnePattern 
               ( CopyTree ( LCurrent ^ . OnePatternsList . Patterns ) 
                 (* ^A Decompose node.  See ExpandDecompose. *) 
               , LSuffix 
               ) 
      ; IF CarryOut (* Actually, this is the carry in. *) 
        THEN 
          LCurrent := LCurrent ^ . OnePatternsList . Next 
        ; IF LCurrent ^ . Kind = Tree . NoPatternsList 
          THEN 
            Patterns ^ . OnePatternAlts . Current 
              := Patterns ^ . OnePatternAlts . PatternsList 
          ELSE 
            CarryOut := FALSE  
          ; Patterns ^ . OnePatternAlts . Current := LCurrent 
          END (* IF *)  
        END (* IF *) 
    END (* CASE *) 
  END NextPatterns ; 

PROCEDURE ExpandDecompose 
  ( Pos: tPosition
  ; Selector: tIdent
  ; Expr: tTree (* VarUse, Index, or Binary, a form which is a node or type *) 
                (* 1st VarUse inside must have Object field set. *) 
  ; Exprs: tTree (* Untransformed *) 
  ; Widen: BOOLEAN 
  ; VAR Result : tTree 
  ; VAR PatternCount : CARDINAL 
  )
(* POST: Either PatternCount = 1 and Result points to a Decompose node,
   or PatternCount > 1 and Result points to a list of PatternsList
   nodes, each of which points to a Decompose.  The latter case 
   violates the definition of OnePatternsList, but it is a path of
   lower coding resistance. *) 

; VAR LTreeName , LClasses , LClassVarUse , LClass , LOperands : tTree 
; VAR LDecomposeExpr , LResult , LPatterns , LSingleOperands : tTree 
; VAR LClassCount , LOperandsCount : CARDINAL 
; VAR LCarryOut , LHasExactlyOneClass : BOOLEAN 

; BEGIN
    LClassCount := 1 
  ; PatternCount := 0 
  ; LResult := mNoPatternsList ( ) 
  ; CASE Expr ^ . Kind OF 
    | Tree . Index 
      : AssertPos 
          ( Expr ^ . Index . Expr ^ . Kind = Tree . VarUse 
          , "ExpandDecompose, Index w/o 1st VarUse." 
          , Expr ^ . Index . Pos 
          ) 
      ; LTreeName := Expr ^ . Index . Expr ^ . VarUse . Object 
      ; LClasses := Expr ^ . Index . Exprs 
      ; AssertPos 
          ( LClasses ^ . Kind = Tree . OneExpr 
          , "ExpandDecompose, Index w/o Expr." 
          , Expr ^ . Index . Pos 
          ) 
      ; LClassVarUse := LClasses ^ . OneExpr . Expr 
      ; AssertPos 
          ( LClassVarUse ^ . Kind = Tree . VarUse  
          , "ExpandDecompose, Index w/o 2nd VarUse." 
          , Expr ^ . Index . Pos 
          ) 
      ; LClass 
          := IdentifyClass 
               ( LTreeName ^ . TreeName . Classes 
               , LClassVarUse ^ . VarUse . Name 
               ) 
      ; LClassVarUse ^ . VarUse . Object := LClass 
      ; LDecomposeExpr 
          := mBinary 
               ( Expr ^ . Index . Pos 
               , Expr ^ . Index . Expr 
               , IdentDot 
               , LClassVarUse 
               ) 
      ; LHasExactlyOneClass 
          := LClasses ^ . OneExpr . Next ^ . Kind = Tree . NoExpr 
    | Tree . VarUse 
      : LClassVarUse := Expr 
      ; LClass := LClassVarUse ^ . VarUse . Object 
      ; LDecomposeExpr := Expr  
      ; LHasExactlyOneClass := TRUE 
    | Tree . Binary 
      : AssertPos 
          ( Expr ^ . Binary . Operator = IdentDot 
          , "ExpandDecompose, Binary w/o dot." 
          , Expr ^ . Binary . Pos 
          ) 
      ; AssertPos 
          ( Expr ^ . Binary . Lop ^ . Kind = Tree . VarUse  
          , "ExpandDecompose, Binary w/o 1st VarUse." 
          , Expr ^ . Binary . Pos 
          ) 
      ; LTreeName := Expr ^ . Binary . Lop ^ . VarUse . Object 
      ; AssertPos 
          ( Expr ^ . Binary . Rop ^ . Kind = Tree . VarUse 
          , "ExpandDecompose, Binary w/o 2nd VarUse." 
          , Expr ^ . Binary . Pos 
          ) 
      ; LClassVarUse := Expr ^ . Binary . Rop 
      ; LClass 
          := IdentifyClass 
               ( LTreeName ^ . TreeName . Classes 
               , LClassVarUse ^ . VarUse . Name 
               ) 
      ; LClassVarUse ^ . VarUse . Object := LClass 
      ; LDecomposeExpr := Expr 
      ; LHasExactlyOneClass := TRUE 
    ELSE CantHappen ( "ExpandDecompose, Bad Kind." ) 
    END (* CASE *) 
  ; LOOP (* Thru type elements *)
    (* INVARIANT: Expr ^ . Kind = Tree . Index 
                    => LTreeName is the object for the tree name. 
                  LClassVarUse points to a VarUse node for the
                    next Class.
                  LDecomposeExpr is the Expr child of the to-be-constructed
                    Decompose node. 
                  LHasExactlyOneClass is set appropriately. 
                  LClass is the decl of the class. 
    *) 
      IF LClass = NoTree 
      THEN 
        Error ( "not a class or node of the required tree" 
              , LClassVarUse ^ . VarUse . Pos 
              ) 
      ELSE 
        AssertPos 
          ( LClass ^ . Kind = Tree . Class 
          , "ExpandDecompose, not a class. "
          , Expr ^ . Expr . Pos 
          ) 
      ; LOperands 
          := TransformName ( Exprs , LClass ^ . Class . Formals ) 
      ; TransformPattern ( LOperands , LOperands , LOperandsCount ) 
      ; INC ( PatternCount , LOperandsCount ) 
      ; LOOP (* Thru cartesian product of operand patterns *) 
          IF LHasExactlyOneClass AND ( LOperandsCount = 1 ) 
          THEN (* Avoid unnecessary copying *) 
            LSingleOperands := LOperands 
          ; LCarryOut := TRUE 
          ELSE 
            NextPatterns ( LOperands , LSingleOperands , LCarryOut ) 
          END (* IF *) 
        ; LPatterns 
            := mDecompose 
                 ( Pos 
                 , Selector 
                 , LDecomposeExpr 
                 , LSingleOperands 
                 , Widen 
                 ) 
        ; LPatterns ^ . Decompose . Object := LClass  
        ; LResult 
            := mOnePatternsList ( LPatterns , LResult ) 
          (* ^This builds the result list backwards. *) 
        ; IF LCarryOut THEN EXIT END (* IF *) 
        END (* LOOP *) 
      END (* IF *) 
    (* Loop advance and termination: *) 
    ; IF Expr ^ . Kind = Tree . Index 
      THEN 
        LOOP (* Thru possibly bad type elements *) 
          LClasses := LClasses ^ . OneExpr . Next 
        ; CASE LClasses ^ . Kind OF 
          | Tree . NoExpr 
            : LClassVarUse := NoTree 
            ; EXIT (* Inner loop.  Will then exit outer loop. *) 
          | Tree . NamedExpr 
            : LClassVarUse := LClasses ^ . NamedExpr . Expr 
            ; Error 
                ( "named expression not allowed in a type" 
                , LClassVarUse ^ . Expr . Pos 
                ) 
            ; IF LClassVarUse ^ . Kind <> Tree . VarUse 
              THEN 
                Error 
                  ( "single identifier required in a type" 
                  , LClassVarUse ^ . Expr . Pos 
                  ) 
              END (* IF *) 
          | Tree .OneExpr 
            : LClassVarUse := LClasses ^ . OneExpr . Expr 
            ; IF LClassVarUse ^ . Kind <> Tree . VarUse 
              THEN 
                Error 
                  ( "single identifier required in a type" 
                  , LClassVarUse ^ . Expr . Pos 
                  ) 
              ELSE 
                INC ( LClassCount ) 
              ; LClass 
                  := IdentifyClass 
                       ( LTreeName ^ . TreeName . Classes 
                       , LClassVarUse ^ . VarUse . Name 
                       )  
              ; LClassVarUse ^ . VarUse . Object := LClass 
              ; LDecomposeExpr 
                  := mBinary 
                       ( Expr ^ . Index . Pos 
                       , Expr ^ . Index . Expr 
                       , IdentDot 
                       , LClassVarUse 
                       ) 
              ; EXIT (* Inner loop. Will then go around outer loop *) 
              END (* IF *) 
          ELSE CantHappenPos 
                 ( "ExpandDecompose, not an expr." 
                 , LClassVarUse ^ . VarUse . Pos 
                 ) 
          END (* CASE *) 
        END (* LOOP Thru possibly bad type elements *) 
      ; IF LClassVarUse = NoTree THEN EXIT END (* IF *)  
      ELSE 
        EXIT 
      END (* IF *) 
    END (* LOOP Thru type elements *) 
  ; IF PatternCount = 1 
    THEN 
      Result := LResult ^ . OnePatternsList . Patterns 
    ELSE
      Result := ReverseTree ( LResult ) 
    END (* IF *) 
  END ExpandDecompose ; 

PROCEDURE TransformPattern 
  ( t : tTree ; VAR Result : tTree ; VAR PatternCount : CARDINAL ) 

; BEGIN 
    IF t ^ . Kind = Tree . NoExpr 
    THEN
      Result 
        := mOnePattern 
             ( mDontCareInternal ( t ^ . NoExpr . Pos ) 
             , mNoPattern ( t ^ . NoExpr . Pos )  
             ) 
    ; PatternCount := 1 
    ELSE
      TransformPatternRecurse ( t , Result , PatternCount ) 
    END (* IF *) 

  END TransformPattern ; 

PROCEDURE TransformPatternRecurse 
  ( t : tTree ; VAR Result : tTree ; VAR PatternCount : CARDINAL ) 

; VAR TreeName , s , LTreeName , LClass , LPrefixVarUse , L1stVarUse : tTree 
; VAR LTree1 , LTree2 : tTree 
; VAR LThisCount , LNextCount : CARDINAL 

; BEGIN 
    PatternCount := 1 
  ; CASE t ^ . Kind 

    OF Tree . NoExpr 
      : Result := mNoPattern ( t ^ . NoExpr . Pos ) 

    | Tree . Parents 
      : IF IsType ( t ^ . Parents . Expr , Tree . DontCare1 ) 
        THEN (* Ignore parentheses around '_' *) 
          TransformPatternRecurse 
            ( t ^ . Parents . Expr , LTree1 , PatternCount ) 
          (* Result := mParents ( t ^ . Parents . Pos , LTree1 ) ; *) 
        ; Result := LTree1 ; 
        ELSE 
          Result := mValue ( t ^ . Expr . Pos , TransformExpr ( t ) ) 
        END (* IF *) 

    | Tree . OneExpr 
      : WITH t ^ . OneExpr 
        DO 
          TransformPatternRecurse ( Expr , LTree1 , LThisCount ) 
        ; TransformPatternRecurse ( Next , LTree2 , LNextCount ) 
        ; IF LThisCount = 1 
          THEN 
            Result := mOnePattern ( LTree1 , LTree2 ) 
          ELSE  
            Result 
              := mOnePatternAlts 
                   ( (* PatternsList := *) LTree1 
                   , (* Next := *) LTree2 
                   , (* Current := *) LTree1 
                   ) 
          END (* IF *) 
        ; PatternCount := LThisCount * LNextCount 
        END (* WITH *) 

    | Tree . NamedExpr 
      : WITH t ^ . NamedExpr 
        DO 
          Error 
            ( "illegal context for named association" 
            , Expr ^ . Expr . Pos 
            ) 
        ; TransformPatternRecurse ( Expr , LTree1 , LThisCount ) 
        ; TransformPatternRecurse ( Next , LTree2 , LNextCount ) 
        ; IF LThisCount = 1 
          THEN 
            Result := mOnePattern ( LTree1 , LTree2 ) 
          ELSE  
            Result 
              := mOnePatternAlts 
                   ( (* PatternsList := *) LTree1 
                   , (* Next := *) LTree2 
                   , (* Current := *) LTree1 
                   ) 
          END (* IF *) 
        ; PatternCount := LThisCount * LNextCount 
        END (* WITH *) 

    | Tree . Nil 
      : Result 
          := mNilTest ( t ^ . Nil . Pos , t ^ . Nil . Selector ) 

    | Tree . DontCareExplicit , Tree . DontCareInternal  
    , Tree . DontCare1Explicit , Tree . DontCare1Internal  
      : Result := t 

    | Tree . DontCare1 , Tree . DontCare
      : CantHappen 
          ( 'TransformPatternRecurse, undistinguished DontCare' ) 

    | Tree . Compose 
      : WITH t ^ . Compose 
        DO 
          IF Expr ^ . Kind = Tree . Index 
          THEN 
            IF ( Expr ^ . Index . Expr ^ . Kind = Tree . VarUse ) 
               AND IsType 
                     ( Expr ^ . Index . Exprs , Tree . OneExpr ) 
               AND ( Expr ^ . Index . Exprs ^ . OneExpr . Expr ^ . Kind 
                     = Tree . VarUse 
                   ) 
            THEN (* [ <ident> ] '[' <ident> ... ']' '(' ... ')' *) 
              LPrefixVarUse := Expr ^ . Index . Expr  
            ; L1stVarUse 
                := Expr ^ . Index . Exprs ^ . OneExpr . Expr 
            ; IF LPrefixVarUse ^ . VarUse . Name = NoIdent 
              THEN (* '[' <ident> ... ']' *) 
                Object (* of Compose node *)
                  := IdentifyClass2 
                       ( L1stVarUse ^ . VarUse . Name , LTreeName ) 
              ; LPrefixVarUse ^ . VarUse . Object := LTreeName 
              ; L1stVarUse ^ . VarUse . Object := Object 
              ; IF Object = NoTree 
                THEN 
                  Error 
                    ( "node type not declared" 
                    , L1stVarUse ^ . VarUse . Pos 
                    ) 
                ; Result := mDontCareInternal ( Pos ) 
                ELSE 
                  ExpandDecompose 
                    ( Pos , Selector , Expr , Exprs , Widen 
                    , Result , PatternCount 
                    ) 
                END (* IF *) 
              ELSE (* prefix identifier is present. *) 
                LTreeName 
                  := IdentifyTree 
                       ( LPrefixVarUse ^ . VarUse . Name ) 
              ; LPrefixVarUse ^ . VarUse . Object := LTreeName 
              ; IF LTreeName = NoTree 
                THEN (* Interpret as plain target index expression. *) 
                  Result 
                    := mValue 
                         ( t ^ . Expr . Pos , TransformExpr ( t ) ) 
                ELSE 
                  Object 
                    := IdentifyClass 
                         ( LTreeName ^ . TreeName . Classes 
                         , L1stVarUse ^ . VarUse . Name 
                         ) 
                ; L1stVarUse ^ . VarUse . Object := Object 
                ; IF Object = NoTree 
                  THEN (* Interpret as plain target index expression. *) 
                    Result 
                      := mValue 
                           ( t ^ . Expr . Pos , TransformExpr ( t ) ) 
                  ELSE 
                    ExpandDecompose 
                      ( Pos , Selector , Expr , Exprs , Widen 
                      , Result , PatternCount 
                      ) 
                  END (* IF *) 
                END (* IF *) 
              END (* IF *) 
            ELSE (* Not a special form of index *) 
              Result 
                := mValue ( t ^ . Expr . Pos , TransformExpr ( t ) ) 
            END (* IF special form of index *) 
          ELSE (* Not Index *) 
            IF Expr ^ . Kind = Tree . VarUse 
            THEN 
              Object 
                := IdentifyClass2 
                     ( Expr ^ . VarUse . Name , TreeName ) 
            ; IF Object = NoTree 
              THEN 
                Object := IdentifyProc ( Expr ^ . VarUse . Name ) 
              END 
            ; Expr ^ . VarUse . Object := Object 
            ELSIF ( Expr ^ . Kind = Tree . Binary ) 
                  AND ( Expr ^ . Binary . Operator = IdentDot ) 
                  AND ( Expr ^ . Binary . Lop ^ . Kind 
                        = Tree . VarUse 
                      ) 
                  AND ( Expr ^ . Binary . Rop ^ . Kind 
                        = Tree . VarUse 
                      ) 
            THEN 
              Object 
                := IdentifyTree 
                     ( Expr ^ . Binary . Lop ^ . VarUse . Name ) 
            ; Expr ^ . Binary . Lop ^ . VarUse . Object := Object 
            ; IF Object # NoTree 
              THEN 
                Object 
                  := IdentifyClass 
                       ( Object ^ . TreeName . Classes 
                       , Expr ^ . Binary . Rop ^ . VarUse . Name 
                       ) 
              END 
            ; Expr ^ . Binary . Rop ^ . VarUse . Object := Object 
            ELSE (* Expr is not one of the forms consistent with Decompose. 
                    Treat as a target call. *) 
              Expr := TransformExpr ( Expr ) 
            ; Object := NoTree 
            END 
          ; IF Object # NoTree 
            THEN 
              IF Object ^ . Kind = Class 
              THEN 
                ExpandDecompose 
                  ( Pos , Selector , Expr , Exprs , Widen 
                  , Result , PatternCount 
                  ) 
              ELSE (* Object denotes a puma-declared procedure *) 
                s := mCall 
                       ( Pos 
                       , Expr 
                       , TransformExpr ( Exprs ) 
                       , mNoPattern ( Pos ) 
                       ) 
              ; s ^ . Call . Object := Object 
              ; Result := mValue ( Pos , s ) 
              END 
            ELSE (* Object is unknown.  Treat as a target procedure call. *) 
              s := mCall 
                     ( Pos 
                     , Expr 
                     , TransformExpr ( Exprs ) 
                     , mNoExpr ( Pos ) 
                     ) 
            ; s ^ . Call . Object := Object 
            ; Result := mValue ( Pos , s ) 
            END (* IF *) 
          END (* IF *) 
        END (* WITH t^.Compose *) 

    | Tree . VarUse 
      : WITH t ^ . VarUse 
        DO 
          IF MustBeLabel 
          THEN (* It had ':' or ':>' after it. *) 
            Result := mVarDef ( Pos , Name ) 
          ELSE 
            Object := IdentifyClass2 ( Name , TreeName ) 
          ; IF ( ( Object # NoTree ) 
                 AND IsElement ( ORD ( 'p' ) , Options ) 
               ) 
                (* Allow (de)constructors w/o parentheses. *) 
            THEN (* It is a node name *) 
              t ^ . VarUse . Object := Object 
            ; Result 
                := mDecompose 
                     ( Pos 
                     , NoIdent 
                     , t 
                     , mOnePattern 
                         ( mDontCareInternal ( Pos ) , mNoPattern ( Pos ) ) 
                     , FALSE 
                     ) 
            ; Result ^ . Decompose . Object := Object 
            ELSE (* Not a node name, treat as a label. *) 
              IF IsElement ( ORD ( 'u' ) , Options ) 
                  (* Colon, etc. required on labels *) 
              THEN 
                Error ( "Missing colon after label" , Pos ) 
              END (* IF *) 
            ; Result := mVarDef ( Pos , Name ) 
            END 
          END (* IF *) 
        END (* WITH *) 

    | Tree . Binary 
      : WITH t ^ . Binary 
        DO 
          IF IsElement ( ORD ( 'p' ) , Options ) 
             AND ( Operator = IdentDot ) 
             AND ( Lop ^ . Kind = Tree . VarUse ) 
             AND ( Rop ^ . Kind = Tree . VarUse ) 
          THEN (* Ident '.' Ident 
                  and (de)constructors w/o parentheses allowed. *)
            LTreeName := IdentifyTree ( Lop ^ . VarUse . Name ) 
          ; IF LTreeName # NoTree 
            THEN 
              LClass 
                := IdentifyClass 
                     ( LTreeName ^ . TreeName . Classes 
                     , Rop ^ . VarUse . Name 
                     ) 
            ; IF LClass # NoTree 
              THEN 
                Lop ^ . VarUse . Object := LTreeName 
              ; Rop ^ . VarUse . Object := LClass 
              ; Result 
                  := mDecompose 
                       ( Pos 
                       , NoIdent 
                       , t 
                       , mOnePattern 
                           ( mDontCareInternal ( Pos ) , mNoPattern ( Pos ) ) 
                       , FALSE 
                       ) 
              ; Result ^ . Decompose . Object := LClass 
              ELSE 
                Result := mValue ( Pos , TransformExpr ( t ) ) 
              END 
            ELSE 
              Result := mValue ( Pos , TransformExpr ( t ) ) 
            END 
          ELSE 
            Result := mValue ( Pos , TransformExpr ( t ) ) 
          END 
        END (* WITH *) 

    | Tree . Index 
      : WITH t ^ . Index 
        DO 
          IF IsElement ( ORD ( 'p' ) , Options ) 
             AND ( Expr ^ . Kind = Tree . VarUse ) 
             AND IsType ( Exprs , Tree . OneExpr ) 
             AND ( Exprs ^ . OneExpr . Expr ^ . Kind = Tree . VarUse ) 
          THEN (* [ <ident> ] [ '.' ] '[' <ident> ... ']' 
                  and (de)constructors w/o parentheses allowed. *)
            L1stVarUse := Exprs ^ . OneExpr . Expr 
          ; IF Expr ^ . VarUse . Name = NoIdent 
            THEN (* '[' <ident> ... ']' *) 
              LClass 
                := IdentifyClass2 
                     ( L1stVarUse ^ . VarUse . Name , LTreeName ) 
            ; Expr ^ . VarUse . Object := LTreeName 
            ; L1stVarUse ^ . VarUse . Object := LClass 
            ; IF LClass = NoTree 
              THEN 
                Error 
                  ( "node type not declared" 
                  , L1stVarUse ^ . VarUse . Pos 
                  ) 
              ; Result := mDontCareInternal ( L1stVarUse ^ . VarUse . Pos ) 
              ELSE
                ExpandDecompose 
                  ( Pos 
                  , NoIdent (* Selector, i.e. label *) 
                  , t 
                  , mOnePattern 
                      ( mDontCareInternal ( Pos ) , mNoPattern ( Pos ) ) 
                  , FALSE 
                  , Result 
                  , PatternCount 
                  ) 
              END (* IF *) 
            ELSE (* prefix identifier is present. *) 
              LTreeName := IdentifyTree ( Expr ^ . VarUse . Name ) 
            ; Expr ^ . VarUse . Object := LTreeName 
            ; IF LTreeName = NoTree 
              THEN (* Interpret as target code index *) 
                Result := mValue 
                  ( t ^ . Expr . Pos , TransformExpr ( t ) ) 
              ELSE 
                LClass 
                  := IdentifyClass 
                       ( LTreeName ^ . TreeName . Classes 
                       , L1stVarUse ^ . VarUse . Name 
                       ) 
              ; L1stVarUse ^ . VarUse . Object := LClass 
              ; IF LClass = NoTree 
                THEN (* Interpret as target index *) 
                  Result 
                    := mValue 
                         ( t ^ . Expr . Pos , TransformExpr ( t ) ) 
                ELSE
                  ExpandDecompose 
                    ( Pos 
                    , NoIdent (* Selector, i.e. label *) 
                    , t 
                    , mOnePattern 
                        ( mDontCareInternal ( Pos ) , mNoPattern ( Pos ) ) 
                    , FALSE 
                    , Result 
                    , PatternCount 
                    ) 
                END (* IF *) 
              END (* IF *) 
            END (* IF *) 
          ELSE 
            Result 
              := mValue ( t ^ . Expr . Pos , TransformExpr ( t ) ) 
          END (* IF *) 
        END (* WITH *) 

    | Tree . Call , Tree . PreOperator , Tree . PostOperator 
    , Tree . TargetExpr , Tree . StringExpr 
    , Tree . AttrDesc (* '::' in an expression *) 
      : Result := mValue ( t ^ . Expr . Pos , TransformExpr ( t ) ) 

    | Tree . NoPattern , Tree . OnePattern , Tree . OnePatternAlts 
      : CantHappen ( "TransformPatternRecurse, already transformed." ) 
      ; Result := t 

    END (* CASE *) 
  END TransformPatternRecurse ; 

PROCEDURE TransformExpr (t: tTree): tTree;
   VAR TreeName, s, LObject1, LObject2  : tTree;
   VAR LPatternCount : CARDINAL ; 
   BEGIN
      CASE t^.Kind OF
      | Tree.NoExpr     :

      | Tree.OneExpr    : WITH t^.OneExpr DO
            Expr        := TransformExpr (Expr);
            Next        := TransformExpr (Next);
         END;

      | Tree.NamedExpr  : WITH t^.NamedExpr DO
            Error 
              ("label illegal in an expression"
              , t^.NamedExpr.Expr^.Expr.Pos);
            RETURN mOneExpr (TransformExpr (Expr), TransformExpr (Next));
         END;

      | Tree.Compose    : WITH t^.Compose DO
            IF Expr^.Kind = Tree.VarUse THEN
               Object := IdentifyClass2 (Expr^.VarUse.Name, TreeName);
               IF Object = NoTree 
               THEN Object := IdentifyProc (Expr^.VarUse.Name); END;
               Expr^.VarUse.Object := Object; 
            ELSIF (Expr^.Kind = Tree.Binary) AND
                  (Expr^.Binary.Lop^.Kind = Tree.VarUse) AND
                  (Expr^.Binary.Rop^.Kind = Tree.VarUse) THEN
(* Can assert Operator is a dot? *) 
               Object := IdentifyTree (Expr^.Binary.Lop^.VarUse.Name);
               (* Expr^.Binary.Lop^.VarUse.Object := Object; 
                  This seems reasonable, but breaks M2.puma`s generation of 
                  Tree.<NotAClass> M2.puma always expects a VarUse with a 
                  non-NIL Object field to have Object of kind Formal, with
                  a Path to call ImplMod on. *) 
               IF Object # NoTree THEN
                  Object := IdentifyClass (Object^.TreeName.Classes, Expr^.Binary.Rop^.VarUse.Name);
               END;
               IF Object = NoTree 
               THEN 
                 Expr^.Binary.Lop^.VarUse.Object := NoTree 
               ; Expr^.Binary.Rop^.VarUse.Object := NoTree 
               END (* IF *) 
            ELSE
               Object := NoTree;
               Expr := TransformExpr (Expr);
            END;

            IF Object # NoTree THEN
               IF Object^.Kind = Class THEN
                  Exprs := TransformName (Exprs, Object^.Class.Formals);
                  Exprs := TransformExpr (Exprs);
                  RETURN t;
               ELSE
                  s := mCall (Pos, Expr, TransformExpr (Exprs), mNoPattern (Pos));
                  s^.Call.Object := Object;
                  RETURN s;
               END;
            ELSE
               s := mCall (Pos, Expr, TransformExpr (Exprs), mNoExpr (Pos));
               s^.Call.Object := Object;
               RETURN s;
            END;
         END;

      | Tree.VarUse     : WITH t^.VarUse DO
            Object := IdentifyClass2 (Name, TreeName);
            IF (Object # NoTree) AND IsElement (ORD ('p'), Options) THEN
               s := mCompose (Pos, NoIdent, t, mOneExpr (mDontCareInternal (Pos), mNoExpr (Pos)), FALSE);
               s^.Compose.Object := Object;
               RETURN s;
            ELSE
               Object := NoTree;
               RETURN t;
            END;
         END;

      | Tree.Nil        :
      | Tree.DontCare1Explicit  :
      | Tree.DontCare1Internal  :
      | Tree.DontCareExplicit   :
      | Tree.DontCareInternal   :

      | Tree.DontCare1, Tree.DontCare   
        : CantHappen 
            ( 'TransformExpr, undistinguished DontCare' ) 

      | Tree.Call       : WITH t^.Call DO
            IF Expr^.Kind = Tree.VarUse THEN
               Object := IdentifyProc (Expr^.VarUse.Name);
            ELSE
               Object := NoTree;
            END;
            Expr  := TransformExpr (Expr);
            Exprs := TransformExpr (Exprs);
            IF Object # NoTree THEN
              TransformPattern ( Patterns , Patterns , LPatternCount ) 
              (* ^These are the actuals of out formals of a puma routine. 
                 Why don`t we do a TransformName? *)
            ; IF LPatternCount > 1 
              THEN 
                Error 
                  ( 'pattern containing multi-valued types not allowed as actual to out formal' 
                  , Pos 
                  ) 
              END (* IF *) 
            ELSIF Patterns ^ . Kind = Tree . OneExpr  
                  (* Parser builds these as a list of expressions.
                     TransformPattern, if done at all, transforms
                     into a list of patterns. *) 
            THEN 
               Error 
                 ( "Call on user procedure cannot have result patterns" 
                 , Pos 
                 ) ;
               Patterns := TransformExpr (Patterns);
            END;
         END;

      | Tree.Binary     : WITH t^.Binary DO
            IF IsElement (ORD ('p'), Options) AND 
               ( Operator = IdentDot ) AND 
               (Lop^.Kind = Tree.VarUse) AND (Rop^.Kind = Tree.VarUse) THEN
               LObject1 := IdentifyTree (Lop^.VarUse.Name);
               IF LObject1 # NoTree THEN
                  LObject2 := IdentifyClass (LObject1^.TreeName.Classes, Rop^.VarUse.Name);
                  IF LObject2 # NoTree THEN
                     s := mCompose (Pos, NoIdent, t, mOneExpr (mDontCareInternal (Pos), mNoExpr (Pos)), FALSE);
                     s^.Compose.Object := LObject2;
                     Lop^.VarUse.Object := LObject1; 
                     Rop^.VarUse.Object := LObject2; 
                     RETURN s;
                  END;
               END;
            END;
            Lop         := TransformExpr (Lop);
            Rop         := TransformExpr (Rop);
         END;

      | Tree . BinaryCompound 
        : WITH t ^ . BinaryCompound 
          DO 
            Lop         := TransformExpr (Lop)
          ; Rop         := TransformExpr (Rop)
          END (* WITH t ^ . BinaryCompound *) ; 

      | Tree.PreOperator, Tree.PostOperator     : WITH t^.PreOperator DO
            Expr        := TransformExpr (Expr);
         END;

      | Tree.Index      : WITH t^.Index DO
            Expr        := TransformExpr (Expr);
            Exprs       := TransformExpr (Exprs);
         END;

      | Tree.Parents    : WITH t^.Parents DO
            Expr        := TransformExpr (Expr);
         END;

      | Tree.TargetExpr :
      | Tree.StringExpr :
      | Tree.AttrDesc   : (* '::' in an expression *)
      END;
      RETURN t;
   END TransformExpr;

PROCEDURE TransformStmt (t: tTree): tTree;
   BEGIN
      CASE t^.Kind OF
      | Tree.NoStatement: RETURN t;

      | Tree.ProcCall   : WITH t^.ProcCall DO
            Call := TransformExpr (Call);
            IF Call^.Kind = Tree.Call THEN
               WITH Call^.Call DO
                  IF (Object # NoTree) AND
                     ((Object^.Kind = Tree.Predicate) OR (Object^.Kind = Tree.Function)) THEN
                     t^.Kind := Tree.Condition;
                  END;
               END;
            ELSIF Call^.Kind = Tree.Compose THEN
              Error ("Node constructor as a statement", Pos);
            ELSIF Call^.Kind = Tree.StringExpr THEN
               t := mWriteStr (Pos, Next, Call^.StringExpr.String);
            ELSE
               t^.Kind := Tree.Condition;
            END;
         END;

      | Tree.Assignment : WITH t^.Assignment DO
            Adr  := TransformExpr (Adr );
            Expr := TransformExpr (Expr);
         END;

      | Tree.Reject     :
      | Tree.Fail       :
      | Tree.TargetStmt :
      | Tree.Nl         :
      | Tree.WriteStr   :
      END;
      t^.Statement.Next := TransformStmt (t^.Statement.Next);
      RETURN t;
   END TransformStmt;

PROCEDURE TransformName (t, Formals: tTree): tTree;
   VAR
      Exprs             : tTree;
      Last              : POINTER TO tTree;
      n, i              ,
      Minimum, Maximum  : INTEGER;
      PatternsSize      : LONGINT;
      PatternsPtr       : POINTER TO ARRAY [0..50000] OF tTree;

   BEGIN
      Exprs := t;
      WHILE Exprs^.Kind = Tree.OneExpr DO Exprs := Exprs^.OneExpr.Next; END;
      IF Exprs^.Kind = Tree.NoExpr THEN RETURN t; END;
      n := 0;
      Exprs := Formals;
      WHILE Exprs^.Kind = Tree.Formal DO INC (n); Exprs := Exprs^.Formal.Next; END;
      PatternsSize := n + 1;
      MakeArray (PatternsPtr, PatternsSize, TSIZE (tTree));
      FOR i := 1 TO n DO PatternsPtr^[i] := NoTree; END;
      Last := ADR (t);
      Exprs := t;
      i := 0;
      WHILE Exprs^.Kind = Tree.OneExpr DO
         INC (i);
         PatternsPtr^[i] := Exprs^.OneExpr.Expr;
         Last := ADR (Exprs^.OneExpr.Next);
         Exprs := Exprs^.OneExpr.Next;
      END;
      Minimum := i + 1;
      Maximum := i;
      WHILE Exprs^.Kind = Tree.NamedExpr DO
         i := LookupFormal (Exprs^.NamedExpr.Name, Formals);
         IF i = 0 THEN
            Error ("no such formal/child name", Exprs^.NamedExpr.Expr^.Expr.Pos);
         ELSIF PatternsPtr^[i] # NoTree THEN
            Error ("this formal/child was previously supplied"
                  , Exprs^.NamedExpr.Expr^.Expr.Pos
                  );
         ELSE
            PatternsPtr^[i] := Exprs^.NamedExpr.Expr;
         END;
         Maximum := Max (Maximum, i);
         Exprs := Exprs^.NamedExpr.Next;
      END;
      Exprs := mOneExpr (mDontCareInternal (NoPosition), mNoExpr (NoPosition));
      FOR i := Maximum TO Minimum BY -1 DO
         IF PatternsPtr^[i] = NoTree THEN
            Exprs := mOneExpr (mDontCare1Internal (NoPosition), Exprs);
         ELSE
            Exprs := mOneExpr (PatternsPtr^[i], Exprs);
         END;
      END;
      Last^ := Exprs;
      ReleaseArray (PatternsPtr, PatternsSize, TSIZE (tTree));
      RETURN t;
   END TransformName;

PROCEDURE CheckExprList (t, Formals: tTree);
   BEGIN
      IF (t^.Kind = Tree.NoExpr) AND (Formals^.Kind # Tree.Formal) THEN RETURN; END;
      IF t^.Kind = Tree.NoExpr THEN
         Error ("too few expressions or arguments", t^.NoExpr.Pos); RETURN;
      END;
      WITH t^.OneExpr DO
         IF Tree . IsType ( Expr , Tree.DontCare ) THEN RETURN; END;
         IF Formals^.Kind = Tree.NoFormal THEN
            Error ("too many expressions or arguments", Expr^.Expr.Pos); RETURN;
         END;
         CheckExpr (Expr, Formals);
         CheckExprList (Next, Formals^.Formal.Next);
      END;
   END CheckExprList;

PROCEDURE CheckInParams (t, Formals: tTree);
   BEGIN
      IF (t^.Kind = Tree.NoExpr) OR (Formals^.Kind # Tree.Formal) THEN RETURN; END;
      WITH t^.OneExpr DO
         IF Tree . IsType ( Expr , Tree.DontCare ) THEN RETURN; END;
         IF Formals^.Formal.Path^.Var.IsOutput AND (Expr^.Kind = Tree.VarUse) AND
            (Expr^.VarUse.Object # NoTree) AND (Expr^.VarUse.Object^.Formal.Path^.Kind = Tree.Var) AND
            NOT Expr^.VarUse.Object^.Formal.Path^.Var.IsOutput THEN
            Expr^.VarUse.Object^.Formal.Path^.Var.IsRegister := FALSE;
         END;
         CheckInParams (Next, Formals^.Formal.Next);
      END;
   END CheckInParams;

PROCEDURE CheckCallExprs (t, Formals: tTree);
   BEGIN
      IF (t^.Kind = Tree.NoExpr) AND (Formals^.Kind # Tree.Formal) THEN RETURN; END;
      IF t^.Kind = Tree.NoExpr THEN
         Error ("too few actual parameters", t^.NoExpr.Pos); RETURN;
      END;
      WITH t^.OneExpr DO
         IF Tree . IsType ( Expr , Tree.DontCare ) THEN
            Expr^.DontCare.Tempos := MakeTempos (Formals);
            RETURN;
         END;
         IF Formals^.Kind = Tree.NoFormal THEN
            Error ("too many actual parameters", Expr^.Expr.Pos); RETURN;
         END;
         CheckExprVar (Expr, Formals);
         CheckCallExprs (Next, Formals^.Formal.Next);
      END;
   END CheckCallExprs;

PROCEDURE CheckExprVar (t, Formals: tTree);
   BEGIN
      IF t^.Kind = Tree.Compose THEN
         t^.Compose.Tempo := MakeTempoIdent ();
         IF Formals^.Kind = Tree.Formal THEN
            t^.Compose.TypeDesc := Formals^.Formal.TypeDesc;
         ELSE
            t^.Compose.TypeDesc := t^.Compose.Object^.Class.TypeDesc;
         END;
      ELSIF Tree . IsType ( t , Tree.DontCare1 ) THEN
         t^.DontCare1.Tempo := MakeTempoIdent ();
         IF Formals^.Kind = Tree.Formal THEN
            t^.DontCare1.TypeDesc := Formals^.Formal.TypeDesc;
         ELSE 
           Error ( "Dont care in illegal context" , t ^ . DontCare1 . Pos ) 
         END;
      END;
      CheckExpr (t, Formals);
   END CheckExprVar;

PROCEDURE CheckExpr (t, Formals: tTree);

   VAR LAttrFormal : tTree ; 

   BEGIN
      CASE t^.Kind OF

      | Tree.Compose: WITH t^.Compose DO
            IF Selector # NoIdent THEN
               Warning ("label ignored on compose in expression", Pos);
            END;
            IF Formals^.Kind = Tree.Formal THEN
               CheckSubtype 
                 (Formals^.Formal.TypeDesc, Object^.Class.TypeDesc, Pos,
                  'Composed node not in formal/child type, specifically:');
            END;
            IF Object = NoTree THEN
               CheckExpr (Expr, dFormals);
            ELSE
               CheckExpr2 (Expr);
            END;
            CheckExprList (Exprs, Object^.Class.Formals);
         END;

      | Tree.VarUse: WITH t^.VarUse DO
            IF IsElement (Name, LabelNames) THEN
               Object := IdentifyVar (Decls, Name);
               IF (Object # NoTree) AND (Formals^.Kind = Tree.Formal) THEN
                  CheckSubtype 
                    (Formals^.Formal.TypeDesc, Object^.Formal.TypeDesc, Pos,
                     'Type of label reference not in formal/child type, specifically:');
               END;
            ELSIF NOT IsElement (Name, ExternNames) AND
                  NOT IsElement (Name, LocExternNames) AND
                  NOT IsElement (Name, UserNames) THEN
               IF IsElement (ORD ('e'), Options) THEN
                  ErrorI ("identifier not declared", Pos, Name);
               ELSIF IsElement (ORD ('v'), Options) AND NOT IsElement (ORD ('s'), Options) THEN
                  WarningI ("identifier not declared", Pos, Name);
               END;
               Include (LabelNames, Name);
                (* ^This will suppress further messages on this identifier
                   within this rule, but at the beginning of a new rule,
                   we will start over. *) 
            END;
         END;

      | Tree.Nil: WITH t^.Nil DO
            IF Selector # NoIdent THEN
               Warning ("label ignored on NIL in expr", Pos);
            END;
         END;

      | Tree.Call: WITH t^.Call DO
            IF Object = NoTree THEN
               CheckExpr (Expr, dFormals);
               IF Expr^.Kind = Tree.VarUse THEN
                  ProcName := Expr^.VarUse.Name;
               ELSIF (Expr^.Kind = Tree.Binary) AND
                     (Expr^.Binary.Lop^.Kind = Tree.VarUse) THEN
(* Can assert Expr ^ . Binary . Operator = Identdot ? *) 
                  ProcName := Expr^.Binary.Lop^.VarUse.Name;
               ELSE
                  ProcName := NoIdent;
               END;

               IF NOT IsElement (ProcName, ExternNames) AND
                  NOT IsElement (ProcName, LocExternNames) AND
                  NOT IsElement (ProcName, UserNames) 
               THEN
                  IF IsElement (ORD ('e'), Options) THEN
                     ErrorI ("subroutine identifier not declared", Pos, ProcName);
                  ELSIF IsElement (ORD ('v'), Options) AND NOT IsElement (ORD ('s'), Options) 
                  THEN
                     WarningI ("subroutine identifier not declared", Pos, ProcName);
                  END;
                  Include (UserNames, ProcName);
               END;
               CheckCallExprs (Exprs, dFormals);
               CheckCallExprs (Patterns, dFormals);
            ELSIF IsType (Object, Tree.Routine) THEN
               CheckExpr2 (Expr);
               IF (Object^.Kind = Tree.Function) AND (Formals^.Kind = Tree.Formal) THEN
                  CheckSubtype 
                    (Formals^.Formal.TypeDesc, 
                     Object^.Function.ReturnForm^.Formal.TypeDesc, Pos
                     , 'Result type of puma function not in formal/child type, specifically:');
               END;
               CheckCallExprs (Exprs, Object^.Routine.InForm);
               CheckCallPatterns (Patterns, Object^.Routine.OutForm);
(* ^We want this to happen for puma routines which are externally declared *) 
               CheckInParams (Exprs, Object^.Routine.InForm);
            ELSE
               Error ("subroutine identifier required", Pos);
            END;
         END;

      | Tree.Binary: WITH t^.Binary DO
            CheckExprVar (Lop, dFormals);
            CheckExprVar (Rop, dFormals);
         END;

      | Tree . BinaryCompound 
        : WITH t ^ . BinaryCompound 
          DO
            CheckExprVar (Lop, dFormals)
          ; CheckExprVar (Rop, dFormals)
          END (* WITH t ^ . BinaryCompound *) ;

      | Tree.PreOperator, Tree.PostOperator: WITH t^.PreOperator DO
            CheckExprVar (Expr, dFormals);
           (* *)
         END;

      | Tree.Index: WITH t^.Index DO
            CheckExprVar (Expr, dFormals);
            CheckExprList (Exprs, dFormals);
         END;

      | Tree.Parents: WITH t^.Parents DO
            CheckExprVar (Expr, Formals);
         END;

      | Tree.AttrDesc: (* '::' in an expression *)
         WITH t^.AttrDesc DO
            IF IsElement (Name, LabelNames) THEN
               Object := IdentifyVar (Decls, Name);
               IF Object^.Formal.TypeDesc^.Kind = Tree.NodeTypes THEN
                  ActClass 
                    := LookupClass 
                         ( Object^.Formal.TypeDesc^.NodeTypes.TreeName^.TreeName.Classes
                         , Minimum (Object^.Formal.TypeDesc^.NodeTypes.Types)
                         );
                  Type := ActClass^.Class.Name;
                  LAttrFormal 
                    := IdentifyVar ( ActClass^.Class.Formals , Attribute ) ; 
                  IF LAttrFormal = NoTree 
                  THEN
                    Error 
                      ( "No such child/attribute to right of '::'" , Pos ) ; 
(* Give AttrDesc a position for the Attribute and use it here. *) 
                  END (* IF *) ; 
               ELSE
                  Error ("tree-type required before '::' ", Pos);
               END;
            ELSE
               Error ("Identifier to left of '::' not declared", Pos);
            END;
         END;

      ELSE
      END;
   END CheckExpr;

PROCEDURE CheckExpr2 (t: tTree);
   BEGIN
      CASE t^.Kind OF

      | Tree.VarUse: WITH t^.VarUse DO
            Object := IdentifyVar (Decls, Name);
         END;

      | Tree.Binary: WITH t^.Binary DO
            CheckExpr2 (Lop);
            CheckExpr2 (Rop);
         END;

      | Tree . BinaryCompound 
        : WITH t ^ . BinaryCompound 
          DO
            CheckExpr2 (Lop) 
          ; CheckExpr2 (Rop)
          END (* WITH t ^ . BinaryCompound *) ;

      | Tree.Compose:
            CheckExpr (t, dFormals);
      END;
   END CheckExpr2;

TYPE FormalKindTyp 
  = ( RoutineFormal (* A formal of the routine we are translating *) 
    , ChildFormal   (* A child of a matched node. *) 
    , CallFormal    (* A result formal of a puma routine we are calling *) 
    ) ; 

PROCEDURE CheckPatternList (t, Formals, Predecessor: tTree);

(* CheckPatternList is for the top-level list of a rule.  All
   the formal names are already declared, so if CheckPattern
   declares a formal, it is just a type-changing declaration
   of the same thing.  There is no need to call CheckPattern 
   for dont cares.  It would just redeclare the formal name 
   redundantly anyway. 
*)
   VAR Pattern  : tTree;
   BEGIN
      IF (t^.Kind = Tree.NoPattern) AND (Formals^.Kind # Tree.Formal) THEN RETURN; END;
      IF t^.Kind = Tree.NoPattern THEN
        IF IsElement ( ORD ( 'g' ) , Options ) (* AND ( Predecessor <> NIL ) *)
        THEN
          (* Predecessor ^ . OnePattern . Next 
            := mOnePattern ( mDontCareInternal ( NoPosition ) , t ) *) 
        ELSE 
          Error ("too few patterns for rule", t^.NoPattern.Pos); RETURN;
        END (* IF *); 
      ; RETURN 
      END;
      Pattern := t^.OnePattern.Pattern;
      IF Tree . IsType ( Pattern , Tree.DontCare ) THEN RETURN; END;
      IF Formals^.Kind = Tree.NoFormal THEN
         Error ("too many patterns for rule", Pattern^.Pattern.Pos); RETURN;
      END;
      CheckPattern (Pattern, Formals, Formals^.Formal.Path, RoutineFormal);
      CheckPatternList (t^.OnePattern.Next, Formals^.Formal.Next, t);
   END CheckPatternList;

PROCEDURE CheckSubPatterns (t, Formals, Path: tTree);

(* CheckSubPatterns handles a pattern list for a child of a higher
   node.  CheckPattern will be declaring a new meaning of the formal
   name. If there are explicit dont cares in the pattern list, we
   need to call CheckPattern for each formal anyway, so it can declare 
   the name of the child.  
*) 
   VAR Lt , LFormals , LPattern : tTree; 
   BEGIN
     Lt := t; 
     LFormals := Formals; 
     LOOP 
       IF (Lt^.Kind = Tree.NoPattern) 
       THEN 
         IF ( LFormals^.Kind = Tree.Formal )  
            (* NoFormal or DummyFormal is OK *) 
            AND NOT IsElement ( ORD ( 'g' ) , Options ) 
         THEN
           Error ("too few child patterns", Lt^.NoPattern.Pos); 
         END;
         EXIT  
       END;
       LPattern := Lt^.OnePattern.Pattern;
       IF LFormals^.Kind = Tree.NoFormal 
       THEN 
         IF NOT Tree . IsType ( LPattern  , Tree . DontCare ) 
         THEN 
           Error ("too many child patterns", LPattern^.Pattern.Pos); 
         END (* IF *) 
       ; EXIT; 
       END;
       CheckPattern  
         (LPattern, LFormals, mField (Path, LFormals^.Formal.Name), ChildFormal);
       IF NOT Tree . IsType ( LPattern  , Tree . DontCare ) 
       THEN 
         Lt := Lt^.OnePattern.Next 
       END (* IF *) ; 
       LFormals := LFormals^.Formal.Next
     END (* LOOP *) 
   END CheckSubPatterns;

(* Old: replaced by tail-recursion-eliminated version. 

PROCEDURE CheckSubPatterns (t, Formals, Path: tTree);
   VAR Pattern  : tTree;
   BEGIN
      IF (t^.Kind = Tree.NoPattern) AND (Formals^.Kind # Tree.Formal) THEN RETURN; END;
      IF t^.Kind = Tree.NoPattern THEN
         Error ("too few patterns", t^.NoPattern.Pos); 
         RETURN;
      END;
      Pattern := t^.OnePattern.Pattern;
      IF Tree . IsType ( Pattern , Tree.DontCare ) THEN RETURN; END;
      IF Formals^.Kind = Tree.NoFormal THEN
         Error ("too many patterns", Pattern^.Pattern.Pos); RETURN;
      END;
      CheckPattern  (Pattern, Formals, mField (Path, Formals^.Formal.Name));
      CheckSubPatterns (t^.OnePattern.Next, Formals^.Formal.Next, Path);
   END CheckSubPatterns;
*) 

PROCEDURE CheckCallPatterns (t, Formals: tTree); 

(* CheckCallPatterns handles patterns corresponding to result formals
   in a call to a puma routine.   
*) 
   VAR Lt , LFormals : tTree; 
   BEGIN
     Lt := t; 
     LFormals := Formals; 
     LOOP 
       IF Lt^.Kind = Tree.NoPattern THEN
          IF ( LFormals^.Kind = Tree.Formal ) 
             (* NoFormal or DummyFormal is OK *) 
             AND NOT IsElement ( ORD ( 'g' ) , Options ) 
          THEN 
            Error ("too few result patterns", Lt^.NoPattern.Pos); 
          END (* IF *) 
       ;  EXIT 
       END;
       WITH Lt^.OnePattern DO
         IF IsType ( Pattern , Tree.DontCare ) THEN
            Pattern^.DontCare.Tempos := MakeTempos (LFormals);
              (* MakeTempos does it for all the rest of the formals *) 
         ELSE (* Not a DontCare *) 
           IF LFormals^.Kind = Tree.NoFormal THEN
              Error ("too many result patterns", Pattern^.Pattern.Pos); 
              EXIT ;
           END; 
           Pattern^.Pattern.Tempo := MakeTempoIdent ();
           Pattern^.Pattern.TypeDesc := LFormals^.Formal.TypeDesc;
         END; 
         CheckPattern 
           ( Pattern, LFormals, mVar (Pattern^.Pattern.Tempo, FALSE, TRUE)
           , CallFormal 
           );
         IF NOT Tree . IsType ( Pattern  , Tree . DontCare ) 
         THEN 
           Lt := Next; 
         END; 
         LFormals := LFormals^.Formal.Next
       END (* WITH *) 
     END (* LOOP *) 
   END CheckCallPatterns;

(* Old: replaced by tail-recursion-eliminated version. 

PROCEDURE CheckCallPatterns (t, Formals: tTree);
   BEGIN
      IF (t^.Kind = Tree.NoPattern) AND (Formals^.Kind # Tree.Formal) THEN RETURN; END;
      IF t^.Kind = Tree.NoPattern THEN
         Error ("too few patterns or arguments", t^.NoPattern.Pos); RETURN;
      END;
      WITH t^.OnePattern DO
         IF Tree . IsType ( Pattern , Tree.DontCare ) THEN
            Pattern^.DontCare.Tempos := MakeTempos (Formals);
            RETURN;
         END;
         IF Formals^.Kind = Tree.NoFormal THEN
            Error ("too many patterns or arguments", Pattern^.Pattern.Pos); RETURN;
         END;
         Pattern^.Pattern.Tempo := MakeTempoIdent ();
         Pattern^.Pattern.TypeDesc := Formals^.Formal.TypeDesc;
         CheckPattern (Pattern, Formals, mVar (Pattern^.Pattern.Tempo, FALSE, TRUE));
         CheckCallPatterns (Next, Formals^.Formal.Next);
      END;
   END CheckCallPatterns;
*)

PROCEDURE AddDecl
  ( FormalKind : FormalKindTyp ; Name : tIdent ; TypeDesc , Path : tTree 
  ; Pos : tPosition ) 

; BEGIN 
    CASE FormalKind 
    OF RoutineFormal 
    (* This will be a redeclaration with narrowed type *) 
    : Decls := mFormal ( Decls, Name , TypeDesc , Path ) ;
    | ChildFormal 
    : IF IsElement ( ORD ( 'j' ) , Options ) 
      THEN 
        IF IsElement ( Name, LabelNames) 
           AND IsElement ( ORD ( 'J' ) , Options ) 
        THEN
          Warning( "Child name hides another declaration." , Pos ) 
        END (* IF *) 
      ; Include ( LabelNames , Name ) 
      ; Decls := mFormal ( Decls, Name , TypeDesc , Path ) ;
      END (* IF *) 
    | CallFormal : (* Don`t declare anything *) 
    END (* CASE *) 
  END AddDecl ; 

PROCEDURE CheckPattern 
  (t, Formals, FPath: tTree; FormalKind : FormalKindTyp ); 
   VAR LParam , LTypeDesc : tTree; 
   VAR LIsProperlyNarrowed : BOOLEAN ; 
   VAR LPath : tTree ; 
   BEGIN
      CASE t^.Kind OF

      | Tree.Decompose: WITH t^.Decompose DO
            LIsProperlyNarrowed := FALSE ; 
            IF Formals^.Kind = Tree.Formal 
            THEN
               CheckSubtype 
                 (Formals^.Formal.TypeDesc, Object^.Class.TypeDesc, Pos,
                  'Decompose node not in formal/child type, specifically:');
               IF ( Formals ^ . Formal . TypeDesc ^ . Kind = Tree . NodeTypes ) 
                  AND ( Object ^ . Class . TypeDesc ^ . Kind = Tree . NodeTypes ) 
                  AND IsNotEqual 
                        ( Formals ^ . Formal . TypeDesc ^ . NodeTypes . Types 
                        , Object ^ . Class . TypeDesc ^ . NodeTypes . Types 
                        ) 
               THEN LIsProperlyNarrowed := TRUE 
               END (* IF *) ; 
               LPath 
                 := mConsType 
                      ( FPath , Object ^ . Class . Name , LIsProperlyNarrowed ) ; 
               AddDecl 
                 ( FormalKind , Formals^.Formal.Name 
                 , Object^.Class.TypeDesc 
                 , LPath 
                 , Pos 
                 ) 
            ELSE 
               LPath 
                 := mConsType 
                      ( FPath , Object ^ . Class . Name , FALSE ) ; 
            END ; 
            IF Object = NoTree THEN
               (* RMB: If this can happen, then the code above will have
                  already crashed. *) 
               CheckExpr (Expr, dFormals);
            ELSE
               CheckExpr2 (Expr);
            END ;
            IF Selector # NoIdent THEN
               IF IsElement (Selector, LabelNames) THEN
                  Error ("label on deconstructor previously declared", Pos);
               ELSE
                  Include (LabelNames, Selector);
               END;
               IF Widen AND (Formals^.Kind = Tree.Formal) THEN
                  Decls := mFormal (Decls, Selector, Formals^.Formal.TypeDesc, FPath);
               ELSE
                  Decls := mFormal (Decls, Selector, Object^.Class.TypeDesc, LPath);
               END;
            END;
            t ^ . Decompose . Path := FPath ; 
            CheckSubPatterns ( Patterns , Object^.Class.Formals , LPath ) ;
         END;

      | Tree.NilTest: 
          WITH t^.NilTest 
          DO
            IF Formals^.Kind = Tree.Formal 
            THEN
              LTypeDesc := Formals^.Formal.TypeDesc 
            ; IF LTypeDesc^.Kind = Tree.NodeTypes 
              THEN
                LIsProperlyNarrowed 
                  := IsNotEqual 
                       ( LTypeDesc ^ . NodeTypes . Types 
                       , LTypeDesc^.NodeTypes.TreeName^.TreeName.EmptyType ^ . NodeTypes . Types 
                       ) 
              ; LPath := mConsType ( FPath , IdentEmptyType , LIsProperlyNarrowed ) 
              ; LTypeDesc := LTypeDesc^.NodeTypes.TreeName^.TreeName.EmptyType 
              ELSE 
                Error ( "NIL test on non-node type" , Pos )  
              ; LPath := mConsType ( FPath , LTypeDesc ^ . UserType . Type , FALSE ) 
              ; LTypeDesc := NoTree 
              END (* IF *) 
            ; AddDecl 
                ( FormalKind , Formals^.Formal.Name , LTypeDesc , LPath , Pos ) 
            ELSE 
              LPath := mVar ( NoIdent , FALSE , FALSE ) 
            ; LTypeDesc := NoTree 
            END (* IF *) 
          ; IF Selector # NoIdent THEN
               IF IsElement (Selector, LabelNames) 
               THEN
                  Error ("label on NIL previously declared", Pos)
               ELSE
                 Include (LabelNames, Selector) 
               ; Decls := mFormal (Decls, Selector, LTypeDesc, LPath) 
               END
            END ;
            t ^ . NilTest . Path := FPath 
          END (* WITH *) 

      | Tree.VarDef: WITH t^.VarDef DO
(* RMB 5-97: I decided that a child which is matched by a label only
             in a pattern will not declare the child name. Labels alone,
             but with or without ':' , ':>' , and/or '_' parse as a
             label alone.  I intend to eventually allow '_' to have a
             label on it.  This will require data structure changes.
             When that happens, this case will parse as DontCare1Explicit,
             which will declare the child name.  Presumably, if the
             programmer declares a label, she intends to use it, and
             may wish not to overlay another name with the child decl.
*) 
            IF IsElement (Name, LabelNames) THEN
               IF NOT IsElement (ORD ('k'), Options) THEN
                  Error ("stand alone label previously declared", Pos);
               END;
               Object := IdentifyVar (Decls, Name);
               IF Formals^.Kind = Tree.Formal THEN
                  CheckType (Formals^.Formal.TypeDesc, Object^.Formal.TypeDesc, Pos);
               END;
            ELSE (* Newly declared label *) 
               Include (LabelNames, Name);
               IF Formals^.Kind = Tree.Formal THEN
                  Decls := mFormal (Decls, Name, Formals^.Formal.TypeDesc, FPath);
               END;
               Object := NoTree;
            END;
            t ^ . VarDef . Path := FPath 
         END;

      | Tree . DontCare1Explicit 
        : LPath := mConsType ( FPath , NoIdent , FALSE ) ; 
          IF Formals^.Kind = Tree.Formal 
          THEN
            AddDecl 
              ( FormalKind , Formals^.Formal.Name 
              , Formals^.Formal.TypeDesc 
              , LPath 
              , t^.DontCare1Explicit.Pos 
              ) ; 
            t ^ . DontCare1Explicit . Path := FPath 
          END (* IF *) 

      | Tree . DontCareExplicit 
        : LPath := mConsType ( FPath , NoIdent , FALSE ) ; 
          IF Formals^.Kind = Tree.Formal 
          THEN
            AddDecl 
              ( FormalKind , Formals^.Formal.Name 
              , Formals^.Formal.TypeDesc 
              , LPath  
              , t^.DontCareExplicit.Pos 
              ) ; 
            t ^ . DontCareExplicit . Path := FPath 
          END (* IF *) 

      | Tree.Value
          : CheckExprVar (t^.Value.Expr, Formals);
            t ^ . Value . Path := FPath 

      ELSE
        t ^ . Pattern . Path := FPath
      END;
   END CheckPattern;

PROCEDURE MakeTempoIdent (): tIdent;
   VAR String1, String2 : tString;
   BEGIN
      INC (TempoCount);
      ArrayToString ("yyV", String1);
      IntToString (TempoCount, String2);
      Concatenate (String1, String2);
      RETURN MakeIdent (String1);
   END MakeTempoIdent;

PROCEDURE MakeTempos (Formals: tTree): tTree;
   BEGIN
      IF Formals^.Kind = Tree.Formal THEN
         WITH Formals^.Formal DO
            RETURN mFormal (MakeTempos (Next), MakeTempoIdent (), TypeDesc, Path);
         END;
      ELSE
         RETURN nNoFormal;
      END;
   END MakeTempos;








































































PROCEDURE yyAbort (yyFunction: ARRAY OF CHAR);
 BEGIN
  IO.WriteS (IO.StdError, 'Error: module Semantics, routine ');
  IO.WriteS (IO.StdError, yyFunction);
  IO.WriteS (IO.StdError, ' failed');
  IO.WriteNl (IO.StdError);
  Exit;
 END yyAbort;

PROCEDURE yyIsEqual (yya, yyb: ARRAY OF SYSTEM.BYTE): BOOLEAN;
 VAR yyi	: INTEGER;
 BEGIN
  FOR yyi := 0 TO INTEGER (HIGH (yya)) DO
   IF yya [yyi] # yyb [yyi] THEN RETURN FALSE; END;
  END;
  RETURN TRUE;
 END yyIsEqual;

PROCEDURE Semantics (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Spec:
(* line 1921 "sem.puma" *)
     WITH t^.Spec DO
(* line 1921 "sem.puma" *)
      
        TypeCount := MaxIdent ();
        MakeSet (RoutineNames   , TypeCount);
        MakeSet (LabelNames     , TypeCount);
        MakeSet (ParamNames     , TypeCount);
        MakeSet (TypeNames      , TypeCount);
        MakeSet (ExternNames    , TypeCount);
        MakeSet (LocExternNames , TypeCount);
        MakeSet (UserTypes      , TypeCount);
        MakeSet (UserNames      , TypeCount);
        ComputeDepths ( TreeNames ) ; 
        ClassFormals (TreeNames);
        Semantics (Public);
        CollectExtern (Extern, ExternNames);
        ProcFormals (Routines);
        Semantics (Routines);
      IF IsElement (ORD ('o'), Options) AND NOT IsEmpty (UserNames) THEN
        WriteNl (StdOutput);
        WriteS (StdOutput, "Undefined External Names"); WriteNl (StdOutput);
        WriteS (StdOutput, "------------------------"); WriteNl (StdOutput);
        WriteNl (StdOutput);
        FOR i := 1 TO TypeCount DO
           IF IsElement (i, UserNames) THEN
              WriteIdent (StdOutput, i); WriteNl (StdOutput);
           END;
        END;
      END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Name:
(* line 1951 "sem.puma" *)
     WITH t^.Name DO
(* line 1951 "sem.puma" *)
      
        Object := IdentifyProc (Name);
        IF Object = NoTree THEN
           ErrorI ("subroutine identifier not declared", Pos, Name);
        ELSE
           Object^.Routine.IsExtern := TRUE;
        END;
        Semantics (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Procedure:
(* line 1960 "sem.puma" *)
     WITH t^.Procedure DO
(* line 1961 "sem.puma" *)
      
        AssignEmpty (LocExternNames);
        CollectExtern (Extern, LocExternNames);
        IF IsElement (Name, RoutineNames) THEN
           Error ("routine identifier previously declared", Pos);
        ELSE
           Include (RoutineNames, Name);
        END;
        AssignEmpty (ParamNames);
        Check (InParams);
        Check (OutParams);
        InFormals := InForm;
        OutFormals := OutForm;
        Parameters := ParamDecls;
        IsFunction := FALSE;
        RuleCount := 0;
        Check (Rules);
        Semantics (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Predicate:
(* line 1960 "sem.puma" *)
     WITH t^.Predicate DO
(* line 1961 "sem.puma" *)
      
        AssignEmpty (LocExternNames);
        CollectExtern (Extern, LocExternNames);
        IF IsElement (Name, RoutineNames) THEN
           Error ("routine identifier previously declared", Pos);
        ELSE
           Include (RoutineNames, Name);
        END;
        AssignEmpty (ParamNames);
        Check (InParams);
        Check (OutParams);
        InFormals := InForm;
        OutFormals := OutForm;
        Parameters := ParamDecls;
        IsFunction := FALSE;
        RuleCount := 0;
        Check (Rules);
        Semantics (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Function:
(* line 1980 "sem.puma" *)
     WITH t^.Function DO
(* line 1980 "sem.puma" *)
      
        AssignEmpty (LocExternNames);
        CollectExtern (Extern, LocExternNames);
        IF IsElement (Name, RoutineNames) THEN
           Error ("function identifier previously declared", Pos);
        ELSE
           Include (RoutineNames, Name);
        END;
        AssignEmpty (ParamNames);
        Check (InParams);
        Check (OutParams);
        Check (ReturnParams);
        InFormals := InForm;
        OutFormals := OutForm;
        ReturnFormal := ReturnForm;
        Parameters := ParamDecls;
        IsFunction := TRUE;
        RuleCount := 0;
        Check (Rules);
        Semantics (Next);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Semantics;

PROCEDURE CollectExtern (t: Tree.tTree; VAR Names: tSet);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Name) THEN
(* line 2005 "sem.puma" *)
     WITH t^.Name DO
(* line 2006 "sem.puma" *)
      Include (Names, Name);
(* line 2007 "sem.puma" *)
      CollectExtern (Next, Names);
      RETURN;
     END (* WITH *) ;

  END;
 END CollectExtern;

PROCEDURE ProcFormals (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Procedure:
(* line 2013 "sem.puma" *)
     WITH t^.Procedure DO
(* line 2014 "sem.puma" *)
      
        Args := nNoFormal;
        Decls := nNoFormal;
        AssignEmpty (ParamNames);
        IsOutput := FALSE;
        ProcFormals (InParams);
        InForm := ReverseTree (Args);
        Args := nNoFormal;
        IsOutput := TRUE;
        ProcFormals (OutParams);
        OutForm := ReverseTree (Args);
        ParamDecls := Decls;
        ProcFormals (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Predicate:
(* line 2013 "sem.puma" *)
     WITH t^.Predicate DO
(* line 2014 "sem.puma" *)
      
        Args := nNoFormal;
        Decls := nNoFormal;
        AssignEmpty (ParamNames);
        IsOutput := FALSE;
        ProcFormals (InParams);
        InForm := ReverseTree (Args);
        Args := nNoFormal;
        IsOutput := TRUE;
        ProcFormals (OutParams);
        OutForm := ReverseTree (Args);
        ParamDecls := Decls;
        ProcFormals (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Function:
(* line 2028 "sem.puma" *)
     WITH t^.Function DO
(* line 2028 "sem.puma" *)
      
        Args := nNoFormal;
        Decls := nNoFormal;
        AssignEmpty (ParamNames);
        IsOutput := FALSE;
        ProcFormals (InParams);
        InForm := ReverseTree (Args);
        Args := nNoFormal;
        IsOutput := TRUE;
        ProcFormals (OutParams);
        OutForm := ReverseTree (Args);
        Args := nNoFormal;
        IsOutput := TRUE;
        ProcFormals (ReturnParams);
        ReturnForm := ReverseTree (Args);
        ParamDecls := Decls;
        ProcFormals (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Param:
(* line 2046 "sem.puma" *)
     WITH t^.Param DO
(* line 2046 "sem.puma" *)
      
        IF IsElement (Name, ParamNames) THEN
           Error ("parameter identifier previously declared", Pos);
        ELSE
           Include (ParamNames, Name);
        END;
        ParamName := Name;
        Mode := IsRef;
        ProcFormals (Type);
        ProcFormals (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Type:
(* line 2057 "sem.puma" *)
     WITH t^.Type DO
(* line 2057 "sem.puma" *)
      
        IF (Name # NoIdent) AND (Names^.Kind # Tree.NoName) THEN
           TreeName := IdentifyTree (Name);
           IF TreeName # NoTree THEN
              MakeSet (ActTypes, TreeName^.TreeName.ClassCount);
           ELSE
              Error ("tree type not declared", Pos);
           END;
        ELSIF (Name # NoIdent) AND (Names^.Kind = Tree.NoName) THEN
           TreeName := IdentifyTree (Name);
           IF TreeName # NoTree THEN                    
              MakeSet (ActTypes, TreeName^.TreeName.ClassCount);
              MakeTypes (TreeName^.TreeName.Classes^.Class.Index, TreeName^.TreeName.Classes, ActTypes);
           ELSE                                         
              ActClass := IdentifyClass2 (Name, TreeName);
              IF ActClass # NoTree THEN                 
                 MakeSet (ActTypes, TreeName^.TreeName.ClassCount);
                 MakeTypes (ActClass^.Class.Index, ActClass^.Class.Extensions, ActTypes);
              END;
           END;
        ELSIF (Name = NoIdent) AND (Names^.Kind # Tree.NoName) THEN
           ActClass := IdentifyClass2 (Names^.Name.Name, TreeName);
           IF ActClass # NoTree THEN
              MakeSet (ActTypes, TreeName^.TreeName.ClassCount);
           ELSE
              Error ("node type not declared", Names^.Name.Pos);
           END;
        ELSE
           TreeName := NoTree;
        END;

        IF TreeName # NoTree THEN
           ActTree := TreeName^.TreeName.Classes;
           ProcFormals (Names);
           Node := mNodeTypes (TreeName, ActTypes);
        ELSE                                            
           IF Name = NoIdent THEN
              Error ("incorrect type", Pos);
           ELSE
              Include (TypeNames, Name);
           END;
           Node := mUserType (Name);
        END;
        Var   := mVar (ParamName, IsOutput OR Mode, TRUE);
        Args  := mFormal (Args , ParamName, Node, Var);
        Decls := mFormal (Decls, ParamName, Node, Var);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Name:
(* line 2104 "sem.puma" *)
     WITH t^.Name DO
(* line 2104 "sem.puma" *)
      
        ActClass := IdentifyClass (ActTree, Name);
        IF ActClass # NoTree THEN
           Include (ActTypes, ActClass^.Class.Index);
           ForallClasses (ActClass^.Class.Extensions, ProcFormals);
        ELSE
           Error ("node type not declared", Pos);
        END;
        ProcFormals (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Class:
(* line 2114 "sem.puma" *)
     WITH t^.Class DO
(* line 2114 "sem.puma" *)
      
        Include (ActTypes, Index);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ProcFormals;

PROCEDURE CollectUniversalTypeDesc (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 2120 "sem.puma" *)
     WITH t^.Class DO
(* line 2121 "sem.puma" *)
       Union ( ActTypes , TypeDesc ^ . NodeTypes . Types ) ; 
       CollectUniversalTypeDesc ( Next ) ; 
     ;
      RETURN;
     END (* WITH *) ;

  END;
 END CollectUniversalTypeDesc;

PROCEDURE ClassFormals (t: Tree.tTree);
(* line 2128 "sem.puma" *)
 VAR String1 , String2 : tString ; 

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.TreeName:
(* line 2130 "sem.puma" *)
     WITH t^.TreeName DO
(* line 2130 "sem.puma" *)
      
        ActTree := t;
        ClassCount := 0;
        ForallClasses (Classes, CountClasses);

        EmptyType := mNodeTypes (t, ActTypes);  
        MakeSet (EmptyType^.NodeTypes.Types, t^.TreeName.ClassCount);
        AssignEmpty(EmptyType^.NodeTypes.Types);

        ArrayToString ("t", String1);
        GetString (Name, String2);
        Concatenate (String1, String2);

        ForallClasses (Classes, ClassTypes);
        ForallClasses (Classes, ClassFormals);

        UniversalClass 
          := mClass 
               ( MakeIdent ( String1 ) , { Nonterminal } 
               , NoTree , NoTree , NoTree ) ; 
        UniversalClass ^ . Class . BaseClass := NoTree ; 
        UniversalClass ^ . Class . Formals := NoTree ; 
        UniversalClass ^ . Class . Index := 0 ; 
        MakeSet ( ActTypes , t ^ . TreeName . ClassCount ) ;
        AssignEmpty ( ActTypes ) ;
        CollectUniversalTypeDesc ( Classes ) ;
        UniversalClass ^ . Class . TypeDesc 
          := mNodeTypes ( t , ActTypes ) ; 

        ComputeDepthsClasses ( Classes , 1 ) ; 
        
        ClassFormals (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Class:
(* line 2163 "sem.puma" *)
     WITH t^.Class DO
(* line 2163 "sem.puma" *)
      
        Args := nNoFormal;
        ForallAttributes (t, ClassFormals);
        Formals := ReverseTree (Args);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 2168 "sem.puma" *)
     WITH t^.Child DO
(* line 2168 "sem.puma" *)
      
        ActClass := IdentifyClass (ActTree^.TreeName.Classes, Type);
        Args := mFormal (Args, Name, ActClass^.Class.TypeDesc, NoTree);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 2172 "sem.puma" *)
     WITH t^.Attribute DO
(* line 2172 "sem.puma" *)
      
        IF ({Test, Dummy} * Properties) = {} 
        THEN
           ActClass := IdentifyClass (ActTree^.TreeName.Classes, Type);
           IF ActClass = NoTree 
           THEN   
             Args := mFormal (Args, Name, mUserType (Type), NoTree);
             Include (TypeNames, Type);
           ELSE 
             Args := mFormal (Args, Name, ActClass^.Class.TypeDesc, NoTree);
           END  
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ClassFormals;

PROCEDURE CountClasses (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 2189 "sem.puma" *)
     WITH t^.Class DO
(* line 2189 "sem.puma" *)
      
        INC (ActTree^.TreeName.ClassCount);
        Index := ActTree^.TreeName.ClassCount;
;
      RETURN;
     END (* WITH *) ;

  END;
 END CountClasses;

PROCEDURE ClassTypes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 2197 "sem.puma" *)
     WITH t^.Class DO
(* line 2197 "sem.puma" *)
      
        TypeDesc := mNodeTypes (ActTree, ActTypes);     
        MakeSet (TypeDesc^.NodeTypes.Types, ActTree^.TreeName.ClassCount);
        MakeTypes (Index, Extensions, TypeDesc^.NodeTypes.Types);
;
      RETURN;
     END (* WITH *) ;

  END;
 END ClassTypes;

PROCEDURE Check (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 4: yyR4: RECORD
  LPatternCount: CARDINAL;
  LIsLast: BOOLEAN;
  LPatterns: Tree.tTree;
  LSinglePatterns: Tree.tTree;
  LNewRule: Tree.tTree;
  END;
 | 28: yyR28: RECORD
  LAttrFormal: tTree;
  END;
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Reject:
  IF Tree.IsType (t^.Reject.Next, Tree.Statement) THEN
(* line 2206 "sem.puma" *)
   LOOP
     WITH t^.Reject DO
     WITH Next^.Statement DO
(* line 2208 "sem.puma" *)
      Warning ("statement not reachable", t^.Reject.Next^.Statement.Pos);
(* line 2209 "sem.puma" *)
      EXIT;
     END (* WITH *) ;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
  | Tree.Fail:
  IF Tree.IsType (t^.Fail.Next, Tree.Statement) THEN
(* line 2206 "sem.puma" *)
   LOOP
     WITH t^.Fail DO
     WITH Next^.Statement DO
(* line 2208 "sem.puma" *)
      Warning ("statement not reachable", t^.Fail.Next^.Statement.Pos);
(* line 2209 "sem.puma" *)
      EXIT;
     END (* WITH *) ;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
(* line 2338 "sem.puma" *)
     WITH t^.Fail DO
(* line 2338 "sem.puma" *)
      
        IF IsFunction THEN
           Error ("FAIL not allowed in function", Pos);
        END;
        Check (Next);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;


  CASE t^.Kind OF
  | Tree.Param:
(* line 2211 "sem.puma" *)
     WITH t^.Param DO
(* line 2211 "sem.puma" *)
      
        Include (ParamNames, Name);
        Check (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Rule:
(* line 2215 "sem.puma" *)
    WITH yyTempo.yyR4 DO  
     WITH t^.Rule DO
(* line 2216 "sem.puma" *)
      ;
(* line 2217 "sem.puma" *)
      ;
(* line 2218 "sem.puma" *)
      ;
(* line 2219 "sem.puma" *)
      ;
(* line 2220 "sem.puma" *)
      ;
(* line 2221 "sem.puma" *)
       LPatterns       := TransformName (Patterns, InFormals);
        TransformPattern ( LPatterns , LPatterns , LPatternCount ); 
        Exprs           := TransformName (Exprs, OutFormals);
        Exprs           := TransformExpr (Exprs);
        Expr            := TransformExpr (Expr);
        Statements      := TransformStmt (Statements);
        LOOP 
          WITH t^.Rule 
           
          DO 
            IF LPatternCount = 1 
            THEN  
              t^.Rule.Patterns := LPatterns 
            ; LIsLast := TRUE ; 
            ELSE     
              NextPatterns ( LPatterns , LSinglePatterns , LIsLast ) 
            ; IF NOT LIsLast  
              THEN 
                LNewRule 
                  := mRule 
                       ( t^.Rule.Line 
                       , NoTree  
                       , CopyTree ( t^.Rule.Exprs )  
                       , CopyTree ( t^.Rule.Expr )  
                       , CopyTree ( t^.Rule.Statements )  
                       , t^.Rule.Next 
                       ) 
              ; t^.Rule.Next := LNewRule 
           
              END  
            ; t^.Rule.Patterns := LSinglePatterns 
            END  ; 
            INC (RuleCount);
            t^.Rule.Index               := RuleCount;
            TempoCount  := 0;
            HasLocals   := FALSE;
            Decls               := Parameters;
            Assign (LabelNames, ParamNames);
            CheckPatternList (t^.Rule.Patterns, InFormals, NIL);
            Check (t^.Rule.Patterns);
            Check (t^.Rule.Statements);
            CheckExprList (t^.Rule.Exprs, OutFormals);
            Check (t^.Rule.Exprs);
            IF IsFunction THEN
               IF t^.Rule.Expr^.Kind = Tree.NoExpr THEN
                  IF NOT HasReject (t^.Rule.Statements) THEN
                     Error ("function requires RETURN expression"
                           , t^.Rule.Expr^.Expr.Pos
                           );
                  END;
               ELSE
                  CheckExprVar (t^.Rule.Expr, ReturnFormal);
                  Success := FALSE;
                  Check (t^.Rule.Expr);
                  t^.Rule.HasPatterns := Success;
                  IF t^.Rule.HasPatterns 
                     AND (t^.Rule.Expr^.Kind # Tree.Compose) 
                     AND NOT Tree . IsType ( t , Tree.DontCare1) 
                          
                  THEN
                     t^.Rule.Tempo := MakeTempoIdent ();
                  END;
               END;
            END;
            IF NOT IsFunction AND (t^.Rule.Expr^.Kind # Tree.NoExpr) THEN
               Error ("illegal RETURN", t^.Rule.Expr^.Expr.Pos);
            END;
            t^.Rule.VarDecls := Decls;
            IF IsElement (ORD ('c'), Options) THEN
              t^.Rule.HasTempos := (TempoCount > 0) OR HasLocals;
            ELSE
              t^.Rule.HasTempos := (TempoCount > 0) OR HasLocals 
                 OR t^.Rule.HasPatterns;
            END;
            CheckTargetCode (t^.Rule.Patterns);
            CheckTargetCode (t^.Rule.Exprs);
            IF IsFunction THEN
               CheckTargetCode (t^.Rule.Expr);
            END;
            CheckTargetCode (t^.Rule.Statements);
            IF LIsLast THEN EXIT 
            ELSE t := t ^ . Rule . Next 
                  
            END   
          END  
        END  ; 
        Check (t^.Rule.Next);
;
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.ProcCall:
(* line 2312 "sem.puma" *)
     WITH t^.ProcCall DO
(* line 2312 "sem.puma" *)
      
        CheckExprVar (Call, dFormals);
        Check (Call);
        Check (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Condition:
(* line 2317 "sem.puma" *)
     WITH t^.Condition DO
(* line 2317 "sem.puma" *)
      
        CheckExprVar (Expr, dFormals);
        Check (Expr);
        Check (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Assignment:
(* line 2322 "sem.puma" *)
     WITH t^.Assignment DO
(* line 2322 "sem.puma" *)
      
        IF Adr^.Kind = Tree.VarUse THEN
           Object := IdentifyVar (Decls, Adr^.VarUse.Name);
        ELSE
           Object := NoTree;
        END;
        CheckExprVar (Adr, dFormals);
        IF Object # NoTree THEN
           CheckExprVar (Expr, Object);
        ELSE
           CheckExprVar (Expr, dFormals);
        END;
        Check (Adr);
        Check (Expr);
        Check (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TargetStmt:
(* line 2344 "sem.puma" *)
     WITH t^.TargetStmt DO
(* line 2344 "sem.puma" *)
      
        CheckTargetCode (Parameters);
        MakeSet (UsedNames, MaxIdent ());
        ActNames := UsedNames;
        Check (Stmt);
        UsedNames := ActNames;
        Check (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Statement
  , Tree.Reject
  , Tree.Fail
  , Tree.Nl
  , Tree.WriteStr:
(* line 2352 "sem.puma" *)
     WITH t^.Statement DO
(* line 2352 "sem.puma" *)
      
        Check (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.OnePattern:
(* line 2355 "sem.puma" *)
     WITH t^.OnePattern DO
(* line 2355 "sem.puma" *)
      
        Check (Pattern);
        Check (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.OneExpr
  , Tree.NamedExpr:
(* line 2359 "sem.puma" *)
     WITH t^.OneExpr DO
(* line 2359 "sem.puma" *)
      
        Check (Expr);
        Check (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Decompose:
(* line 2363 "sem.puma" *)
     WITH t^.Decompose DO
(* line 2363 "sem.puma" *)
      
        Check (Expr);
        Success := TRUE;
        Check (Patterns);
;
      RETURN;
     END (* WITH *) ;

  | Tree.VarDef:
(* line 2368 "sem.puma" *)
     WITH t^.VarDef DO
(* line 2368 "sem.puma" *)
      
        IF Object # NoTree THEN Success := TRUE; END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.NilTest:
(* line 2371 "sem.puma" *)
     WITH t^.NilTest DO
(* line 2371 "sem.puma" *)
      
        Success := TRUE;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Value:
(* line 2374 "sem.puma" *)
     WITH t^.Value DO
(* line 2374 "sem.puma" *)
      
        Success := TRUE;
        Check (Expr);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Compose:
(* line 2378 "sem.puma" *)
     WITH t^.Compose DO
(* line 2378 "sem.puma" *)
      
        Check (Expr);
        Check (Exprs);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Call:
(* line 2382 "sem.puma" *)
     WITH t^.Call DO
(* line 2382 "sem.puma" *)
      
        Check (Expr);
        Check (Exprs);
        Check (Patterns);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Binary
  , Tree.yy1
  , Tree.BinaryCompound:
(* line 2387 "sem.puma" *)
     WITH t^.Binary DO
(* line 2387 "sem.puma" *)
      
        Check (Lop);
        Check (Rop);
;
      RETURN;
     END (* WITH *) ;

  | Tree.PreOperator:
(* line 2391 "sem.puma" *)
     WITH t^.PreOperator DO
(* line 2393 "sem.puma" *)
      
        Check (Expr);
;
      RETURN;
     END (* WITH *) ;

  | Tree.PostOperator:
(* line 2391 "sem.puma" *)
     WITH t^.PostOperator DO
(* line 2393 "sem.puma" *)
      
        Check (Expr);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Parents:
(* line 2391 "sem.puma" *)
     WITH t^.Parents DO
(* line 2393 "sem.puma" *)
      
        Check (Expr);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Index:
(* line 2396 "sem.puma" *)
     WITH t^.Index DO
(* line 2396 "sem.puma" *)
      
        Check (Expr);
        Check (Exprs);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TargetExpr:
(* line 2400 "sem.puma" *)
     WITH t^.TargetExpr DO
(* line 2400 "sem.puma" *)
      
        MakeSet (UsedNames, MaxIdent ());
        ActNames := UsedNames;
        Check (Expr);
        UsedNames := ActNames;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Ident:
(* line 2406 "sem.puma" *)
     WITH t^.Ident DO
(* line 2406 "sem.puma" *)
      
        Object := IdentifyVar (Decls, Attribute);  
        IF Object = NoTree 
        THEN Include (ActNames, Attribute); END;
        Check (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Any:
(* line 2412 "sem.puma" *)
     WITH t^.Any DO
(* line 2413 "sem.puma" *)
      
        Check (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Anys:
(* line 2412 "sem.puma" *)
     WITH t^.Anys DO
(* line 2413 "sem.puma" *)
      
        Check (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Designator:
(* line 2416 "sem.puma" *)
    WITH yyTempo.yyR28 DO  
     WITH t^.Designator DO
(* line 2417 "sem.puma" *)
      ;
(* line 2418 "sem.puma" *)
      
        IF IsElement (Selector, LabelNames) THEN
           Object := IdentifyVar (Decls, Selector);
           IF Object^.Formal.TypeDesc^.Kind = Tree.NodeTypes THEN
              ActClass := LookupClass (Object^.Formal.TypeDesc^.NodeTypes.TreeName^.TreeName.Classes,
                              Minimum (Object^.Formal.TypeDesc^.NodeTypes.Types));
              Type := ActClass^.Class.Name;
              LAttrFormal 
                := IdentifyVar ( ActClass^.Class.Formals , Attribute ) ; 
              IF LAttrFormal = NoTree 
              THEN
                Error 
                  ( "D No such child/attribute to right of '::'" , Pos ) ; 
 
              END  ; 
           ELSE
              Error ("tree-type required before '::'.", Pos);
           END;
        ELSE
           Error ("label to left of '::' is not declared or computed", Pos);
        END;
        Check (Next);
;
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  ELSE END;

 END Check;

PROCEDURE CheckTargetCode (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Param:
(* line 2445 "sem.puma" *)
     WITH t^.Param DO
(* line 2446 "sem.puma" *)
      
        HasLocals := TRUE;
        ParamName := Name;
        IsOutput := FALSE;
        ProcFormals (Type);
        IF IsElement (Name, LabelNames) THEN
           Error ("identifier previously declared", Pos);
        ELSE
           Include (LabelNames, Name);
        END;
        CheckTargetCode (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.ProcCall:
(* line 2458 "sem.puma" *)
     WITH t^.ProcCall DO
(* line 2458 "sem.puma" *)
      
        CheckTargetCode (Call);
        CheckTargetCode (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Condition:
(* line 2462 "sem.puma" *)
     WITH t^.Condition DO
(* line 2462 "sem.puma" *)
      
        CheckTargetCode (Expr);
        CheckTargetCode (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Assignment:
(* line 2466 "sem.puma" *)
     WITH t^.Assignment DO
(* line 2466 "sem.puma" *)
      
        CheckTargetCode (Expr);
        CheckTargetCode (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TargetStmt:
(* line 2470 "sem.puma" *)
     WITH t^.TargetStmt DO
(* line 2470 "sem.puma" *)
      
        ActNames := UsedNames;
        CheckTargetCode (Stmt);
        ReleaseSet (UsedNames);
        CheckTargetCode (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Statement
  , Tree.Reject
  , Tree.Fail
  , Tree.Nl
  , Tree.WriteStr:
(* line 2476 "sem.puma" *)
     WITH t^.Statement DO
(* line 2476 "sem.puma" *)
      
        CheckTargetCode (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.OnePattern:
(* line 2479 "sem.puma" *)
     WITH t^.OnePattern DO
(* line 2479 "sem.puma" *)
      
        CheckTargetCode (Pattern);
        CheckTargetCode (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.OneExpr
  , Tree.NamedExpr:
(* line 2483 "sem.puma" *)
     WITH t^.OneExpr DO
(* line 2483 "sem.puma" *)
      
        CheckTargetCode (Expr);
        CheckTargetCode (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Decompose:
(* line 2487 "sem.puma" *)
     WITH t^.Decompose DO
(* line 2487 "sem.puma" *)
      
        CheckTargetCode (Expr);
        CheckTargetCode (Patterns);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Value:
(* line 2491 "sem.puma" *)
     WITH t^.Value DO
(* line 2491 "sem.puma" *)
      
        CheckTargetCode (Expr);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Compose:
(* line 2494 "sem.puma" *)
     WITH t^.Compose DO
(* line 2494 "sem.puma" *)
      
        CheckTargetCode (Expr);
        CheckTargetCode (Exprs);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Call:
(* line 2498 "sem.puma" *)
     WITH t^.Call DO
(* line 2498 "sem.puma" *)
      
        CheckTargetCode (Expr);
        CheckTargetCode (Exprs);
        CheckTargetCode (Patterns);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Binary
  , Tree.yy1
  , Tree.BinaryCompound:
(* line 2503 "sem.puma" *)
     WITH t^.Binary DO
(* line 2503 "sem.puma" *)
      
        CheckTargetCode (Lop);
        CheckTargetCode (Rop);
;
      RETURN;
     END (* WITH *) ;

  | Tree.PreOperator:
(* line 2507 "sem.puma" *)
     WITH t^.PreOperator DO
(* line 2509 "sem.puma" *)
      
        CheckTargetCode (Expr);
;
      RETURN;
     END (* WITH *) ;

  | Tree.PostOperator:
(* line 2507 "sem.puma" *)
     WITH t^.PostOperator DO
(* line 2509 "sem.puma" *)
      
        CheckTargetCode (Expr);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Parents:
(* line 2507 "sem.puma" *)
     WITH t^.Parents DO
(* line 2509 "sem.puma" *)
      
        CheckTargetCode (Expr);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Index:
(* line 2512 "sem.puma" *)
     WITH t^.Index DO
(* line 2512 "sem.puma" *)
      
        CheckTargetCode (Expr);
        CheckTargetCode (Exprs);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TargetExpr:
(* line 2516 "sem.puma" *)
     WITH t^.TargetExpr DO
(* line 2516 "sem.puma" *)
      
        ActNames := UsedNames;
        CheckTargetCode (Expr);
        ReleaseSet (UsedNames);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Ident:
(* line 2521 "sem.puma" *)
     WITH t^.Ident DO
(* line 2521 "sem.puma" *)
      
        IF IsElement (Attribute, ActNames) 
           AND (IdentifyVar (Decls, Attribute) # NoTree) 
            
        THEN
           Error ("label not computed yet", Pos);
        END;
        CheckTargetCode (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Any:
(* line 2542 "sem.puma" *)
     WITH t^.Any DO
(* line 2544 "sem.puma" *)
      CheckTargetCode (Next);
      RETURN;
     END (* WITH *) ;

  | Tree.Anys:
(* line 2542 "sem.puma" *)
     WITH t^.Anys DO
(* line 2544 "sem.puma" *)
      CheckTargetCode (Next);
      RETURN;
     END (* WITH *) ;

  | Tree.Designator:
(* line 2542 "sem.puma" *)
     WITH t^.Designator DO
(* line 2544 "sem.puma" *)
      CheckTargetCode (Next);
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END CheckTargetCode;

PROCEDURE RemoveTreeTypes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 2: yyR2: RECORD
  String1: tString;
  String2: tString;
  i: tIdent;
  END;
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Spec:
(* line 2548 "sem.puma" *)
     WITH t^.Spec DO
(* line 2549 "sem.puma" *)
      RemoveTreeTypes (TreeNames);
      RETURN;
     END (* WITH *) ;

  | Tree.TreeName:
(* line 2551 "sem.puma" *)
    WITH yyTempo.yyR2 DO  
     WITH t^.TreeName DO
(* line 2552 "sem.puma" *)
      ;
(* line 2553 "sem.puma" *)
      
   ArrayToString ("t", String1);
   GetString (Name, String2);
   Concatenate (String1, String2);
   i := MakeIdent (String1);
   IF i <= TypeCount THEN Exclude (TypeNames, i); END;
   RemoveTreeTypes (Next);
;
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  ELSE END;

 END RemoveTreeTypes;

PROCEDURE HasReject (yyP1: Tree.tTree): BOOLEAN;

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF yyP1 = Tree.NoTree THEN RETURN FALSE; END;

  CASE yyP1^.Kind OF
  | Tree.Reject:
(* line 2564 "sem.puma" *)
      RETURN TRUE;

  | Tree.Statement
  , Tree.ProcCall
  , Tree.Condition
  , Tree.Assignment
  , Tree.Fail
  , Tree.TargetStmt
  , Tree.Nl
  , Tree.WriteStr:
(* line 2565 "sem.puma" *)
   LOOP
     WITH yyP1^.Statement DO
(* line 2565 "sem.puma" *)
      IF NOT (HasReject (Next)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  ELSE END;

  RETURN FALSE;
 END HasReject;

PROCEDURE BeginSemantics;
 BEGIN
(* line 1910 "sem.puma" *)

   dFormals := mDummyFormal (NoTree); dFormals^.DummyFormal.Next := dFormals;
   nNoFormal := mNoFormal ();
   ArrayToString (".", String1);
   IdentDot := MakeIdent ( String1 ) ; 
   ArrayToString ("EmptyType", String1);
   IdentEmptyType := MakeIdent ( String1 ) ; 


 END BeginSemantics;

PROCEDURE CloseSemantics;
 BEGIN

 END CloseSemantics;

PROCEDURE yyExit;
 BEGIN
  IO.CloseIO; System.Exit (1);
 END yyExit;

BEGIN
 yyf	:= IO.StdOutput;
 Exit	:= yyExit;
 BeginSemantics;
END Semantics.

