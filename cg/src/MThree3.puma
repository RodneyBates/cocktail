
(* file MThree3.puma 
   Modula-3 generation of simple attribute evaluator. 
   Rodney M. Bates Oct 97 
   Extensively modified from file mod3.puma, which had these header comments:  
     /* Ich, Doktor Josef Grosch, Informatiker, 23.5.1989 */
   July 99 Add VAR to rule local decls. 
*)

TRAFO EvalMThree
TREE Tree
PUBLIC EvalInterface EvalModule EvalModuleHead GenEvaluator

EXPORT { VAR Class: Tree.tTree; }

GLOBAL {

FROM SYSTEM	IMPORT ADR;
FROM IO		IMPORT WriteS, WriteNl;
FROM StringMem	IMPORT WriteString;
FROM Texts	IMPORT WriteText;
FROM Sets	IMPORT IsElement;
FROM TreeMThree2	IMPORT WriteLine;
FROM EvalMThree3	IMPORT ToBit0;

FROM Tree	IMPORT
   NoTree	, tTree		, Child		, NoCodeClass	,
   Computed	, Reverse	, Write		, Read		,
   Inherited	, Synthesized	, Input		, Output	,
   CopyDef	, CopyUse	, Thread	, Virtual	,
   Test		, Left		, Right		,
   NonBaseComp	, First		, Dummy		, Trace		,
   Options	, TreeRoot	, iModule	, iMain		,
   itTree	, f		, WI	, WN	,
   IdentifyClass, IdentifyAttribute, GrammarClass, cOAG		,
   MaxVisit	;

VAR
   n		: SHORTCARD;
   Node		,
   Attr		,
   ChildsClass	: tTree;
}

PROCEDURE EvalInterface (t: Tree)
	
Ag (..) :- {
	!INTERFACE ! WI (EvalName); ! ;!
	!!
	!IMPORT ! WI (iMain); ! ;!
      IF IsElement (ORD ('X'), Options) 
         OR IsElement (ORD ('Y'), Options) 
         OR IsElement (ORD ('Z'), Options) 
         OR IsElement (ORD ('L'), Options) 
         OR IsElement (ORD ('9'), Options) THEN 
        !IMPORT Wr , Fmt ;!
      END; 
      IF IsElement (ORD ('X'), Options) 
         OR IsElement (ORD ('Y'), Options) 
         OR IsElement (ORD ('Z'), Options) THEN 
        !IMPORT Text ;!
      END; 
        !IMPORT Stdio , Text ;!
	WriteLine (EvalCodes^.Codes.ImportLine);
	WriteText (f, EvalCodes^.Codes.Import);
	Node := Modules;
	WHILE Node^.Kind = Tree.Module DO
	   WriteLine (Node^.Module.EvalCodes^.Codes.ImportLine);
	   WriteText (f, Node^.Module.EvalCodes^.Codes.Import);
	   Node := Node^.Module.Next;
	END;
	WriteLine (EvalCodes^.Codes.ExportLine);
	WriteText (f, EvalCodes^.Codes.Export);
	Node := Modules;
	WHILE Node^.Kind = Tree.Module DO
	   WriteLine (Node^.Module.EvalCodes^.Codes.ExportLine);
	   WriteText (f, Node^.Module.EvalCodes^.Codes.Export);
	   Node := Node^.Module.Next;
	END;
	!!
	!PROCEDURE Eval ( t : ! WI (iMain); ! . ! WI (itTree); ! ) ;!
	!PROCEDURE Begin! WI (EvalName); ! ( ) ;!
	!PROCEDURE Close! WI (EvalName); ! ( ) ;!
	!!
	!END ! WI (EvalName); ! .!
}; .

PROCEDURE EvalModuleHead (t: Tree)
	
Ag (..) :- {
	!# define DEP(a, b) a!
	!# define SELF TNode!
	!MODULE ! WI (EvalName); !;!
	!!
	!IMPORT ! WI (iMain); !;!
      IF IsElement (ORD ('Y'), Options) OR
         IsElement (ORD ('Z'), Options) THEN
      END;
      IF IsElement (ORD ('Y'), Options) OR
         IsElement (ORD ('Z'), Options) OR
         IsElement (ORD ('L'), Options) OR
         IsElement (ORD ('9'), Options) THEN
      END;
	WriteLine (EvalCodes^.Codes.GlobalLine);
	WriteText (f, EvalCodes^.Codes.Global);
	Node := Modules;
	WHILE Node^.Kind = Tree.Module DO
	   WriteLine (Node^.Module.EvalCodes^.Codes.GlobalLine);
	   WriteText (f, Node^.Module.EvalCodes^.Codes.Global);
	   Node := Node^.Module.Next;
	END;
	!!
	!VAR yyb	: BOOLEAN;!
      IF IsElement (ORD ('X'), Options) THEN
	@# include "yy@ WI (iModule); @.w"@
	!# define yyWrite! WI (iMain); !(a) ! WI (iMain); !.Write! WI (iMain); ! (yyf, a)!
	!!
	!VAR yyf	: Wr . T ;!
	!!
	!PROCEDURE yyWriteHex ( VAR yyx : ARRAY OF CHAR ) !
	!=BEGIN!
	!  IF yyTrace THEN!
	!   FOR yyi := 0 TO NUMBER ( yyx ) - 1 DO!
	!    Wr . PutText ( yyf , Fmt . Pad ( Fmt . Int ( ORD ( yyx [ yyi ] ) , 16 ) , 2 ) ) ;!
	!    Wr . PutChar ( yyf, ' ' ) ;!
	!   END ;!
	!  END;!
	! END yyWriteHex ;!
	!!
	!PROCEDURE yyWriteNl ( ) !
	!=BEGIN IF yyTrace THEN!
        !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ;!
        !  Wr . Flush ( Stdio . stdout ) ;!
	! END; END yyWriteNl;!
      END;
      IF IsElement (ORD ('Y'), Options) OR
         IsElement (ORD ('Z'), Options) THEN
	!!
	!CONST yyTrace = TRUE;!
	!!
	!PROCEDURE yyWriteS (yys: TEXT )!
	!=BEGIN!
	!  Wr . PutText ( Stdio . Stdout , yys ) ;!
        @  Wr . PutText ( Stdio . Stdout , Fmt . Pad ( "" , MAX ( 0, 15 - Text . Length ( yys ) ) ) ) ;@
	! END yyWriteS;!
	!!
	!PROCEDURE yyWriteType ( yyt : ! WI (iMain); ! . ! WI (itTree); ! )!
	!=BEGIN!
	!  TYPECASE yyt OF!
	WriteType ( Classes ) ;
	!  ELSE!
	!  END;!
	! END yyWriteType;!
      END;
      IF IsElement (ORD ('X'), Options) THEN
	!!
	!PROCEDURE yyWriteEval  (yyt : ! WI (iMain); ! . ! WI (itTree); ! ; yys : TEXT )!
	!=BEGIN!
	!  IF yyTrace THEN!
	!   yyWriteType ( yyt ) ;!
	@   Wr . PutText ( Stdio . Stdout, " e " ) ;@
	!   Wr . PutText ( Stdio . Stdout, yys ) ;!
	@   Wr . PutText ( Stdio . Stdout , Fmt . Pad ( "" , MAX ( 0 , 23 - Text . Length ( yys ) ) ) ) ;@
	@   Wr . PutText ( Stdio . Stdout, " = " ) ;@
	!   Wr . Flush ( Stdio . Stdout) ;!
	!  END ;!
	! END yyWriteEval ;!
      ELSIF IsElement (ORD ('Y'), Options) THEN
	!!
	!PROCEDURE yyWriteEval  (yyt : ! WI (iMain); ! . ! WI (itTree); ! ; yys : TEXT )!
	!=BEGIN!
	!  IF yyTrace THEN!
	!   yyWriteType ( yyt ) ;!
	@   Wr . PutText ( Stdio . Stdout, " e " ) ;@
	!   Wr . PutText ( Stdio . Stdout, yys ) ;!
	!   Wr . PutText ( Stdio . Stdout , Wr . EOL ) ;!
	!   Wr . Flush ( Stdio . Stdout) ;!
	!  END ;!
	! END yyWriteEval;!
      END;
      IF IsElement (ORD ('Z'), Options) THEN
	!!
	!PROCEDURE yyWriteVisit ( yyt : ! WI (iMain); ! . ! WI (itTree); ! ; yys : TEXT )!
	!=BEGIN!
	!  IF yyTrace THEN!
	!   yyWriteType ( yyt ) ;!
	@   Wr . PutText ( Stdio . Stdout, " v " ) ;@
	!   Wr . PutText ( Stdio . Stdout, yys ) ;!
	!   Wr . PutText ( Stdio . Stdout , Wr . EOL ) ;!
	!   Wr . Flush ( Stdio . Stdout) ;!
	!  END ;!
	! END yyWriteVisit ;!
	!!
	!PROCEDURE yyVisitParent ( yyt : ! WI (iMain); ! . ! WI (itTree); ! )!
	@=BEGIN yyWriteVisit ( yyt , "parent" ) ; END yyVisitParent ;@
      END;
}; .

PROCEDURE EvalModule (t: Tree)
	
Ag (..) :- {
	EvalModuleHead (t);
      IF NOT IsElement (ORD ('9'), Options) THEN
	!!
	!PROCEDURE Eval ( yyt : ! WI (iMain); ! . ! WI (itTree); ! )!
	!=BEGIN ! 
	IF MaxVisit > 0 THEN !yyVisit1  (yyt ) ;! END;
	!END Eval ;!
      ELSE
	!!
	!VAR xxStack : INTEGER ;!
	!!
	!PROCEDURE Eval ( yyt : ! WI (iMain); ! . ! WI (itTree); ! )!
	!=VAR xxHigh : BOOLEAN ;!
	! BEGIN!
	!  xxStack := LAST ( INTEGER ) ;!
	IF MaxVisit > 0 THEN
	!  yyVisit1 ( yyt ) ;!
	END;
	@  Wr . PutText ( Stdio . Stdout , "Stacksize " ) ;@
	!  Wr . PutText ( Stdio . Stdout!
        !               , Fmt . Int ( LOOPHOLE ( ADR ( xxHigh ) , INTEGER ) - xxStack ) ) ;!
	!  Wr . PutText ( Stdio . Stdout , Wr . EOL );!
	! END Eval;!
      END;
	!!
	FOR n := 1 TO MaxVisit DO
	   !PROCEDURE yyVisit! WN (n); !  (yyt : ! WI (iMain); ! . ! WI (itTree); ! )!
           !=!
	   WriteLine (EvalCodes^.Codes.LocalLine);
	   WriteText (f, EvalCodes^.Codes.Local);
	   Node := Modules;
	   WHILE Node^.Kind = Tree.Module DO
	      WriteLine (Node^.Module.EvalCodes^.Codes.LocalLine);
	      WriteText (f, Node^.Module.EvalCodes^.Codes.Local);
	      Node := Node^.Module.Next;
	   END;
      IF IsElement (ORD ('9'), Options) THEN
	   ! VAR xxLow : BOOLEAN ;!
	   ! BEGIN!
	   !  xxStack := MIN ( xxStack , LOOPHOLE ( ADR ( xxLow ) , INTEGER ) ) ;!
(* FIX THIS^ This only works for stacks which grow toward zero. *)
      ELSE
	   ! BEGIN!
      END;
	   !  TYPECASE yyt OF!
	   IF cOAG IN GrammarClass THEN		(* generate evaluator *)
	       GenEvaluator ( Classes ) ;
	   END;
	   !  ELSE!
      IF IsElement (ORD ('Z'), Options) THEN
	   !   yyVisitParent ( yyt ) ;!
      END;
	   !  END;!
	   ! END yyVisit! WN (n); ! ;!
	   !!
	END;
	!PROCEDURE Begin! WI (EvalName); ! ( )!
	!=BEGIN!
	WriteLine (EvalCodes^.Codes.BeginLine);
	WriteText (f, EvalCodes^.Codes.Begin);
	Node := Modules;
	WHILE Node^.Kind = Tree.Module DO
	   WriteLine (Node^.Module.EvalCodes^.Codes.BeginLine);
	   WriteText (f, Node^.Module.EvalCodes^.Codes.Begin);
	   Node := Node^.Module.Next;
	END;
	! END Begin! WI (EvalName); ! ;!
	!!
	!PROCEDURE Close! WI (EvalName); ! ( )!
	!=BEGIN!
	WriteLine (EvalCodes^.Codes.CloseLine);
	WriteText (f, EvalCodes^.Codes.Close);
	Node := Modules;
	WHILE Node^.Kind = Tree.Module DO
	   WriteLine (Node^.Module.EvalCodes^.Codes.CloseLine);
	   WriteText (f, Node^.Module.EvalCodes^.Codes.Close);
	   Node := Node^.Module.Next;
	END;
	! END Close! WI (EvalName); ! ;!
	!!
	!BEGIN!
      IF IsElement (ORD ('X'), Options) THEN
	! yyf := Stdio . Stdout ;!
      END;
	!END ! WI (EvalName); ! .!
}; .


PROCEDURE WriteType (t: Tree)

Class (..) :-
        WriteType ( Extensions ) ; 
	NoCodeClass * Properties = {{}};
	Trace IN Properties;
	@  | @ WI (TreeRoot^.Ag.TreeName); @ . t@ WI (Name); @ => yyWriteS ( "@ WI (Name); @" );@
        WriteType ( Next ) ; 
	.

PROCEDURE GenEvaluator (t: Tree)

Class (..) :-
        GenEvaluator ( Extensions ) ; 
	NoCodeClass * Properties = {{}};
{	IF (Generated = InstCount) OR (Visits < n) THEN RETURN; END;
	!  | ! WI (TreeRoot^.Ag.TreeName); ! . ! WI (Name); ! ( TNode ) =>!
	Class := t;
	LOOP
	   IF Generated = InstCount THEN EXIT; END;
	   INC (Generated);
	   WITH Instance^ [Instance^ [Generated].Order] DO
	      IF (Left IN Properties) AND (Attribute^.Child.Partition > n) THEN
	         DEC (Generated); EXIT;
	      END;
	      IF ({Inherited, Right, First} <= Properties) AND NOT (Virtual IN Properties) THEN
      IF IsElement (ORD ('X'), Options) AND (Trace IN t^.Class.Properties) THEN
		 @    yyWriteEval ( TNode , "@ WI (Selector^.Child.Name); @:@ WI (Attribute^.Child.Name); @" );@
		 IF Action # ADR (Action) THEN GenEvaluator (Action); END; !!
		 IF (Attribute^.Kind = Tree.Child) OR (Attribute^.Attribute.Type = itTree) THEN
		    !    write! WI (itTree);
		    !( TNode . ! WI (Selector^.Child.Name); 
		    ! . ! WI (Attribute^.Child.Name); !)!
		 ELSE
		    !    write! WI (Attribute^.Child.Type);
		    !( TNode . ! WI (Selector^.Child.Name);
		    ! . ! WI (Attribute^.Child.Name); !)!
                    !yyWriteNl ;!
		 END;
      ELSIF IsElement (ORD ('Y'), Options) AND (Trace IN t^.Class.Properties) THEN
		 @    yyWriteEval ( TNode , "@ WI (Selector^.Child.Name); @:@ WI (Attribute^.Child.Name); @" ) ;@
		 IF Action # ADR (Action) THEN GenEvaluator (Action); END;
      ELSE
		 IF Action # ADR (Action) THEN GenEvaluator (Action); END;
      END;
	      END;
	      IF ({Synthesized, Left, First} <= Properties) AND ({Dummy, Virtual} * Properties = {}) THEN
      IF IsElement (ORD ('X'), Options) AND (Trace IN t^.Class.Properties) THEN
		 @    yyWriteEval ( TNode , "@ WI (Attribute^.Child.Name); @" ) ;@
		 IF Action # ADR (Action) THEN GenEvaluator (Action); END; !!
		 IF Test IN Properties THEN
		    !    writeBOOLEAN(yyb) yyWriteNl;!
		 ELSIF (Attribute^.Kind = Tree.Child) OR (Attribute^.Attribute.Type = itTree) THEN
		    !    write! WI (itTree);
		    ! ( TNode . ! WI (Attribute^.Child.Name); !)! 
		 ELSE
		    !    write! WI (Attribute^.Child.Type);
		    ! ( TNode . ! WI (Attribute^.Child.Name); !) yyWriteNl;!
		 END;
      ELSIF IsElement (ORD ('Y'), Options) AND (Trace IN t^.Class.Properties) THEN
		 @    yyWriteEval ( TNode , "@ WI (Attribute^.Child.Name); @" ) ;@
		 IF Action # ADR (Action) THEN GenEvaluator (Action); END;
      ELSE
		 IF Action # ADR (Action) THEN GenEvaluator (Action); END;
      END;
	      END;
	      IF ({Synthesized, Right, First} <= Properties) AND
		 (Attribute^.Child.Partition <= Selector^.Child.Class^.Class.Visits) THEN
      IF IsElement (ORD ('Z'), Options) AND (Trace IN t^.Class.Properties) THEN
		 @    yyWriteVisit ( TNode , "@ WI (Selector^.Child.Name); @ @  
		 WN (Attribute^.Child.Partition); @" ) ;@
      END;
		 !    yyVisit! WN (Attribute^.Child.Partition);
		 ! ( TNode . ! WI (Selector^.Child.Name); ! ) ;!
	      END;
	   END;
	END;
      IF IsElement (ORD ('Z'), Options) AND (Trace IN t^.Class.Properties) THEN
	!    yyVisitParent ( TNode ) ;!
      END;
        GenEvaluator ( Next ) ; 
}; .
Assign (..) :- {
	WriteLine (Pos);
	GenEvaluator (Results); ! := ! GenEvaluator (Arguments); ! ;!
}; .
Copy (..) :- {
	WriteLine (Pos);
	GenEvaluator (Results); ! := ! GenEvaluator (Arguments); ! ;!
}; .
TargetCode (..) :- {
	WriteLine (Pos);
	GenEvaluator (Code); !!
}; .
Check (..) :- {
	WriteLine (Pos);
	IF Condition # NoTree THEN
      IF IsElement (ORD ('X'), Options) THEN
	   !    yyb := ! GenEvaluator (Condition); ! ; IF NOT yyb THEN ! 
      ELSE
	   !    IF NOT ( ! GenEvaluator (Condition); ! ) THEN ! 
      END;
	   GenEvaluator (Statement); !!
	   IF Actions^.Kind = Tree.Check THEN
	      !    ELSE!
	      GenEvaluator (Actions);
	   END;
	   !    END ;!
	ELSE
      IF IsElement (ORD ('X'), Options) THEN
	   !    yyb := FALSE ; ! 
      END;
	   GenEvaluator (Statement); !;!
	   GenEvaluator (Actions);
	END;
}; .
Designator (..) :- {
	Attr := IdentifyAttribute (Class, Selector);
	IF Attr # NoTree THEN
	   ChildsClass := Attr^.Child.Class;
	   Attr := IdentifyAttribute (ChildsClass, Attribute);
	   IF NOT (Virtual IN Attr^.Attribute.Properties) THEN
	      ! TNode . ! WI (Selector); ! . ! WI (Attribute);
	   END;
	ELSE
	   WI (Selector); !:! WI (Attribute);
	END;
	GenEvaluator (Next);
}; .
Ident (..) :- {
	Attr := IdentifyAttribute (Class, Attribute);
	IF Attr # NoTree THEN
	   IF NOT (Virtual IN Attr^.Attribute.Properties) THEN
	      ! TNode . ! WI (Attribute);
	   END;
	ELSE
	   WI (Attribute);
	END;
	GenEvaluator (Next);
}; .
Remote (..) :-
   VAR TheClass : Class ; 
   VAR k : INTEGER ;
   TheClass := IdentifyClass (TreeRoot^.Ag.Classes, Type);
{  IF TheClass # NoTree THEN
      Attr := IdentifyAttribute (TheClass, Attribute);
      IF Attr # NoTree THEN
	 WITH Attr^.Attribute DO
	    k := ToBit0 (TheClass, AttrIndex);
	    IF Synthesized IN Properties THEN
	       !REMOTE_SYN (yyIsComp, ! WN (k); !, yyS! WN (k); !, ! 
	       GenEvaluator (Designators); !, ! WI (t^.Remote.Type); !, ! WI (Attribute); !)! 
	    ELSIF Inherited IN Properties THEN
	       !REMOTE_INH (yyIsComp, ! WN (k); !, ! WN (k); !, ! 
	       GenEvaluator (Designators); ! , ! WI (t^.Remote.Type); ! , ! WI (Attribute); ! )! 
	    ELSE
	       GenEvaluator (Designators); ! . ! WI (Attribute);
	    END;
	 END;
      END;
   END;
   GenEvaluator (Next);
}; .
Any (..) :- {
	WriteString (f, Code);
	GenEvaluator (Next);
}; .
Anys (..) :- {
	GenEvaluator (Layouts);
	GenEvaluator (Next);
}; .
LayoutAny (..) :- {
	WriteString (f, Code);
	GenEvaluator (Next);
}; .

