(* Ich, Doktor Josef Grosch, Informatiker, 22.3.1989 *)

(* file ada1.puma 
   Rodney M. Bates, modifications: 
   (Changes made to precursor file mod1.puma:) 
      - Added generation of declaration and import
        of constants <Node>Max, with option '+'. 
      - Added generation of declaration and import
        of types p<Node>, with option '^'. 
      - Put IsType in generated imports list. 
   (Changes to file ada1.puma:)
   4-97  Copied from mod1.puma to ada1.puma and just began 
         the conversion to produce Ada output. 
   9-97  Changed to use IOUtils.WriteBackslash 
   7-99  Added handling of LINK attributes to Check. 
   7-99  Added handling of LINK attributes to Query. 
   6-2000 Changed generated yyStoreOldToNew and yyMapOldToNew to use 
          element zero. 
   6-2000 Partial conversion to Ada output.  Did not implement these
          command line options: -f - F -o -w -r -p -g -q -t -b -R -y 
          These routines (which help to implement the above options)
          are not called and not converted to Ada output:
            TraverseTD TraverseBU Reverse1 Reverse2 
            ReleaseAttributes1 ReleaseAttributes2 Copy
            InitNodeSize QueryAttributes IsEqualAttributes 
*)

TRAFO TreeAda1
TREE Tree
PUBLIC TreePackSpec TreePackBody 

EXPORT {
  FROM Positions  IMPORT tPosition;
  CONST BSS       = 32;   (* BITSET size *)
}

GLOBAL {

FROM Positions IMPORT tPosition ; 

FROM General    IMPORT Max;
FROM IO         IMPORT WriteS, WriteNl, StdError; 
FROM Idents     IMPORT tIdent;
FROM Texts      IMPORT WriteText;
FROM Sets       IMPORT IsElement, Include;
FROM TreeAda2   IMPORT TreeIO , GetIterator , Iterator ;
FROM IOUtils    IMPORT WriteBackslash ; 

FROM Tree       IMPORT
   NoTree       , tTree         , Input         , Reverse       ,
   Class        , Child         , Attribute     , Abstract      ,
   HasChildren  , HasAttributes , NoCodeAttr    , NoCodeClass   ,
   Options      , TreeRoot      , ClassCount    , iNoTree       ,
   itTree       , iMain         , iModule       , f             ,
   WI   , WN    , ForallClasses , ForallAttributes, Ignore      ,
   Test         , Dummy         , ForallClassesPreAndPost       ,
   Link         ;

IMPORT Strings;

VAR
   ConstCount   ,
   ListCount    : INTEGER;
   iRange       ,
   iClassName   : tIdent;
   Node         : tTree;
   gBitCount    : SHORTCARD;
   i, MaxBit    : SHORTCARD;

(* Move this to Ada2.puma when it is converted: *) 
PROCEDURE WriteLine (Line: tPosition);
   BEGIN
      IF Line.Line # 0 THEN
         !-- Copied from line ! WN (Line.Line); @ of file "@ WI (Line.File); @" @
      END;
   END WriteLine;
}

BEGIN { ConstCount := 0; }

PROCEDURE TreePackSpec (t: Tree)

Ag (..) :- {
        !!
        !-- This Ada PACKAGE spec file was mechanically generated by cg. !
        !!
      IF IsElement (ORD ('<'), Options) THEN
        !WITH ! WI (iMain); ! ; USE ! WI (iMain); ! ; !
      END;
      IF IsElement (ORD ('^'), Options) 
         OR IsElement (ORD ('o'), Options) THEN
        !WITH Text_IO ; ! 
      END; 
        WriteLine (TreeCodes^.Codes.SpecWithLine);
        WriteText (f, TreeCodes^.Codes.SpecWith);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.SpecWithLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.SpecWith);
           Node := Node^.Module.Next;
        END;
        !PACKAGE ! WI (iModule); ! IS !
        !!
        WriteLine (TreeCodes^.Codes.ImportLine);
        WriteText (f, TreeCodes^.Codes.Import);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.ImportLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Import);
           Node := Node^.Module.Next;
        END;
        !!
      IF NOT IsElement (ORD ('<'), Options) THEN
        !KindNull : CONSTANT := ! WN (ConstCount); ! ; !
        ForallClassesPreAndPost (Classes, ConstDeclsPre, ConstDeclsPost);
        !!
        IF FALSE OR IsElement (ORD ('^'), Options) THEN
(* This option is used primarily for Html dumper.  It has this ambiguous
   meaning in mod1.puma. *) 
          ForallClasses ( Classes, PointerTypes);
        END;
        !KindLast : CONSTANT := ! WN (ConstCount+1); ! ; !
     (* !tProcTree = PROCEDURE (! WI (itTree); !);!*) 
      END;
        WriteLine (TreeCodes^.Codes.ExportLine);
        WriteText (f, TreeCodes^.Codes.Export);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.ExportLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Export);
           Node := Node^.Module.Next;
        END;
        !!
      IF NOT IsElement (ORD ('<'), Options) THEN
        !# ifndef yyNodeHead!
        !# define yyNodeHead!
        !# endif!
        !SUBTYPE KindTyp IS INTEGER RANGE KindNull .. KindLast ; ! 
        !TYPE yyNode ( Kind : KindTyp := KindNull ) ; !
        !TYPE ! WI (itTree); ! IS ACCESS yyNode ; !
        !!
        !SUBTYPE SHORTCARD IS INTEGER RANGE 0 .. 32767 ; ! 
        !!
        !TYPE BITSET IS ARRAY ( 0 .. 31 ) OF BOOLEAN ; !
        !BitSetEmpty : CONSTANT BITSET := ( OTHERS => FALSE ) ; ! 
        !!
      IF IsElement (ORD ('L'), Options) THEN
        MaxBit := 0;
        ForallClasses (Classes, CompMaxBit);
        !TYPE yytNodeHead IS RECORD !
        !  yyMark , yyOffset : SHORTCARD ; !
        !  yyParent : ! WI (itTree); ! ; !
        !  yyIsComp0! 
      IF IsElement (ORD ('5'), Options) THEN
        ! , yyIsDone0! 
      END;
        FOR i := 1 TO (MaxBit - 1) DIV BSS DO
           ! , yyIsComp! WN (i);
      IF IsElement (ORD ('5'), Options) THEN
           ! , yyIsDone! WN (i);
      END;
        END;
        ! : BITSET ; yyNodeHead !
        !END RECORD ; !
      ELSE
        !TYPE yytNodeHead IS RECORD !
        !  yyMark : SHORTCARD ; yyNodeHead !
        !END RECORD ; !
      END;
        ForallClasses (Classes, TypeDeclNode);
        !!
        !TYPE yyNode ( Kind : KindTyp := KindNull ) IS RECORD !
        !  yyHead : yytNodeHead ; !
        !  CASE Kind IS !
        ForallClasses (Classes, TypeDeclRecord);
        !  WHEN OTHERS => NULL ; ! 
        !  END CASE ; !
        !END RECORD ; !
        !!
        WI (iNoTree); ! : CONSTANT ! WI (itTree); ! := NULL ; !
        !!
        WI (iMain); !Root : ! WI (itTree); ! ; !
     (* !VAR HeapUsed   : LONGCARD;!
        !VAR yyPoolFreePtr, yyPoolMaxPtr        : SYSTEM.ADDRESS;!
        !VAR yyNodeSize : ARRAY [0..! WN (ClassCount); !] OF SHORTCARD;!
        !VAR yyExit     : PROC;!
        !!
        !PROCEDURE yyAlloc      (): ! WI (itTree); !;!*) 
        !FUNCTION Make! WI (iMain); ! ( Kind : KindTyp ) RETURN ! WI (itTree); ! ; !
        !FUNCTION IsType ( Tree : ! WI (itTree); ! ; Kind : KindTyp ) RETURN BOOLEAN ; !
        !!
      END;
      IF IsElement (ORD ('n'), Options) THEN
        ForallClasses (Classes, ProcedureDecln);
        !!
      END;
      IF IsElement (ORD ('m'), Options) THEN
        ForallClasses (Classes, ProcedureDeclm);
        !!
      END;
      IF IsElement (ORD ('f'), Options) THEN
        WriteS ( StdError , "-f option not implemented for Ada" ) ; 
        WriteNl (StdError ) ;
        (* !PROCEDURE Release! WI (iModule); !     (Tree: ! WI (itTree); !);!*)
      END;
      IF IsElement (ORD ('F'), Options) AND NOT IsElement (ORD ('<'), Options) THEN
        WriteS ( StdError , "-F option not implemented for Ada" ) ; 
        WriteNl (StdError ) ;
        (*!PROCEDURE Release! WI (iModule); !Module;!*) 
      END;
      IF IsElement (ORD ('o'), Options) THEN
        !PROCEDURE Write! WI (iModule); !Node !
        ! ( f : Text_Io . File_Type ; Tree : ! WI (itTree); ! ) ; !
      END;
      IF IsElement (ORD ('w'), Options) THEN
        WriteS ( StdError , "-w option not implemented for Ada" ) ; 
        WriteNl (StdError ) ;
        (*!PROCEDURE Write! WI (iModule); !       (f: IO.tFile; Tree: ! WI (itTree); !);!*)
      END;
      IF IsElement (ORD ('^'), Options) THEN
        !-- Html graph writer:!
        !PROCEDURE Write! WI (iModule); !Html !
        @  ( f : Text_Io . File_Type ; Tree : @ WI (itTree); @ ; Title : STRING := "" @
        !  ; SuppressNullFields : BOOLEAN := FALSE ) ; !
        !!
      END;
      IF IsElement (ORD ('r'), Options) THEN
        WriteS ( StdError , "-r option not implemented for Ada" ) ; 
        WriteNl (StdError ) ;
        (*!PROCEDURE Read! WI (iModule); !        (f: IO.tFile): ! WI (itTree); !;!*)
      END;
      IF IsElement (ORD ('p'), Options) THEN
        WriteS ( StdError , "-p option not implemented for Ada" ) ; 
        WriteNl (StdError ) ;
        (*!PROCEDURE Put! WI (iModule); ! (f: IO.tFile; Tree: ! WI (itTree); !);!*)
      END;
      IF IsElement (ORD ('g'), Options) THEN
        WriteS ( StdError , "-g option not implemented for Ada" ) ; 
        WriteNl (StdError ) ;
        (*!PROCEDURE Get! WI (iModule); ! (f: IO.tFile): ! WI (itTree); !;!*)
      END;
      IF IsElement (ORD ('t'), Options) THEN
        WriteS ( StdError , "-t option not implemented for Ada" ) ; 
        WriteNl (StdError ) ;
        (*!PROCEDURE Traverse! WI (iModule); !TD  (Tree: ! WI (itTree); !; Proc: tProcTree);!*)
      END;
      IF IsElement (ORD ('b'), Options) THEN
        WriteS ( StdError , "-b option not implemented for Ada" ) ; 
        WriteNl (StdError ) ;
        (*!PROCEDURE Traverse! WI (iModule); !BU  (Tree: ! WI (itTree); !; Proc: tProcTree);!*)
      END;
      IF IsElement (ORD ('R'), Options) THEN
        WriteS ( StdError , "-R option not implemented for Ada" ) ; 
        WriteNl (StdError ) ;
        (*!PROCEDURE Reverse! WI (iModule); !     (Tree: ! WI (itTree); !): ! WI (itTree); !;!*)
      END;
      IF IsElement (ORD ('y'), Options) THEN
        WriteS ( StdError , "-y option not implemented for Ada" ) ; 
        WriteNl (StdError ) ;
        (*!PROCEDURE Copy! WI (iModule); !        (Tree: ! WI (itTree); !): ! WI (itTree); !;!*)
      END;
      IF IsElement (ORD ('k'), Options) THEN
        !FUNCTION Check! WI (iModule); ! ( Tree : ! WI (itTree); ! ) RETURN BOOLEAN ; !
      END;
      IF IsElement (ORD ('q'), Options) THEN
        WriteS ( StdError , "-q option not implemented for Ada" ) ; 
        WriteNl (StdError ) ;
        (*!PROCEDURE Query! WI (iModule); !       (Tree: ! WI (itTree); !);!*)
      END;
      IF IsElement (ORD ('='), Options) THEN
        WriteS ( StdError , "-= option not implemented for Ada" ) ; 
        WriteNl (StdError ) ;
      (*!FUNCTION IsEqual! WI (iModule); ! ( Tree1 , Tree2 : ! WI (itTree); 
           !) RETURN BOOLEAN ; !*)
      END;
      IF IsElement (ORD ('L'), Options) THEN
        !PROCEDURE Init! WI (iModule); ! ( Tree : ! WI (itTree); ! ) ; !
      END;
        !PROCEDURE Begin! WI (iModule); ! ; !
        !PROCEDURE Close! WI (iModule); ! ; !
        !!
        !END ! WI (iModule); ! ; !
}; .


PROCEDURE ConstDeclsPre (t: Tree)

Class (..) :- {
        IF NOT (Abstract IN Properties) THEN
           INC (ConstCount);
           IF NOT (Ignore IN Properties) THEN
              WI (Name); ! : CONSTANT := ! WN (ConstCount); !;!
           END;
        END;
}; .

PROCEDURE ConstDeclsPost (t: Tree)

Class (..) :- {
      IF IsElement (ORD ('+'), Options) THEN
        IF NOT (Abstract IN Properties) THEN
           IF NOT (Ignore IN Properties) THEN
              WI (Name); !Max : CONSTANT := ! WN (ConstCount); ! ; !
           END;
        END;
      END;
}; .

PROCEDURE PointerTypes (t: Tree)

Class (..) :- {
        IF NOT (Abstract IN Properties) THEN
           IF NOT (Ignore IN Properties) THEN
              !SUBTYPE p!WI (Name); ! IS ! WI ( itTree ); ! ; !
           END;
        END;
}; .

PROCEDURE TypeDeclNode (t: Tree)

Class (..) :- {
        IF (NoCodeClass * Properties) = {} THEN
           !TYPE y! WI (Name); ! IS RECORD !
           ForallAttributes (t, TypeDeclNode); 
           !  END RECORD ; !
        END;
}; .
Child (..) :- {
        !  ! WI (Name); ! : ! WI (itTree); ! ; !
}; .
Attribute (..) :- {
        IF (NoCodeAttr * Properties) = {} THEN 
           !  ! WI (Name); ! : ! WI (Type); ! ; !
        END;
}; .


PROCEDURE TypeDeclRecord (t: Tree)

Class (..) :- {
        IF (NoCodeClass * Properties) = {} THEN
           !  WHEN ! WI (Name); ! => ! WI (Name); ! : y! WI (Name); ! ; !
        END;
}; .


PROCEDURE ProcedureDecln (t: Tree)

Class (..) :- {
        IF (NoCodeClass * Properties) = {} THEN
           !FUNCTION n! WI (Name); ! RETURN ! WI (itTree); ! ; !
        END;
}; .


PROCEDURE ProcedureDeclm (t: Tree)

  Class ( .. ) 
    :- ProcedureHeadingm ( t ) ; 
       ! ; !
    . 

PROCEDURE ProcedureHeadingm (t: Tree)

Class (..) :- {
        IF (NoCodeClass * Properties) = {} THEN
           ListCount := 0;
           !FUNCTION m! WI (Name); !!
           !  ( !  
           ForallAttributes (t, ProcedureHeadingm); 
           !) RETURN ! WI (itTree); !! (*No EOL*)  
        END;
}; .
Child (..) :- {
        IF Input IN Properties THEN
           IF ListCount > 0 THEN !; ! END;
           !  p! WI (Name); ! : ! WI (itTree); ! := NULL !
           !  ! 
           INC (ListCount);
        END;
}; .
Attribute (..) :- {
        IF Input IN Properties THEN
           IF ListCount > 0 THEN !; ! END;
           !  p! WI (Name); !: ! WI (Type); !!
           !  !
           INC (ListCount);
        END;
}; .

PROCEDURE TreePackBody (t: Tree)

Ag (..) :- {
        !!
        !-- This Ada PACKAGE BODY file was mechanically generated by cg. !
        !!
      IF IsElement (ORD ('k'), Options) 
         OR IsElement (ORD ('q'), Options) 
         OR IsElement (ORD ('w'), Options) 
         OR IsElement (ORD ('^'), Options) 
         OR IsElement (ORD ('o'), Options) THEN
        !WITH Text_IO ; ! 
      END; 
      IF IsElement (ORD ('o'), Options) THEN
        !WITH Unchecked_Conversion ; ! 
      END; 
      IF IsElement (ORD ('<'), Options) THEN
        !WITH ! WI (iMain); ! ; USE ! WI (iMain); ! ; !
        !!
      END;
        !PACKAGE BODY ! WI (iModule); ! IS !
      (*!# define yyALLOC(ptr, size)    ptr := yyPoolFreePtr; ! WriteBackslash ( f ) ; !!
        !  IF SYSTEM.ADDRESS (ptr) >= yyPoolMaxPtr THEN ptr := yyAlloc (); END; ! WriteBackslash ( f ) ; !!
        !  INC (yyPoolFreePtr, size);!
        !# define yyFREE(ptr, size)     !
        !!
        !IMPORT SYSTEM, System, General, Memory, DynArray, IO, Layout, StringMem, Strings, Idents, Texts, Sets, Positions;!*)
      IF IsElement (ORD ('<'), Options) THEN
      (*!FROM ! WI (iMain); ! IMPORT ! WI (itTree); !, ! WI (iNoTree); !, tProcTree, Make! WI (iMain); !, IsType, yyExit,!
        ForallClasses (Classes, ImportConst);
        !yyAlloc, yyPoolFreePtr, yyPoolMaxPtr, yyNodeSize;!
        !!*) 
      END;
        WriteLine (TreeCodes^.Codes.GlobalLine);
        WriteText (f, TreeCodes^.Codes.Global);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.GlobalLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Global);
           Node := Node^.Module.Next;
        END;
        WriteLine (TreeCodes^.Codes.LocalLine);
        WriteText (f, TreeCodes^.Codes.Local);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.LocalLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Local);
           Node := Node^.Module.Next;
        END;
        @# include "yy@ WI (iModule); @.w"@
        !!
      IF NOT IsElement (ORD ('<'), Options) THEN
        !yyTypeRange : ARRAY ( 0..! WN (ClassCount); !) OF SHORTCARD;!
      (*!CONST yyBlockSize = 20480;!
        !!
        !TYPE!
        ! yytBlockPtr   = POINTER TO yytBlock;!
        ! yytBlock      = RECORD!
        !                    yyBlock    : ARRAY [1..yyBlockSize] OF CHAR;!
        !                    yySuccessor: yytBlockPtr;!
        !                 END;!
        !!
        !VAR yyBlockList        : yytBlockPtr;!
        !VAR yyMaxSize, yyi     : SHORTCARD;!
        !!
        !PROCEDURE yyAlloc (): ! WI (itTree); !;!
        ! VAR yyBlockPtr        : yytBlockPtr;!
        ! BEGIN!
        !  yyBlockPtr   := yyBlockList;!
        !  yyBlockList  := Memory.Alloc (SYSTEM.TSIZE (yytBlock));!
        !  yyBlockList^.yySuccessor := yyBlockPtr;!
        !  yyPoolFreePtr        := SYSTEM.ADR (yyBlockList^.yyBlock);!
        !  yyPoolMaxPtr := yyPoolFreePtr + yyBlockSize - yyMaxSize + 1;!
        !  INC (HeapUsed, yyBlockSize);!
        !  RETURN yyPoolFreePtr;!
        ! END yyAlloc;!
        !!*)
        !FUNCTION  Make! WI (iMain); ! ( Kind : KindTyp ) RETURN ! WI (itTree); !!
        !  IS !
        !    yyt : ! WI (itTree); ! ; !
        !  BEGIN !
        !    yyt := NEW yyNode ( Kind ) ; ! 
        !    yyt . ALL . yyHead . yyMark := 0 ; !
        !    RETURN yyt; !
        ! END Make! WI (iMain); ! ; !
        !!
        !FUNCTION IsType ( Tree : ! WI (itTree); ! ; Kind : KindTyp ) RETURN  BOOLEAN !
        !  IS BEGIN !
        !    RETURN Tree /= ! WI (iNoTree); !!
        !      AND Kind <= Tree . ALL . Kind !
        !      AND Tree . ALL . Kind <= yyTypeRange ( Kind ) ; !
        !  END IsType ; !
        !!
      END;
      IF IsElement (ORD ('n'), Options) THEN
        ForallClasses (Classes, ProcedureBodyn);
      END;
        !!
      IF IsElement (ORD ('m'), Options) THEN
        ForallClasses (Classes, ProcedureBodym);
      END;
      TreeIO (t);  
      IF IsElement (ORD ('f'), Options) THEN
      (*!PROCEDURE Release! WI (iModule); ! (yyt: ! WI (itTree); !);!
        ! BEGIN!
        !  yyMark (yyt);!
        !  yyRelease! WI (iModule); ! (yyt);!
        ! END Release! WI (iModule); !;!
        !!
        !VAR yyChild    : ! WI (itTree); !;!
        !!
        !PROCEDURE yyRelease! WI (iModule); ! (yyt: ! WI (itTree); !);!
        ! BEGIN!
        !  IF yyt = ! WI (iNoTree); ! THEN RETURN; END;!
        !  CASE yyt . ALL . Kind OF!
        ForallClasses (Classes, ReleaseAttributes1);
        !  ELSE!
        !  END;!
        !!
        !  DEC (yyt . ALL . yyHead . yyMark);!
        !  IF yyt . ALL . yyHead . yyMark = 0 THEN!
        !   CASE yyt . ALL . Kind OF!
        ForallClasses (Classes, ReleaseAttributes2);
        !   ELSE!
        !   END;!
        !   yyFREE (yyt, yyNodeSize [yyt . ALL . Kind])!
        !  END;!
        ! END yyRelease! WI (iModule); !;!
        !!*)
      END;
      IF IsElement (ORD ('F'), Options) AND NOT IsElement (ORD ('<'), Options) THEN
      (*!PROCEDURE Release! WI (iModule); !Module;!
        ! VAR yyBlockPtr        : yytBlockPtr;!
        ! BEGIN!
        !  WHILE yyBlockList /= NIL DO!
        !   yyBlockPtr  := yyBlockList;!
        !   yyBlockList := yyBlockList^.yySuccessor;!
        !   Memory.Free (SYSTEM.TSIZE (yytBlock), yyBlockPtr);!
        !  END;!
        !  yyPoolFreePtr        := NIL;!
        !  yyPoolMaxPtr := NIL;!
        !  HeapUsed     := 0;!
        ! END Release! WI (iModule); !Module;!
        !!*)
      END;
      IF IsElement (ORD ('t'), Options) OR
         IsElement (ORD ('b'), Options) THEN
      (*!VAR yyProc     : tProcTree;!
        !!*)
      END;
      IF IsElement (ORD ('t'), Options) THEN
      (*!PROCEDURE Traverse! WI (iModule); !TD (yyt: ! WI (itTree); !; yyyProc: tProcTree);!
        ! BEGIN!
        !  yyMark (yyt);!
        !  yyProc := yyyProc;!
        !  yyTraverse! WI (iModule); !TD (yyt);!
        ! END Traverse! WI (iModule); !TD;!
        !!
        !PROCEDURE yyTraverse! WI (iModule); !TD (yyt: ! WI (itTree); !);!
        ! BEGIN!
        !  LOOP!
        !   IF (yyt = ! WI (iNoTree); !) OR (yyt . ALL . yyHead . yyMark = 0) THEN RETURN; END;!
        !   yyt . ALL . yyHead . yyMark := 0;!
        !   yyProc (yyt);!
        !!
        !   CASE yyt . ALL . Kind OF!
        ForallClasses (Classes, TraverseTD);
        !   ELSE RETURN;!
        !   END;!
        !  END;!
        ! END yyTraverse! WI (iModule); !TD;!
        !!
      END;
      IF IsElement (ORD ('b'), Options) THEN
        !PROCEDURE Traverse! WI (iModule); !BU (yyt: ! WI (itTree); !; yyyProc: tProcTree);!
        ! BEGIN!
        !  yyMark (yyt);!
        !  yyProc := yyyProc;!
        !  yyTraverse! WI (iModule); !BU (yyt);!
        ! END Traverse! WI (iModule); !BU;!
        !!
        !PROCEDURE yyTraverse! WI (iModule); !BU (yyt: ! WI (itTree); !);!
        ! BEGIN!
        !  IF (yyt = ! WI (iNoTree); !) OR (yyt . ALL . yyHead . yyMark = 0) THEN RETURN; END;!
        !  yyt . ALL . yyHead . yyMark := 0;!
        !!
        !  CASE yyt . ALL . Kind OF!
        ForallClasses (Classes, TraverseBU);
        !  ELSE!
        !  END;!
        !  yyProc (yyt);!
        ! END yyTraverse! WI (iModule); !BU;!
        !!*)
      END;
      IF IsElement (ORD ('R'), Options) THEN
      (*!PROCEDURE Reverse! WI (iModule); ! (yyOld: ! WI (itTree); !): ! WI (itTree); !;!
        ! VAR yyNew, yyNext, yyTail     : ! WI (itTree); !;!
        ! BEGIN!
        !  yyNew        := yyOld;!
        !  yyTail       := yyOld;!
        !  LOOP!
        !   CASE yyOld . ALL . Kind OF!
        ForallClasses (Classes, Reverse1);
        !   ELSE EXIT;!
        !   END;!
        !   yyNew       := yyOld;!
        !   yyOld       := yyNext;!
        !  END;!
        !  CASE yyTail . ALL . Kind OF!
        ForallClasses (Classes, Reverse2);
        !  ELSE!
        !  END;!
        !  RETURN yyNew;!
        ! END Reverse! WI (iModule); !;!
        !!*)
      END;
      IF IsElement (ORD ('y'), Options) THEN
      (*!CONST yyInitOldToNewStoreSize  = 32;!
        !!
        !TYPE yytOldToNew = RECORD yyOld, yyNew: ! WI (itTree); !; END;!
        !!
        !VAR yyOldToNewStoreSize        : LONGINT;!
        !VAR yyOldToNewStorePtr : POINTER TO ARRAY [0..50000] OF yytOldToNew;!
        !VAR yyOldToNewCount    : INTEGER;!
        !!
        !PROCEDURE yyStoreOldToNew (yyOld, yyNew: ! WI (itTree); !);!
        ! BEGIN!
        !  IF (yyOldToNewCount = yyOldToNewStoreSize) THEN!
        !   DynArray.ExtendArray (yyOldToNewStorePtr, yyOldToNewStoreSize, SYSTEM.TSIZE (yytOldToNew));!
        !  END;!
        !  yyOldToNewStorePtr^[yyOldToNewCount].yyOld := yyOld;!
        !  yyOldToNewStorePtr^[yyOldToNewCount].yyNew := yyNew;!
        !  INC (yyOldToNewCount);!
        ! END yyStoreOldToNew;!
        !!
        !PROCEDURE yyMapOldToNew (yyOld: ! WI (itTree); !): ! WI (itTree); !;!
        ! VAR yyi: INTEGER;!
        ! BEGIN!
        !  FOR yyi := 0 TO yyOldToNewCount - 1 DO!
        !   IF yyOldToNewStorePtr^[yyi].yyOld = yyOld THEN!
        !    RETURN yyOldToNewStorePtr^[yyi].yyNew;!
        !   END;!
        !  END;!
        ! END yyMapOldToNew;!
        !!
        !PROCEDURE yyCopy! WI (iModule); ! (yyt: ! WI (itTree); !; yyNew: yyPtrtTree);!
        ! BEGIN!
        !  LOOP!
        !   IF yyt = ! WI (iNoTree); ! THEN yyNew^ := ! WI (iNoTree); !; RETURN; END;!
        !   IF yyt . ALL . yyHead . yyMark = 0 THEN yyNew^ := yyMapOldToNew (yyt); RETURN; END;!
        !   yyNew^ := Make! WI (iMain); ! (yyt . ALL . Kind);!
        !   IF yyt . ALL . yyHead . yyMark > 1 THEN yyStoreOldToNew (yyt, yyNew^); END;!
        !   yyt . ALL . yyHead . yyMark := 0;!
        !!
        !   CASE yyt . ALL . Kind OF!
        ForallClasses (Classes, Copy);
        !   ELSE!
        !   END;!
        !  END;!
        ! END yyCopy! WI (iModule); !;!
        !!
        !PROCEDURE Copy! WI (iModule); ! (yyt: ! WI (itTree); !): ! WI (itTree); !;!
        ! VAR yyNew     : ! WI (itTree); !;!
        ! BEGIN!
        !  yyMark (yyt);!
        !  yyOldToNewCount := 0;!
        !  yyCopy! WI (iModule); ! (yyt, SYSTEM.ADR (yyNew));!
        !  RETURN yyNew;!
        ! END Copy! WI (iModule); !;!
        !!*)
      END;
      IF IsElement (ORD ('k'), Options) THEN
        !FUNCTION yyCheckChild !
        !  ( yyParent , yyChild : ! WI (itTree); !!
        !  ; yyType : KindTyp ; yySelector: STRING !
        !  ) !
        !RETURN BOOLEAN ; !
        !!
        !FUNCTION yyCheck! WI (iModule); ! ( yyt : ! WI (itTree); ! ) RETURN BOOLEAN !
        !  IS ! 
        !    yyResult : BOOLEAN ; !
        !  BEGIN !
        !    IF yyt = ! WI (iNoTree); ! THEN RETURN FALSE ; !
        !    ELSIF yyt . ALL . yyHead . yyMark = 0 THEN RETURN TRUE ; !
        !    END IF ; !
        !    yyt . ALL . yyHead . yyMark := 0;!
        !!
        !    yyResult := TRUE;!
        !    CASE yyt . ALL . Kind IS !
        ForallClasses (Classes, CheckAttributes);
        !    WHEN OTHERS => NULL ; !
        !    END CASE ; !
        !    RETURN yyResult ; !
        !  END yyCheck! WI (iModule); ! ; !
        !!
        !FUNCTION yyCheckChild !
        !  ( yyParent , yyChild : ! WI (itTree); !!
        !  ; yyType : KindTyp ; yySelector: STRING !
        !  ) !
        !RETURN BOOLEAN !
        !  IS ! 
        !    yyf : CONSTANT Text_Io . File_Type := Text_Io . StdErr ; ! 
        !    yySuccess : BOOLEAN ; !
        !  BEGIN!
        !    yySuccess := IsType ( yyChild , yyType ) ; !
        !    IF NOT yySuccess THEN!
        @      Text_Io . Put ( yyf , "CheckTree: parent = " ) ; @
        !      Write! WI (iModule); !Node ( yyf , yyParent ) ; !
        !      Text_Io . Put_Line ( yyf ) ; !
        @      Text_Io . Put ( yyf , "selector: " ) ; @
        !      Text_Io . Put ( yyf , yySelector ) ; !
        @      Text_Io . Put ( yyf , ", child = " ) ; @
        !      Write! WI (iModule); !Node ( yyf , yyChild ) ; !
        !      Text_Io . Put_Line ( yyf ) ; !
        !    END IF ; !
        !  RETURN yyCheck! WI (iModule); ! ( yyChild ) AND yySuccess ; !
        ! END yyCheckChild ; !
        !!
        !FUNCTION Check! WI (iModule); ! ( Tree : ! WI (itTree); ! ) RETURN BOOLEAN !
        !  IS BEGIN !
        !    yyMark ( Tree ) ; !
        !    RETURN yyCheck! WI (iModule); ! ( Tree ) ; !
        !  END Check! WI (iModule); ! ; !
        !!
      END;
      IF IsElement (ORD ('q'), Options) THEN
      (*!CONST yyyWrite = 1; yyyRead = 2; yyyQuit = 3;!
        !!
        !VAR yyString   : ARRAY [0..31] OF CHAR;!
        !VAR yyLength   : INTEGER;!
        !VAR yyCh       : CHAR;!
        !VAR yyState    : INTEGER;!
        !!
        !PROCEDURE yyyIsEqual (yya: ARRAY OF CHAR): BOOLEAN;!
        ! VAR yyi       : INTEGER;!
        ! BEGIN!
        !  IF (yyLength >= 0) AND (yyString [yyLength] = ' ') THEN!
        !   IF yyLength - 1 /= INTEGER (HIGH (yya)) THEN RETURN FALSE; END;!
        !   FOR yyi := 0 TO yyLength - 1 DO!
        !    IF yyString [yyi] /= yya [yyi] THEN RETURN FALSE; END;!
        !   END;!
        !  ELSE!
        !   IF yyLength > INTEGER (HIGH (yya)) THEN RETURN FALSE; END;!
        !   FOR yyi := 0 TO yyLength DO!
        !    IF yyString [yyi] /= yya [yyi] THEN RETURN FALSE; END;!
        !   END;!
        !  END;!
        !  RETURN TRUE;!
        ! END yyyIsEqual;!
        !!
        !PROCEDURE Query! WI (iModule); ! (yyt: ! WI (itTree); !);!
        ! BEGIN!
        !  yyState := yyyWrite;!
        !  LOOP!
        !   CASE yyState OF!
        !   | yyyQuit   : RETURN;!
        !   | yyyWrite  : Write! WI (iModule); !Node (IO.StdOutput, yyt); yyState := yyyRead;!
        !   | yyyRead   : Text_Io . Put (IO.StdOutput, '? '); yyLength := -1; yyCh := IO.ReadC (IO.StdInput);!
        !    WHILE yyCh /= 12C DO INC (yyLength); yyString [yyLength] := yyCh; yyCh := IO.ReadC (IO.StdInput); END;!
        !    IF    yyyIsEqual ('parent') THEN yyState := yyyWrite; RETURN;!
        !    ELSIF yyyIsEqual ('quit'  ) THEN yyState := yyyQuit ; RETURN;!
        !    ELSIF yyt /= ! WI (iNoTree); ! THEN!
        !     CASE yyt . ALL . Kind OF!
        ForallClasses (Classes, QueryAttributes);
        !     ELSE!
        !     END;!
        !    END;!
        !   END;!
        !  END;!
        ! END Query! WI (iModule); !;!
        !!*)
      END;
      IF IsElement (ORD ('='), Options) THEN
      (*!PROCEDURE yyIsEqual (yya, yyb: ARRAY OF SYSTEM.BYTE): BOOLEAN;!
        ! VAR yyi       : INTEGER;!
        ! BEGIN!
        !  FOR yyi := 0 TO INTEGER (HIGH (yya)) DO!
        !   IF yya [yyi] /= yyb [yyi] THEN RETURN FALSE; END;!
        !  END;!
        !  RETURN TRUE;!
        ! END yyIsEqual;!
        !!
        !PROCEDURE IsEqual! WI (iModule); ! (yyt1, yyt2: ! WI (itTree); !): BOOLEAN;!
        ! BEGIN!
        !  IF yyt1 = yyt2 THEN RETURN TRUE; END;!
        !  IF (yyt1 = ! WI (iNoTree); !) OR (yyt2 = ! WI (iNoTree); !) OR (yyt1 . ALL . Kind /= yyt2 . ALL . Kind) THEN RETURN FALSE; END;!
        !  CASE yyt1 . ALL . Kind OF!
        ForallClasses (Classes, IsEqualAttributes);
        !  ELSE RETURN TRUE;!
        !  END;!
        ! END IsEqual! WI (iModule); !;!
        !!*)
      END;
      IF IsElement (ORD ('L'), Options) THEN
        MaxBit := 0;
        ForallClasses (Classes, CompMaxBit);
        !PROCEDURE Init! WI ( iModule); ! ( yyt : ! WI (itTree); ! ) !
        !  IS BEGIN!
        !  LOOP!
        FOR i := 0 TO (MaxBit - 1) DIV BSS DO
           !     yyt . ALL . yyIsComp! WN (i); ! := BitsetEmpty ; !
      IF IsElement (ORD ('5'), Options) THEN
           !     yyt . ALL . yyIsDone! WN (i); ! := BitsetEmpty ;!
      END;
        END;
        !    CASE yyt . ALL . Kind OF!
        ForallClasses (Classes, InitAttributes);
        !    ELSE RETURN;!
        !    END CASE ; !
        !  END LOOP ;!
        ! END Init! WI (iModule); !;!
        !!
      END;
        !PROCEDURE Begin! WI (iModule); !!
        !  IS BEGIN !
        WriteLine (TreeCodes^.Codes.BeginLine);
        WriteText (f, TreeCodes^.Codes.Begin);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.BeginLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Begin);
           Node := Node^.Module.Next;
        END;
        !    NULL ; !
          (* ^Just in case nothing is generated in here. *) 
        !  END Begin! WI (iModule); ! ; !
        !!
        !PROCEDURE Close! WI (iModule); !!
        !  IS BEGIN !
        WriteLine (TreeCodes^.Codes.CloseLine);
        WriteText (f, TreeCodes^.Codes.Close);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.CloseLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Close);
           Node := Node^.Module.Next;
        END;
        !    NULL ; !
          (* ^Just in case nothing is generated in here. *) 
        !  END Close! WI (iModule); ! ; !
        !!
      IF NOT IsElement (ORD ('<'), Options) THEN
      (*!  PROCEDURE xxExit !
        !  IS BEGIN !
        !     Exit ( 1 ) ; !
        !   END xxExit ; !
        !!*)
      END;
        !BEGIN!
      IF IsElement (ORD ('r'), Options) THEN
        (*! yyIsInitialized := FALSE;!*)
      END;
      IF NOT IsElement (ORD ('<'), Options) THEN
      (*! yyBlockList   := NIL;!
        ! yyPoolFreePtr := NIL;!
        ! yyPoolMaxPtr  := NIL;!
        ! HeapUsed      := 0;!
        ! yyExit        := xxExit;!
        ForallClasses (Classes, InitNodeSize);
        ! yyMaxSize     := 0 ; !
        ! FOR yyi := 1 TO ! WN (ClassCount); ! DO!
        !  yyNodeSize [yyi] := LONGINT (BITSET (yyNodeSize [yyi] + CARDINAL (General.MaxAlign) - 1) * General.AlignMasks [General.MaxAlign]);!
        !  yyMaxSize := General.Max (yyNodeSize [yyi], yyMaxSize);!
        ! END;!*)
        ForallClasses (Classes, InitTypeRange);
      END;
      IF IsElement (ORD (';'), Options) THEN
      (*! yyRecursionLevel := 0;!
        ! yyTreeStoreSize := yyInitTreeStoreSize;!
        ! DynArray.MakeArray (yyTreeStorePtr, yyTreeStoreSize, SYSTEM.TSIZE (! WI (itTree); !));!*) 
      END;
      IF IsElement (ORD ('y'), Options) THEN
      (*! yyOldToNewStoreSize := yyInitOldToNewStoreSize;!
        ! DynArray.MakeArray (yyOldToNewStorePtr, yyOldToNewStoreSize, SYSTEM.TSIZE (yytOldToNew));!*)
      END;
        !  Begin! WI (iModule); ! ; !
        !END ! WI (iModule); ! ; !
}; .


PROCEDURE ProcedureBodyn (t: Tree)

Class (..) :- {
        IF (NoCodeClass * Properties) = {} THEN
           !FUNCTION n! WI (Name); ! RETURN ! WI (itTree); !!
           !  IS !
           !    yyt : ! WI (itTree); ! ; !
           !  BEGIN !
           !    yyt := NEW yyNode ( ! WI ( Name ) ; ! ) ; !
           !    yyt . ALL . yyHead . yyMark := 0 ; !
           iClassName := Name;
           ForallAttributes (t, ProcedureBodyn);
           !    RETURN yyt ; !
           ! END n! WI (Name); ! ; !
           !!
        END;
}; .
Child (..) :- {
        !    begin! WI (itTree); ! ( yyt . ALL . ! WI (Name); ! ) !
}; .
Attribute (..) :- {
        IF (NoCodeAttr * Properties) = {} THEN 
           !    begin! WI (Type); ! ( yyt . ALL . ! WI (Name); ! ) !
        END;
}; .


PROCEDURE ProcedureBodym (t: Tree)

Class (..) :- {
        IF (NoCodeClass * Properties) = {} THEN
           ProcedureHeadingm (t);
           !  IS ! 
           !    yyt : ! WI (itTree); ! ; !
           !  BEGIN !
           !    yyt := NEW yyNode ( ! WI ( Name ) ; ! ) ; !
           !    yyt . ALL . yyHead . yyMark := 0 ; !
           IF ({HasChildren, HasAttributes} * Properties) # {} THEN
              ForallAttributes (t, ProcedureBodym);
           END;
           !    RETURN yyt ; !
           !  END m! WI (Name); ! ; !
           !!
        END;
}; .
Child (..) :- {
        IF Input IN Properties THEN
           !    yyt . ALL . ! WI (Name); ! := p! WI (Name); ! ; !
        ELSE
           !    begin! WI (itTree); ! ( yyt . ALL . ! WI (Name); ! ) !
        END;
}; .
Attribute (..) :- {
        IF (NoCodeAttr * Properties) = {} THEN 
           IF Input IN Properties THEN
              !    yyt . ALL . ! WI (Name); ! := p! WI (Name); ! ; !
           ELSE
              !    begin! WI (Type); ! ( yyt . ALL . ! WI (Name); ! ) !
           END;
        END;
}; .


PROCEDURE ReleaseAttributes1 (t: Tree)

Class (..) :- {
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           !| ! WI (Name); !:!
           iClassName := Name;
           ForallAttributes (t, ReleaseAttributes1);
        END;
}; .
Child (..) :- {
        !close! WI (itTree); ! (yyt^.! WI (iClassName); !.! WI (Name); !)!
}; .


PROCEDURE ReleaseAttributes2 (t: Tree)

Class (..) :- {
        IF ((NoCodeClass * Properties) = {}) AND (HasAttributes IN Properties) THEN
           !| ! WI (Name); !:!
           iClassName := Name;
           ForallAttributes (t, ReleaseAttributes2);
        END;
}; .
Attribute (..) :- {
        IF (NoCodeAttr * Properties) = {} THEN 
           !close! WI (Type); ! (yyt^.! WI (iClassName); !.! WI (Name); !)!
        END;
}; .


PROCEDURE TraverseTD (t: Tree)

Class (..) :- {
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           !| ! WI (Name); !:!
           GetIterator (t);
           iClassName := Name;
           ForallAttributes (t, TraverseTD);
           IF Iterator = NoTree THEN
              !RETURN;!
           ELSE
              !yyt := yyt^.! WI (iClassName); !.! WI (Iterator^.Child.Name); !;!
           END;
        END;
}; .
Child (..) :- {
        IF t # Iterator THEN
           !yyTraverse! WI (iModule); !TD (yyt^.! WI (iClassName); !.! WI (Name); !);!
        END;
}; .


PROCEDURE TraverseBU (t: Tree)

Class (..) :- {
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           !| ! WI (Name); !:!
           GetIterator (t);
           iClassName := Name;
           ForallAttributes (t, TraverseBU);
           IF Iterator = NoTree THEN
              !RETURN;!
           ELSE
              !yyTraverse! WI (iModule); !BU (yyt^.! WI (iClassName); !.! WI (Iterator^.Child.Name); !);!
           END;
        END;
}; .
Child (..) :- {
        IF t # Iterator THEN
           !yyTraverse! WI (iModule); !BU (yyt^.! WI (iClassName); !.! WI (Name); !);!
        END;
}; .


PROCEDURE Reverse1 (t: Tree)

Class (..) :- {
        IF (NoCodeClass * Properties) = {} THEN
           iClassName := Name;
           ForallAttributes (t, Reverse1);
        END;
}; .
Child (..) :- {
        IF Reverse IN Properties THEN
           !| ! WI (iClassName); !: yyNext := yyOld^.! WI (iClassName); !.! WI (Name); !;! 
           ! yyOld^.! WI (iClassName); !.! WI (Name); ! := yyNew;!
        END;
}; .


PROCEDURE Reverse2 (t: Tree)

Class (..) :- {
        IF (NoCodeClass * Properties) = {} THEN
           iClassName := Name;
           ForallAttributes (t, Reverse2);
        END;
}; .
Child (..) :- {
        IF Reverse IN Properties THEN
           !| ! WI (iClassName); !: yyTail^.! WI (iClassName); !.! WI (Name); ! := yyOld;!
        END;
}; .


PROCEDURE Copy (t: Tree)

Class (..) :- {
        IF (NoCodeClass * Properties) = {} THEN
           !| ! WI (Name); !: yyNew^^.! WI (Name); ! := yyt^.! WI (Name); !;!
           GetIterator (t);
           iClassName := Name;
           ForallAttributes (t, Copy);
           IF Iterator = NoTree THEN
              !RETURN;!
           ELSE
              !yyt := yyt^.! WI (Name); !.! WI (Iterator^.Child.Name); !;!
              !yyNew := SYSTEM.ADR (yyNew^^.! WI (Name); !.! WI (Iterator^.Child.Name); !);!
           END;
        END;
}; .
Child (..) :- {
        IF t # Iterator THEN
           !copy! WI (itTree); ! (yyNew^^.! WI (iClassName); !.! WI (Name); !, ! 
              !yyt^.! WI (iClassName); !.! WI (Name); !)!
        END;
}; .
Attribute (..) :- {
        IF (NoCodeAttr * Properties) = {} THEN 
           !copy! WI (Type); ! (yyNew^^.! WI (iClassName); !.! WI (Name); !, ! 
              !yyt^.! WI (iClassName); !.! WI (Name); !)!
        END;
}; .


PROCEDURE CheckAttributes (t: Tree)

Class (..) :- {
        IF ((NoCodeClass * Properties) = {}) 
           AND (HasChildren IN Properties) THEN
           !    WHEN ! WI (Name); ! => !
           iClassName := Name;
           ForallAttributes (t, CheckAttributes);
        END;
}; .
Child (..) 
  :- { !       yyResult := yyResult AND THEN !
       !         yyCheckChild ( yyt , yyt . ALL . ! WI ( iClassName ) ; ! . ! WI (Name); ! , ! 
                   WI (Type); @ , "@ WI (Name); @" ) ; @
     } ; .
Attribute (..) 
  :- ( { Link IN Properties } ) ; 
     { !       yyResult := yyResult AND THEN !
       !         yyCheckChild  ( yyt , yyt . ALL . ! WI ( iClassName ) ; ! . ! WI (Name); ! , ! 
                   WI (Type); @ , "@ WI (Name); @" ) ; @
     } ; .


PROCEDURE InitTypeRange (t: Tree)

Class (..) :- {
        IF (NoCodeClass * Properties) = {} THEN
           iRange := Name;
           ForallClasses (Extensions, InitTypeRange2);
           !  yyTypeRange (! WI (Name); !) := ! WI (iRange); ! ; !
        END;
}; .


PROCEDURE InitTypeRange2 (t: Tree)

Class (..) :- {
        iRange := Name;
}; .


PROCEDURE QueryAttributes (t: Tree)

Class (..) :- {
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           !| ! WI (Name); !: IF FALSE THEN!
           iClassName := Name;
           ForallAttributes (t, QueryAttributes);
           !END;!
        END;
}; .
Child (..) 
  :- { !ELSIF yyyIsEqual ('! WI (Name); !') THEN Query! WI (iModule);
       ! (yyt^.! WI (iClassName); !.! WI (Name); !);!
     } ; .
Attribute (..) 
  :- ( { Link IN Properties } ) ; 
     { !ELSIF yyyIsEqual ('! WI (Name); !') THEN Query! WI (iModule);
       ! (yyt^.! WI (iClassName); !.! WI (Name); !);!
     } ; .


PROCEDURE IsEqualAttributes (t: Tree)

Class (..) :- {
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           !| ! WI (Name); !: RETURN TRUE!
           iClassName := Name;
           ForallAttributes (t, IsEqualAttributes);
        END;
}; .
Child (..) :- {
        !AND equal! WI (itTree); ! (yyt1^.! WI (iClassName); !.! WI (Name);
        !, yyt2^.! WI (iClassName); !.! WI (Name); !)!
}; .
Attribute (..) :- {
        IF (NoCodeAttr * Properties) = {} THEN 
           !AND (equal! WI (Type); ! (yyt1^.! WI (iClassName); !.! WI (Name);
           !, yyt2^.! WI (iClassName); !.! WI (Name); !))!
        END;
}; .


PROCEDURE InitAttributes (t: Tree)

Class (..) :-
        ((NoCodeClass * Properties) = {{}}) AND (HasChildren IN Properties);
        !    WHEN ! WI (Name); ! => !
        GetIterator (t);
        iClassName := Name;
        gBitCount := BitCount;
        ForallAttributes (t, InitAttributes);
{       IF (Iterator = NoTree) OR NOT (Input IN Iterator^.Child.Properties) THEN
           !       RETURN ; !
        ELSE
           !       yyt := yyt . ALL . ! WI (Iterator^.Child.Name); ! ; !
        END;
};      .
Child (..) :-
        Input IN Properties;
        !       yyt . ALL . yyHead . yyOffset := ! (*No EOL *) 
        WN (gBitCount + BitOffset); ! ; ! 
        !       yyt . ALL . yyHead . yyParent := yyt ; ! 
        t # Iterator;
        !       Init! WI (iModule); ! (yyt . ALL . ! WI (Name); ! ) ; !
        .

PROCEDURE InitNodeSize (t: Tree)

Class (..) :-
        (NoCodeClass * Properties) = {{}};
        ! yyNodeSize [! WI (Name); !] := SYSTEM.TSIZE (y! WI (Name); !);!
        .

PROCEDURE CompMaxBit (t: Tree)

Class (..) :-
        i := 1;
        ForallAttributes (t, CompMaxBit);
        MaxBit := Max (i, MaxBit);
        .
Child (..) ;
Attribute (..) :-
        ({{Input, Test, Dummy}} * Properties = {{}});
        INC (i);
        .
