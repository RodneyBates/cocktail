
(* file MThree6.puma 

   Generation of specialized tree converter from Gnat tree to 
   semantically equivalent cg tree. 
   Rodney M. Bates 10-97 

*)

TRAFO GenGnat 
TREE Tree
PUBLIC GnatModule 

GLOBAL {

(* IMPORT IO; This is already generated by puma *) 
FROM IO		IMPORT WriteS, WriteNl;
IMPORT Idents , Errors ; 
FROM Idents	IMPORT tIdent;
FROM Sets       IMPORT IsElement;
FROM Tree	IMPORT
   NoTree	, tTree		, 
   Class	, Child		, Attribute	, 
   NoCodeAttr	, NoCodeClass	, Link          , Low           ,
   iNoTree	, Options       , 
   itTree	, iMain		, iModule	, f		,
   WI	        , ForallClasses	, ForallAttributes, 
   IdentifyClass ;

IMPORT Positions , Strings;

VAR debug1 : BOOLEAN ; 

VAR Node : tTree;
VAR gNClassNonEmptyClass : tTree ; 
VAR gEntityClass : tTree ; 
VAR gIdentNodeNumber : tIdent ;
VAR gIdentNext : tIdent ;
VAR gIdentPrev : tIdent ;
VAR gIdentIsListMember : tIdent ;
VAR gIdentLink : tIdent ;
VAR gIdentSloc : tIdent ;
VAR gIdentIsRewriteSubstitution : tIdent ;
VAR gIdentIsRewriteInsertion : tIdent ;
VAR gIdentComesFromSource : tIdent ;
VAR gIdentAnalyzed : tIdent ;
VAR gIdentErrorPosted : tIdent ;
VAR gIdentParenCount : tIdent ;
VAR gIdentHasDynamicLengthCheck : tIdent ;
VAR gIdentHasDynamicRangeCheck : tIdent ;
VAR gIdentDiscriminantConstraint : tIdent ;
VAR gIdentPrimitiveOperations : tIdent ;
VAR gIdentPrivalsChain : tIdent ;
VAR gIdentPrivateDependents : tIdent ;
VAR gIdentGirderConstraint : tIdent ;
VAR gIdentDefiningIdentifier : tIdent ;
VAR gIdentMechanism : tIdent ;


VAR gIdentChars : tIdent ;
VAR gIdentNextEntity : tIdent ;
VAR gIdentScope : tIdent ;
VAR gIdentHomonym : tIdent ;
VAR gIdentEtype : tIdent ;
VAR gIdentEinfo : tIdent ;
VAR gIdentSinfo : tIdent ;
VAR gIdentGnatUtils : tIdent ;
VAR gIdentGnatAdaUtils : tIdent ;
VAR gIdentAtree : tIdent ;
VAR gIdentNlists : tIdent ;
VAR gIdentNClassNonEmpty : tIdent ;
VAR gIdentNClassEntity : tIdent ;
VAR gFieldInterface : tIdent ;
VAR gString : Strings . tString ; 

(* Convert an M3-style identifier (mixed case) back to Gnat-style (underscores) *)
PROCEDURE WG ( Ident : tIdent ) 
; VAR I : CARDINAL 
; VAR LString : Strings . tString 
; VAR LPrevChar , LChar , LNextChar : CHAR 
; VAR LLength : CARDINAL 
; BEGIN 
    Idents . GetString ( Ident , LString ) 
  ; LLength := Strings . Length ( LString )  
  ; IF LLength > 0 
    THEN 
    ; I := 1 
    ; LPrevChar := ' ' 
    ; LChar := Strings . Char ( LString , 1 ) 
    ; LOOP 
        IF I < LLength 
        THEN 
          INC ( I )
        ; LNextChar := Strings . Char ( LString , I ) 
        ELSIF I = LLength  
        THEN 
          INC ( I )
        ; LNextChar := ' ' 
        ELSE EXIT 
        END (* IF *) 
      ; IF  ( ( ( 'a' <= LPrevChar ) AND ( LPrevChar <= 'z' ) ) 
              AND ( ( ( '0' <= LChar ) AND ( LChar <= '9' ) ) 
                    OR ( ( 'A' <= LChar ) AND ( LChar <= 'Z' ) ) 
                  ) 
            ) OR ( ( ( 'A' <= LPrevChar ) AND ( LPrevChar <= 'Z' ) ) 
                   AND ( ( 'A' <= LChar ) AND ( LChar <= 'Z' ) ) 
                   AND ( ( 'a' <= LNextChar ) AND ( LNextChar <= 'z' ) ) 
                 ) 
        THEN IO . WriteC ( f , '_' ) 
        END (* IF *) 
      ; IO . WriteC ( f , LChar ) 
      ; LPrevChar := LChar 
      ; LChar := LNextChar 
      END (* LOOP *) 
    END (* IF *) 
  END WG; 

PROCEDURE IsDescendedFrom ( Descendent : tTree ; Ancestor : tTree ) : BOOLEAN 
; VAR LClass : tTree 
; BEGIN
    IF Ancestor = NoTree THEN RETURN FALSE 
    ELSIF Tree . IsType ( Ancestor , Tree . NoClass ) THEN RETURN FALSE 
    ELSIF NOT Tree . IsType ( Ancestor , Tree . Class ) 
    THEN 
      Errors . MessageI
        ( 'IsDescendedFrom, Ancestor not Class' 
        , Errors . Fatal 
        , Positions . NoPosition 
        , Errors . Integer 
        , SYSTEM . ADR ( Ancestor ^ . Kind )  
        ) 
    ELSE 
      LClass := Descendent 
    ; LOOP 
        IF LClass = Ancestor THEN RETURN TRUE 
        ELSIF LClass  = NoTree THEN RETURN FALSE 
        ELSIF Tree . IsType ( LClass , Tree . NoClass ) THEN RETURN FALSE 
        ELSIF NOT Tree . IsType ( LClass , Tree . Class ) 
        THEN 
          Errors . MessageI
            ( 'IsDescendedFrom, LClass not Class' 
            , Errors . Fatal 
            , Positions . NoPosition 
            , Errors . Integer 
            , SYSTEM . ADR ( LClass ^ . Kind )
            ) 
        ELSE 
          LClass := LClass ^ . Class . BaseClass 
        END (* IF *) 
      END (* LOOP *) 
    END (* IF *) 
  END IsDescendedFrom ; 

PROCEDURE PackageName ( FieldName : tIdent ) : tIdent 
; BEGIN 
    IF FieldName = gIdentNext 
    THEN RETURN gIdentNlists
    ELSIF FieldName = gIdentPrev 
    THEN RETURN gIdentNlists
    ELSIF FieldName = gIdentLink 
    THEN RETURN gIdentGnatAdaUtils
    ELSIF FieldName = gIdentNextEntity
    THEN RETURN gIdentSinfo
    ELSIF FieldName = gIdentScope
    THEN RETURN gIdentSinfo
    ELSIF FieldName = gIdentHomonym
    THEN RETURN gIdentSinfo
    ELSIF FieldName = gIdentEtype
    THEN RETURN gIdentSinfo
    ELSIF FieldName = gIdentDiscriminantConstraint
    THEN RETURN gIdentGnatAdaUtils
    ELSIF FieldName = gIdentPrimitiveOperations
    THEN RETURN gIdentGnatAdaUtils
    ELSIF FieldName = gIdentPrivalsChain
    THEN RETURN gIdentGnatAdaUtils
    ELSIF FieldName = gIdentPrivateDependents
    THEN RETURN gIdentGnatAdaUtils
    ELSIF FieldName = gIdentGirderConstraint
    THEN RETURN gIdentGnatAdaUtils
    ELSIF FieldName = gIdentDefiningIdentifier
    THEN RETURN gIdentGnatAdaUtils
    ELSIF FieldName = gIdentMechanism
    THEN RETURN gIdentGnatAdaUtils
    ELSIF FieldName = gIdentIsListMember  
    THEN RETURN gIdentNlists
    ELSIF FieldName = gIdentSloc
    THEN RETURN gIdentAtree
    ELSIF FieldName = gIdentIsRewriteSubstitution
    THEN RETURN gIdentAtree
    ELSIF FieldName = gIdentIsRewriteInsertion
    THEN RETURN gIdentAtree
    ELSIF FieldName = gIdentComesFromSource
    THEN RETURN gIdentAtree
    ELSIF FieldName = gIdentAnalyzed
    THEN RETURN gIdentAtree
    ELSIF FieldName = gIdentErrorPosted
    THEN RETURN gIdentAtree
    ELSIF FieldName = gIdentParenCount
    THEN RETURN gIdentAtree
    ELSIF FieldName = gIdentHasDynamicLengthCheck
    THEN RETURN gIdentSinfo
    ELSIF FieldName = gIdentHasDynamicRangeCheck
    THEN RETURN gIdentSinfo
    ELSIF FieldName = gIdentChars
    THEN RETURN gIdentSinfo
    ELSE RETURN gFieldInterface 
    END (* IF *) 
  END PackageName ;

CONST UseQualifiers = FALSE ; 

PROCEDURE WriteQualifier ( Name : tIdent ) 
; BEGIN  
    IF IsElement ( ORD ( '%' ) , Options )  
    THEN 
      WI ( PackageName ( Name ) ) ; 
      WriteS ( f , " . " )  
    END (* IF *) 
  END WriteQualifier ; 

} (* End of GLOBAL *) 

(*
BEGIN 
  {  }
*)

PROCEDURE GnatModule (t: Tree)

Ag (..) :- {
      IF IsElement (ORD ('~'), Options) THEN

        debug1 := IsElement ( ORD ( 'Z' ) , Options ) ; 

        Strings . ArrayToString ( 'NodeNumber' , gString ) ; 
        gIdentNodeNumber := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Next' , gString ) ; 
        gIdentNext := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Prev' , gString ) ; 
        gIdentPrev := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'IsListMember' , gString ) ; 
        gIdentIsListMember := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Link' , gString ) ; 
        gIdentLink := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Sloc' , gString ) ; 
        gIdentSloc := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'IsRewriteSubstitution' , gString ) ; 
        gIdentIsRewriteSubstitution := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'IsRewriteInsertion' , gString ) ; 
        gIdentIsRewriteInsertion := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'ComesFromSource' , gString ) ; 
        gIdentComesFromSource := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Analyzed' , gString ) ; 
        gIdentAnalyzed := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'ErrorPosted' , gString ) ; 
        gIdentErrorPosted := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'ParenCount' , gString ) ; 
        gIdentParenCount := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'HasDynamicLengthCheck' , gString ) ; 
        gIdentHasDynamicLengthCheck := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'DiscriminantConstraint' , gString ) ; 
        gIdentDiscriminantConstraint := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'PrimitiveOperations' , gString ) ; 
        gIdentPrimitiveOperations := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'PrivalsChain' , gString ) ; 
        gIdentPrivalsChain := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'PrivateDependents' , gString ) ; 
        gIdentPrivateDependents := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'GirderConstraint' , gString ) ; 
        gIdentGirderConstraint := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'DefiningIdentifier' , gString ) ; 
        gIdentDefiningIdentifier := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Mechanism' , gString ) ; 
        gIdentMechanism := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'HasDynamicRangeCheck' , gString ) ; 
        gIdentHasDynamicRangeCheck := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Chars' , gString ) ; 
        gIdentChars := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'NextEntity' , gString ) ; 
        gIdentNextEntity := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Scope' , gString ) ; 
        gIdentScope := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Homonym' , gString ) ; 
        gIdentHomonym := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Etype' , gString ) ; 
        gIdentEtype := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Einfo' , gString ) ; 
        gIdentEinfo := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Sinfo' , gString ) ; 
        gIdentSinfo := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'GnatUtils' , gString ) ; 
        gIdentGnatUtils := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'GnatAdaUtils' , gString ) ; 
        gIdentGnatAdaUtils := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Atree' , gString ) ; 
        gIdentAtree := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Nlists' , gString ) ; 
        gIdentNlists := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'NClassNonEmpty' , gString ) ; 
        gIdentNClassNonEmpty := Idents . MakeIdent ( gString ) ;
        gNClassNonEmptyClass := IdentifyClass ( NoTree , gIdentNClassNonEmpty ) ; 
        Strings . ArrayToString ( 'NClassEntity' , gString ) ; 
        gIdentNClassEntity := Idents . MakeIdent ( gString ) ;
        gEntityClass := IdentifyClass ( NoTree , gIdentNClassEntity ) ; 


	!TYPE yyPtrtTree	= UNTRACED REF ! WI (itTree); !;!
	!!
	!TYPE yytMapArray = ARRAY OF ! WI (itTree); ! ;!
	!TYPE yytMapRef = REF yytMapArray ;!
	!!
        !VAR yyNodeMapRef : yytMapRef ;!
        !VAR yyListMapRef : yytMapRef ;!
        !VAR yyElistMapRef : yytMapRef ;!
        !VAR yyElmtMapRef : yytMapRef ;!
        !VAR yyNextNodeNumber : INTEGER := 1 ;!
        !!
	!PROCEDURE yyConvert! WI (iMain); !!
        !   ( FId : GnatTypes . Union_Id !
        !   ; FNew : yyPtrtTree !
        !   ; FCallerId : GnatTypes . Union_Id !
        !   ; FCallerField : TEXT !
        !   )!
        !=VAR LKind : ! WI ( iMain ) ; ! . SHORTCARD !
        !;VAR LId := FId!
        !;VAR LNew := FNew!
        !;VAR LCallerId := FCallerId!
        !;VAR LCallerField := FCallerField!
        !;BEGIN!
	!  LOOP!
        !    IF GnatTypes . List_Low_Bound <= LId !
        !       AND LId < GnatTypes . List_Low_Bound + NUMBER ( yyListMapRef ^ )!
        !    THEN (* This is a list node. *) !
	!      IF LId = GnatTypes . No_List!
        !      THEN!
        !        VAR LNewList := NEW ( ! WI ( iMain ) ; ! . NoList )!
        !                   (* Multiple copies of NoList nodes *)!
        !      ; BEGIN!
        !          LNew ^ := LNewList!
        !        ; LNew ^ . Kind := Tree . NkNoList!
        !        ; LNewList . NodeNumber := yyNextNodeNumber!
        !        ; INC ( yyNextNodeNumber )!
        !        ; RETURN!
        !        END (* BEGIN *)!
        !      END (* IF *) !
        !    ; WITH WNewRef = yyListMapRef ^ [ LId - GnatTypes . List_Low_Bound ] !
        !      DO!
        !        IF WNewRef # ! WI ( iNoTree ) ; !!
        !        THEN LNew ^ := WNewRef ; RETURN END (* IF *) !
        !      ; VAR LNewList : Tree . List := NEW ( ! WI ( iMain ) ; ! . List ) !
        !        ; BEGIN!
        !            WNewRef := LNewList!
        !          ; LNew ^ := LNewList!
        !          ; LNew ^ . Kind := Tree . NkList!
        !          ; LNewList . NodeNumber := yyNextNodeNumber!
        !          ; INC ( yyNextNodeNumber )!
        !          ; yyConvert! WI (iMain); !!
        !               ( Nlists . Parent ( LId ) , ADR ( LNewList . Parent )!
        @               , LId , " Parent" ) @
        !          ; yyConvert! WI (iMain); !!
        !               ( Nlists . Last ( LId ) , ADR ( LNewList . Last )!
        @               , LId , "Last" ) @
        !          ; LCallerId := LId!
        @          ; LCallerField := "First"@
        !          ; LId := Nlists . First ( LId ) !
        !          ; LNew := ADR ( LNewList . First )!
        !          END (* BEGIN *) !
        !      END (* WITH WNewRef *) !
        !    ELSIF GnatTypes . Elist_Low_Bound <= LId!
        !          AND LId < GnatTypes . Elist_Low_Bound + NUMBER ( yyElistMapRef ^ )!
        !    THEN (* This is an Elist node. *) !
	!      IF LId = GnatTypes . No_Elist!
        !      THEN!
        !        VAR LNewElist := NEW ( ! WI ( iMain ) ; ! . NoElist ) !
        !                   (* Multiple copies of NoElist nodes *)!
        !      ; BEGIN!
        !          LNew ^ := LNewElist!
        !        ; LNew ^ . Kind := Tree . NkNoElist!
        !        ; LNewElist . NodeNumber := yyNextNodeNumber!
        !        ; INC ( yyNextNodeNumber )!
        !        ; RETURN  !
        !        END (* BEGIN *)!
        !      END (* IF *) !
        !    ; WITH WNewRef = yyElistMapRef ^ [ LId - GnatTypes . Elist_Low_Bound ] !
        !      DO!
        !        IF WNewRef # ! WI ( iNoTree ) ; !!
        !        THEN LNew ^ := WNewRef ; RETURN END (* IF *) !
        !      ; VAR LNewElist : Tree . Elist := NEW ( ! WI ( iMain ) ; ! . Elist ) !
        !        ; BEGIN!
        !            WNewRef := LNewElist!
        !          ; LNew ^ := LNewElist!
        !          ; LNew ^ . Kind := Tree . NkElist!
        !          ; LNewElist . NodeNumber := yyNextNodeNumber!
        !          ; INC ( yyNextNodeNumber )!
        !          ; yyConvert! WI (iMain);!!
        !               ( Elists . Last_Elmt ( LId ) , ADR ( LNewElist . LastElmt )!
        @               , LId , "Last_Elmt" ) @
        !          ; LCallerId := LId!
        @          ; LCallerField := "First_Elmt"@
        !          ; LId := Elists . First_Elmt ( LId ) !
        !          ; LNew := ADR ( LNewElist . FirstElmt )!
        !          END (* BEGIN *) !
        !      END (* WITH WNewRef *) !
        !    ELSIF GnatTypes . Elmt_Low_Bound <= LId!
        !          AND LId < GnatTypes . Elmt_Low_Bound + NUMBER ( yyElmtMapRef ^ )!
        !    THEN (* This is an Elmt node. *) !
	!      IF LId = GnatTypes . No_Elmt!
        !      THEN!
        !        VAR LNewElmt := NEW ( ! WI ( iMain ) ; ! . NoElmt ) !
        !                   (* Multiple copies of NoElmt nodes *)!
        !      ; BEGIN!
        !          LNew ^ := LNewElmt !
        !        ; LNew ^ . Kind := Tree . NkNoElmt!
        !        ; LNewElmt . NodeNumber := yyNextNodeNumber!
        !        ; INC ( yyNextNodeNumber )!
        !        ; RETURN !
        !        END (* BEGIN *)!
        !      END (* IF *) !
        !    ; WITH WNewRef = yyElmtMapRef ^ [ LId - GnatTypes . Elmt_Low_Bound ] !
        !      DO!
        !        IF WNewRef # ! WI ( iNoTree ) ; !!
        !        THEN LNew ^ := WNewRef!
        !        ; RETURN!
        !        END (* IF *) !
        !      ; VAR LNewElmt : Tree . Elmt := NEW ( ! WI ( iMain ) ; ! . Elmt ) !
        !        ; BEGIN!
        !            WNewRef := LNewElmt!
        !          ; LNew ^ := LNewElmt!
        !          ; LNew ^ . Kind := Tree . NkElmt!
        !          ; LNewElmt . NodeNumber := yyNextNodeNumber!
        !          ; INC ( yyNextNodeNumber )!
        !          ; yyConvert! WI (iMain); !!
        !               ( Elists . Node ( LId ) , ADR ( LNewElmt . Node )!
        @               , LId , "Node" ) @
        !          ; LCallerId := LId!
        @          ; LCallerField := "Next_Elmt"@
        !          ; LId := Elists . Next_Elmt ( LId ) !
        !          ; LNew := ADR ( LNewElmt . NextElmt )!
        !          END (* BEGIN *) !
        !      END (* WITH WNewRef *) !
        !    ELSIF GnatTypes . Node_Low_Bound <= LId!
        !          AND LId < GnatTypes . Node_Low_Bound + NUMBER ( yyNodeMapRef ^ )!
        !    THEN (* This is an ordinary node. *) !
	!      IF LId = GnatTypes . Empty!
        !      THEN!
        !        VAR LNewNode := NEW ( ! WI ( iMain ) ; ! . NNoNode ) !
        !                   (* Multiple copies of Empty nodes *)!
        !      ; BEGIN !
        !          LNew ^ := LNewNode !
        !        ; LNew ^ . Kind := Tree . NkNNoNode!
        !        ; LNewNode . NodeNumber := yyNextNodeNumber!
        !        ; INC ( yyNextNodeNumber )!
        !        ; RETURN !
        !        END (* BEGIN *) !
        !      END (* IF *) !
        !    ; WITH WNewRef = yyNodeMapRef [ LId - GnatTypes . Node_Low_Bound ] !
        !      DO!
        !        IF WNewRef # ! WI ( iNoTree ) ; !!
        !        THEN LNew ^ := WNewRef!
        !        ; RETURN!
        !        END (* IF *) !
        !      ; LKind := GnatUtils . Kind ( LId )!
        !      ; CASE LKind OF!
	ForallClasses ( Classes , Convert);
        !        END (* CASE *)!
        !      END (* WITH WNewRef *) !
        !    ELSE (* Bad UnionId *)  !
        @      Wr . PutText ( Stdio . stdout , "Bad union id, " )@
        !    ; Wr . PutText ( Stdio . stdout , Fmt . Int ( LCallerId ) )!
        !    ; Wr . PutChar ( Stdio . stdout , ':' )!
        !    ; Wr . PutText ( Stdio . stdout , LCallerField )!
        !    ; Wr . PutChar ( Stdio . stdout , '=' )!
        !    ; Wr . PutText ( Stdio . stdout , Fmt . Int ( LId ) )!
        !    ; Wr . PutText ( Stdio . stdout , Wr . EOL )!
        !    ; Wr . Flush ( Stdio . stdout )!
        !    ; LNew ^ := NIL!
        !    ; RETURN!
        !    END (* IF *) !
        !  END (* LOOP *) !
	! END yyConvert! WI (iMain); !;!
	!!
        IF debug1 
        THEN 
        !PROCEDURE yyWriteHex ( VAR yyx : ARRAY OF CHAR ) !
        !=BEGIN!
        !  FOR yyi := 0 TO NUMBER ( yyx ) - 1 DO!
        !   Wr . PutText ( Stdio . stdout , Fmt . Pad ( Fmt . Int ( ORD ( yyx [ yyi ] ) , 16 ) , 2 , '0' ) ) ;!
        !   Wr . PutChar ( Stdio . stdout , ' ' ) ;!
        !  END ;!
        ! END yyWriteHex ;!
	!!
        END (* IF debug1 *) ; 
        !PROCEDURE GnatConvert! WI (iMain); ! ( GnatTree : GnatTypes . Node_Id ) !
        ! : ! WI (itTree); !!
	!=VAR LNew	: ! WI (itTree); !;!
	! BEGIN!
	!  !
        !  yyNodeMapRef := NEW ( yytMapRef , Atree . Last_Node_Id ( )  - GnatTypes . Node_Low_Bound + 1 ) ;!
        IF debug1 
        THEN 
        @  Wr . PutText ( Stdio . stdout , "Last_Node_Id = " ) ; @
        !  Wr . PutText ( Stdio . stdout , Fmt . Int ( Atree . Last_Node_Id ( ) ) ) ; !
        !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; !
        @  Wr . PutText ( Stdio . stdout , "yyNodeMapRef = " ) ; @
        !  yyWriteHex ( LOOPHOLE ( yyNodeMapRef , ARRAY [ 0..BYTESIZE ( yytMapRef ) - 1 ] OF CHAR ) ) ; !
        !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; !
        @  Wr . PutText ( Stdio . stdout , "NUMBER = " ) ; @
        !  Wr . PutText ( Stdio . stdout , Fmt . Int ( NUMBER ( yyNodeMapRef ^ ) ) ) ; !
        !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; !
        !  Wr . Flush ( Stdio . stdout ) ; !
        END (* IF debug1 *) ; 
        !  yyListMapRef := NEW ( yytMapRef , Nlists . Last_List_Id ( ) - GnatTypes . List_Low_Bound + 1 ) ;!
        IF debug1 
        THEN 
        @  Wr . PutText ( Stdio . stdout , "Last_List_Id = " ) ; @
        !  Wr . PutText ( Stdio . stdout , Fmt . Int ( Nlists . Last_List_Id ( ) ) ) ; !
        !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; !
        @  Wr . PutText ( Stdio . stdout , "yyListMapRef = " ) ; @
        !  yyWriteHex ( LOOPHOLE ( yyListMapRef , ARRAY [ 0..BYTESIZE ( yytMapRef ) - 1 ] OF CHAR ) ) ; !
        !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; !
        @  Wr . PutText ( Stdio . stdout , "NUMBER = " ) ; @
        !  Wr . PutText ( Stdio . stdout , Fmt . Int ( NUMBER ( yyListMapRef ^ ) ) ) ; !
        !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; !
        !  Wr . Flush ( Stdio . stdout ) ; !
        END (* IF debug1 *) ; 
        !  yyElistMapRef := NEW ( yytMapRef , Elists . Last_Elist_Id ( ) - GnatTypes . Elist_Low_Bound + 1 ) ;!
        IF debug1 
        THEN 
        @  Wr . PutText ( Stdio . stdout , "Last_Elist_Id = " ) ; @
        !  Wr . PutText ( Stdio . stdout , Fmt . Int ( Elists . Last_Elist_Id ( ) ) ) ; !
        !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; !
        @  Wr . PutText ( Stdio . stdout , "yyElistMapRef = " ) ; @
        !  yyWriteHex ( LOOPHOLE ( yyElistMapRef , ARRAY [ 0..BYTESIZE ( yytMapRef ) - 1 ] OF CHAR ) ) ; !
        !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; !
        @  Wr . PutText ( Stdio . stdout , "NUMBER = " ) ; @
        !  Wr . PutText ( Stdio . stdout , Fmt . Int ( NUMBER ( yyElistMapRef ^ ) ) ) ; !
        !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; !
        !  Wr . Flush ( Stdio . stdout ) ; !
        END (* IF debug1 *) ; 
        !  yyElmtMapRef := NEW ( yytMapRef , Elists . Last_Elmt_Id ( ) - GnatTypes . Elmt_Low_Bound + 1 ) ;!
        IF debug1 
        THEN 
        @  Wr . PutText ( Stdio . stdout , "Last_Elmt_Id = " ) ; @
        !  Wr . PutText ( Stdio . stdout , Fmt . Int ( Elists . Last_Elmt_Id ( ) ) ) ; !
        !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; !
        @  Wr . PutText ( Stdio . stdout , "yyElmtMapRef = " ) ; @
        !  yyWriteHex ( LOOPHOLE ( yyElmtMapRef , ARRAY [ 0..BYTESIZE ( yytMapRef ) - 1 ] OF CHAR ) ) ; !
        !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; !
        @  Wr . PutText ( Stdio . stdout , "NUMBER = " ) ; @
        !  Wr . PutText ( Stdio . stdout , Fmt . Int ( NUMBER ( yyElmtMapRef ^ ) ) ) ; !
        !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; !
        !  Wr . Flush ( Stdio . stdout ) ; !
        END (* IF debug1 *) ; 
        !!
	!  yyConvert! WI (iMain); !!
        @    ( GnatTree , ADR ( LNew ) , 0 , "<ROOT>" ) ;@
        !!
        !  yyNodeMapRef := NIL ; !
        !  yyListMapRef := NIL ; !
        !  yyElistMapRef := NIL ; !
        !  yyElmtMapRef := NIL ; !
        !!
	!  RETURN LNew;!
	! END GnatConvert! WI (iMain); !;!
	!!
      END (* IF *) 
}; .


PROCEDURE Convert (t: Tree)

Class (..) :- {
	IF ( ( NoCodeClass * Properties ) = { } ) 
           AND ( Extensions ^ . Kind = Tree . NoClass ) (* Low IN Properties ) is not set *) 
           AND IsDescendedFrom ( t , gNClassNonEmptyClass ) 
        THEN
	   !        | ! WI ( iMain ) ; ! . Nk! WI (Name); !!
           !        => VAR LNewNode := NEW ( ! WI ( iMain ) ; ! . ! WI ( Name ) ; ! )!
           !           ; BEGIN!
           !               WNewRef := LNewNode!
           !             ; LNew ^ := WNewRef!
           !             ; LNew ^ . Kind := LKind!
           !             ; LNewNode . NodeNumber := yyNextNodeNumber!
           !             ; INC ( yyNextNodeNumber )!
	   ConvertAttrs (t);
           !             (* Field Next of Node is the builtin tail-recursion eliminated iterator *) !
           !             ; LCallerId := LId!
           @             ; LCallerField := "Next"@
           !             ; LId := Nlists . Next ( LId ) !
           !             ; LNew := ADR ( LNewNode . Next )!
           !             END (* BEGIN *) !
	END;
}; .

PROCEDURE ConvertAttrs (t: Tree)

Class (..) :- {
	IF ( ( NoCodeClass * Properties ) = { } ) 
        THEN
           ConvertAttrs ( t^.Class.BaseClass); 
           IF IsDescendedFrom ( t , gEntityClass ) 
           THEN gFieldInterface := gIdentEinfo 
           ELSE gFieldInterface := gIdentSinfo 
           END (* IF *);   
	   ConvertAttrs (t^.Class.Attributes);
	END;
}; .

Child (..) :- {
        IF Name = gIdentNext
        THEN 
           !             (* Next is handled last, as tail recursion elimination *) !
        ELSE 
           !             ; yyConvert! WI (iMain); !!
           !                 ( ! WriteQualifier ( Name ) ; WG ( Name ) ; 
                                 ! ( LId ) , ADR ( LNewNode . ! WI ( Name ) ; ! )!
           @                 , LId , "@ WG ( Name ) ; @" ) @
        END (* IF *) ; 
        ConvertAttrs ( t^.Child.Next); 
}; .
Attribute (..) :- {
	IF ( NoCodeAttr * Properties ) = {} 
        THEN 
          IF Name = gIdentNodeNumber
          THEN (* Handled specially *)  
          ELSIF Link IN Properties 
          THEN 
           !             ; yyConvert! WI (iMain); !!
           !                 ( ! WriteQualifier ( Name ) ; WG ( Name ) ; 
                                 ! ( LId ) , ADR ( LNewNode . ! WI ( Name ) ; ! )!
           @                 , LId , "@ WG ( Name ) ; @" ) @
          ELSE 
(*         !             ; LNewNode . ! WI ( Name ) ; 
                           ! := ! WriteQualifier ( Name ) ; WG ( Name ) ; ! ( LId )!
*)
	   !             ; copy! WI (Type); ! ( LNewNode . ! WI ( Name ) ; 
                           ! , ! WriteQualifier ( Name ) ; WG ( Name ) ; ! ( LId ) )!
          END (* IF *) 
	END;
        ConvertAttrs ( t^.Attribute.Next); 
}; .


 (* End of file MThree6.puma *) 


