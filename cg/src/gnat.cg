
(* File Gnat.cg *) 
(* Cocktail cg tree definition abstractly equivalent to the Gnat tree. *)
(* Rodney M. Bates Dec 97 *) 

(* TREE Tree *) 

  IMPORT 
    { FROM M3GnatTypes 
      IMPORT CharCode , ComponentAlignmentKind , MechanismType 
      , NameId , StringId , Uint , Ureal , ParenCountType , SourcePtr ; 
    } (* End of TREE IMPORT *) 

  GLOBAL 
    { 
# include "GnatTree.w"
    } (* End of TREE GLOBAL *) 

  BEGIN 
    { 
    } (* End of TREE BEGIN *) 

PROPERTY INPUT 

RULE

  ClassElistOrElmt  
  = < ClassElmt 
      = < NoElmt = . (* Null element Only used for an empty list, where both First and Last *) 
                     (* of the Elist header point to one of these. *) 

          Elmt (* Elements of Elists.  These never get mixed with anything else. *) 
          = Node : NClassNode (* The node on the list. *) 
            NextElmt : ClassElist 
          . 
        > 
      . (* End of ClassElmt *) 

      ClassElist 
      = < NoElist = . (* Null Elist, used for an absent Elist *) 

          Elist (* Header of Elist.  These use separate link objects (type Elmt), so *) 
                (* A node can be on many Elists. *) 
          = FirstElmt : Elmt 
            LastElmt : Elmt 
          . 
        >
      . (* End of ClassElist *) 
    > 
  . (* End of ClassElistOrElmt *) 

(*%%%%%*) 
  (* Field Link of a node can point to either a List or a Node. *) 
  ClassListOrNode (* Field Link can point to either. *) 
  = < (* List/Node distinction *) 

      ClassList (* header of node list, which is linked through the Prev and Next Fields of nodes. *) 
           (* A Node can be on at most, one node list. *) 
      = < NoList = . 

          List
          = First : NClassNode (* First node in list *) 
            Last : NClassNode  (* Last node in list *) 
            Parent : NClassNode (* Parent node of this list *) 
          . 
        > 
      . 

      NClassNode 
      = < NNoNode = (* Cocktail dummy node.  Different from NEmpty *) . 

          NClassNonEmpty 
          = (* Common fields of all nodes: *) 

            Link : ClassListOrNode
            (* RMB: There is no direct Gnat access function for this field.
               The following conditional expression will get it: 
               IF Nlists . Is_List_Member ( N ) 
               THEN Nlists . List_Containing ( N ) 
               ELSE Atree . Parent ( N ) 
            *) 
              (* This field is used either as the Parent pointer (if In_List *)
              (* is False), or to point to the list header (if In_List is *)
              (* True). This field is considered private and can be modified *)
              (* only by Atree or by Nlists. *)

            Prev : NClassNode 
            Next : NClassNode (* two way links of nodes that are on a node list. *) 
            (* Gnat access functions: Nlists . Prev, Nlists . Next *)

            [ Sloc : SourcePtr ] 
            (* Gnat access function: Atree . Sloc *) 
              (* Location (SourcePtr) of the corresponding token *)
              (* in the Source buffer. The individual node definitions *)
              (* show which token is referenced by this pointer. *)

            [ IsListMember : BOOLEAN ]
            (* Gnat access function: Nlists . Is_List_Member. *) 
              (* A flag used to indicate if the node is a member *)
              (* of a node list. *)

            [ IsRewriteSubstitution : BOOLEAN ]      
            (* Gnat access function: Atree . Is_Rewrite_Substitution *)     
            (* This field is named in Gnat comments, but it has been removed from
               the actual node.  Its space has apparently been renamed Unused_1.
               Access function Atree . Is_Rewrite_Substitution computes it using 
               a map of Node_Id to original Node_Id. It is reinserted explicitly
               by the Cocktail conversion. *) 
              (* A flag set if the node has been rewritten using *)
              (* the Rewrite procedure. The original value of the *)
              (* node is retrievable with Original_Node. *)

            [ IsRewriteInsertion : BOOLEAN ] 
            (* Gnat access function: Atree . Is_Rewrite_Insertion *)     
              (* A flag set if a node is marked as a rewrite inserted *)
              (* node as a result of a call to Mark_Rewrite_Insertion. *)

            [ ComesFromSource : BOOLEAN ]
            (* Gnat Access function: Atree . Comes_From_Source *) 
              (* This flag is present in all nodes. It is set if the *)
              (* node is built by the scanner or parser, and clear if *)
              (* the node is built by the analyzer or expander. It *)
              (* indicates that the node corresponds to a construct *)
              (* that appears in the original source program. *)

            [ Analyzed : BOOLEAN ]        
            (* Gnat Access function: Atree . Analyzed *) 
              (* This flag is present in all nodes. It is set when *)
              (* a node is analyzed, and is used to avoid analyzing *)
              (* the same node twice. Analysis includes expansion if *)
              (* expansion is active, so in this case if the flag is *)
              (* set it means the node has been analyzed and expanded. *)

            [ ErrorPosted : BOOLEAN ] 
            (* Gnat Access function: Atree . Error_Posted *) 
              (* This flag is present in all nodes. It is set when *)
              (* an error message is posted which is associated with *)
              (* the flagged node. This is used to avoid posting more *)
              (* than one message on the same node. *)

            [ HasDynamicLengthCheck : BOOLEAN ]
            (* Gnat Access function: Sinfo . Has_Dynamic_Length_Check *) 
              (* This flag is present on all nodes. It is set to indicate that one *)
              (* of the routines in unit Checks has generated a length check action *)
              (* which has been inserted at the flagged node. This is used to avoid *)
              (* the generation of duplicate checks. *)

            [ HasDynamicRangeCheck : BOOLEAN ]
            (* Gnat Access function: Sinfo . Has_Dynamic_Range_Check *) 
              (* This flag is present on all nodes. It is set to indicate that one *)
              (* of the routines in unit Checks has generated a range check action *)
              (* which has been inserted at the flagged node. This is used to avoid *)
              (* the generation of duplicate checks. *)

(*%%%%%*) 
            < NClassSNode (* Syntactic Nodes *)
              = < NClassNonExpression 
                  = < (* Different kinds of NClassNonExpression *) 
                      (*-------------- *)
                      (* 2.7  Comment  *)
                      (*-------------- *)

                      (*  A COMMENT starts with two adjacent hyphens and extends up to the *)
                      (*  end of the line. A COMMENT may appear on any line of a program. *)

                      (*  Comments are skipped by the scanner and do not appear in the tree. *)
                      (*  It is possible to reconstruct the position of comments with respect *)
                      (*  to the elements of the tree by using the source position (Sloc) *)
                      (*  pointers that appear in every tree node. *)

                      (*------------- *)
                      (* 2.8  Pragma  *)
                      (*------------- *)

                      (*  PRAGMA ::= pragma IDENTIFIER *)
                      (*    [(PRAGMA_ARGUMENT_ASSOCIATION {, PRAGMA_ARGUMENT_ASSOCIATION})]; *)

                      (*  Note that a pragma may appear in the tree anywhere a declaration *)
                      (*  or a statement may appear, as well as in some other situations *)
                      (*  which are explicitly documented. *)

                      NPragma =
                        (* Sloc points to PRAGMA *)
                        [ Chars : NameId ] (*  identifier name from pragma identifier *)
                        PragmaArgumentAssociations : ClassList (*  (points to a NoList object if none) *)
                        DebugStatement : NClassNode (*  (points to an Empty object if not Debug, Assert) *)
                        NextRepItem : NClassNode 
                      . 

                      (*---------------------------------- *)
                      (* 2.8  Pragma Argument Association  *)
                      (*---------------------------------- *)

                      (*  PRAGMA_ARGUMENT_ASSOCIATION ::= *)
                      (*    [pragma_argument_IDENTIFIER =>] NAME *)
                      (*  | [pragma_argument_IDENTIFIER =>] EXPRESSION *)

                      NPragmaArgumentAssociation =
                        (* Sloc points to first token in association *)
                        [ Chars : NameId ] (*  (set to No_Name if no pragma argument identifier) *)
                        Expression : NClassNode 
                      .

                      (*-------------------- *)
                      (* 2.9  Reserved Word  *)
                      (*-------------------- *)

                      (*  Reserved words are parsed by the scanner, and returned as the *)
                      (*  corresponding token types (e.g. PACKAGE is returned as Tok_Package) *)

                      (*------------------------ *)
                      (* 3.1  Basic Declaration  *)
                      (*------------------------ *)

                      (*  BASIC_DECLARATION ::= *)
                      (*    TYPE_DECLARATION          | SUBTYPE_DECLARATION *)
                      (*  | OBJECT_DECLARATION        | NUMBER_DECLARATION *)
                      (*  | SUBPROGRAM_DECLARATION    | ABSTRACT_SUBPROGRAM_DECLARATION *)
                      (*  | PACKAGE_DECLARATION       | RENAMING_DECLARATION *)
                      (*  | EXCEPTION_DECLARATION     | GENERIC_DECLARATION *)
                      (*  | GENERIC_INSTANTIATION *)

                      (*  Basic declaration also includes IMPLICIT_LABEL_DECLARATION *)
                      (*  see further description in section on semantic nodes. *)

                      (*  Also, in the tree that is constructed, a pragma may appear *)
                      (*  anywhere that a declaration may appear. *)

                      (*------------------------- *)
                      (* 3.2.1  Type Declaration  *)
                      (*------------------------- *)

                      (*  TYPE_DECLARATION ::= *)
                      (*    FULL_TYPE_DECLARATION *)
                      (*  | INCOMPLETE_TYPE_DECLARATION *)
                      (*  | PRIVATE_TYPE_DECLARATION *)
                      (*  | PRIVATE_EXTENSION_DECLARATION *)

                      (*------------------------------ *)
                      (* 3.2.1  Full Type Declaration  *)
                      (*------------------------------ *)

                      (*  FULL_TYPE_DECLARATION ::= *)
                      (*    type DEFINING_IDENTIFIER [KNOWN_DISCRIMINANT_PART] *)
                      (*      is TYPE_DEFINITION; *)
                      (*  | TASK_TYPE_DECLARATION *)
                      (*  | PROTECTED_TYPE_DECLARATION *)

                      (*  The full type declaration node is used only for the first case. The *)
                      (*  second case (concurrent type declaration), is represented directly *)
                      (*  by a task type declaration or a protected type declaration. *)

                      NFullTypeDeclaration =
                        (* Sloc points to TYPE *)
                        DefiningIdentifier : NClassEntity 
                        DiscriminantSpecifications : ClassList (*  (points to a NoList object if none) *)
                        TypeDefinition : NClassNode 
                      .

                      (*------------------------ *)
                      (* 3.2.1  Type Definition  *)
                      (*------------------------ *)

                      (*  TYPE_DEFINITION ::= *)
                      (*    ENUMERATION_TYPE_DEFINITION  | INTEGER_TYPE_DEFINITION *)
                      (*  | REAL_TYPE_DEFINITION         | ARRAY_TYPE_DEFINITION *)
                      (*  | RECORD_TYPE_DEFINITION       | ACCESS_TYPE_DEFINITION *)
                      (*  | DERIVED_TYPE_DEFINITION *)

                      (*---------------------------- *)
                      (* 3.2.2  Subtype Declaration  *)
                      (*---------------------------- *)

                      (*  SUBTYPE_DECLARATION ::= *)
                      (*    subtype DEFINING_IDENTIFIER is SUBTYPE_INDICATION; *)

                      (*  The subtype indication field is points to an Empty object for subtypes *)
                      (*  declared in package Standard (Positive, Natural). *)

                      NSubtypeDeclaration =
                        (* Sloc points to SUBTYPE *)
                        DefiningIdentifier : NClassEntity 
                        SubtypeIndication : NClassNode 
                        GenericParentType : NClassNode (*  (set for an actual derived type). *)
                      .

                      (*--------------------------- *)
                      (* 3.2.2  Subtype Indication  *)
                      (*--------------------------- *)

                      (*  SUBTYPE_INDICATION ::= SUBTYPE_MARK [CONSTRAINT] *)

                      (*  Note: if no constraint is present, the subtype indication appears *)
                      (*  directly in the tree as a subtype mark. The NSubtypeIndication *)
                      (*  node is used only if a constraint is present. *)

                      (*  Note: the reason that this node has expression fields is that a *)
                      (*  subtype indication can appear as an operand of a membership test. *)

                      NSubtypeIndication =
                        (* Sloc points to first token of subtype mark *)
                        SubtypeMark : NClassNode 
                        Constraint : NClassNode 
                        Etype : NClassNode 
                        [ MustNotFreeze : BOOLEAN ] 
                      .

                      (*  Note: Etype is a copy of the Etype field of the SubtypeMark. The *)
                      (*  reason for this redundancy is so that in a list of array index types, *)
                      (*  the Etype can be uniformly accessed to determine the subscript type. *)
                      (*  This means that no Itype is constructed for the actual subtype that *)
                      (*  is created by the subtype indication. If such an Itype is required, *)
                      (*  it is constructed in the context in which the indication appears. *)

                      (*--------------------- *)
                      (* 3.2.2  Subtype Mark  *)
                      (*--------------------- *)

                      (*  SUBTYPE_MARK ::= subtype_NAME *)

                      (*------------------- *)
                      (* 3.2.2  Constraint  *)
                      (*------------------- *)

                      (*  CONSTRAINT ::= SCALAR_CONSTRAINT | COMPOSITE_CONSTRAINT *)

                      (*-------------------------- *)
                      (* 3.2.2  Scalar Constraint  *)
                      (*-------------------------- *)

                      (*  SCALAR_CONSTRAINT ::= *)
                      (*    RANGE_CONSTRAINT | DIGITS_CONSTRAINT | DELTA_CONSTRAINT *)

                      (*----------------------------- *)
                      (* 3.2.2  Composite Constraint  *)
                      (*----------------------------- *)

                      (*  COMPOSITE_CONSTRAINT ::= *)
                      (*    INDEX_CONSTRAINT | DISCRIMINANT_CONSTRAINT *)

                      (*--------------------------- *)
                      (* 3.3.1  Object Declaration  *)
                      (*--------------------------- *)

                      (*  OBJECT_DECLARATION ::= *)
                      (*    DEFINING_IDENTIFIER_LIST : [aliased] [constant] *)
                      (*      SUBTYPE_INDICATION [:= EXPRESSION]; *)
                      (*  | DEFINING_IDENTIFIER_LIST : [aliased] [constant] *)
                      (*      ARRAY_TYPE_DEFINITION [:= EXPRESSION]; *)
                      (*  | SINGLE_TASK_DECLARATION *)
                      (*  | SINGLE_PROTECTED_DECLARATION *)

                      (*  Note: aliased is not permitted in Ada 83 mode *)

                      (*  The NObjectDeclaration node is only for the first two cases. *)
                      (*  Single task declaration is handled by P_Task (9.1) *)
                      (*  Single protected declaration is handled by P_protected (9.5) *)

                      (*  Although the syntax allows multiple identifiers in the list, the *)
                      (*  semantics is as though successive declarations were given with *)
                      (*  identical type definition and expression components. To simplify *)
                      (*  semantic processing, the parser represents a multiple declaration *)
                      (*  case as a sequence of single declarations, using the MoreIds and *)
                      (*  PrevIds flags to preserve the original source form as described *)
                      (*  in the section on "Handling of Defining Identifier Lists". *)

                      (*  Note: if a range check is required for the initialization *)
                      (*  expression then the DoRangeCheck flag is set in the Expression, *)
                      (*  with the check being done against the type given by the object *)
                      (*  definition, which is also the Etype of the defining identifier. *)

                      NObjectDeclaration =
                        (* Sloc points to first identifier *)
                        DefiningIdentifier : NClassEntity 
                        [ AliasedPresent : BOOLEAN ] (*  set if ALIASED appears *)
                        [ ConstantPresent : BOOLEAN ] (*  set if CONSTANT appears *)
                        ObjectDefinition : NClassNode (*  subtype indication/array type definition *)
                        Expression : NClassNode (*  (points to an Empty object if not present) *)
                        [ MoreIds : BOOLEAN ] (*  (set to False if no more identifiers in list) *)
                        [ PrevIds : BOOLEAN ] (*  (set to False if no previous identifiers in list) *)
                        [ NoDefaultInit : BOOLEAN ] 
                        [ AssignmentOK : BOOLEAN ] 
                      .

                      (*--------------------------------- *)
                      (* 3.3.1  Defining Identifier List  *)
                      (*--------------------------------- *)

                      (*  DEFINING_IDENTIFIER_LIST ::= *)
                      (*    DEFINING_IDENTIFIER {, DEFINING_IDENTIFIER} *)

                      (*--------------------------- *)
                      (* 3.3.2  Number Declaration  *)
                      (*--------------------------- *)

                      (*  NUMBER_DECLARATION ::= *)
                      (*    DEFINING_IDENTIFIER_LIST : constant := static_EXPRESSION; *)

                      (*  Although the syntax allows multiple identifiers in the list, the *)
                      (*  semantics is as though successive declarations were given with *)
                      (*  identical expressions. To simplify semantic processing, the parser *)
                      (*  represents a multiple declaration case as a sequence of single *)
                      (*  declarations, using the MoreIds and PrevIds flags to preserve *)
                      (*  the original source form as described in the section on "Handling *)
                      (*  of Defining Identifier Lists". *)

                      NNumberDeclaration =
                        (* Sloc points to first identifier *)
                        DefiningIdentifier : NClassEntity 
                        Expression : NClassNode 
                        [ MoreIds : BOOLEAN ] (*  (set to False if no more identifiers in list) *)
                        [ PrevIds : BOOLEAN ] (*  (set to False if no previous identifiers in list) *)
                      .
                      (*------------------------------ *)
                      (* 3.4  Derived Type Definition  *)
                      (*------------------------------ *)

                      (*  DERIVED_TYPE_DEFINITION ::= *)
                      (*    [abstract] new parent_SUBTYPE_INDICATION [RECORD_EXTENSION_PART] *)

                      (*  Note: ABSTRACT, record extension part not permitted in Ada 83 mode *)

                      (*  Note: a record extension part is required if ABSTRACT is present *)

                      NDerivedTypeDefinition =
                        (* Sloc points to NEW *)
                        [ AbstractPresent : BOOLEAN ] 
                        SubtypeIndication : NClassNode 
                        RecordExtensionPart : NClassNode (*  (points to an Empty object if not present) *)
                      .

                      (*----------------------- *)
                      (* 3.5  Range Constraint  *)
                      (*----------------------- *)

                      (*  RANGE_CONSTRAINT ::= range RANGE *)

                      NRangeConstraint =
                        (* Sloc points to RANGE *)
                        RangeExpression : NClassNode 
                      .

                      (*------------------------------------ *)
                      (* 3.5.1  Enumeration Type Definition  *)
                      (*------------------------------------ *)

                      (*  ENUMERATION_TYPE_DEFINITION ::= *)
                      (*    (ENUMERATION_LITERAL_SPECIFICATION *)
                      (*      {, ENUMERATION_LITERAL_SPECIFICATION}) *)

                      (*  Note: the Literals field in the node described below is null for *)
                      (*  the case of the standard types CHARACTER and WIDE_CHARACTER, for *)
                      (*  which special processing handles these types as special cases. *)

                      NEnumerationTypeDefinition =
                        (* Sloc points to left parenthesis *)
                        Literals : ClassList (*  (points to an Empty object for CHARACTER or WIDE_CHARACTER) *)
                      .

                      (*------------------------------------------ *)
                      (* 3.5.1  Enumeration Literal Specification  *)
                      (*------------------------------------------ *)

                      (*  ENUMERATION_LITERAL_SPECIFICATION ::= *)
                      (*    DEFINING_IDENTIFIER | DEFINING_CHARACTER_LITERAL *)

                      (*-------------------------------- *)
                      (* 3.5.4  Integer Type Definition  *)
                      (*-------------------------------- *)

                      (*  Note: there is an error in this rule in the latest version of the *)
                      (*  grammar, so we have retained the old rule pending clarification. *)

                      (*  INTEGER_TYPE_DEFINITION ::= *)
                      (*    SIGNED_INTEGER_TYPE_DEFINITION *)
                      (*    MODULAR_TYPE_DEFINITION *)

                      (*--------------------------------------- *)
                      (* 3.5.4  Signed Integer Type Definition  *)
                      (*--------------------------------------- *)

                      (*  SIGNED_INTEGER_TYPE_DEFINITION ::= *)
                      (*    range static_SIMPLE_EXPRESSION .. static_SIMPLE_EXPRESSION *)

                      (*  Note: the LowBound and HighBound fields are points to an Empty object for *)
                      (*  integer types defined in package Standard. *)

                      NSignedIntegerTypeDefinition =
                        (* Sloc points to RANGE *)
                        LowBound : NClassNode 
                        HighBound : NClassNode 
                      .

                      (*------------------------------------- *)
                      (* 3.5.4  Unsigned Range Specification  *)
                      (*------------------------------------- *)

                      (*  MODULAR_TYPE_DEFINITION ::= mod static_EXPRESSION *)

                      NModularTypeDefinition =
                        (* Sloc points to MOD *)
                        Expression : NClassNode 
                      .

                      (*----------------------------- *)
                      (* 3.5.6  Real Type Definition  *)
                      (*----------------------------- *)

                      (*  REAL_TYPE_DEFINITION ::= *)
                      (*    FLOATING_POINT_DEFINITION | FIXED_POINT_DEFINITION *)

                      (*---------------------------------- *)
                      (* 3.5.7  Floating Point Definition  *)
                      (*---------------------------------- *)

                      (*  FLOATING_POINT_DEFINITION ::= *)
                      (*    digits static_SIMPLE_EXPRESSION [REAL_RANGE_SPECIFICATION] *)

                      (*  Note: The DigitsExpression and Real_Range_Specifications fields *)
                      (*  are points to an Empty object for floating-point types declared in Standard. *)

                      NFloatingPointDefinition =
                        (* Sloc points to DIGITS *)
                        DigitsExpression : NClassNode 
                        RealRangeSpecification : NClassNode (*  (points to an Empty object if not present) *)
                      .

                      (*--------------------------------- *)
                      (* 3.5.7  Real Range Specification  *)
                      (*--------------------------------- *)

                      (*  REAL_RANGE_SPECIFICATION ::= *)
                      (*    range static_SIMPLE_EXPRESSION .. static_SIMPLE_EXPRESSION *)

                      NRealRangeSpecification =
                        (* Sloc points to RANGE *)
                        LowBound : NClassNode 
                        HighBound : NClassNode 
                      .

                      (*------------------------------- *)
                      (* 3.5.9  Fixed Point Definition  *)
                      (*------------------------------- *)

                      (*  FIXED_POINT_DEFINITION ::= *)
                      (*    ORDINARY_FIXED_POINT_DEFINITION | DECIMAL_FIXED_POINT_DEFINITION *)

                      (*---------------------------------------- *)
                      (* 3.5.9  Ordinary Fixed Point Definition  *)
                      (*---------------------------------------- *)

                      (*  ORDINARY_FIXED_POINT_DEFINITION ::= *)
                      (*    delta static_EXPRESSION REAL_RANGE_SPECIFICATION *)

                      (*  Note: In Ada 83, the EXPRESSION must be a SIMPLE_EXPRESSION *)

                      (*  Note: the DeltaExpression and RealRangeSpecification fields *)
                      (*  are points to an Empty object for fixed point types declared in Standard. *)

                      NOrdinaryFixedPointDefinition =
                        (* Sloc points to DELTA *)
                        DeltaExpression : NClassNode 
                        RealRangeSpecification : NClassNode 
                      .

                      (*--------------------------------------- *)
                      (* 3.5.9  Decimal Fixed Point Definition  *)
                      (*--------------------------------------- *)

                      (*  DECIMAL_FIXED_POINT_DEFINITION ::= *)
                      (*    delta static_EXPRESSION *)
                      (*      digits static_EXPRESSION [REAL_RANGE_SPECIFICATION] *)

                      (*  Note: decimal types are not permitted in Ada 83 mode *)

                      NDecimalFixedPointDefinition =
                        (* Sloc points to DELTA *)
                        DeltaExpression : NClassNode 
                        DigitsExpression : NClassNode 
                        RealRangeSpecification : NClassNode (*  (points to an Empty object if not present) *)
                      .

                      (*-------------------------- *)
                      (* 3.5.9  Digits Constraint  *)
                      (*-------------------------- *)

                      (*  DIGITS_CONSTRAINT ::= *)
                      (*    digits static_EXPRESSION [RANGE_CONSTRAINT] *)

                      (*  Note: in Ada 83, the EXPRESSION must be a SIMPLE_EXPRESSION *)
                      (*  Note: in Ada 95, reduced accuracy subtypes are obsolescent *)

                      NDigitsConstraint =
                        (* Sloc points to DIGITS *)
                        DigitsExpression : NClassNode 
                        RangeConstraint : NClassNode (*  (points to an Empty object if not present) *)
                      .

                      (*---------------------------- *)
                      (* 3.6  Array Type Definition  *)
                      (*---------------------------- *)

                      (*  ARRAY_TYPE_DEFINITION ::= *)
                      (*    UNCONSTRAINED_ARRAY_DEFINITION | CONSTRAINED_ARRAY_DEFINITION *)

                      (*------------------------------------- *)
                      (* 3.6  Unconstrained Array Definition  *)
                      (*------------------------------------- *)

                      (*  UNCONSTRAINED_ARRAY_DEFINITION ::= *)
                      (*    array (INDEX_SUBTYPE_DEFINITION {, INDEX_SUBTYPE_DEFINITION}) of *)
                      (*      COMPONENT_DEFINITION *)

                      (*  Note: dimensionality of array is indicated by number of entries in *)
                      (*  the SubtypeMarks list, which has one entry for each dimension. *)

                      NUnconstrainedArrayDefinition =
                        (* Sloc points to ARRAY *)
                        SubtypeMarks : ClassList 
                        [ AliasedPresent : BOOLEAN ] (*  from component definition *)
                        SubtypeIndication : NClassNode (*  from component definition *)
                      .

                      (*------------------------------- *)
                      (* 3.6  Index Subtype Definition  *)
                      (*------------------------------- *)

                      (*  INDEX_SUBTYPE_DEFINITION ::= SUBTYPE_MARK range <> *)

                      (*  There is no explicit node in the tree for an index subtype *)
                      (*  definition since the NUnconstrainedArrayDefinition node *)
                      (*  incorporates the type marks which appear in this context. *)

                      (*----------------------------------- *)
                      (* 3.6  Constrained Array Definition  *)
                      (*----------------------------------- *)

                      (*  CONSTRAINED_ARRAY_DEFINITION ::= *)
                      (*    array (DISCRETE_SUBTYPE_DEFINITION *)
                      (*      {, DISCRETE_SUBTYPE_DEFINITION}) *)
                      (*        of COMPONENT_DEFINITION *)

                      (*  Note: dimensionality of array is indicated by number of entries *)
                      (*  in the DiscreteSubtypeDefinitions list, which has one entry *)
                      (*  for each dimension. *)

                      NConstrainedArrayDefinition =
                        (* Sloc points to ARRAY *)
                        DiscreteSubtypeDefinitions : ClassList 
                        [ AliasedPresent : BOOLEAN ] (*  from component definition *)
                        SubtypeIndication : NClassNode (*  from component definition *)
                      .

                      (*---------------------------------- *)
                      (* 3.6  Discrete Subtype Definition  *)
                      (*---------------------------------- *)

                      (*  DISCRETE_SUBTYPE_DEFINITION ::= *)
                      (*    discrete_SUBTYPE_INDICATION | RANGE *)

                      (*--------------------------- *)
                      (* 3.6  Component Definition  *)
                      (*--------------------------- *)

                      (*  COMPONENT_DEFINITION ::= [aliased] SUBTYPE_INDICATION *)

                      (*  There is no explicit node in the tree for a component definition. *)
                      (*  Instead the subtype indication appears directly, and the ALIASED *)
                      (*  indication (AliasedPresent flag) is in the parent node. *)

                      (*  Note: although the syntax does not permit a component definition to *)
                      (*  be an anonymous array (and the parser will diagnose such an attempt *)
                      (*  with an appropriate message), it is possible for anonymous arrays *)
                      (*  to appear as component definitions. The semantics and back end handle *)
                      (*  this case properly, and the expander in fact generates such cases. *)

                      (*------------------------- *)
                      (* 3.6.1  Index Constraint  *)
                      (*------------------------- *)

                      (*  INDEX_CONSTRAINT ::= (DISCRETE_RANGE {, DISCRETE_RANGE}) *)

                      (*  It is not in general possible to distinguish between discriminant *)
                      (*  constraints and index constraints at parse time, since a simple *)
                      (*  name could be either the subtype mark of a discrete range, or an *)
                      (*  expression in a discriminant association with no name. Either *)
                      (*  entry appears simply as the name, and the semantic parse must *)
                      (*  distinguish between the two cases. Thus we use a common tree *)
                      (*  node format for both of these constraint types. *)

                      (*  See Discriminant_Constraint for format of node *)

                      (*----------------------- *)
                      (* 3.6.1  Discrete Range  *)
                      (*----------------------- *)

                      (*  DISCRETE_RANGE ::= discrete_SUBTYPE_INDICATION | RANGE *)

                      (*------------------------ *)
                      (* 3.7  Discriminant Part  *)
                      (*------------------------ *)

                      (*  DISCRIMINANT_PART ::= *)
                      (*    UNKNOWN_DISCRIMINANT_PART | KNOWN_DISCRIMINANT_PART *)

                      (*-------------------------------- *)
                      (* 3.7  Unknown Discriminant Part  *)
                      (*-------------------------------- *)

                      (*  UNKNOWN_DISCRIMINANT_PART ::= (<>) *)

                      (*  Note: unknown discriminant parts are not permitted in Ada 83 mode *)

                      (*  There is no explicit node in the tree for an unknown discriminant *)
                      (*  part. Instead the UnknownDiscriminantsPresent flag is set in the *)
                      (*  parent node. *)

                      (*------------------------------ *)
                      (* 3.7  Known Discriminant Part  *)
                      (*------------------------------ *)

                      (*  KNOWN_DISCRIMINANT_PART ::= *)
                      (*    (DISCRIMINANT_SPECIFICATION {; DISCRIMINANT_SPECIFICATION}) *)

                      (*--------------------------------- *)
                      (* 3.7  Discriminant Specification  *)
                      (*--------------------------------- *)

                      (*  DISCRIMINANT_SPECIFICATION ::= *)
                      (*    DEFINING_IDENTIFIER_LIST : SUBTYPE_MARK *)
                      (*      [:= DEFAULT_EXPRESSION] *)
                      (*  | DEFINING_IDENTIFIER_LIST : ACCESS_DEFINITION *)
                      (*      [:= DEFAULT_EXPRESSION] *)

                      (*  Although the syntax allows multiple identifiers in the list, the *)
                      (*  semantics is as though successive specifications were given with *)
                      (*  identical type definition and expression components. To simplify *)
                      (*  semantic processing, the parser represents a multiple declaration *)
                      (*  case as a sequence of single specifications, using the MoreIds and *)
                      (*  PrevIds flags to preserve the original source form as described *)
                      (*  in the section on "Handling of Defining Identifier Lists". *)

                      NDiscriminantSpecification =
                        (* Sloc points to first identifier *)
                        DefiningIdentifier : NClassEntity 
                        DiscriminantType : NClassNode (*  subtype mark or *)
                                        (*    access parameter definition *)
                        Expression : NClassNode (*  (points to an Empty object if no default expression) *)
                        [ MoreIds : BOOLEAN ] (*  (set to False if no more identifiers in list) *)
                        [ PrevIds : BOOLEAN ] (*  (set to False if no previous identifiers in list) *)
                      .

                      (*------------------------- *)
                      (* 3.7  Default Expression  *)
                      (*------------------------- *)

                      (*  DEFAULT_EXPRESSION ::= EXPRESSION *)

                      (*-------------------------------- *)
                      (* 3.7.1  Discriminant Constraint  *)
                      (*-------------------------------- *)

                      (*  DISCRIMINANT_CONSTRAINT ::= *)
                      (*    (DISCRIMINANT_ASSOCIATION {, DISCRIMINANT_ASSOCIATION}) *)

                      (*  It is not in general possible to distinguish between discriminant *)
                      (*  constraints and index constraints at parse time, since a simple *)
                      (*  name could be either the subtype mark of a discrete range, or an *)
                      (*  expression in a discriminant association with no name. Either *)
                      (*  entry appears simply as the name, and the semantic parse must *)
                      (*  distinguish between the two cases. Thus we use a common tree *)
                      (*  node format for both of these constraint types. *)

                      NIndexOrDiscriminantConstraint =
                        (* Sloc points to left paren *)
                        Constraints : ClassList (*  points to list of discrete ranges or *)
                                           (*    discriminant associations *)
                      .

                      (*--------------------------------- *)
                      (* 3.7.1  Discriminant Association  *)
                      (*--------------------------------- *)

                      (*  DISCRIMINANT_ASSOCIATION ::= *)
                      (*    [discriminant_SELECTOR_NAME *)
                      (*      {| discriminant_SELECTOR_NAME} =>] EXPRESSION *)

                      (*  Note: a discriminant association that has no selector name list *)
                      (*  appears directly as an expression in the tree. *)

                      NDiscriminantAssociation =
                        (* Sloc points to first token of discriminant association *)
                        SelectorNames : ClassList (*  (always non-empty, since if no selector *)
                                     (*   names are present, this node is not used, see comment above) *)
                        Expression : NClassNode 
                      .

                      (*----------------------------- *)
                      (* 3.8  Record Type Definition  *)
                      (*----------------------------- *)

                      (*  RECORD_TYPE_DEFINITION ::= *)
                      (*    [[abstract] tagged] [limited] RECORD_DEFINITION *)

                      (*  Note: ABSTRACT, TAGGED, LIMITED are not permitted in Ada 83 mode *)

                      (*  There is no explicit node in the tree for a record type definition. *)
                      (*  Instead the flags for TaggedPresent and LimitedPresent appear in *)
                      (*  the NRecordDefinition node for a record definition appearing in *)
                      (*  the context of a record type definition. *)

                      (*------------------------ *)
                      (* 3.8  Record Definition  *)
                      (*------------------------ *)

                      (*  RECORD_DEFINITION ::= *)
                      (*    record *)
                      (*      COMPONENT_LIST *)
                      (*    end record *)
                      (*  | null record *)

                      (*  Note: the AbstractPresent, TaggedPresent and LimitedPresent *)
                      (*  flags appear only for a record definition appearing in a record *)
                      (*  type definition. *)

                      (*  Note: the NULL RECORD case is not permitted in Ada 83 *)

                      NRecordDefinition =
                        (* Sloc points to RECORD or NULL *)
                        [ AbstractPresent : BOOLEAN ] 
                        [ TaggedPresent : BOOLEAN ] 
                        [ LimitedPresent : BOOLEAN ] 
                        ComponentList : NClassNode (* points to an Empty object in null record case *)
                        [ NullPresent : BOOLEAN ] (*  set in null record case *)
                      .

                      (*--------------------- *)
                      (* 3.8  Component List  *)
                      (*--------------------- *)

                      (*  COMPONENT_LIST ::= *)
                      (*    COMPONENT_ITEM {COMPONENT_ITEM} *)
                      (*  | {COMPONENT_ITEM} VARIANT_PART *)
                      (*  | null; *)

                      NComponentList =
                        (* Sloc points to first token of component list *)
                        ComponentItems : ClassList 
                        VariantPart : NClassNode (*  (points to an Empty object if no variant part) *)
                        [ NullPresent : BOOLEAN ] 
                      .

                      (*--------------------- *)
                      (* 3.8  Component Item  *)
                      (*--------------------- *)

                      (*  COMPONENT_ITEM ::= COMPONENT_DECLARATION | REPRESENTATION_CLAUSE *)

                      (*  Note: A component item can also be a pragma, and in the tree *)
                      (*  that is obtained after semantic processing, a component item *)
                      (*  can be an NNull node resulting from a non-recognized pragma. *)

                      (*---------------------------- *)
                      (* 3.8  Component Declaration  *)
                      (*---------------------------- *)

                      (*  COMPONENT_DECLARATION ::= *)
                      (*    DEFINING_IDENTIFIER_LIST : COMPONENT_DEFINITION *)
                      (*      [:= DEFAULT_EXPRESSION] *)

                      (*  Note: although the syntax does not permit a component definition to *)
                      (*  be an anonymous array (and the parser will diagnose such an attempt *)
                      (*  with an appropriate message), it is possible for anonymous arrays *)
                      (*  to appear as component definitions. The semantics and back end handle *)
                      (*  this case properly, and the expander in fact generates such cases. *)

                      (*  Although the syntax allows multiple identifiers in the list, the *)
                      (*  semantics is as though successive declarations were given with the *)
                      (*  same component definition and expression components. To simplify *)
                      (*  semantic processing, the parser represents a multiple declaration *)
                      (*  case as a sequence of single declarations, using the MoreIds and *)
                      (*  PrevIds flags to preserve the original source form as described *)
                      (*  in the section on "Handling of Defining Identifier Lists". *)

                      NComponentDeclaration =
                        (* Sloc points to first identifier *)
                        DefiningIdentifier : NClassEntity 
                        [ AliasedPresent : BOOLEAN ] (*  from component definition *)
                        SubtypeIndication : NClassNode (*  from component definition *)
                        Expression : NClassNode (*  (points to an Empty object if no default expression) *)
                        [ MoreIds : BOOLEAN ] (*  (set to False if no more identifiers in list) *)
                        [ PrevIds : BOOLEAN ] (*  (set to False if no previous identifiers in list) *)
                      .

                      (*--------------------- *)
                      (* 3.8.1  Variant Part  *)
                      (*--------------------- *)

                      (*  VARIANT_PART ::= *)
                      (*    case discriminant_DIRECT_NAME is *)
                      (*      VARIANT *)
                      (*      {VARIANT} *)
                      (*    end case; *)

                      (*  Note: the variants list can contain pragmas as well as variants. *)
                      (*  In a properly formed program there is at least one variant. *)

                      NVariantPart =
                        (* Sloc points to CASE *)
                        Name : NClassNode 
                        Variants : ClassList 
                      .

                      (*---------------- *)
                      (* 3.8.1  Variant  *)
                      (*---------------- *)

                      (*  VARIANT ::= *)
                      (*    when DISCRETE_CHOICE_LIST => *)
                      (*      COMPONENT_LIST *)

                      NVariant =
                        (* Sloc points to WHEN *)
                        DiscreteChoices : ClassList 
                        ComponentList : NClassNode 
                        EnclosingVariant : NClassNode 
                      .

                      (*----------------------------- *)
                      (* 3.8.1  Discrete Choice List  *)
                      (*----------------------------- *)

                      (*  DISCRETE_CHOICE_LIST ::= DISCRETE_CHOICE {| DISCRETE_CHOICE} *)

                      (*------------------------ *)
                      (* 3.8.1  Discrete Choice  *)
                      (*------------------------ *)

                      (*  DISCRETE_CHOICE ::= EXPRESSION | DISCRETE_RANGE | others *)

                      (*  Note: in Ada 83 mode, the expression must be a simple expression *)

                      (*  The only choice that appears explicitly is the OTHERS choice, as *)
                      (*  defined here. Other cases of discrete choice (expression and *)
                      (*  discrete range) appear directly. This production is also used *)
                      (*  for the OTHERS possibility of an exception choice. *)

                      (*  Note: in accordance with the syntax, the parser does not check that *)
                      (*  OTHERS appears at the end on its own in a choice list context. This *)
                      (*  is a semantic check. *)

                      NOthersChoice =
                        (* Sloc points to OTHERS *)
                        OthersDiscreteChoices : ClassList 
                        [ AllOthers : BOOLEAN ] 
                      .

                      (*------------------------------ *)
                      (* 3.9.1  Record Extension Part  *)
                      (*------------------------------ *)

                      (*  RECORD_EXTENSION_PART ::= with RECORD_DEFINITION *)

                      (*  Note: record extension parts are not permitted in Ada 83 mode *)

                      (*------------------------------ *)
                      (* 3.10  Access Type Definition  *)
                      (*------------------------------ *)

                      (*  ACCESS_TYPE_DEFINITION ::= *)
                      (*    ACCESS_TO_OBJECT_DEFINITION *)
                      (*  | ACCESS_TO_SUBPROGRAM_DEFINITION *)

                      (*----------------------------------- *)
                      (* 3.10  Access To Object Definition  *)
                      (*----------------------------------- *)

                      (*  ACCESS_TO_OBJECT_DEFINITION ::= *)
                      (*    access [GENERAL_ACCESS_MODIFIER] SUBTYPE_INDICATION *)

                      NAccessToObjectDefinition =
                        (* Sloc points to ACCESS *)
                        [ AllPresent : BOOLEAN ] 
                        SubtypeIndication : NClassNode 
                        [ ConstantPresent : BOOLEAN ] 
                      .

                      (*------------------------------- *)
                      (* 3.10  General Access Modifier  *)
                      (*------------------------------- *)

                      (*  GENERAL_ACCESS_MODIFIER ::= all | constant *)

                      (*  Note: general access modifiers are not permitted in Ada 83 mode *)

                      (*  There is no explicit node in the tree for general access modifier. *)
                      (*  Instead the AllPresent or ConstantPresent flags are set in the *)
                      (*  parent node. *)

                      (*--------------------------------------- *)
                      (* 3.10  Access To Subprogram Definition  *)
                      (*--------------------------------------- *)

                      (*  ACCESS_TO_SUBPROGRAM_DEFINITION *)
                      (*    access [protected] procedure PARAMETER_PROFILE *)
                      (*  | access [protected] function PARAMETER_AND_RESULT_PROFILE *)

                      (*  Note: access to subprograms are not permitted in Ada 83 mode *)

                      NAccessFunctionDefinition =
                        (* Sloc points to ACCESS *)
                        [ ProtectedPresent : BOOLEAN ] 
                        ParameterSpecifications : ClassList (*  (points to a NoList object if no formal part) *)
                        SubtypeMark : NClassNode (*  result subtype *)
                      .

                      NAccessProcedureDefinition =
                        (* Sloc points to ACCESS *)
                        [ ProtectedPresent : BOOLEAN ] 
                        ParameterSpecifications : ClassList (*  (points to a NoList object if no formal part) *)
                      .

                      (*------------------------- *)
                      (* 3.10  Access Definition  *)
                      (*------------------------- *)

                      (*  ACCESS_DEFINITION ::= access SUBTYPE_MARK *)

                      NAccessDefinition =
                        (* Sloc points to ACCESS *)
                        SubtypeMark : NClassNode 
                      .

                      (*------------------------------------- *)
                      (* 3.10.1  Incomplete Type Declaration  *)
                      (*------------------------------------- *)

                      (*  INCOMPLETE_TYPE_DECLARATION ::= *)
                      (*    type DEFINING_IDENTIFIER [DISCRIMINANT_PART]; *)

                      NIncompleteTypeDeclaration =
                        (* Sloc points to TYPE *)
                        DefiningIdentifier : NClassEntity 
                        DiscriminantSpecifications : ClassList (*  (points to a NoList object if no *)
                          (* discriminant part, or if the discriminant part is an *)
                          (* unknown discriminant part) *)
                        [ UnknownDiscriminantsPresent : BOOLEAN ] (*  set if (<>) discriminant *)
                      .

                      (*------------------------ *)
                      (* 3.11  Declarative Part  *)
                      (*------------------------ *)

                      (*  DECLARATIVE_PART ::= {DECLARATIVE_ITEM} *)

                      (*  Note: although the parser enforces the syntactic requirement that *)
                      (*  a declarative part can contain only declarations, the semantic *)
                      (*  processing may add statements to the list of actions in a *)
                      (*  declarative part, so the code generator should be prepared *)
                      (*  to accept a statement in this position. *)

                      (*------------------------ *)
                      (* 3.11  Declarative Item  *)
                      (*------------------------ *)

                      (*  DECLARATIVE_ITEM ::= BASIC_DECLARATIVE_ITEM | BODY *)

                      (*------------------------------ *)
                      (* 3.11  Basic Declarative Item  *)
                      (*------------------------------ *)

                      (*  BASIC_DECLARATIVE_ITEM ::= *)
                      (*    BASIC_DECLARATION | REPRESENTATION_CLAUSE | USE_CLAUSE *)

                      (*------------ *)
                      (* 3.11  Body  *)
                      (*------------ *)

                      (*  BODY ::= PROPER_BODY | BODY_STUB *)

                      (*------------------- *)
                      (* 3.11  Proper Body  *)
                      (*------------------- *)

                      (*  PROPER_BODY ::= *)
                      (*    SUBPROGRAM_BODY | PACKAGE_BODY | TASK_BODY | PROTECTED_BODY *)

                      (*----------- *)
                      (* 4.1  Name  *)
                      (*----------- *)

                      (*  NAME ::= *)
                      (*    DIRECT_NAME        | EXPLICIT_DEREFERENCE *)
                      (*  | INDEXED_COMPONENT  | SLICE *)
                      (*  | SELECTED_COMPONENT | ATTRIBUTE_REFERENCE *)
                      (*  | TYPE_CONVERSION    | FUNCTION_CALL *)
                      (*  | CHARACTER_LITERAL *)

                      (*------------------ *)
                      (* 4.1  Direct Name  *)
                      (*------------------ *)

                      (*  DIRECT_NAME ::= IDENTIFIER | OPERATOR_SYMBOL *)

                      (*------------- *)
                      (* 4.1  Prefix  *)
                      (*------------- *)

                      (*  PREFIX ::= NAME | IMPLICIT_DEREFERENCE *)

                      (*------------------------------------------ *)
                      (* 4.3.1  Record Component Association List  *)
                      (*------------------------------------------ *)

                      (*  RECORD_COMPONENT_ASSOCIATION_LIST ::= *)
                      (*     RECORD_COMPONENT_ASSOCIATION {, RECORD_COMPONENT_ASSOCIATION} *)
                      (*   | null record *)

                      (*  There is no explicit node in the tree for a record component *)
                      (*  association list. Instead the NullRecordPresent flag is set in *)
                      (*  the parent node for the NULL RECORD case. *)

                      (*-------------------------------------------------- *)
                      (* 4.3.1  Record Component Association (also 4.3.3)  *)
                      (*-------------------------------------------------- *)

                      (*  RECORD_COMPONENT_ASSOCIATION ::= *)
                      (*    [COMPONENT_CHOICE_LIST =>] EXPRESSION *)

                      NComponentAssociation =
                        (* Sloc points to first selector name *)
                        Choices : ClassList 
                        Expression : NClassNode 
                      .

                      (*  Note: this structure is used for both record component associations *)
                      (*  and array component associations, since the two cases aren't always *)
                      (*  separable by the parser. The choices list may represent either a *)
                      (*  list of selector names in the record aggregate case, or a list of *)
                      (*  discrete choices in the array aggregate case or an NOthersChoice *)
                      (*  node (which appears as a singleton list). *)

                      (*-------------------------------- *)
                      (*  4.3.1  Commponent Choice List  *)
                      (*-------------------------------- *)

                      (*  COMPONENT_CHOICE_LIST ::= *)
                      (*    component_SELECTOR_NAME {| component_SELECTOR_NAME} *)
                      (*  | others *)

                      (*  The entries of a component choice list appear in the Choices list *)
                      (*  of the associated NComponentAssociation, as either selector *)
                      (*  names, or as an NOthersChoice node. *)

                      (*----------------------------- *)
                      (* 5.1  Sequence Of Statements  *)
                      (*----------------------------- *)

                      (*  SEQUENCE_OF_STATEMENTS ::= STATEMENT {STATEMENT} *)

                      (*  Note: Although the parser will not accept a declaration as a *)
                      (*  statement, the semantic analyzer may insert declarations (e.g. *)
                      (*  declarations of implicit types needed for execution of other *)
                      (*  statements) into a sequence of statements, so the code genmerator *)
                      (*  should be prepared to accept a declaration where a statement is *)
                      (*  expected. Note also that pragmas can appear as statements. *)

                      (*---------------- *)
                      (* 5.1  Statement  *)
                      (*---------------- *)

                      (*  STATEMENT ::= *)
                      (*    {LABEL} SIMPLE_STATEMENT | {LABEL} COMPOUND_STATEMENT *)

                      (*  There is no explicit node in the tree for a statement. Instead, the *)
                      (*  individual statement appears directly. Labels are treated  as a *)
                      (*  kind of statement, i.e. they are linked into a statement list at *)
                      (*  the point they appear, so the labeled statement appears following *)
                      (*  the label or labels in the statement list. *)

                      (*----------------------- *)
                      (* 5.1  Simple Statement  *)
                      (*----------------------- *)

                      (*  SIMPLE_STATEMENT ::=      NULL_STATEMENT *)
                      (*  | ASSIGNMENT_STATEMENT  | EXIT_STATEMENT *)
                      (*  | GOTO_STATEMENT        | PROCEDURE_CALL_STATEMENT *)
                      (*  | RETURN_STATEMENT      | ENTRY_CALL_STATEMENT *)
                      (*  | REQUEUE_STATEMENT     | DELAY_STATEMENT *)
                      (*  | ABORT_STATEMENT       | RAISE_STATEMENT *)
                      (*  | CODE_STATEMENT *)

                      (*------------------------- *)
                      (* 5.1  Compound Statement  *)
                      (*------------------------- *)

                      (*  COMPOUND_STATEMENT ::= *)
                      (*    IF_STATEMENT         | CASE_STATEMENT *)
                      (*  | LOOP_STATEMENT       | BLOCK_STATEMENT *)
                      (*  | ACCEPT_STATEMENT     | SELECT_STATEMENT *)

                      (*--------------------- *)
                      (* 5.1  Null Statement  *)
                      (*--------------------- *)

                      (*  NULL_STATEMENT ::= null; *)

                      NNullStatement =
                        (* Sloc points to NULL *)
                      .

                      (*------------ *)
                      (* 5.1  Label  *)
                      (*------------ *)

                      (*  LABEL ::= <<label_STATEMENT_IDENTIFIER>> *)

                      (*  Note that the occurrence of a label is not a defining identifier, *)
                      (*  but rather a referencing occurrence. The defining occurrence is *)
                      (*  in the implicit label declaration which occurs in the innermost *)
                      (*  enclosing block. *)

                      NLabel =
                        (* Sloc points to << *)
                        Identifier : NClassNode (*  direct name of statement identifier *)
                      .

                      (*--------------------------- *)
                      (* 5.1  Statement Identifier  *)
                      (*--------------------------- *)

                      (*  STATEMENT_INDENTIFIER ::= DIRECT_NAME *)

                      (*  The IDENTIFIER of a STATEMENT_IDENTIFIER shall be an identifier *)
                      (*  (not an OPERATOR_SYMBOL) *)

                      (*--------------------------- *)
                      (* 5.2  Assignment Statement  *)
                      (*--------------------------- *)

                      (*  ASSIGNMENT_STATEMENT ::= *)
                      (*    variable_NAME := EXPRESSION; *)

                      NAssignmentStatement =
                        (* Sloc points to := *)
                        Name : NClassNode 
                        Expression : NClassNode 
                        [ DoTagCheck : BOOLEAN ] 
                        [ DoLengthCheck : BOOLEAN ] 
                        [ ForwardsOK : BOOLEAN ] 
                        [ BackwardsOK : BOOLEAN ] 
                        [ NoCtrlActions : BOOLEAN ] 
                      .

                      (*  Note: if a range check is required, then the DoRangeCheck flag *)
                      (*  is set in the Expression (right hand side), with the check being *)
                      (*  done against the type of the Name (left hand side). *)

                      (*------------------- *)
                      (* 5.3  If Statement  *)
                      (*------------------- *)

                      (*  IF_STATEMENT ::= *)
                      (*    if CONDITION then *)
                      (*      SEQUENCE_OF_STATEMENTS *)
                      (*    {elsif CONDITION then *)
                      (*      SEQUENCE_OF_STATEMENTS} *)
                      (*    [else *)
                      (*      SEQUENCE_OF_STATEMENTS] *)
                      (*    end if; *)

                      NIfStatement =
                        (* Sloc points to IF *)
                        Condition : NClassNode 
                        ThenStatements : ClassList 
                        ElsifParts : ClassList (*  (points to a NoList object if none present) *)
                        ElseStatements : ClassList (*  (points to a NoList object if no else part present) *)
                      .

                      NElsifPart =
                        (* Sloc points to ELSIF *)
                        Condition : NClassNode 
                        ThenStatements : ClassList 
                        ConditionActions : ClassList 
                      .

                      (*---------------- *)
                      (* 5.3  Condition  *)
                      (*---------------- *)

                      (*  CONDITION ::= boolean_EXPRESSION *)

                      (*--------------------- *)
                      (* 5.4  Case Statement  *)
                      (*--------------------- *)

                      (*  CASE_STATEMENT ::= *)
                      (*    case EXPRESSION is *)
                      (*      CASE_STATEMENT_ALTERNATIVE *)
                      (*      {CASE_STATEMENT_ALTERNATIVE} *)
                      (*    end case; *)

                      (*  Note: the Alternatives can contain pragmas. These only occur at *)
                      (*  the start of the list, since any pragmas occurring after the first *)
                      (*  alternative are absorbed into the corresponding statement sequence. *)

                      NCaseStatement =
                        (* Sloc points to CASE *)
                        Expression : NClassNode 
                        Alternatives : ClassList 
                      .

                      (*--------------------------------- *)
                      (* 5.4  Case Statement Alternative  *)
                      (*--------------------------------- *)

                      (*  CASE_STATEMENT_ALTERNATIVE ::= *)
                      (*    when DISCRETE_CHOICE_LIST => *)
                      (*      SEQUENCE_OF_STATEMENTS *)

                      NCaseStatementAlternative =
                        (* Sloc points to WHEN *)
                        DiscreteChoices : ClassList 
                        Statements : ClassList 
                      .

                      (*--------------------- *)
                      (* 5.5  Loop Statement  *)
                      (*--------------------- *)

                      (*  LOOP_STATEMENT ::= *)
                      (*    [loop_STATEMENT_IDENTIFIER :] *)
                      (*      [ITERATION_SCHEME] loop *)
                      (*        SEQUENCE_OF_STATEMENTS *)
                      (*      end loop [loop_IDENTIFIER]; *)

                      (*  Note: The occurrence of a loop label is not a defining identifier *)
                      (*  but rather a referencing occurrence. The defining occurrence is in *)
                      (*  the implicit label declaration which occurs in the innermost *)
                      (*  enclosing block. *)

                      (*  Note: there is always a loop statement identifier present in *)
                      (*  the tree, even if none was given in the source. In the case where *)
                      (*  no loop identifier is given in the source, the parser creates *)
                      (*  a name of the form _Loop_n, where n is a decimal integer (the *)
                      (*  two underlines ensure that the loop names created in this manner *)
                      (*  do not conflict with any user defined identifiers), and the flag *)
                      (*  HasCreatedIdentifier is set to True. The only exception to the *)
                      (*  rule that all loop statement nodes have identifiers occurs for *)
                      (*  loops constructed by the expander, and the semantic analyzer will *)
                      (*  create and supply dummy loop identifiers in these cases. *)

                      NLoopStatement =
                        (* Sloc points to LOOP *)
                        Identifier : NClassNode (*  loop identifier (points to an Empty object if no identifier) *)
                        IterationScheme : NClassNode (*  (points to an Empty object if no iteration scheme) *)
                        Statements : ClassList 
                        [ HasCreatedIdentifier : BOOLEAN ] 
                      .

                      (*---------------------- *)
                      (* 5.5 Iteration Scheme  *)
                      (*---------------------- *)

                      (*  ITERATION_SCHEME ::= *)
                      (*    while CONDITION | for LOOP_PARAMETER_SPECIFICATION *)

                      NIterationScheme =
                        (* Sloc points to WHILE or FOR *)
                        Condition : NClassNode (*  (points to an Empty object if FOR case) *)
                        ConditionActions : ClassList 
                        LoopParameterSpecification : NClassNode (*  (points to an Empty object if WHILE case) *)
                      .

                      (*----------------------------------- *)
                      (* 5.5  Loop parameter specification  *)
                      (*----------------------------------- *)

                      (*  LOOP_PARAMETER_SPECIFICATION ::= *)
                      (*    DEFINING_IDENTIFIER in [reverse] DISCRETE_SUBTYPE_DEFINITION *)

                      NLoopParameterSpecification =
                        (* Sloc points to first identifier *)
                        DefiningIdentifier : NClassEntity 
                        [ ReversePresent : BOOLEAN ] 
                        DiscreteSubtypeDefinition : NClassNode 
                      .

                      (*---------------------- *)
                      (* 5.6  Block Statement  *)
                      (*---------------------- *)

                      (*  BLOCK_STATEMENT ::= *)
                      (*    [block_STATEMENT_IDENTIFIER:] *)
                      (*      [declare *)
                      (*        DECLARATIVE_PART] *)
                      (*      begin *)
                      (*        HANDLED_SEQUENCE_OF_STATEMENTS *)
                      (*      end [block_IDENTIFIER]; *)

                      (*  Note that the occurrence of a block identifier is not a defining *)
                      (*  identifier, but rather a referencing occurrence. The defining *)
                      (*  occurrence is in the implicit label declaration which occurs in *)
                      (*  the innermost enclosing block. *)

                      (*  Note: there is always a block statement identifier present in *)
                      (*  the tree, even if none was given in the source. In the case where *)
                      (*  no block identifier is given in the source, the parser creates *)
                      (*  a name of the form _Block_n, where n is a decimal integer (the *)
                      (*  two underlines ensure that the block names created in this manner *)
                      (*  do not conflict with any user defined identifiers), and the flag *)
                      (*  HasCreatedIdentifier is set to True. The only exception to the *)
                      (*  rule that all loop statement nodes have identifiers occurs for *)
                      (*  blocks constructed by the expander, and the semantic analyzer *)
                      (*  creates and supplies dummy names for the blocks). *)

                      NBlockStatement =
                        (* Sloc points to DECLARE or BEGIN *)
                        Identifier : NClassNode (*  block direct name (points to an Empty object if not present) *)
                        Declarations : ClassList (*  (points to a NoList object if no DECLARE part) *)
                        HandledStatementSequence : NClassNode 
                        [ IsTaskMaster : BOOLEAN ] 
                        ActivationChainEntity : NClassNode 
                        [ HasCreatedIdentifier : BOOLEAN ] 
                        [ IsTaskAllocationBlock : BOOLEAN ] 
                        [ IsAsynchronousCallBlock : BOOLEAN ] 
                      .

                      (*--------------------- *)
                      (* 5.7  Exit Statement  *)
                      (*--------------------- *)

                      (*  EXIT_STATEMENT ::= exit [loop_NAME] [when CONDITION]; *)

                      NExitStatement =
                        (* Sloc points to EXIT *)
                        Name : NClassNode (*  (points to an Empty object if no loop name present) *)
                        Condition : NClassNode (*  (points to an Empty object if no when part present) *)
                      .

                      (*--------------------- *)
                      (* 5.9  Goto Statement  *)
                      (*--------------------- *)

                      (*  GOTO_STATEMENT ::= goto label_NAME; *)

                      NGotoStatement =
                        (* Sloc points to GOTO *)
                        Name : NClassNode 
                      .

                      (*----------------------------- *)
                      (* 6.1  Subprogram Declaration  *)
                      (*----------------------------- *)

                      (*  SUBPROGRAM_DECLARATION ::= SUBPROGRAM_SPECIFICATION; *)

                      NSubprogramDeclaration =
                        (* Sloc points to FUNCTION or PROCEDURE *)
                        Specification : NClassNode 
                        CorrespondingBody : NClassNode 
                        ParentSpec : NClassNode 
                      .

                      (*-------------------------------------- *)
                      (* 6.1  Abstract Subprogram Declaration  *)
                      (*-------------------------------------- *)

                      (*  ABSTRACT_SUBPROGRAM_DECLARATION ::= *)
                      (*    SUBPROGRAM_SPECIFICATION is abstract; *)

                      NAbstractSubprogramDeclaration =
                        (* Sloc points to ABSTRACT *)
                        Specification : NClassNode 
                      .

                      (*------------------------------- *)
                      (* 6.1  Subprogram Specification  *)
                      (*------------------------------- *)

                      (*  SUBPROGRAM_SPECIFICATION ::= *)
                      (*    procedure DEFINING_PROGRAM_UNIT_NAME PARAMETER_PROFILE *)
                      (*  | function DEFINING_DESIGNATOR PARAMETER_AND_RESULT_PROFILE *)

                      (*  Note: there are no separate nodes for the profiles, instead the *)
                      (*  information appears directly in the following nodes. *)

                      NFunctionSpecification =
                        (* Sloc points to FUNCTION *)
                        DefiningUnitName : NClassNode (*  (the designator) *)
                        ElaborationBoolean : NClassNode 
                        ParameterSpecifications : ClassList (*  (points to a NoList object if no formal part) *)
                        SubtypeMark : NClassNode (*  for return type *)
                        GenericParent : NClassNode 
                      .

                      NProcedureSpecification =
                        (* Sloc points to PROCEDURE *)
                        DefiningUnitName : NClassNode 
                        ElaborationBoolean : NClassNode 
                        ParameterSpecifications : ClassList (*  (points to a NoList object if no formal part) *)
                        GenericParent : NClassNode 
                      .

                      (*----------------- *)
                      (* 6.1  Designator  *)
                      (*----------------- *)

                      (*  DESIGNATOR ::= *)
                      (*    [PARENT_UNIT_NAME .] IDENTIFIER | OPERATOR_SYMBOL *)

                      (*  Designators that are simply identifiers or operator symbols appear *)
                      (*  directly in the tree in this form. The following node is used only *)
                      (*  in the case where the designator has a parent unit name component. *)

                      NDesignator =
                        (* Sloc points to period *)
                        Name : NClassNode (*  holds the parent unit name. Note that this is always *)
                          (* non-Empty, since this node is only used for the case where a *)
                          (* parent library unit package name is present. *)
                        Identifier : NClassNode 
                      .

                      (*-------------------------- *)
                      (* 6.1  Defining Designator  *)
                      (*-------------------------- *)

                      (*  DEFINING_DESIGNATOR ::= *)
                      (*    DEFINING_PROGRAM_UNIT_NAME | DEFINING_OPERATOR_SYMBOL *)

                      (*--------------------------------- *)
                      (* 6.1  Defining Program Unit Name  *)
                      (*--------------------------------- *)

                      (*  DEFINING_PROGRAM_UNIT_NAME ::= *)
                      (*    [PARENT_UNIT_NAME .] DEFINING_IDENTIFIER *)

                      (*  The parent unit name is present only in the case of a child unit *)
                      (*  name (permissible only for Ada 95 for a library level unit, i.e. *)
                      (*  a unit at scope level one). If no such name is present, the defining *)
                      (*  program unit name is represented simply as the defining identifier. *)
                      (*  In the child unit case, the following node is used to represent the *)
                      (*  child unit name. *)

                      NDefiningProgramUnitName =
                        (* Sloc points to period *)
                        Name : NClassNode (*  holds the parent unit name. Note that this is always *)
                          (* non-Empty, since this node is only used for the case where a *)
                          (* parent unit name is present. *)
                        DefiningIdentifier : NClassEntity 
                      .

                      (*---------------------- *)
                      (* 6.1  Operator Symbol  *)
                      (*---------------------- *)

                      (*  OPERATOR_SYMBOL ::= STRING_LITERAL *)

                      (*  Note: the fields of the NOperatorSymbol node are laid out to *)
                      (*  match the corresponding fields of an NCharacterLiteral node. This *)
                      (*  allows easy conversion of the operator symbol node into a character *)
                      (*  literal node in the case where a string constant of the form of an *)
                      (*  operator symbol is scanned out as such, but turns out semantically *)
                      (*  to be a string literal that is not an operator. For details see *)
                      (*  Sinfo.CN.Change_Operator_Symbol_To_String_Literal. *)

                      NOperatorSymbol =
                        (* Sloc points to literal *)
                        [ Chars : NameId ] (*  contains the Name_Id for the operator symbol *)
                        [ Strval : StringId ] (*  Id of string value. This is used if the operator *)
                          (* symbol turns out to be a normal string after all. *)
                        Entity : NClassNode 
                        [ HasPrivateView : BOOLEAN ] (*  set in generic units. *)
                        Etype : NClassNode 
                      .

                      (*------------------------ *)
                      (* 6.1  Parameter Profile  *)
                      (*------------------------ *)

                      (*  PARAMETER_PROFILE ::= [FORMAL_PART] *)

                      (*----------------------------------- *)
                      (* 6.1  Parameter and Result Profile  *)
                      (*----------------------------------- *)

                      (*  PARAMETER_AND_RESULT_PROFILE ::= [FORMAL_PART] return SUBTYPE_MARK *)

                      (*  There is no explicit node in the tree for a parameter and result *)
                      (*  profile. Instead the information appears directly in the parent. *)

                      (*------------------ *)
                      (* 6.1  Formal part  *)
                      (*------------------ *)

                      (*  FORMAL_PART ::= *)
                      (*    (PARAMETER_SPECIFICATION {; PARAMETER_SPECIFICATION}) *)

                      (*------------------------------ *)
                      (* 6.1  Parameter specification  *)
                      (*------------------------------ *)

                      (*  PARAMETER_SPECIFICATION ::= *)
                      (*    DEFINING_IDENTIFIER_LIST : MODE SUBTYPE_MARK *)
                      (*      [:= DEFAULT_EXPRESSION] *)
                      (*  | DEFINING_IDENTIFIER_LIST : ACCESS_DEFINITION *)
                      (*      [:= DEFAULT_EXPRESSION] *)

                      (*  Although the syntax allows multiple identifiers in the list, the *)
                      (*  semantics is as though successive specifications were given with *)
                      (*  identical type definition and expression components. To simplify *)
                      (*  semantic processing, the parser represents a multiple declaration *)
                      (*  case as a sequence of single Specifications, using the MoreIds and *)
                      (*  PrevIds flags to preserve the original source form as described *)
                      (*  in the section on "Handling of Defining Identifier Lists". *)

                      NParameterSpecification =
                        (* Sloc points to first identifier *)
                        DefiningIdentifier : NClassEntity 
                        [ InPresent : BOOLEAN ] 
                        [ OutPresent : BOOLEAN ] 
                        ParameterType : NClassNode (*  subtype mark or access definition *)
                        Expression : NClassNode (*  (points to an Empty object if no default expression present) *)
                        [ DoAccessibilityCheck : BOOLEAN ] 
                        [ MoreIds : BOOLEAN ] (*  (set to False if no more identifiers in list) *)
                        [ PrevIds : BOOLEAN ] (*  (set to False if no previous identifiers in list) *)
                        DefaultExpression : NClassNode 
                      .

                      (*----------- *)
                      (* 6.1  Mode  *)
                      (*----------- *)

                      (*  MODE ::= [in] | in out | out *)

                      (*  There is no explicit node in the tree for the Mode. Instead the *)
                      (*  InPresent and OutPresent flags are set in the parent node to *)
                      (*  record the presence of keywords specifying the mode. *)

                      (*---------------------- *)
                      (* 6.3  Subprogram Body  *)
                      (*---------------------- *)

                      (*  SUBPROGRAM_BODY ::= *)
                      (*    SUBPROGRAM_SPECIFICATION is *)
                      (*      DECLARATIVE_PART *)
                      (*    begin *)
                      (*      HANDLED_SEQUENCE_OF_STATEMENTS *)
                      (*    end [DESIGNATOR]; *)

                      NSubprogramBody =
                        (* Sloc points to FUNCTION or PROCEDURE *)
                        Specification : NClassNode 
                        Declarations : ClassList 
                        HandledStatementSequence : NClassNode 
                        ActivationChainEntity : NClassNode 
                        CorrespondingSpec : NClassNode 
                        [ ActsAsSpec : BOOLEAN ] 
                        [ BadIsDetected : BOOLEAN ] (*  used only by parser *)
                        [ CodeRangeTaken : BOOLEAN ] 
                        [ DoStorageCheck : BOOLEAN ] 
                        [ HasPriorityPragma : BOOLEAN ] 
                        [ IsProtectedSubprogramBody : BOOLEAN ] 
                        [ IsTaskMaster : BOOLEAN ] 
                        [ WasOriginallyStub : BOOLEAN ] 
                      .

                      (*---------------------------- *)
                      (* 6.4  Actual Parameter Part  *)
                      (*---------------------------- *)

                      (*  ACTUAL_PARAMETER_PART ::= *)
                      (*    (PARAMETER_ASSOCIATION {,PARAMETER_ASSOCIATION}) *)

                      (*---------------------------- *)
                      (* 6.4  Parameter Association  *)
                      (*---------------------------- *)

                      (*  PARAMETER_ASSOCIATION ::= *)
                      (*    [formal_parameter_SELECTOR_NAME =>] EXPLICIT_ACTUAL_PARAMETER *)

                      (*  Note: the NParameterAssociation node is built only if a formal *)
                      (*  parameter selector name is present, otherwise the parameter *)
                      (*  association appears in the tree simply as the node for the *)
                      (*  explicit actual parameter. *)

                      NParameterAssociation =
                        (* Sloc points to formal parameter *)
                        SelectorName : NClassNode (*  (always non-Empty, since this node is *)
                          (* only used if a formal parameter selector name is present) *)
                        ExplicitActualParameter : NClassNode 
                        NextNamedActual : NClassNode 
                      .

                      (*----------------------- *)
                      (* 6.4  Actual Parameter  *)
                      (*----------------------- *)

                      (*  EXPLICIT_ACTUAL_PARAMETER ::= EXPRESSION | variable_NAME *)

                      (*----------------------- *)
                      (* 6.5  Return Statement  *)
                      (*----------------------- *)

                      (*  RETURN_STATEMENT ::= return [EXPRESSION]; *)

                      NReturnStatement =
                        (* Sloc points to RETURN *)
                        Expression : NClassNode (*  (points to an Empty object if no expression present) *)
                        StoragePool : NClassNode 
                        ProcedureToCall : NClassNode 
                        [ DoTagCheck : BOOLEAN ] 
                        ReturnType : NClassNode 
                        [ ByRef : BOOLEAN ] 
                      .

                      (*  Note: if a range check is required, then DoRangeCheck is set *)
                      (*  on the Expression. The range check is against ReturnType. *)

                      (*-------------------------- *)
                      (* 7.1  Package Declaration  *)
                      (*-------------------------- *)

                      (*  PACKAGE_DECLARATION ::= PACKAGE_SPECIFICATION; *)

                      (*  Note: the activation chain entity for a package spec is used for *)
                      (*  all tasks declared in the package spec, or in the package body. *)

                      NPackageDeclaration =
                        (* Sloc points to PACKAGE *)
                        Specification : NClassNode 
                        CorrespondingBody : NClassNode 
                        ParentSpec : NClassNode 
                        ActivationChainEntity : NClassNode 
                      .

                      (*---------------------------- *)
                      (* 7.1  Package Specification  *)
                      (*---------------------------- *)

                      (*  PACKAGE_SPECIFICATION ::= *)
                      (*    package DEFINING_PROGRAM_UNIT_NAME is *)
                      (*      {BASIC_DECLARATIVE_ITEM} *)
                      (*    [private *)
                      (*      {BASIC_DECLARATIVE_ITEM}] *)
                      (*    end [[PARENT_UNIT_NAME .] IDENTIFIER] *)

                      NPackageSpecification =
                        (* Sloc points to PACKAGE *)
                        DefiningUnitName : NClassNode 
                        VisibleDeclarations : ClassList 
                        PrivateDeclarations : ClassList (*  (points to a NoList object if no private *)
                          (* part present) *)
                        GenericParent : NClassNode 
                      .

                      (*------------------- *)
                      (* 7.1  Package Body  *)
                      (*------------------- *)

                      (*  PACKAGE_BODY ::= *)
                      (*    package body DEFINING_PROGRAM_UNIT_NAME is *)
                      (*      DECLARATIVE_PART *)
                      (*    [begin *)
                      (*      HANDLED_SEQUENCE_OF_STATEMENTS] *)
                      (*    end [[PARENT_UNIT_NAME .] IDENTIFIER]; *)

                      NPackageBody =
                        (* Sloc points to PACKAGE *)
                        DefiningUnitName : NClassNode 
                        Declarations : ClassList 
                        HandledStatementSequence : NClassNode (*  (points to an Empty object if not present) *)
                        CorrespondingSpec : NClassNode 
                        [ WasOriginallyStub : BOOLEAN ] 
                      .

                      (*------------------------------- *)
                      (* 7.4  Private Type Declaration  *)
                      (*------------------------------- *)

                      (*  PRIVATE_TYPE_DECLARATION ::= *)
                      (*    type DEFINING_IDENTIFIER [DISCRIMINANT_PART] *)
                      (*      is [[abstract] tagged] [limited] private; *)

                      (*  Note: TAGGED is not permitted in Ada 83 mode *)

                      NPrivateTypeDeclaration =
                        (* Sloc points to TYPE *)
                        DefiningIdentifier : NClassEntity 
                        DiscriminantSpecifications : ClassList (*  (points to a NoList object if no *)
                          (*   discriminant part) *)
                        [ UnknownDiscriminantsPresent : BOOLEAN ] (*  set if (<>) discriminant *)
                        [ AbstractPresent : BOOLEAN ] 
                        [ TaggedPresent : BOOLEAN ] 
                        [ LimitedPresent : BOOLEAN ] 
                      .

                      (*------------------------------------ *)
                      (* 7.4  Private Extension Declaration  *)
                      (*------------------------------------ *)

                      (*  PRIVATE_EXTENSION_DECLARATION ::= *)
                      (*    type DEFINING_IDENTIFIER [DISCRIMINANT_PART] is *)
                      (*      [abstract] new ancestor_SUBTYPE_INDICATION with private; *)

                      (*  Note: private extension declarations are not allowed in Ada 83 mode *)

                      NPrivateExtensionDeclaration =
                        (* Sloc points to TYPE *)
                        DefiningIdentifier : NClassEntity 
                        DiscriminantSpecifications : ClassList (*  (points to a NoList object if no *)
                          (*   discriminant part) *)
                        [ UnknownDiscriminantsPresent : BOOLEAN ] (*  set if (<>) discriminant *)
                        [ AbstractPresent : BOOLEAN ] 
                        SubtypeIndication : NClassNode 
                      .

                      (*----------------- *)
                      (* 8.4  Use Clause  *)
                      (*----------------- *)

                      (*  USE_CLAUSE ::= USE_PACKAGE_CLAUSE | USE_TYPE_CLAUSE *)

                      (*------------------------- *)
                      (* 8.4  Use Package Clause  *)
                      (*------------------------- *)

                      (*  USE_PACKAGE_CLAUSE ::= use package_NAME {, package_NAME}; *)

                      NUsePackageClause =
                        (* Sloc points to USE *)
                        Names : ClassList 
                        NextUseClause : NClassNode 
                        HiddenByUseClause : ClassElist 
                      .

                      (*---------------------- *)
                      (* 8.4  Use Type Clause  *)
                      (*---------------------- *)

                      (*  USE_TYPE_CLAUSE ::= use type SUBTYPE_MARK {, SUBTYPE_MARK}; *)

                      (*  Note: use type clause is not permitted in Ada 83 mode *)

                      NUseTypeClause =
                        (* Sloc points to USE *)
                        SubtypeMarks : ClassList 
                        NextUseClause : NClassNode 
                        HiddenByUseClause : ClassElist 
                      .

                      (*--------------------------- *)
                      (* 8.5  Renaming Declaration  *)
                      (*--------------------------- *)

                      (*  RENAMING_DECLARATION ::= *)
                      (*    OBJECT_RENAMING_DECLARATION *)
                      (*  | EXCEPTION_RENAMING_DECLARATION *)
                      (*  | PACKAGE_RENAMING_DECLARATION *)
                      (*  | SUBPROGRAM_RENAMING_DECLARATION *)
                      (*  | GENERIC_RENAMING_DECLARATION *)

                      (*---------------------------------- *)
                      (* 8.5  Object Renaming Declaration  *)
                      (*---------------------------------- *)

                      (*  OBJECT_RENAMING_DECLARATION ::= *)
                      (*    DEFINING_IDENTIFIER : SUBTYPE_MARK renames object_NAME; *)

                      NObjectRenamingDeclaration =
                        (* Sloc points to first identifier *)
                        DefiningIdentifier : NClassEntity 
                        SubtypeMark : NClassNode 
                        Name : NClassNode 
                      .

                      (*------------------------------------- *)
                      (* 8.5  Exception Renaming Declaration  *)
                      (*------------------------------------- *)

                      (*  EXCEPTION_RENAMING_DECLARATION ::= *)
                      (*    DEFINING_IDENTIFIER : exception renames exception_NAME; *)

                      NExceptionRenamingDeclaration =
                        (* Sloc points to first identifier *)
                        DefiningIdentifier : NClassEntity 
                        Name : NClassNode 
                      .

                      (*----------------------------------- *)
                      (* 8.5  Package Renaming Declaration  *)
                      (*----------------------------------- *)

                      (*  PACKAGE_RENAMING_DECLARATION ::= *)
                      (*    package DEFINING_PROGRAM_UNIT_NAME renames package_NAME; *)

                      NPackageRenamingDeclaration =
                        (* Sloc points to PACKAGE *)
                        DefiningUnitName : NClassNode 
                        Name : NClassNode 
                        ParentSpec : NClassNode 
                      .

                      (*-------------------------------------- *)
                      (* 8.5  Subprogram Renaming Declaration  *)
                      (*-------------------------------------- *)

                      (*  SUBPROGRAM_RENAMING_DECLARATION ::= *)
                      (*    SUBPROGRAM_SPECIFICATION renames callable_entity_NAME; *)

                      NSubprogramRenamingDeclaration =
                        (* Sloc points to RENAMES *)
                        Specification : NClassNode 
                        Name : NClassNode 
                        ParentSpec : NClassNode 
                        CorrespondingSpec : NClassNode 
                      .

                      (*------------------------------------- *)
                      (* 8.5.5  Generic Renaming Declaration  *)
                      (*------------------------------------- *)

                      (*  GENERIC_RENAMING_DECLARATION ::= *)
                      (*    generic package DEFINING_PROGRAM_UNIT_NAME *)
                      (*      renames generic_package_NAME *)
                      (*  | generic procedure DEFINING_PROGRAM_UNIT_NAME *)
                      (*      renames generic_procedure_NAME *)
                      (*  | generic function DEFINING_PROGRAM_UNIT_NAME *)
                      (*      renames generic_function_NAME *)

                      NGenericPackageRenamingDeclaration =
                        (* Sloc points to GENERIC *)
                        DefiningUnitName : NClassNode 
                        Name : NClassNode 
                        ParentSpec : NClassNode 
                      .

                      NGenericProcedureRenamingDeclaration =
                        (* Sloc points to GENERIC *)
                        DefiningUnitName : NClassNode 
                        Name : NClassNode 
                        ParentSpec : NClassNode 
                      .

                      NGenericFunctionRenamingDeclaration =
                        (* Sloc points to GENERIC *)
                        DefiningUnitName : NClassNode 
                        Name : NClassNode 
                        ParentSpec : NClassNode 
                      .

                      (*---------------------------- *)
                      (* 9.1  Task Type Declaration  *)
                      (*---------------------------- *)

                      (*  TASK_TYPE_DECLARATION ::= *)
                      (*    task type DEFINING_IDENTIFIER [KNOWN_DISCRIMINANT_PART] *)
                      (*      [is TASK_DEFINITITION]; *)

                      NTaskTypeDeclaration =
                        (* Sloc points to TASK *)
                        DefiningIdentifier : NClassEntity 
                        DiscriminantSpecifications : ClassList (*  (points to a NoList object if no *)
                                                          (*   discriminant part) *)
                        TaskDefinition : NClassNode (*  (points to an Empty object if not present) *)
                        CorrespondingBody : NClassNode 
                      .

                      (*------------------------------ *)
                      (* 9.1  Single Task Declaration  *)
                      (*------------------------------ *)

                      (*  SINGLE_TASK_DECLARATION ::= *)
                      (*    task DEFINING_IDENTIFIER [is TASK_DEFINITION]; *)

                      NSingleTaskDeclaration =
                        (* Sloc points to TASK *)
                        DefiningIdentifier : NClassEntity 
                        TaskDefinition : NClassNode (*  (points to an Empty object if not present) *)
                      .

                      (*---------------------- *)
                      (* 9.1  Task Definition  *)
                      (*---------------------- *)

                      (*  TASK_DEFINITION ::= *)
                      (*      {TASK_ITEM} *)
                      (*    [private *)
                      (*      {TASK_ITEM}] *)
                      (*    end [task_IDENTIFIER] *)

                      (*  Note: as a result of semantic analysis, the list of task items can *)
                      (*  include implicit type declarations resulting from entry families. *)

                      NTaskDefinition =
                        (* Sloc points to first token of task definition *)
                        VisibleDeclarations : ClassList 
                        PrivateDeclarations : ClassList (*  (points to a NoList object if no private part) *)
                        [ HasPriorityPragma : BOOLEAN ] 
                        [ HasStorageSizePragma : BOOLEAN ] 
                        [ HasTaskInfoPragma : BOOLEAN ] 
                      .

                      (*---------------- *)
                      (* 9.1  Task Item  *)
                      (*---------------- *)

                      (*  TASK_ITEM ::= ENTRY_DECLARATION | REPRESENTATION_CLAUSE *)

                      (*---------------- *)
                      (* 9.1  Task Body  *)
                      (*---------------- *)

                      (*  TASK_BODY ::= *)
                      (*    task body task_DEFINING_IDENTIFIER is *)
                      (*      DECLARATIVE_PART *)
                      (*    begin *)
                      (*      HANDLED_SEQUENCE_OF_STATEMENTS *)
                      (*    end [task_IDENTIFIER]; *)

                      (*  Gigi restriction: This node never appears. *)

                      NTaskBody =
                        (* Sloc points to TASK *)
                        DefiningIdentifier : NClassEntity 
                        Declarations : ClassList 
                        HandledStatementSequence : NClassNode 
                        [ IsTaskMaster : BOOLEAN ] 
                        ActivationChainEntity : NClassNode 
                        CorrespondingSpec : NClassNode 
                        [ WasOriginallyStub : BOOLEAN ] 
                      .

                      (*--------------------------------- *)
                      (* 9.4  Protected Type Declaration  *)
                      (*--------------------------------- *)

                      (*  PROTECTED_TYPE_DECLARATION ::= *)
                      (*    protected type DEFINING_IDENTIFIER [KNOWN_DISCRIMINANT_PART] *)
                      (*      is PROTECTED_DEFINITION; *)

                      (*  Note: protected type declarations are not permitted in Ada 83 mode *)

                      NProtectedTypeDeclaration =
                        (* Sloc points to PROTECTED *)
                        DefiningIdentifier : NClassEntity 
                        DiscriminantSpecifications : ClassList (*  (points to a NoList object if no *)
                                                          (*   discriminant part) *)
                        ProtectedDefinition : NClassNode 
                        CorrespondingBody : NClassNode 
                      .

                      (*----------------------------------- *)
                      (* 9.4  Single Protected Declaration  *)
                      (*----------------------------------- *)

                      (*  SINGLE_PROTECTED_DECLARATION ::= *)
                      (*    protected DEFINING_IDENTIFIER is PROTECTED_DEFINITION; *)

                      (*  Note: single protected declarations are not allowed in Ada 83 mode *)

                      NSingleProtectedDeclaration =
                        (* Sloc points to PROTECTED *)
                        DefiningIdentifier : NClassEntity 
                        ProtectedDefinition : NClassNode 
                      .

                      (*--------------------------- *)
                      (* 9.4  Protected Definition  *)
                      (*--------------------------- *)

                      (*  PROTECTED_DEFINITION ::= *)
                      (*      {PROTECTED_OPERATION_DECLARATION} *)
                      (*    [private *)
                      (*      {PROTECTED_ELEMENT_DECLARATION}] *)
                      (*    end [protected_IDENTIFIER] *)

                      NProtectedDefinition =
                        (* Sloc points to first token of protected definition *)
                        VisibleDeclarations : ClassList 
                        PrivateDeclarations : ClassList (*  (points to a NoList object if no private part) *)
                        [ HasPriorityPragma : BOOLEAN ] 
                      .

                      (*-------------------------------------- *)
                      (* 9.4  Protected Operation Declaration  *)
                      (*-------------------------------------- *)

                      (*  PROTECTED_OPERATION_DECLARATION ::= *)
                      (*    SUBPROGRAM_DECLARATION *)
                      (*  | ENTRY_DECLARATION *)
                      (*  | REPRESENTATION_CLAUSE *)

                      (*------------------------------------ *)
                      (* 9.4  Protected Element Declaration  *)
                      (*------------------------------------ *)

                      (*  PROTECTED_ELEMENT_DECLARATION ::= *)
                      (*    PROTECTED_OPERATION_DECLARATION | COMPONENT_DECLARATION *)

                      (*--------------------- *)
                      (* 9.4  Protected Body  *)
                      (*--------------------- *)

                      (*  PROTECTED_BODY ::= *)
                      (*    protected body DEFINING_IDENTIFIER is *)
                      (*      {PROTECTED_OPERATION_ITEM} *)
                      (*    end [protected_IDENTIFIER]; *)

                      (*  Note: protected bodies are not allowed in Ada 83 mode *)

                      (*  Gigi restriction: This node never appears. *)

                      NProtectedBody =
                        (* Sloc points to PROTECTED *)
                        DefiningIdentifier : NClassEntity 
                        Declarations : ClassList (*  protected operation items (and pragmas) *)
                        CorrespondingSpec : NClassNode 
                        [ WasOriginallyStub : BOOLEAN ] 
                      .

                      (*------------------------------- *)
                      (* 9.4  Protected Operation Item  *)
                      (*------------------------------- *)

                      (*  PROTECTED_OPERATION_ITEM ::= *)
                      (*    SUBPROGRAM_DECLARATION *)
                      (*  | SUBPROGRAM_BODY *)
                      (*  | ENTRY_BODY *)
                      (*  | REPRESENTATION_CLAUSE *)

                      (*-------------------------- *)
                      (* 9.5.2  Entry Declaration  *)
                      (*-------------------------- *)

                      (*  ENTRY_DECLARATION ::= *)
                      (*    entry DEFINING_IDENTIFIER *)
                      (*      [(DISCRETE_SUBTYPE_DEFINITION)] PARAMETER_PROFILE; *)

                      NEntryDeclaration =
                        (* Sloc points to ENTRY *)
                        DefiningIdentifier : NClassEntity 
                        DiscreteSubtypeDefinition : NClassNode (*  (points to an Empty object if not present) *)
                        ParameterSpecifications : ClassList (*  (points to a NoList object if no formal part) *)
                      .

                      (*------------------------- *)
                      (* 9.5.2  Accept statement  *)
                      (*------------------------- *)

                      (*  ACCEPT_STATEMENT ::= *)
                      (*    accept entry_DIRECT_NAME *)
                      (*      [(ENTRY_INDEX)] PARAMETER_PROFILE [do *)
                      (*        HANDLED_SEQUENCE_OF_STATEMENTS *)
                      (*    end [entry_IDENTIFIER]]; *)

                      (*  Gigi restriction: This node never appears. *)

                      (*  Note: there are no explicit declarations allowed in an accept *)
                      (*  statement. However, the implicit declarations for any statement *)
                      (*  identifiers (labels and block/loop identifiers) are declarations *)
                      (*  that belong logically to the accept statement, and that is why *)
                      (*  there is a Declarations field in this node. *)

                      NAcceptStatement =
                        (* Sloc points to ACCEPT *)
                        EntryDirectName : NClassNode 
                        EntryIndex : NClassNode (*  (points to an Empty object if not present) *)
                        ParameterSpecifications : ClassList (*  (points to a NoList object if no formal part) *)
                        HandledStatementSequence : NClassNode 
                        Declarations : ClassList (*  (points to a NoList object if no declarations) *)
                      .

                      (*-------------------- *)
                      (* 9.5.2  Entry Index  *)
                      (*-------------------- *)

                      (*  ENTRY_INDEX ::= EXPRESSION *)

                      (*------------------- *)
                      (* 9.5.2  Entry Body  *)
                      (*------------------- *)

                      (*  ENTRY_BODY ::= *)
                      (*    entry DEFINING_IDENTIFIER ENTRY_BODY_FORMAL_PART ENTRY_BARRIER is *)
                      (*      DECLARATIVE_PART *)
                      (*    begin *)
                      (*      HANDLED_SEQUENCE_OF_STATEMENTS *)
                      (*    end [entry_IDENTIFIER]; *)

                      (*  ENTRY_BARRIER ::= when CONDITION *)

                      (*  Note: we store the CONDITION of the ENTRY_BARRIER in the node for *)
                      (*  the ENTRY_BODY_FORMAL_PART to avoid the NEntryBody node getting *)
                      (*  too full (it would otherwise have too many fields) *)

                      (*  Gigi restriction: This node never appears. *)

                      NEntryBody =
                        (* Sloc points to ENTRY *)
                        DefiningIdentifier : NClassEntity 
                        EntryBodyFormalPart : NClassNode 
                        Declarations : ClassList 
                        HandledStatementSequence : NClassNode 
                        ActivationChainEntity : NClassNode 
                      .

                      (*------------------------------- *)
                      (* 9.5.2  Entry Body Formal Part  *)
                      (*------------------------------- *)

                      (*  ENTRY_BODY_FORMAL_PART ::= *)
                      (*    [(ENTRY_INDEX_SPECIFICATION)] PARAMETER_PROFILE *)

                      (*  Note that an entry body formal part node is present even if it is *)
                      (*  empty. This reflects the grammar, in which it is the components of *)
                      (*  the entry body formal part that are optional, not the entry body *)
                      (*  formal part itself. Also this means that the barrier condition *)
                      (*  always has somewhere to be stored. *)

                      (*  Gigi restriction: This node never appears. *)

                      NEntryBodyFormalPart =
                        EntryIndexSpecification : NClassNode (*  (points to an Empty object if not present) *)
                        ParameterSpecifications : ClassList (*  (points to a NoList object if no formal part) *)
                        Condition : NClassNode (*  from entry barrier of entry body *)
                      .

                      (*---------------------- *)
                      (* 9.5.2  Entry Barrier  *)
                      (*---------------------- *)

                      (*  ENTRY_BARRIER ::= when CONDITION *)

                      (*---------------------------------- *)
                      (* 9.5.2  Entry Index Specification  *)
                      (*---------------------------------- *)

                      (*  ENTRY_INDEX_SPECIFICATION ::= *)
                      (*    for DEFINING_IDENTIFIER in DISCRETE_SUBTYPE_DEFINITION *)

                      (*  Gigi restriction: This node never appears. *)

                      NEntryIndexSpecification =
                        (* Sloc points to FOR *)
                        DefiningIdentifier : NClassEntity 
                        DiscreteSubtypeDefinition : NClassNode 
                      .

                      (*----------------------------- *)
                      (* 9.5.3  Entry Call Statement  *)
                      (*----------------------------- *)

                      (*  ENTRY_CALL_STATEMENT ::= entry_NAME [ACTUAL_PARAMETER_PART]; *)

                      (*  The parser may generate a procedure call for this construct. The *)
                      (*  semantic pass must correct this misidentification where needed. *)

                      (*  Gigi restriction: This node never appears. *)

                      NEntryCallStatement =
                        (* Sloc points to first token of name *)
                        Name : NClassNode 
                        ParameterAssociations : ClassList (*  (points to a NoList object if no *)
                                                     (*   actual parameter part) *)
                        FirstNamedActual : NClassNode 
                      .

                      (*-------------------------- *)
                      (* 9.5.4  Requeue Statement  *)
                      (*-------------------------- *)

                      (*  REQUEUE_STATEMENT ::= requeue entry_NAME [with abort]; *)

                      (*  Note: requeue statements are not permitted in Ada 83 mode *)

                      (*  Gigi restriction: This node never appears. *)

                      NRequeueStatement =
                        (* Sloc points to REQUEUE *)
                        Name : NClassNode 
                        [ AbortPresent : BOOLEAN ] 
                      .

                      (*---------------------- *)
                      (* 9.6  Delay Statement  *)
                      (*---------------------- *)

                      (*  DELAY_STATEMENT ::= *)
                      (*    DELAY_UNTIL_STATEMENT *)
                      (*  | DELAY_RELATIVE_STATEMENT *)

                      (*---------------------------- *)
                      (* 9.6  Delay Until Statement  *)
                      (*---------------------------- *)

                      (*  DELAY_UNTIL_STATEMENT ::= delay until delay_EXPRESSION; *)

                      (*  Note: delay until statements are not permitted in Ada 83 mode *)

                      (*  Gigi restriction: This node never appears. *)

                      NDelayUntilStatement =
                        (* Sloc points to DELAY *)
                        Expression : NClassNode 
                      .

                      (*------------------------------- *)
                      (* 9.6  Delay Relative Statement  *)
                      (*------------------------------- *)

                      (*  DELAY_RELATIVE_STATEMENT ::= delay delay_EXPRESSION; *)

                      (*  Gigi restriction: This node never appears. *)

                      NDelayRelativeStatement =
                        (* Sloc points to DELAY *)
                        Expression : NClassNode 
                      .

                      (*----------------------- *)
                      (* 9.7  Select Statement  *)
                      (*----------------------- *)

                      (*  SELECT_STATEMENT ::= *)
                      (*    SELECTIVE_ACCEPT *)
                      (*  | TIMED_ENTRY_CALL *)
                      (*  | CONDITIONAL_ENTRY_CALL *)
                      (*  | ASYNCHRONOUS_SELECT *)

                      (*------------------------- *)
                      (* 9.7.1  Selective Accept  *)
                      (*------------------------- *)

                      (*  SELECTIVE_ACCEPT ::= *)
                      (*    select *)
                      (*      [GUARD] *)
                      (*        SELECT_ALTERNATIVE *)
                      (*    {or *)
                      (*      [GUARD] *)
                      (*        SELECT_ALTERNATIVE} *)
                      (*    [else *)
                      (*      SEQUENCE_OF_STATEMENTS] *)
                      (*    end select; *)

                      (*  Gigi restriction: This node never appears. *)

                      (*  Note: the guard expression, if present, appears in the node for *)
                      (*  the select alternative. *)

                      NSelectiveAccept =
                        (* Sloc points to SELECT *)
                        SelectAlternatives : ClassList 
                        ElseStatements : ClassList (*  (points to a NoList object if no else part) *)
                      .

                      (*-------------- *)
                      (* 9.7.1  Guard  *)
                      (*-------------- *)

                      (*  GUARD ::= when CONDITION => *)

                      (*  As noted above, the CONDITION that is part of a GUARD is included *)
                      (*  in the node for the select alernative for convenience. *)

                      (*--------------------------- *)
                      (* 9.7.1  Select Alternative  *)
                      (*--------------------------- *)

                      (*  SELECT_ALTERNATIVE ::= *)
                      (*    ACCEPT_ALTERNATIVE *)
                      (*  | DELAY_ALTERNATIVE *)
                      (*  | TERMINATE_ALTERNATIVE *)

                      (*--------------------------- *)
                      (* 9.7.1  Accept Alternative  *)
                      (*--------------------------- *)

                      (*  ACCEPT_ALTERNATIVE ::= *)
                      (*    ACCEPT_STATEMENT [SEQUENCE_OF_STATEMENTS] *)

                      (*  Gigi restriction: This node never appears. *)

                      NAcceptAlternative =
                        (* Sloc points to ACCEPT *)
                        AcceptStatement : NClassNode 
                        Condition : NClassNode (*  from the guard (points to an Empty object if no guard present) *)
                        Statements : ClassList (*  (points to an Empty object_List if no statements) *)
                        PragmasBefore : ClassList (*  pragmas before alt (points to a NoList object if none) *)
                      .

                      (*-------------------------- *)
                      (* 9.7.1  Delay Alternative  *)
                      (*-------------------------- *)

                      (*  DELAY_ALTERNATIVE ::= *)
                      (*    DELAY_STATEMENT [SEQUENCE_OF_STATEMENTS] *)

                      (*  Gigi restriction: This node never appears. *)

                      NDelayAlternative =
                        (* Sloc points to DELAY *)
                        DelayStatement : NClassNode 
                        Condition : NClassNode (*  from the guard (points to an Empty object if no guard present) *)
                        Statements : ClassList (*  (points to an Empty object_List if no statements) *)
                        PragmasBefore : ClassList (*  pragmas before alt (points to a NoList object if none) *)
                      .

                      (*------------------------------ *)
                      (* 9.7.1  Terminate Alternative  *)
                      (*------------------------------ *)

                      (*  TERMINATE_ALTERNATIVE ::= terminate; *)

                      (*  Gigi restriction: This node never appears. *)

                      NTerminateAlternative =
                        (* Sloc points to TERMINATE *)
                        Condition : NClassNode (*  from the guard (points to an Empty object if no guard present) *)
                        PragmasBefore : ClassList (*  pragmas before alt (points to a NoList object if none) *)
                        PragmasAfter : ClassList (*  pragmas after alt (points to a NoList object if none) *)
                      .

                      (*------------------------- *)
                      (* 9.7.2  Timed Entry Call  *)
                      (*------------------------- *)

                      (*  TIMED_ENTRY_CALL ::= *)
                      (*    select *)
                      (*      ENTRY_CALL_ALTERNATIVE *)
                      (*    or *)
                      (*      DELAY_ALTERNATIVE *)
                      (*    end select; *)

                      (*  Gigi restriction: This node never appears. *)

                      NTimedEntryCall =
                        (* Sloc points to SELECT *)
                        EntryCallAlternative : NClassNode 
                        DelayAlternative : NClassNode 
                      .

                      (*------------------------------- *)
                      (* 9.7.2  Entry Call Alternative  *)
                      (*------------------------------- *)

                      (*  ENTRY_CALL_ALTERNATIVE ::= *)
                      (*    ENTRY_CALL_STATEMENT [SEQUENCE_OF_STATEMENTS] *)

                      (*  Gigi restriction: This node never appears. *)

                      NEntryCallAlternative =
                        (* Sloc points to first token of entry call statement *)
                        EntryCallStatement : NClassNode 
                        Statements : ClassList (*  (points to an Empty object_List if no statements) *)
                        PragmasBefore : ClassList (*  pragmas before alt (points to a NoList object if none) *)
                      .

                      (*------------------------------- *)
                      (* 9.7.3  Conditional Entry Call  *)
                      (*------------------------------- *)

                      (*  CONDITIONAL_ENTRY_CALL ::= *)
                      (*    select *)
                      (*      ENTRY_CALL_ALTERNATIVE *)
                      (*    else *)
                      (*      SEQUENCE_OF_STATEMENTS *)
                      (*    end select; *)

                      (*  Gigi restriction: This node never appears. *)

                      NConditionalEntryCall =
                        (* Sloc points to SELECT *)
                        EntryCallAlternative : NClassNode 
                        ElseStatements : ClassList 
                      .

                      (*---------------------------- *)
                      (* 9.7.4  Asynchronous Select  *)
                      (*---------------------------- *)

                      (*  ASYNCHRONOUS_SELECT ::= *)
                      (*    select *)
                      (*      TRIGGERING_ALTERNATIVE *)
                      (*    then abort *)
                      (*      ABORTABLE_PART *)
                      (*    end select; *)

                      (*  Note: asynchronous select is not permitted in Ada 83 mode *)

                      (*  Gigi restriction: This node never appears. *)

                      NAsynchronousSelect =
                        (* Sloc points to SELECT *)
                        TriggeringAlternative : NClassNode 
                        AbortablePart : NClassNode 
                      .

                      (*------------------------------- *)
                      (* 9.7.4  Triggering Alternative  *)
                      (*------------------------------- *)

                      (*  TRIGGERING_ALTERNATIVE ::= *)
                      (*    TRIGGERING_STATEMENT [SEQUENCE_OF_STATEMENTS] *)

                      (*  Gigi restriction: This node never appears. *)

                      NTriggeringAlternative =
                        (* Sloc points to first token of triggering statement *)
                        TriggeringStatement : NClassNode 
                        Statements : ClassList (*  (points to an Empty object_List if no statements) *)
                        PragmasBefore : ClassList (*  pragmas before alt (points to a NoList object if none) *)
                      .

                      (*----------------------------- *)
                      (* 9.7.4  Triggering Statement  *)
                      (*----------------------------- *)

                      (*  TRIGGERING_STATEMENT ::= ENTRY_CALL_STATEMENT | DELAY_STATEMENT *)

                      (*----------------------- *)
                      (* 9.7.4  Abortable Part  *)
                      (*----------------------- *)

                      (*  ABORTABLE_PART ::= SEQUENCE_OF_STATEMENTS *)

                      (*  Gigi restriction: This node never appears. *)

                      NAbortablePart =
                        (* Sloc points to ABORT *)
                        Statements : ClassList 
                      .

                      (*---------------------- *)
                      (* 9.8  Abort Statement  *)
                      (*---------------------- *)

                      (*  ABORT_STATEMENT ::= abort task_NAME {, task_NAME}; *)

                      (*  Gigi restriction: This node never appears. *)

                      NAbortStatement =
                        (* Sloc points to ABORT *)
                        Names : ClassList 
                      .

                      (*--------------------- *)
                      (* 10.1.1  Compilation  *)
                      (*--------------------- *)

                      (*  COMPILATION ::= {COMPILATION_UNIT} *)

                      (*  There is no explicit node in the tree for a compilation, since in *)
                      (*  general the compiler is processing only a single compilation unit *)
                      (*  at a time. It is possible to parse multiple units in syntax check *)
                      (*  only mode, but they the trees are discarded in any case. *)

                      (*-------------------------- *)
                      (* 10.1.1  Compilation Unit  *)
                      (*-------------------------- *)

                      (*  COMPILATION_UNIT ::= *)
                      (*    CONTEXT_CLAUSE LIBRARY_ITEM *)
                      (*  | CONTEXT_CLAUSE SUBUNIT *)

                      (*  The NCompilationUnit node itself respresents the above syntax. *)
                      (*  However, there are two additional items not reflected in the above *)
                      (*  syntax. First we have the global declarations that are added by the *)
                      (*  code generator. These are outer level declarations (so they cannot *)
                      (*  be represented as being inside the units). An example is the wrapper *)
                      (*  subprograms that are created to do ABE checking. As always a list of *)
                      (*  declarations can contain actions as well (i.e. statements), and such *)
                      (*  statements are executed as part of the elaboration of the unit. Note *)
                      (*  that all such declarations are elaborated before the library unit. *)

                      (*  Similarly, certain actions need to be elaborated at the completion *)
                      (*  of elaboration of the library unit (notably the statement that sets *)
                      (*  the BOOLEAN flag indicating that elaboration is complete). *)

                      (*  The third item not reflected in the syntax is pragmas that appear *)
                      (*  after the compilation unit. As always pragmas are a problem since *)
                      (*  they are not part of the formal syntax, but can be stuck into the *)
                      (*  source following a set of ad hoc rules, and we have to find an ad *)
                      (*  hoc way of sticking them into the tree. For pragmas that appear *)
                      (*  before the library unit, we just consider them to be part of the *)
                      (*  context clause, and pragmas can appear in the ContextItems list *)
                      (*  of the compilation unit. However, pragmas can also appear after *)
                      (*  the library item. *)

                      (*  To deal with all these problems, we create an auxiliary node for *)
                      (*  a compilation unit, referenced from the NCompilationUnit node *)
                      (*  that contains these three items. *)

                      NCompilationUnit =
                        (* Sloc points to first token of defining unit name *)
                        LibraryUnit : NClassNode (*  corresponding/parent spec/body *)
                        ContextItems : ClassList (*  context items and pragmas preceding unit *)
                        [ PrivatePresent : BOOLEAN ] (*  set if library unit has private keyword *)
                        Unit : NClassNode (*  library item or subunit *)
                        AuxDeclsNode : NClassNode (*  points to the NCompilationUnitAux node *)
                        [ HasNoElabCode : BOOLEAN ] 
                        [ BodyRequired : BOOLEAN ] (*  set for spec if body is required *)
                        [ ActsAsSpec : BOOLEAN ] (*  flag for subprogram body with no spec *)
                        FirstInlinedSubprogram : NClassEntity 
                      .

                      NCompilationUnitAux =
                        (* Sloc is a copy of the Sloc from the NCompilationUnit node *)
                        Declarations : ClassList (*  (points to a NoList object if no global declarations) *)
                        Actions : ClassList (*  (points to a NoList object if no actions) *)
                        PragmasAfter : ClassList (*  pragmas after unit (points to a NoList object if none) *)
                      .

                      (*---------------------- *)
                      (* 10.1.1  Library Item  *)
                      (*---------------------- *)

                      (*  LIBRARY_ITEM ::= *)
                      (*    [private] LIBRARY_UNIT_DECLARATION *)
                      (*  | LIBRARY_UNIT_BODY *)
                      (*  | [private] LIBRARY_UNIT_RENAMING_DECLARATION *)

                      (*  Note: PRIVATE is not allowed in Ada 83 mode *)

                      (*  There is no explicit node in the tree for library item, instead *)
                      (*  the declaration or body, and the flag for private if present, *)
                      (*  appear in the NCompilationUnit clause. *)

                      (*------------------------------------ *)
                      (* 10.1.1  Library Unit Declararation  *)
                      (*------------------------------------ *)

                      (*  LIBRARY_UNIT_DECLARATION ::= *)
                      (*    SUBPROGRAM_DECLARATION | PACKAGE_DECLARATION *)
                      (*  | GENERIC_DECLARATION    | GENERIC_INSTANTIATION *)

                      (*--------------------------------------------- *)
                      (* 10.1.1  Library Unit Renaming Declararation  *)
                      (*--------------------------------------------- *)

                      (*  LIBRARY_UNIT_RENAMING_DECLARATION ::= *)
                      (*    PACKAGE_RENAMING_DECLARATION *)
                      (*  | GENERIC_RENAMING_DECLARATION *)
                      (*  | SUBPROGRAM_RENAMING_DECLARATION *)

                      (*--------------------------- *)
                      (* 10.1.1  Library unit body  *)
                      (*--------------------------- *)

                      (*  LIBRARY_UNIT_BODY ::= SUBPROGRAM_BODY | PACKAGE_BODY *)

                      (*-------------------------- *)
                      (* 10.1.1  Parent Unit Name  *)
                      (*-------------------------- *)

                      (*  PARENT_UNIT_NAME ::= NAME *)

                      (*------------------------ *)
                      (* 10.1.2  Context clause  *)
                      (*------------------------ *)

                      (*  CONTEXT_CLAUSE ::= {CONTEXT_ITEM} *)

                      (*  The context clause can include pragmas, and any pragmas that appear *)
                      (*  before the context clause proper (i.e. all configuration pragmas, *)
                      (*  also appear at the front of this list). *)

                      (*---------------------- *)
                      (* 10.1.2  Context_Item  *)
                      (*---------------------- *)

                      (*  CONTEXT_ITEM ::= WITH_CLAUSE | USE_CLAUSE *)

                      (*--------------------- *)
                      (* 10.1.2  With clause  *)
                      (*--------------------- *)

                      (*  WITH_CLAUSE ::= *)
                      (*    with library_unit_NAME {,library_unit_NAME}; *)

                      (*  A separate With clause is built for each name, so that we have *)
                      (*  a CorrespondingSpec field for each with'ed spec. The flags *)
                      (*  FirstName and LastName are used to reconstruct the exact *)
                      (*  source form. When a list of names appears in one with clause, *)
                      (*  the first name in the list has FirstName set, and the last *)
                      (*  has LastName set. If the with clause has only one name, then *)
                      (*  both of the flags FirstName and LastName are set in this name. *)

                      (*  Note: in the case of implicit with's that are installed by the *)
                      (*  Rtsfind routine, ImplicitWith is set, and the Sloc is typically *)
                      (*  set to Standard_Location, but it is incorrect to test the Sloc *)
                      (*  to find out if a with clause is implicit, test the flag instead. *)

                      NWithClause =
                        (* Sloc points to first token of library unit name *)
                        Name : NClassNode 
                        LibraryUnit : NClassNode 
                        CorrespondingSpec : NClassNode 
                        [ FirstName : BOOLEAN ] (*  (set to True if first name or only one name) *)
                        [ LastName : BOOLEAN ] (*  (set to True if last name or only one name) *)
                        [ ContextInstalled : BOOLEAN ] 
                        [ ElaboratePresent : BOOLEAN ] 
                        [ ElaborateAllPresent : BOOLEAN ] 
                        [ ImplicitWith : BOOLEAN ] 
                      .

                      (*----------------- *)
                      (* 10.2  Body stub  *)
                      (*----------------- *)

                      (*  BODY_STUB ::= *)
                      (*    SUBPROGRAM_BODY_STUB *)
                      (*  | PACKAGE_BODY_STUB *)
                      (*  | TASK_BODY_STUB *)
                      (*  | PROTECTED_BODY_STUB *)

                      (*------------------------------ *)
                      (* 10.1.3  Subprogram Body Stub  *)
                      (*------------------------------ *)

                      (*  SUBPROGRAM_BODY_STUB ::= *)
                      (*    SUBPROGRAM_SPECIFICATION is separate; *)

                      NSubprogramBodyStub =
                        (* Sloc points to FUNCTION or PROCEDURE *)
                        Specification : NClassNode 
                        LibraryUnit : NClassNode (*  points to the subunit *)
                        CorrespondingBody : NClassNode 
                      .

                      (*--------------------------- *)
                      (* 10.1.3  Package Body Stub  *)
                      (*--------------------------- *)

                      (*  PACKAGE_BODY_STUB ::= *)
                      (*    package body DEFINING_IDENTIFIER is separate; *)

                      NPackageBodyStub =
                        (* Sloc points to PACKAGE *)
                        DefiningIdentifier : NClassEntity 
                        LibraryUnit : NClassNode (*  points to the subunit *)
                        CorrespondingBody : NClassNode 
                      .

                      (*------------------------ *)
                      (* 10.1.3  Task Body Stub  *)
                      (*------------------------ *)

                      (*  TASK_BODY_STUB ::= *)
                      (*    task body DEFINING_IDENTIFIER is separate; *)

                      NTaskBodyStub =
                        (* Sloc points to TASK *)
                        DefiningIdentifier : NClassEntity 
                        LibraryUnit : NClassNode (*  points to the subunit *)
                        CorrespondingBody : NClassNode 
                      .

                      (*----------------------------- *)
                      (* 10.1.3  Protected Body Stub  *)
                      (*----------------------------- *)

                      (*  PROTECTED_BODY_STUB ::= *)
                      (*    protected body DEFINING_IDENTIFIER is separate; *)

                      (*  Note: protected body stubs are not allowed in Ada 83 mode *)

                      NProtectedBodyStub =
                        (* Sloc points to PROTECTED *)
                        DefiningIdentifier : NClassEntity 
                        LibraryUnit : NClassNode (*  points to the subunit *)
                        CorrespondingBody : NClassNode 
                      .

                      (*----------------- *)
                      (* 10.1.3  Subunit  *)
                      (*----------------- *)

                      (*  SUBUNIT ::= separate (PARENT_UNIT_NAME) PROPER_BODY *)

                      NSubunit =
                        (* Sloc points to SEPARATE *)
                        Name : NClassNode (*  is the name of the parent unit *)
                        ProperBody : NClassNode (*  is the subunit body *)
                        CorrespondingStub : NClassNode (*  is the stub declaration for the unit. *)
                      .

                      (*----------------------------- *)
                      (* 11.1  Exception Declaration  *)
                      (*----------------------------- *)

                      (*  EXCEPTION_DECLARATION ::= DEFINING_IDENTIFIER_LIST : exception; *)

                      (*  For consistency with object declarations etc, the parser converts *)
                      (*  the case of multiple identifiers being declared to a series of *)
                      (*  declarations in which the expression is copied, using the MoreIds *)
                      (*  and PrevIds flags to remember the souce form as described in the *)
                      (*  section on "Handling of Defining Identifier Lists". *)

                      NExceptionDeclaration =
                        (* Sloc points to EXCEPTION *)
                        DefiningIdentifier : NClassEntity 
                        Expression : NClassNode 
                        [ MoreIds : BOOLEAN ] (*  (set to False if no more identifiers in list) *)
                        [ PrevIds : BOOLEAN ] (*  (set to False if no previous identifiers in list) *)
                      .

                      (*-------------------------------------- *)
                      (* 11.2  Handled Sequence Of Statements  *)
                      (*-------------------------------------- *)

                      (*  HANDLED_SEQUENCE_OF_STATEMENTS ::= *)
                      (*      SEQUENCE_OF_STATEMENTS *)
                      (*    [exception *)
                      (*      EXCEPTION_HANDLER *)
                      (*      {EXCEPTION_HANDLER}] *)
                      (*    [at end *)
                      (*      cleanup_procedure_call (param, param, param, ...);] *)

                      (*  The AT END phrase is a GNAT extension to provide for cleanups. It is *)
                      (*  used only internally currently, but is considered to be syntactic. *)
                      (*  At the moment, the only cleanup action allowed is a single call to *)
                      (*  a parameterless procedure, and the Identifier field of the node is *)
                      (*  the procedure to be called. Also there is a current restriction *)
                      (*  that exception handles and a cleanup cannot be present in the same *)
                      (*  frame, so at least one of ExceptionHandlers or the Identifier must *)
                      (*  be missing. *)

                      (*  The AT END cleanup handler protects only the sequence of statements *)
                      (*  (not the associated declarations of the parent), just like exception *)
                      (*  handlers. The big difference is that the cleanup procedure is called *)
                      (*  on either a normal or an abnormal exit from the statement sequence. *)

                      (*  Note: although in the Ada syntax, the sequence of statements can *)
                      (*  only contain statements, at the tree level, it is fine to mix in *)
                      (*  declarations into this statement sequence. This is used in some *)
                      (*  cases where a cleanup procedure is required to cover declarations *)
                      (*  as well as statements. *)

                      (*  Note: the list of ExceptionHandlers can contain pragmas as well *)
                      (*  as actual handlers. In practice these pragmas can only occur at *)
                      (*  the start of the list, since any pragmas occurring later on will *)
                      (*  be included in the statement list of the corresponding handler. *)

                      NHandledSequenceOfStatements =
                        (* Sloc points to first token of first statement *)
                        Statements : ClassList 
                        ExceptionHandlers : ClassList (*  (points to a NoList object if none present) *)
                        Identifier : NClassNode (*  (points to an Empty object if no clean up procedure) *)
                        NextFrame : NClassNode 
                        FirstRealStatement : NClassNode 
                        [ CodeRangeTaken : BOOLEAN ] 
                      .

                      (*  Note: the parent always contains a Declarations field which contains *)
                      (*  declarations associated with the handled sequence of statements. This *)
                      (*  is true even in the case of an accept statement (see description of *)
                      (*  the NAcceptStatement node). *)

                      (*------------------------- *)
                      (* 11.2  Exception Handler  *)
                      (*------------------------- *)

                      (*  EXCEPTION_HANDLER ::= *)
                      (*    when [CHOICE_PARAMETER_SPECIFICATION :] *)
                      (*      EXCEPTION_CHOICE {| EXCEPTION_CHOICE} => *)
                      (*        SEQUENCE_OF_STATEMENTS *)

                      (*  Note: choice parameter specification is not allowed in Ada 83 mode *)

                      NExceptionHandler =
                        (* Sloc points to WHEN *)
                        ChoiceParameter : NClassNode (*  (points to an Empty object if not present) *)
                        ExceptionChoices : ClassList 
                        Statements : ClassList 
                      .

                      (*-------------------------------------- *)
                      (* 11.2  Choice parameter specification  *)
                      (*-------------------------------------- *)

                      (*  CHOICE_PARAMETER_SPECIFICATION ::= DEFINING_IDENTIFIER *)

                      (*------------------------ *)
                      (* 11.2  Exception Choice  *)
                      (*------------------------ *)

                      (*  EXCEPTION_CHOICE ::= exception_NAME | others *)

                      (*  Except in the case of OTHERS, no explicit node appears in the tree *)
                      (*  for exception choice. Instead the exception name appears directly. *)
                      (*  An OTHERS choice is represented by a NOthersChoice node (see *)
                      (*  section 3.8.1. *)

                      (*  Note: for the exception choice created for an at end handler, the *)
                      (*  exception choice is an NOthersChoice node with AllOthers set. *)

                      (*----------------------- *)
                      (* 11.3  Raise Statement  *)
                      (*----------------------- *)

                      (*  RAISE_STATEMENT ::= raise [exception_NAME]; *)

                      NRaiseStatement =
                        (* Sloc points to RAISE *)
                        Name : NClassNode (*  (points to an Empty object if no exception name present) *)
                      .

                      (*--------------------------- *)
                      (* 12.1  Generic Declaration  *)
                      (*--------------------------- *)

                      (*  GENERIC_DECLARATION ::= *)
                      (*    GENERIC_SUBPROGRAM_DECLARATION | GENERIC_PACKAGE_DECLARATION *)

                      (*-------------------------------------- *)
                      (* 12.1  Generic Subprogram Declaration  *)
                      (*-------------------------------------- *)

                      (*  GENERIC_SUBPROGRAM_DECLARATION ::= *)
                      (*    GENERIC_FORMAL_PART SUBPROGRAM_SPECIFICATION; *)

                      (*  Note: GenericFormalDeclarations can include pragmas *)

                      NGenericSubprogramDeclaration =
                        (* Sloc points to GENERIC *)
                        Specification : NClassNode (*  subprogram specification *)
                        CorrespondingBody : NClassNode 
                        GenericFormalDeclarations : ClassList (*  from generic formal part *)
                        ParentSpec : NClassNode 
                      .

                      (*----------------------------------- *)
                      (* 12.1  Generic Package Declaration  *)
                      (*----------------------------------- *)

                      (*  GENERIC_PACKAGE_DECLARATION ::= *)
                      (*    GENERIC_FORMAL_PART PACKAGE_SPECIFICATION; *)

                      (*  Note: when we do generics right, the ActivationChainEntity entry *)
                      (*  for this node can be removed (since the expander won't see generic *)
                      (*  units any more)???. *)

                      (*  Note: GenericFormalDeclarations can include pragmas *)

                      NGenericPackageDeclaration =
                        (* Sloc points to GENERIC *)
                        Specification : NClassNode (*  package specification *)
                        CorrespondingBody : NClassNode 
                        GenericFormalDeclarations : ClassList (*  from generic formal part *)
                        ParentSpec : NClassNode 
                        ActivationChainEntity : NClassNode 
                      .

                      (*--------------------------- *)
                      (* 12.1  Generic Formal Part  *)
                      (*--------------------------- *)

                      (*  GENERIC_FORMAL_PART ::= *)
                      (*    generic {GENERIC_FORMAL_PARAMETER_DECLARATION | USE_CLAUSE} *)

                      (*-------------------------------------------- *)
                      (* 12.1  Generic Formal Parameter Declaration  *)
                      (*-------------------------------------------- *)

                      (*  GENERIC_FORMAL_PARAMETER_DECLARATION ::= *)
                      (*    FORMAL_OBJECT_DECLARATION *)
                      (*  | FORMAL_TYPE_DECLARATION *)
                      (*  | FORMAL_SUBPROGRAM_DECLARATION *)
                      (*  | FORMAL_PACKAGE_DECLARATION *)

                      (*----------------------------- *)
                      (* 12.3  Generic Instantiation  *)
                      (*----------------------------- *)

                      (*  GENERIC_INSTANTIATION ::= *)
                      (*    package DEFINING_PROGRAM_UNIT_NAME is *)
                      (*      new generic_package_NAME [GENERIC_ACTUAL_PART]; *)
                      (*  | procedure DEFINING_PROGRAM_UNIT_NAME is *)
                      (*      new generic_procedure_NAME [GENERIC_ACTUAL_PART]; *)
                      (*  | function DEFINING_DESIGNATOR is *)
                      (*      new generic_function_NAME [GENERIC_ACTUAL_PART]; *)

                      NPackageInstantiation =
                        (* Sloc points to PACKAGE *)
                        DefiningUnitName : NClassNode 
                        Name : NClassNode 
                        GenericAssociations : ClassList (*  (points to a NoList object if no *)
                                                   (*   generic actual part) *)
                        ParentSpec : NClassNode 
                        InstanceSpec : NClassNode 
                        [ ABEIsCertain : BOOLEAN ] 
                      .

                      NProcedureInstantiation =
                        (* Sloc points to PROCEDURE *)
                        DefiningUnitName : NClassNode 
                        Name : NClassNode 
                        ParentSpec : NClassNode 
                        GenericAssociations : ClassList (*  (points to a NoList object if no *)
                                                   (*   generic actual part) *)
                        InstanceSpec : NClassNode 
                        [ ABEIsCertain : BOOLEAN ] 
                      .

                      NFunctionInstantiation =
                        (* Sloc points to FUNCTION *)
                        DefiningUnitName : NClassNode 
                        Name : NClassNode 
                        GenericAssociations : ClassList (*  (points to a NoList object if no *)
                                                   (*   generic actual part) *)
                        ParentSpec : NClassNode 
                        InstanceSpec : NClassNode 
                        [ ABEIsCertain : BOOLEAN ] 
                      .

                      (*-------------------------- *)
                      (* 12.3 Generic Actual Part  *)
                      (*-------------------------- *)

                      (*  GENERIC_ACTUAL_PART ::= *)
                      (*    (GENERIC_ASSOCIATION {, GENERIC_ASSOCIATION}) *)

                      (*--------------------------- *)
                      (* 12.3  Generic Association  *)
                      (*--------------------------- *)

                      (*  GENERIC_ASSOCIATION ::= *)
                      (*    [generic_formal_parameter_SELECTOR_NAME =>] *)
                      (*      EXPLICIT_GENERIC_ACTUAL_PARAMETER *)

                      (*  Note: unlike the procedure call case, a generic association node *)
                      (*  is generated for every association, even if no formal is present. *)
                      (*  In this case the parser will leave the SelectorName field pointing *)
                      (*  to Empty, to be filled in later by the semantic pass. *)

                      NGenericAssociation =
                        (* Sloc points to first token of generic association *)
                        SelectorName : NClassNode (*  (points to an Empty object if no formal *)
                                                  (*   parameter selector name) *)
                        ExplicitGenericActualParameter : NClassNode 
                      .

                      (*----------------------------------------- *)
                      (* 12.3  Explicit Generic Actual Parameter  *)
                      (*----------------------------------------- *)

                      (*  EXPLICIT_GENERIC_ACTUAL_PARAMETER ::= *)
                      (*    EXPRESSION      | variable_NAME   | subprogram_NAME *)
                      (*  | entry_NAME      | SUBTYPE_MARK    | package_instance_NAME *)

                      (*--------------------------------- *)
                      (* 12.4  Formal Object Declaration  *)
                      (*--------------------------------- *)

                      (*  FORMAL_OBJECT_DECLARATION ::= *)
                      (*    DEFINING_IDENTIFIER_LIST : *)
                      (*      MODE SUBTYPE_MARK [:= DEFAULT_EXPRESSION]; *)

                      (*  Although the syntax allows multiple identifiers in the list, the *)
                      (*  semantics is as though successive declarations were given with *)
                      (*  identical type definition and expression components. To simplify *)
                      (*  semantic processing, the parser represents a multiple declaration *)
                      (*  case as a sequence of single declarations, using the MoreIds and *)
                      (*  PrevIds flags to preserve the original source form as described *)
                      (*  in the section on "Handling of Defining Identifier Lists". *)

                      NFormalObjectDeclaration =
                        (* Sloc points to first identifier *)
                        DefiningIdentifier : NClassEntity 
                        [ InPresent : BOOLEAN ] 
                        [ OutPresent : BOOLEAN ] 
                        SubtypeMark : NClassNode 
                        Expression : NClassNode (*  (points to an Empty object if no default expression) *)
                        [ MoreIds : BOOLEAN ] (*  (set to False if no more identifiers in list) *)
                        [ PrevIds : BOOLEAN ] (*  (set to False if no previous identifiers in list) *)
                      .

                      (*------------------------------- *)
                      (* 12.5  Formal Type Declaration  *)
                      (*------------------------------- *)

                      (*  FORMAL_TYPE_DECLARATION ::= *)
                      (*    type DEFINING_IDENTIFIER [DISCRIMINANT_PART] *)
                      (*      is FORMAL_TYPE_DEFINITION; *)

                      NFormalTypeDeclaration =
                        (* Sloc points to TYPE *)
                        DefiningIdentifier : NClassEntity 
                        FormalTypeDefinition : NClassNode 
                        DiscriminantSpecifications : ClassList (*  (points to a NoList object if no *)
                                                          (*   discriminant part) *)
                        [ UnknownDiscriminantsPresent : BOOLEAN ] (*  set if (<>) discriminant *)
                      .

                      (*------------------------------ *)
                      (* 12.5  Formal type definition  *)
                      (*------------------------------ *)

                      (*  FORMAL_TYPE_DEFINITION ::= *)
                      (*    FORMAL_PRIVATE_TYPE_DEFINITION *)
                      (*  | FORMAL_DERIVED_TYPE_DEFINITION *)
                      (*  | FORMAL_DISCRETE_TYPE_DEFINITION *)
                      (*  | FORMAL_SIGNED_INTEGER_TYPE_DEFINITION *)
                      (*  | FORMAL_MODULAR_TYPE_DEFINITION *)
                      (*  | FORMAL_FLOATING_POINT_DEFINITION *)
                      (*  | FORMAL_ORDINARY_FIXED_POINT_DEFINITION *)
                      (*  | FORMAL_DECIMAL_FIXED_POINT_DEFINITION *)
                      (*  | FORMAL_ARRAY_TYPE_DEFINITION *)
                      (*  | FORMAL_ACCESS_TYPE_DEFINITION *)

                      (*----------------------------------------- *)
                      (* 12.5.1  Formal Private Type Definition  *)
                      (*----------------------------------------- *)

                      (*  FORMAL_PRIVATE_TYPE_DEFINITION ::= *)
                      (*    [[abstract] tagged] [limited] private *)

                      (*  Note: TAGGED is not allowed in Ada 83 mode *)

                      NFormalPrivateTypeDefinition =
                        (* Sloc points to PRIVATE *)
                        [ AbstractPresent : BOOLEAN ] 
                        [ TaggedPresent : BOOLEAN ] 
                        [ LimitedPresent : BOOLEAN ] 
                      .

                      (*---------------------------------------- *)
                      (* 12.5.1  Formal Derived Type Definition  *)
                      (*---------------------------------------- *)

                      (*  FORMAL_DERIVED_TYPE_DEFINITION ::= *)
                      (*    [abstract] new SUBTYPE_MARK [with private] *)

                      (*  Note: this construct is not allowed in Ada 83 mode *)

                      NFormalDerivedTypeDefinition =
                        (* Sloc points to NEW *)
                        SubtypeMark : NClassNode 
                        [ PrivatePresent : BOOLEAN ] 
                        [ AbstractPresent : BOOLEAN ] 
                      .

                      (*----------------------------------------- *)
                      (* 12.5.2  Formal Discrete Type Definition  *)
                      (*----------------------------------------- *)

                      (*  FORMAL_DISCRETE_TYPE_DEFINITION ::= (<>) *)

                      NFormalDiscreteTypeDefinition =
                        (* Sloc points to ( *)
                      .

                      (*----------------------------------------------- *)
                      (* 12.5.2  Formal Signed Integer Type Definition  *)
                      (*----------------------------------------------- *)

                      (*  FORMAL_SIGNED_INTEGER_TYPE_DEFINITION ::= range <> *)

                      NFormalSignedIntegerTypeDefinition =
                        (* Sloc points to RANGE *)
                      .

                      (*---------------------------------------- *)
                      (* 12.5.2  Formal Modular Type Definition  *)
                      (*---------------------------------------- *)

                      (*  FORMAL_MODULAR_TYPE_DEFINITION ::= mod <> *)

                      NFormalModularTypeDefinition =
                        (* Sloc points to MOD *)
                      .

                      (*------------------------------------------ *)
                      (* 12.5.2  Formal Floating Point Definition  *)
                      (*------------------------------------------ *)

                      (*  FORMAL_FLOATING_POINT_DEFINITION ::= digits <> *)

                      NFormalFloatingPointDefinition =
                        (* Sloc points to DIGITS *)
                      .

                      (*------------------------------------------------ *)
                      (* 12.5.2  Formal Ordinary Fixed Point Definition  *)
                      (*------------------------------------------------ *)

                      (*  FORMAL_ORDINARY_FIXED_POINT_DEFINITION ::= delta <> *)

                      NFormalOrdinaryFixedPointDefinition =
                        (* Sloc points to DELTA *)
                      .

                      (*----------------------------------------------- *)
                      (* 12.5.2  Formal Decimal Fixed Point Definition  *)
                      (*----------------------------------------------- *)

                      (*  FORMAL_DECIMAL_FIXED_POINT_DEFINITION ::= delta <> digits <> *)

                      (*  Note: formal decimal fixed point definition not allowed in Ada 83 *)

                      NFormalDecimalFixedPointDefinition =
                        (* Sloc points to DELTA *)
                      .

                      (*-------------------------------------- *)
                      (* 12.5.3  Formal Array Type Definition  *)
                      (*-------------------------------------- *)

                      (*  FORMAL_ARRAY_TYPE_DEFINITION ::= ARRAY_TYPE_DEFINITION *)

                      (*--------------------------------------- *)
                      (* 12.5.4  Formal Access Type Definition  *)
                      (*--------------------------------------- *)

                      (*  FORMAL_ACCESS_TYPE_DEFINITION ::= ACCESS_TYPE_DEFINITION *)

                      (*------------------------------------- *)
                      (* 12.6  Formal Subprogram Declaration  *)
                      (*------------------------------------- *)

                      (*  FORMAL_SUBPROGRAM_DECLARATION ::= *)
                      (*    with SUBPROGRAM_SPECIFICATION [is SUBPROGRAM_DEFAULT]; *)

                      NFormalSubprogramDeclaration =
                        (* Sloc points to WITH *)
                        Specification : NClassNode 
                        DefaultName : NClassNode (*  (points to an Empty object if no subprogram default) *)
                        [ BoxPresent : BOOLEAN ] 
                      .

                      (*  Note: if no subprogram default is present, then Name points to an *)
                      (*  Empty object, and BoxPresent is False. *)

                      (*-------------------------- *)
                      (* 12.6  Subprogram Default  *)
                      (*-------------------------- *)

                      (*  SUBPROGRAM_DEFAULT ::= DEFAULT_NAME | <> *)

                      (*  There is no separate node in the tree for a subprogram default. *)
                      (*  Instead the parent (NFormalSubprogramDeclaration) node contains *)
                      (*  the default name or box indication, as needed. *)

                      (*-------------------- *)
                      (* 12.6  Default Name  *)
                      (*-------------------- *)

                      (*  DEFAULT_NAME ::= NAME *)

                      (*---------------------------------- *)
                      (* 12.7  Formal Package Declaration  *)
                      (*---------------------------------- *)

                      (*  FORMAL_PACKAGE_DECLARATION ::= *)
                      (*    with package DEFINING_IDENTIFIER *)
                      (*      is new generic_package_NAME FORMAL_PACKAGE_ACTUAL_PART; *)

                      (*  Note: formal package declarations not allowed in Ada 83 mode *)

                      NFormalPackageDeclaration =
                        (* Sloc points to WITH *)
                        DefiningIdentifier : NClassEntity 
                        Name : NClassNode 
                        GenericAssociations : ClassList (*  (points to a NoList object if (<>) case or *)
                                                   (*   empty generic actual part) *)
                        [ BoxPresent : BOOLEAN ] 
                        InstanceSpec : NClassNode 
                        [ ABEIsCertain : BOOLEAN ] 
                      .

                      (*---------------------------------- *)
                      (* 12.7  Formal Package Actual Part  *)
                      (*---------------------------------- *)

                      (*  FORMAL_PACKAGE_ACTUAL_PART ::= *)
                      (*    (<>) | [GENERIC_ACTUAL_PART] *)

                      (*  There is no explicit node in the tree for a formal package *)
                      (*  actual part. Instead the information appears in the parent node *)
                      (*  (i.e. the formal package declaration node itself). *)

                      (*----------------------------- *)
                      (* 13.1  Representation clause  *)
                      (*----------------------------- *)

                      (*  REPRESENTATION_CLAUSE ::= *)
                      (*    ATTRIBUTE_DEFINITION_CLAUSE *)
                      (*  | ENUMERATION_REPRESENTATION_CLAUSE *)
                      (*  | RECORD_REPRESENTATION_CLAUSE *)
                      (*  | AT_CLAUSE *)

                      (*------------------ *)
                      (* 13.1  Local Name  *)
                      (*------------------ *)

                      (*  LOCAL_NAME := *)
                      (*    DIRECT_NAME *)
                      (*  | DIRECT_NAME'ATTRIBUTE_DESIGNATOR *)
                      (*  | library_unit_NAME *)

                      (*  The construct DIRECT_NAME'ATTRIBUTE_DESIGNATOR appears in the tree *)
                      (*  as an attribute reference, which has essentially the same form. *)

                      (*----------------------------------- *)
                      (* 13.3  Attribute definition clause  *)
                      (*----------------------------------- *)

                      (*  ATTRIBUTE_DEFINITION_CLAUSE ::= *)
                      (*    for LOCAL_NAME'ATTRIBUTE_DESIGNATOR use EXPRESSION; *)
                      (*  | for LOCAL_NAME'ATTRIBUTE_DESIGNATOR use NAME; *)

                      (*  In Ada 83, the expression must be a simple expression and the *)
                      (*  local name must be a direct name. *)

                      (*  Note: The only attribute definition clause that is processed *)
                      (*  by Gigi is the alignment clause (for all other cases, the *)
                      (*  information is extracted by the front end and either results *)
                      (*  in setting entity information, e.g. Esize for the Size case, *)
                      (*  or in appropriate expansion actions (e.g. in the storage size *)
                      (*  case). For the alignment case, Gigi requires that the expression *)
                      (*  be an integer literal. *)

                      NAttributeDefinitionClause =
                        (* Sloc points to FOR *)
                        Name : NClassNode (*  the local name *)
                        [ Chars : NameId ] (*  the identifier name from the attribute designator *)
                        Expression : NClassNode (*  the expression or name *)
                        NextRepItem : NClassNode 
                        [ FromAtMod : BOOLEAN ] 
                      .

                      (*----------------------------------------- *)
                      (* 13.4  Enumeration representation clause  *)
                      (*----------------------------------------- *)

                      (*  ENUMERATION_REPRESENTATION_CLAUSE ::= *)
                      (*    for first_subtype_LOCAL_NAME use ENUMERATION_AGGREGATE; *)

                      (*  In Ada 83, the name must be a direct name *)

                      NEnumerationRepresentationClause =
                        (* Sloc points to FOR *)
                        Identifier : NClassNode (*  direct name *)
                        ArrayAggregate : NClassNode 
                        NextRepItem : NClassNode 
                      .

                      (*----------------------------- *)
                      (* 13.4  Enumeration aggregate  *)
                      (*----------------------------- *)

                      (*  ENUMERATION_AGGREGATE ::= ARRAY_AGGREGATE *)

                      (*-------------------------------------- *)
                      (* 13.5.1  Record representation clause  *)
                      (*-------------------------------------- *)

                      (*  RECORD_REPRESENTATION_CLAUSE ::= *)
                      (*    for first_subtype_LOCAL_NAME use *)
                      (*      record [MOD_CLAUSE] *)
                      (*        {COMPONENT_CLAUSE} *)
                      (*      end record; *)

                      (*  Gigi restriction: ModClause always points to an Empty object (if present it is *)
                      (*  replaced by a corresponding Alignment attribute definition clause). *)

                      (*  Note: ComponentClauses can include pragmas *)

                      NRecordRepresentationClause =
                        (* Sloc points to FOR *)
                        Identifier : NClassNode (*  direct name *)
                        ModClause : NClassNode (*  (points to an Empty object if no mod clause present) *)
                        ComponentClauses : ClassList 
                        NextRepItem : NClassNode 
                      .

                      (*-------------------------- *)
                      (* 13.5.1  Component clause  *)
                      (*-------------------------- *)

                      (*  COMPONENT_CLAUSE ::= *)
                      (*    component_LOCAL_NAME at POSITION *)
                      (*      range FIRST_BIT .. LAST_BIT; *)

                      NComponentClause =
                        (* Sloc points to AT *)
                        ComponentName : NClassNode (*  points to Name or Attribute_Reference *)
                        Position : NClassNode 
                        FirstBit : NClassNode 
                        LastBit : NClassNode 
                      .

                      (*------------------ *)
                      (* 13.5.1  Position  *)
                      (*------------------ *)

                      (*  POSITION ::= static_EXPRESSION *)

                      (*------------------- *)
                      (* 13.5.1  FirstBit  *)
                      (*------------------- *)

                      (*  FIRST_BIT ::= static_SIMPLE_EXPRESSION *)

                      (*------------------ *)
                      (* 13.5.1  LastBit  *)
                      (*------------------ *)

                      (*  LAST_BIT ::= static_SIMPLE_EXPRESSION *)

                      (*---------------------- *)
                      (* 13.8  Code statement  *)
                      (*---------------------- *)

                      (*  CODE_STATEMENT ::= QUALIFIED_EXPRESSION; *)

                      (*  Note: in GNAT, the qualified expression has the form *)

                      (*    Asm_Insn'(Asm (...)); *)

                      (*      or *)

                      (*    Asm_Insn'(Asm_Volatile (...)) *)

                      (*  See package System.Machine_Code in file s-maccod.ads for details *)
                      (*  on the allowed parameters to Asm[_Volatile]. There are two ways *)
                      (*  this node can arise, as a code statement, in which case the *)
                      (*  expression is the qualified expression, or as a result of the *)
                      (*  expansion of an intrinsic call to the Asm or Asm_Input procedure. *)

                      NCodeStatement =
                      (*  Note: package Exp_Code contains an abstract functional interface *)
                      (*  for use by Gigi in accessing the data from NCodeStatement nodes. *)
                        (* Sloc points to first token of the expression *)
                        Expression : NClassNode 
                      .

                      (*-------------------- *)
                      (* 13.12  Restriction  *)
                      (*-------------------- *)

                      (*  RESTRICTION ::= *)
                      (*    restriction_IDENTIFIER *)
                      (*  | restriction_parameter_IDENTIFIER => EXPRESSION *)

                      (*  There is no explicit node for restrictions. Instead the restriction *)
                      (*  appears in normal pragma syntax as a pragma argument association, *)
                      (*  which has the same syntactic form. *)

                   (*---------------------- *)
                   (* Obsolescent Features  *)
                   (*---------------------- *)

                      (*  The syntax descriptions and tree nodes for obsolescent features are *)
                      (*  grouped together, corresponding to their location in appendix I in *)
                      (*  the RM. However, parsing and semantic analysis for these constructs *)
                      (*  is located in an appropriate chapter (see individual notes). *)

                      (*----------------------- *)
                      (* J.3  Delta Constraint  *)
                      (*----------------------- *)

                      (*  Note: the parse routine for this construct is located in section *)
                      (*  3.5.9 of Par-Ch3, and semantic analysis is in Sem_Ch3, which is *)
                      (*  where delta constraint logically belongs. *)

                      (*  DELTA_CONSTRAINT ::= DELTA static_EXPRESSION [RANGE_CONSTRAINT] *)

                      NDeltaConstraint =
                        (* Sloc points to DELTA *)
                        DeltaExpression : NClassNode 
                        RangeConstraint : NClassNode (*  (points to an Empty object if not present) *)
                      .

                      (*---------------- *)
                      (* J.7  At Clause  *)
                      (*---------------- *)

                      (*  AT_CLAUSE ::= for DIRECT_NAME use at EXPRESSION; *)

                      (*  Note: the parse routine for this construct is located in Par-Ch13, *)
                      (*  and the semantic analysis is in Sem_Ch13, where at clause logically *)
                      (*  belongs if it were not obsolescent. *)

                      (*  Note: in Ada 83 the expression must be a simple expression *)

                      (*  Gigi restriction: This node never appears, it is rewritten as an *)
                      (*  address attribute definition clause. *)

                      NAtClause =
                        (* Sloc points to FOR *)
                        Identifier : NClassNode 
                        Expression : NClassNode 
                      .

                      (*----------------- *)
                      (* J.8  Mod clause  *)
                      (*----------------- *)

                      (*  MOD_CLAUSE ::= at mod static_EXPRESSION; *)

                      (*  Note: the parse routine for this construct is located in Par-Ch13, *)
                      (*  and the semantic analysis is in Sem_Ch13, where mod clause logically *)
                      (*  belongs if it were not obsolescent. *)

                      (*  Note: in Ada 83, the expression must be a simple expression *)

                      (*  Gigi restriction: this node never appears. It is replaced *)
                      (*  by a corresponding Alignment attribute definition clause. *)

                      (*  Note: pragmas can appear before and after the MOD_CLAUSE since *)
                      (*  its name has "clause" in it. This is rather strange, but is quite *)
                      (*  definitely specified. The pragmas before are collected in the *)
                      (*  PragmasBefore field of the mod clause node itself, and pragmas *)
                      (*  after are simply swallowed up in the list of component clauses. *)

                      NModClause =
                        (* Sloc points to AT *)
                        Expression : NClassNode 
                        PragmasBefore : ClassList (*  Pragmas before mod clause (points to *) 
                                             (*  a NoList object if none) *)
                      . 

                   (*---------------- *)
                   (* Semantic Nodes  *)
                   (*---------------- *)

                   (*  These semantic nodes are used to hold additional semantic information. *)
                   (*  They are inserted into the tree as a resut of semantic processing. *)
                   (*  Although there are no legitimate source syntax constructions that *)
                   (*  correspond directly to these nodes, we need a source syntax for the *)
                   (*  reconstructed tree printed by Sprint, and the node descriptions here *)
                   (*  show this syntax. *)

                      (*---------------------------------- *)
                      (* Free Statement ( Semantic node )  *)
                      (*---------------------------------- *)

                      (*  The NFreeStatement node is generated as a result of a call to an *)
                      (*  instantiation of Unchecked_Deallocation. The instantiation of this *)
                      (*  generic is handled specially and generates this node directly. *)

                      (*  Sprint syntax: free expression *)

                      NFreeStatement =
                        (* Sloc is copied from call to unchecked deallocation procedure *)
                        Expression : NClassNode (*  argument to unchecked deallocation call *)
                        StoragePool : NClassNode 
                        ProcedureToCall : NClassNode 
                      .

                      (*--------------------------------- *)
                      (* Freeze Entity ( Semantic node )  *)
                      (*--------------------------------- *)

                      (*  This node marks the point in a declarative part at which an entity *)
                      (*  declared therein becomes frozen. The expander places initialization *)
                      (*  procedures for types at those points. Gigi uses the freezing point *)
                      (*  to elaborate entities that may depend on previous private types. *)

                      (*  See the section in Einfo "Delayed Freezing and Elaboration" for *)
                      (*  a full description of the use of this node. *)

                      (*  The Entity field points back to the entity for the type (whose *)
                      (*  Freeze_Node field points back to this freeze node). *)

                      (*  The Actions field contains a list of declarations and statements *)
                      (*  generated by the expander which are associated with the freeze *)
                      (*  node, and are elaborated as though the freeze node were replaced *)
                      (*  by this sequence of actions. *)

                      (*  Note: the Sloc field in the freeze node references a construct *)
                      (*  associated with the freezing point. This is used for posting *)
                      (*  messages in some error/warning situations, e.g. the case where *)
                      (*  a primitive operation of a tagged type is declared too late. *)

                      (*  Sprint syntax: freeze entity-name [ *)
                      (*                   freeze actions *)
                      (*                 ] *)

                      NFreezeEntity =
                        (* Sloc set near freeze point (see above special note) *)
                        Entity : NClassNode 
                        TSSElist : ClassElist (*  (set to NoElist if no associated TSS's) *)
                        Actions : ClassList (*  (points to a NoList object if no freeze actions) *)
                        FirstSubtypeLink : NClassEntity (*  (points to an Empty object if no link) *)
                      .

                      (*  The Actions field holds actions associated with the freeze. These *)
                      (*  actions are elaborated at the point where the type is frozen. *)

                      (*---------------------------------------------- *)
                      (* Implicit Label Declaration ( Semantic node )  *)
                      (*---------------------------------------------- *)

                      (*  An implicit label declaration is created for every occurrence of a *)
                      (*  label on a statement or a label on a block or loop. It is chained *)
                      (*  in the declarations of the innermost enclosing block as specified *)
                      (*  in RM section 5.1 (3). *)

                      (*  The DefiningIdentifier is the actual identifier for the *)
                      (*  statement identifier. Note that the occurrence of the label *)
                      (*  is a reference, NOT the defining occurrence. The defining *)
                      (*  occurrence occurs at the head of the innermost enclosing *)
                      (*  block, and is represented by this node. *)

                      (*  Note: from the grammar, this might better be called an implicit *)
                      (*  statement identifier declaration, but the term we choose seems *)
                      (*  friendlier, since at least informally statement identifiers are *)
                      (*  called labels in both cases (i.e. when used in labels, and when *)
                      (*  used as the identifiers of blocks and loops). *)

                      (*  Note: although this is logically a semantic node, since it does *)
                      (*  not correspond directly to a source syntax construction, these *)
                      (*  nodes are actually created by the parser in a post pass done just *)
                      (*  after parsing is complete, before semantic analysis is started (see *)
                      (*  the Par.Labl subunit in file par-labl.adb). *)

                      (*  Sprint syntax: labelname : label; *)

                      NImplicitLabelDeclaration =
                        (* Sloc points to the << of the label *)
                        DefiningIdentifier : NClassEntity 
                        LabelConstruct : NClassNode 
                      .

                      (*---------------------------------- *)
                      (* Interpretation ( Semantic node )  *)
                      (*---------------------------------- *)

                      (*  During overload resolution, the Etype field of a possibly overloaded *)
                      (*  reference is used to point to a chain of NInterpretation nodes, one *)
                      (*  for each possible interpretation. See Sem_Type for further details. *)

                      (*  Note that these nodes are simply for temporary use by the semantic *)
                      (*  analyzer. Logically they are not part of the tree, and are always *)
                      (*  eventually eliminated when final type determination is complete. *)
                      (*  Gigi will never see these nodes in the final tree. *)

                      (*  Sprint syntax: none, since Sprint does not print type information *)

                      (*  Note: NInterpretation nodes are not yet used ??? *)

                      NInterpretation =
                        (* Sloc is copied from the node to which the interpretation applies *)
                        [ Chars : NameId ] (*  is copied from Chars (Etype) *)
                        NextInterp : NClassNode 
                        Entity : NClassNode 
                        Etype : NClassNode 
                      .

                      (*----------------------------------- *)
                      (* Itype_Reference ( Semantic node )  *)
                      (*----------------------------------- *)

                      (*  This node is used to create a reference to an Itype. The only *)
                      (*  purpose is to make sure that the Itype is defined if this is the *)
                      (*  first reference. *)

                      (*  A typical use of this node is when an Itype is to be referenced in *)
                      (*  two branches of an if statement. In this case it is important that *)
                      (*  the first use of the Itype not be inside the conditional, since *)
                      (*  then it might not be defined if the wrong branch of the if is *)
                      (*  taken in the case where the definition generates elaboration code. *)

                      (*  The Itype field points to the referenced Itype *)

                      (*  sprint syntax: reference itype-name *)

                      NItypeReference =
                        (* Sloc points to the node generating the reference *)
                        Itype : NClassEntity 
                      .

                      (*------------------------------------------------- *)
                      (* Validate_Unchecked_Conversion ( Semantic node )  *)
                      (*------------------------------------------------- *)

                      (*  The compiler issues a warning if the size of the source and target *)
                      (*  types for an instantiation of unchecked conversion are not the same. *)

                      (*  When possible, i.e. when the front end knows the sizes involved, *)
                      (*  this check is done in the front end in Validate_Unchecked_Conversion *)
                      (*  in Sem_Ch13. *)

                      (*  However, if it is not possible for the front end to do this check, *)
                      (*  then it is done in Gigi. In this case, the front end constructs an *)
                      (*  NValidateUncheckedConversion node that provides the necessary *)
                      (*  information for Gigi to validate the sizes. *)

                      (*  SourceType and TargetType point to the entities for the two *)
                      (*  types involved in the unchecked conversion instantiation that *)
                      (*  is to be validated. *)

                      (*  Sprint syntax: validate Unchecked_Conversion (source, target); *)

                      NValidateUncheckedConversion =
                        (* Sloc points to instantiation (location for warning message) *)
                        SourceType : NClassEntity 
                        TargetType : NClassEntity 
                      .

                      (*------------------------- *)
                      (* Empty ( Semantic node )  *)
                      (*------------------------- *)

                      NEmpty =
                      (*  Used as the dummy Empty node *)
                      (*  and in some other situations to indicate an uninitialized value. *)
                      (*  Chars is set to No_Name *)
                      .

                      (*------------------------- *)
                      (* Error ( Semantic node )  *)
                      (*------------------------- *)

                      NError =
                      (*  Used as the dummy Error node *)
                      (* Chars   is set to Error_Name *)
                      . 
(*%%%%%*) 
                    > (* End of different kinds of NClassNonExpression *) 
                  . (* End of NClassNonExpression *) 

                  NClassExpression 
                  = (* Common fields for NClassExpression *) 
 
                    [ ParenCount : ParenCountType ]
                      (* A 2-bit count used on expression nodes to indicate *)
                      (* the level of parentheses. Up to 3 levels can be *)
                      (* accomodated. Anything more than 3 levels is treated *)
                      (* as 3 levels (conformance tests that complain about *)
                      (* this are hereby deemed pathological!) Set to zero *)
                      (* for non-subexpression nodes. *)
                    Etype : NClassNode 
                      (* Appears in all expression nodes, all direct names, and all *)
                      (* entities. Points to the entity for the related type. Set after *)
                      (* type resolution. Normally this is the actual subtype of the *)
                      (* expression. However, in certain contexts such as the right side *)
                      (* of an assignment, subscripts, arguments to calls, returned value *)
                      (* in a function, initial value etc. it is the desired target type. *)
                      (* In the event that this is different from the actual type, the *)
                      (* Do_Range_Check flag will be set if a range check is required. *)
                      (* During semantic analysis, this is used to point to a list of *)
                      (* N_Interpretation nodes to represent possible interpretations *)
                      (* resulting from overloading, see Sem_Type for further details. *)
                    [ IsOverloaded : BOOLEAN ] 
                      (* A flag present in all expression nodes. Used temporarily during *)
                      (* overloading determination. The setting of this flag is not *)
                      (* relevant once overloading analysis is complete. *)
                    [ IsStaticExpression : BOOLEAN ] 
                      (* Indicates that an expression is a static expression (RM 4.9). See *)
                      (* spec of package Sem_Eval for full details on the use of this flag. *)
                    [ RaisesConstraintError : BOOLEAN ] 
                      (* Set on an expression whose evaluation will definitely fail a *)
                      (* constraint error check. In the case of static expressions, this *)
                      (* flag must be set accurately (and if it is set, the expression is *)
                      (* typically illegal unless it appears as a non-elaborated branch of *)
                      (* a short-circuit form). For a non-static expression, this flag may *)
                      (* be set whenever an expression (e.g. an aggregate) is known to raise *)
                      (* constraint error. If set, the expression definitely will raise CE *)
                      (* if elaborated at runtime. If not set, the expression may or may *)
                      (* not raise CE. In other words, on static expressions, the flag is *)
                      (* set accurately, on non-static expressions it is set conservatively. *)

                    [ MustNotFreeze : BOOLEAN ] 
                      (* A flag present in all expression nodes. Normally expressions cause *)
                      (* freezing as described in the RM. If this flag is set, then this *)
                      (* is inhibited. This is used by the analyzer and expander to label *)
                      (* nodes that are created by semantic analysis or expansion and which *)
                      (* must not cause freezing even though they normally would. This flag *)
                      (* is also present in an N_Subtype_Indication node, since we also use *)
                      (* these in calls to Freeze_Expression. *)


                    [ DoRangeCheck : BOOLEAN ] 
                      (* This flag is set on an expression which appears in a context where *)
                      (* a range check is required. The target type is clear from the *)
                      (* context. The contexts in which this flag can appear are limited to *)
                      (* the following. *)

                      (*   Right side of an assignment. In this case the target type is *)
                      (*   taken from the left side of the assignment, which is referenced *)
                      (*   by the Name of the N_Assignment_Statement node. *)

                      (*   Subscript expressions in an indexed component. In this case the *)
                      (*   target type is determined from the type of the array, which is *)
                      (*   referenced by the Prefix of the N_Indexed_Component node. *)

                      (*   Parameter expression for an IN parameter, appearing either *)
                      (*   directly in the Parameter_Associations list of a call or as *)
                      (*   the Expression of an N_Parameter_Association node that appears *)
                      (*   in this list. In either case, the check is against the type of *)
                      (*   the formal. Note that OUT and IN OUT parameters are handled by *)
                      (*   expanding assignments and explicit type conversions where a *)
                      (*   range check is required. *)

                      (*   Initialization expression for the initial value in an object *)
                      (*   declaration. In this case the Do_Range_Check flag is set on *)
                      (*   the initialization expression, and the check is against the *)
                      (*   range of the type of the object being declared. *)

                      (*   The expression of a type conversion. In this case the range check *)
                      (*   is against the target type of the conversion. See also the use of *)
                      (*   Do_Overflow_Check on a type conversion. The distinction is that *)
                      (*   the ovrflow check protects against a value that is outside the *)
                      (*   range of the target base type, whereas a range check checks that *)
                      (*   the resulting value (which is a value of the base type of the *)
                      (*   target type), satisfies the range constraint of the target type. *)

                      (* Note: when a range check is required in contexts other than those *)
                      (* listed above (e.g. in a return statement), an additional type *)
                      (* conversion node is introduced to represent the required check. *)

                    [ AssignmentOK : BOOLEAN ] 
                      (* This flag is set in a subexpression node corresponding to indicate *)
                      (* that the associated object can be modified, even if this would not *)
                      (* normally be permissible (either by direct assignment, or by being *)
                      (* passed as an out or in-out parameter. This is used by the expander *)
                      (* for a number of purposes, including initialzation of constants and *)
                      (* limited type objects (such as tasks), setting discriminant fields, *)
                      (* setting tag values, etc. N_Object_Declaration nodes also have this *)
                      (* flag defined. Here it is used to indicate that an initialization *)
                      (* expression is valid, even where it would normally not be allowed *)
                      (* (e.g. where the type involved is limited). *)

                    [ IsControllingActual : BOOLEAN ] 
                    (* This was misspelled as Is_Controlling_Argument in sinfo.ads comments. *) 
                      (* This flag is set on in an expression that is a controlling argument *)
                      (* in a dispatching call. It is off in all other cases. See Sem_Disp *)
                      (* for details of its use. *)

                    (* End of common fields for NClassExpression *) 

                    < NonOperatorExpression 
                      = < (* different kinds of NonOperatorExpression *)

                          (*----------------- *)
                          (* 2.3  Identifier  *)
                          (*----------------- *)

                          (*  IDENTIFIER ::= IDENTIFIER_LETTER {[UNDERLINE] LETTER_OR_DIGIT} *)
                          (*  LETTER_OR_DIGIT ::= IDENTIFIER_LETTER | DIGIT *)

                          (*  An IDENTIFIER shall not be a reserved word *)

                          (*  In the Ada grammar identifiers are the bottom level tokens which *)
                          (*  have very few semantics. Actual program identifiers are direct *)
                          (*  names. If we were being 100% honest with the grammar, then we would *)
                          (*  have a node called N_Direct_Name which would point to an identifier. *)
                          (*  However, that's too many extra nodes, so we just use the NIdentifier *)
                          (*  node directly as a direct name, and it contains the expression fields *)
                          (*  and Entity field that correspond to its use as a direct name. In *)
                          (*  those few cases where identifiers appear in contexts where they are *)
                          (*  not direct names (pragmas, pragma argument associations, attribute *)
                          (*  references and attribute definition clauses), the Chars field of the *)
                          (*  node contains the NameId for the identifier name. *)

                          (*  Note: in GNAT, a reserved word can be treated as an identifier *)
                          (*  in two cases. First, an incorrect use of a reserved word as an *)
                          (*  identifier is diagnosed and then treated as a normal identifier. *)
                          (*  Second, an attribute designator of the form of a reserved word *)
                          (*  (access, delta, digits, range) is treated as an identifier. *)

                          (*  Note: The set of letters that is permitted in an identifier depends *)
                          (*  on the character set in use. See package Csets for full details. *)

                          NIdentifier =
                            (* Sloc points to identifier *)
                            [ Chars : NameId ] (*  contains the Name_Id for the identifier *)
                            Entity : NClassNode 
                            OriginalDiscriminant : NClassNode 
                            [ RedundantUse : BOOLEAN ] 
                            [ HasPrivateView : BOOLEAN ] (*  set in generic units. *)
                            (* plus fields for expression *)
                          . 

                          (*---------------------- *)
                          (* 2.4  Numeric Literal  *)
                          (*---------------------- *)

                          (*  NUMERIC_LITERAL ::= DECIMAL_LITERAL | BASED_LITERAL *)

                          (*------------------------ *)
                          (* 2.4.1  Decimal Literal  *)
                          (*------------------------ *)

                          (*  DECIMAL_LITERAL ::= NUMERAL [.NUMERAL] [EXPONENT] *)

                          (*  NUMERAL ::= DIGIT {[UNDERLINE] DIGIT} *)

                          (*  EXPONENT ::= E [+] NUMERAL | E - NUMERAL *)

                          (*  Decimal literals appear in the tree as either integer literal nodes *)
                          (*  or real literal nodes, depending on whether a period is present. *)

                          (*  Note: literal nodes appear as a result of direct use of literals *)
                          (*  in the source program, and also as the result of evaluating *)
                          (*  expressions at compile time. In the latter case, it is possible *)
                          (*  to construct real literals that have no syntactic representation *)
                          (*  using the standard literal format. Such literals are listed by *)
                          (*  Sprint using the notation [numerator / denominator]. *)

                          NIntegerLiteral =
                            (* Sloc points to literal *)
                            [ Intval : Uint ] (*  contains integer value of literal *)
                            (* plus fields for expression *)
                            [ PrintInHex : BOOLEAN ] 
                          . 

                          NRealLiteral =
                            (* Sloc points to literal *)
                            [ Realval : Ureal ] (*  contains real value of literal *)
                            [ CorrespondingIntegerValue : Uint ] 
                            [ IsMachineNumber : BOOLEAN ] 
                            (* plus fields for expression *)
                          . 

                          (*---------------------- *)
                          (* 2.4.2  Based Literal  *)
                          (*---------------------- *)

                          (*  BASED_LITERAL ::= *)
                          (*   BASE # BASED_NUMERAL [.BASED_NUMERAL] # [EXPONENT] *)

                          (*  BASE ::= NUMERAL *)

                          (*  BASED_NUMERAL ::= *)
                          (*    EXTENDED_DIGIT {[UNDERLINE] EXTENDED_DIGIT} *)

                          (*  EXTENDED_DIGIT ::= DIGIT | A | B | C | D | E | F *)

                          (*  Based literals appear in the tree as either integer literal nodes *)
                          (*  or real literal nodes, depending on whether a period is present. *)

                          (*------------------------ *)
                          (* 2.5  Character Literal  *)
                          (*------------------------ *)

                          (*  CHARACTER_LITERAL ::= ' GRAPHIC_CHARACTER ' *)

                          NCharacterLiteral =
                            (* Sloc points to literal *)
                            [ Chars : NameId ] (*  contains the Name_Id for the "identifier" (sic.) *)
                            [ CharLiteralValue : CharCode ] (*  contains the literal value *)
                            Entity : NClassNode 
                            [ HasPrivateView : BOOLEAN ] (*  set in generic units. *)
                            (* plus fields for expression *)
                          . 

                          (*  Note: the Entity field will be missing (and points to an Empty object) for *)
                          (*  character literals whose type is Standard.Wide_Character or *)
                          (*  Standard.Character or a type derived from one of these two. *)
                          (*  In this case the character literal stands for its own coding. *)
                          (*  The reason we take this irregular short cut is to avoid the *)
                          (*  need to build lots of junk defining character literal nodes. *)

                          (*--------------------- *)
                          (* 2.6  String Literal  *)
                          (*--------------------- *)

                          (*  STRING LITERAL ::= "{STRING_ELEMENT}" *)

                          (*  A STRING_ELEMENT is either a pair of quotation marks ("), or a *)
                          (*  single GRAPHIC_CHARACTER other than a quotation mark. *)

                          NStringLiteral =
                            (* Sloc points to literal *)
                            [ Strval : StringId ] (*  contains Id of string value *)
                            (* plus fields for expression *)
                          . 

                          (*------------ *)
                          (* 3.5  Range  *)
                          (*------------ *)

                          (*  RANGE ::= *)
                          (*    RANGE_ATTRIBUTE_REFERENCE *)
                          (*  | SIMPLE_EXPRESSION .. SIMPLE_EXPRESSION *)

                          (*  Note: the case of a range given as a range attribute reference *)
                          (*  appears directly in the tree as an attribute reference. *)

                          (*  Note: the field name for a reference to a range is RangeExpression *)
                          (*  rather than Range, because range is a reserved keyword in Ada! *)

                          (*  Note: the reason that this node has expression fields is that a *)
                          (*  range can appear as an operand of a membership test. The Etype *)
                          (*  field is the type of the range (we do NOT construct an implicit *)
                          (*  subtype to represent the range exactly). *)

                          NRange =
                            (* Sloc points to .. *)
                            LowBound : NClassNode 
                            HighBound : NClassNode 
                            (* plus fields for expression *)
                          . 

                          (*  Note: if the range appears in a context, such as a subtype *)
                          (*  declaration, where range checks are required on one or both of *)
                          (*  the expression fields, then type conversion nodes are inserted *)
                          (*  to represent the required checks. *)

                          (*--------------------------- *)
                          (* 4.1  Explicit Dereference  *)
                          (*--------------------------- *)

                          (*  EXPLICIT_DEREFERENCE ::= NAME . all *)

                          NExplicitDereference =
                            (* Sloc points to ALL *)
                            Prefix : NClassNode 
                            [ DoAccessCheck : BOOLEAN ] 
                            (* plus fields for expression *)
                          . 

                          (*--------------------------- *)
                          (* 4.1  Implicit Dereference  *)
                          (*--------------------------- *)

                          (*  IMPLICIT_DEREFERENCE ::= NAME *)

                          (*-------------------------- *)
                          (* 4.1.1  Indexed Component  *)
                          (*-------------------------- *)

                          (*  INDEXED_COMPONENT ::= PREFIX (EXPRESSION {, EXPRESSION}) *)

                          (*  Note: the parser may generate this node in some situations where it *)
                          (*  should be a function call. The semantic  pass must correct this *)
                          (*  misidentification (which is inevitable at the parser level). *)

                          NIndexedComponent =
                            (* Sloc contains a copy of the Sloc value of the Prefix *)
                            Prefix : NClassNode 
                            Expressions : ClassList 
                            [ DoAccessCheck : BOOLEAN ] 
                            (* plus fields for expression *)
                          . 

                          (*  Note: if any of the subscripts requires a range check, then the *)
                          (*  DoRangeCheck flag is set on the corresponding expression, with *)
                          (*  the index type being determined from the type of the Prefix, which *)
                          (*  references the array being indexed. *)

                          (*  Note: in a fully analyzed and expanded indexed component node, and *)
                          (*  hence in any such node that gigi sees, if the prefix is an access *)
                          (*  type, then an explicit dereference operation has been inserted. *)

                          (*-------------- *)
                          (* 4.1.2  Slice  *)
                          (*-------------- *)

                          (*  SLICE ::= PREFIX (DISCRETE_RANGE) *)

                          (*  Note: an implicit subtype is created to describe the resulting *)
                          (*  type, so that the bounds of this type are the bounds of the slice. *)

                          NSlice =
                            (* Sloc points to first token of prefix *)
                            Prefix : NClassNode 
                            DiscreteRange : NClassNode 
                            [ DoAccessCheck : BOOLEAN ] 
                            (* plus fields for expression *)
                          . 

                          (*--------------------------- *)
                          (* 4.1.3  Selected Component  *)
                          (*--------------------------- *)

                          (*  SELECTED_COMPONENT ::= PREFIX . SELECTOR_NAME *)

                          (*  Note: selected components that are semantically expanded names get *)
                          (*  changed during semantic processing into the separate NExpandedName *)
                          (*  node. See description of this node in the section on semantic nodes. *)

                          NSelectedComponent =
                            (* Sloc points to period *)
                            Prefix : NClassNode 
                            SelectorName : NClassNode 
                            [ DoAccessCheck : BOOLEAN ] 
                            [ DoDiscriminantCheck : BOOLEAN ] 
                            (* plus fields for expression *)
                          . 

                          (*---------------------- *)
                          (* 4.1.3  Selector Name  *)
                          (*---------------------- *)

                          (*  SELECTOR_NAME ::= IDENTIFIER | CHARACTER_LITERAL | OPERATOR_SYMBOL *)

                          (*---------------------------- *)
                          (* 4.1.4  Attribute Reference  *)
                          (*---------------------------- *)

                          (*  ATTRIBUTE_REFERENCE ::= PREFIX ' ATTRIBUTE_DESIGNATOR *)

                          (*  Note: the syntax is quite ambiguous at this point. Consider: *)

                          (*    A'Length (X)  X is part of the attribute designator *)
                          (*    A'Pos (X)     X is an explicit actual parameter of function A'Pos *)
                          (*    A'Class (X)   X is the expression of a type conversion *)

                          (*  It would be possible for the parser to distinguish these cases *)
                          (*  by looking at the attribute identifier. However, that would mean *)
                          (*  more work in introducing new implementation defined attributes, *)
                          (*  and also it would mean that special processing for attributes *)
                          (*  would be scattered around, instead of being centralized in the *)
                          (*  semantic routine that handles an NAttributeReference node. *)
                          (*  Consequently, the parser in all the above cases stores the *)
                          (*  expression (X in these examples) as a single element list in *)
                          (*  in the Expressions field of the NAttributeReference node. *)

                          (*  Similarly, for attributes like Max which take two arguments, *)
                          (*  we store the two arguments as a two element list in the *)
                          (*  Expressions field. Of course it is clear at parse time that *)
                          (*  this case is really a function call with an attribute as the *)
                          (*  prefix, but it turns out to be convenient to handle the two *)
                          (*  argument case in a similar manner to the one argument case, *)
                          (*  and indeed in general the parser will accept any number of *)
                          (*  expressions in this position and store them as a list in the *)
                          (*  attribute reference node. This allows for future addition of *)
                          (*  attributes that take more than two arguments. *)

                          (*  Note: named associates are not permitted in function calls where *)
                          (*  the function is an attribute (see RM 6.4(3)) so it is legitimate *)
                          (*  to skip the normal subprogram argument processing. *)

                          (*  Note: for the attributes whose designators are technically keywords, *)
                          (*  i.e. digits, access, delta, range, the AttributeName field contains *)
                          (*  the corresponding name, even though no identifier is involved. *)

                          (*  See Exp_Attr for a complete description of which attributes are *)
                          (*  passed onto Gigi, and which are handled entirely by the front end. *)

                          NAttributeReference =
                            (* Sloc points to apostrophe *)
                            Prefix : NClassNode 
                            [ AttributeName : NameId ] (*  identifier name from attribute designator *)
                            Expressions : ClassList (*  (points to a NoList object if no associated expressions) *)
                            Entity : NClassNode (*  used if the attribute yields a type *)
                            [ RedundantUse : BOOLEAN ] 
                            [ DoAccessCheck : BOOLEAN ] 
                            [ DoOverflowCheck : BOOLEAN ] 
                            (* plus fields for expression *)
                          . 

                          (*----------------------------- *)
                          (* 4.1.4  Attribute Designator  *)
                          (*----------------------------- *)

                          (*  ATTRIBUTE_DESIGNATOR ::= *)
                          (*    IDENTIFIER [(static_EXPRESSION)] *)
                          (*  | access | delta | digits *)

                          (*  There is no explicit node in the tree for an attribute designator. *)
                          (*  Instead the AttributeName and Expressions fields of the parent *)
                          (*  node (NAttributeReference node) hold the information. *)

                          (*  Note: if ACCESS, DELTA or DIGITS appears in an attribute *)
                          (*  designator, then they are treated as identifiers internally *)
                          (*  rather than the keywords of the same name. *)

                          (*---------------------------------- *)
                          (* 4.1.4  Range Attribute Reference  *)
                          (*---------------------------------- *)

                          (*  RANGE_ATTRIBUTE_REFERENCE ::= PREFIX ' RANGE_ATTRIBUTE_DESIGNATOR *)

                          (*  A range attribute reference is represented in the tree using the *)
                          (*  normal NAttributeReference node. *)

                          (*----------------------------------- *)
                          (* 4.1.4  Range Attribute Designator  *)
                          (*----------------------------------- *)

                          (*  RANGE_ATTRIBUTE_DESIGNATOR ::= Range [(static_EXPRESSION)] *)

                          (*  A range attribute designator is represented in the tree using the *)
                          (*  normal NAttributeReference node. *)

                          (*---------------- *)
                          (* 4.3  Aggregate  *)
                          (*---------------- *)

                          (*  AGGREGATE ::= *)
                          (*    RECORD_AGGREGATE | EXTENSION_AGGREGATE | ARRAY_AGGREGATE *)

                          (*------------------------- *)
                          (* 4.3.1  Record Aggregate  *)
                          (*------------------------- *)

                          (*  RECORD_AGGREGATE ::= (RECORD_COMPONENT_ASSOCIATION_LIST) *)

                          NAggregate =
                            (* Sloc points to left parenthesis *)
                            Expressions : ClassList (*  (points to a NoList object if none or null record case) *)
                            ComponentAssociations : ClassList (*  (points to a NoList object if none) *)
                            [ NullRecordPresent : BOOLEAN ] 
                            AggregateBounds : NClassNode 
                            [ StaticProcessingOK : BOOLEAN ] 
                            [ CompileTimeKnownAggregate : BOOLEAN ] 
                            [ ExpansionDelayed : BOOLEAN ] 
                            (* plus fields for expression *)
                          . 

                          (*  Note: this structure is used for both record and array aggregates *)
                          (*  since the two cases are not separable by the parser. The parser *)
                          (*  makes no attempt to enforce consistency here, so it is up to the *)
                          (*  semantic phase to make sure that the aggregate is consistent (i.e. *)
                          (*  that it is not a "half-and-half" case that mixes record and array *)
                          (*  syntax. In particular, for a record aggregate, the expressions *)
                          (*  field will be set if there are positional associations. *)

                          (*---------------------------- *)
                          (* 4.3.2  Extension Aggregate  *)
                          (*---------------------------- *)

                          (*  EXTENSION_AGGREGATE ::= *)
                          (*    (ANCESTOR_PART with RECORD_COMPONENT_ASSOCIATION_LIST) *)

                          (*  Note: extension aggregates are not permitted in Ada 83 mode *)

                          NExtensionAggregate =
                            (* Sloc points to left parenthesis *)
                            AncestorPart : NClassNode 
                            Expressions : ClassList (*  (points to a NoList object if none or null record case) *)
                            ComponentAssociations : ClassList (*  (points to a NoList object if none) *)
                            [ NullRecordPresent : BOOLEAN ] 
                            [ ExpansionDelayed : BOOLEAN ] 
                            (* plus fields for expression *)
                          . 

                          (*---------------------- *)
                          (* 4.3.2  Ancestor Part  *)
                          (*---------------------- *)

                          (*  ANCESTOR_PART ::= EXPRESSION | SUBTYPE_MARK *)

                          (*------------------------ *)
                          (* 4.3.3  Array Aggregate  *)
                          (*------------------------ *)

                          (*  ARRAY_AGGREGATE ::= *)
                          (*    POSITIONAL_ARRAY_AGGREGATE | NAMED_ARRAY_AGGREGATE *)

                          (*----------------------------------- *)
                          (* 4.3.3  Positional Array Aggregate  *)
                          (*----------------------------------- *)

                          (*  POSITIONAL_ARRAY_AGGREGATE ::= *)
                          (*    (EXPRESSION, EXPRESSION {, EXPRESSION}) *)
                          (*  | (EXPRESSION {, EXPRESSION}, others => EXPRESSION) *)

                          (*  See Record_Aggregate (4.3.1) for node structure *)

                          (*------------------------------ *)
                          (* 4.3.3  Named Array Aggregate  *)
                          (*------------------------------ *)

                          (*  NAMED_ARRAY_AGGREGATE ::= *)
                          (*  | (ARRAY_COMPONENT_ASSOCIATION {, ARRAY_COMPONENT_ASSOCIATION}) *)

                          (*  See Record_Aggregate (4.3.1) for node structure *)

                          (*------------------------------------ *)
                          (* 4.3.3  Array Component Association  *)
                          (*------------------------------------ *)

                          (*  ARRAY_COMPONENT_ASSOCIATION ::= *)
                          (*    DISCRETE_CHOICE_LIST => EXPRESSION *)

                          (*  See Record_Component_Association (4.3.1) for node structure *)

                          (*---------------------------------------------- *)
                          (* 4.4  Expression/Relation/Term/Factor/Primary  *)
                          (*---------------------------------------------- *)

                          (*  EXPRESSION ::= *)
                          (*    RELATION {and RELATION} | RELATION {and then RELATION} *)
                          (*  | RELATION {or RELATION}  | RELATION {or else RELATION} *)
                          (*  | RELATION {xor RELATION} *)

                          (*  RELATION ::= *)
                          (*    SIMPLE_EXPRESSION [RELATIONAL_OPERATOR SIMPLE_EXPRESSION] *)
                          (*  | SIMPLE_EXPRESSION [not] in RANGE *)
                          (*  | SIMPLE_EXPRESSION [not] in SUBTYPE_MARK *)

                          (*  SIMPLE_EXPRESSION ::= *)
                          (*    [UNARY_ADDING_OPERATOR] TERM {BINARY_ADDING_OPERATOR TERM} *)

                          (*  TERM ::= FACTOR {MULTIPLYING_OPERATOR FACTOR} *)

                          (*  FACTOR ::= PRIMARY [** PRIMARY] | abs PRIMARY | not PRIMARY *)

                          (*  No nodes are generated for any of these constructs. Instead, the *)
                          (*  node for the operator appears directly. When we refer to an *)
                          (*  expression in this description, we mean any of the possible *)
                          (*  consistuent components of an expression (e.g. identifier is *)
                          (*  an example of an expression). *)

                          (*-------------- *)
                          (* 4.4  Primary  *)
                          (*-------------- *)

                          (*  PRIMARY ::= *)
                          (*    NUMERIC_LITERAL  | null *)
                          (*  | STRING_LITERAL   | AGGREGATE *)
                          (*  | NAME             | QUALIFIED_EXPRESSION *)
                          (*  | ALLOCATOR        | (EXPRESSION) *)

                          (*  Usually there is no explicit node in the tree for primary. Instead *)
                          (*  the constituent (e.g. AGGREGATE) appears directly. There are two *)
                          (*  exceptions. First, there is an explicit node for a null primary. *)

                          NNull =
                            (* Sloc points to NULL *)
                            (* plus fields for expression *)
                          . 

                          (*  Second, the case of (EXPRESSION) is handled specially. Ada requires *)
                          (*  that the parser keep track of which subexpressions are enclosed *)
                          (*  in parentheses, and how many levels of parentheses are used. This *)
                          (*  information is required for optimization purposes, and also for *)
                          (*  some semantic checks (e.g. (((1))) in a procedure spec does not *)
                          (*  conform with ((((1)))) in the body). *)

                          (*  The parentheses are recorded by keeping a Paren_Count field in every *)
                          (*  subexpression node (it is actually present in all nodes, but only *)
                          (*  used in subexpression nodes). This count records the number of *)
                          (*  levels of parentheses. If the number of levels in the source exceeds *)
                          (*  the maximum accomodated by this count, then the count is simply left *)
                          (*  at the maximum value. This means that there are some pathalogical *)
                          (*  cases of failure to detect conformance failures (e.g. an expression *)
                          (*  with 500 levels of parens will conform with one with 501 levels), *)
                          (*  but we do not need to lose sleep over this. *)

                          (*  Historical note: in versions of GNAT prior to 1.75, there was a node *)
                          (*  type N_Parenthesized_Expression used to accurately record unlimited *)
                          (*  numbers of levels of parentheses. However, it turned out to be a *)
                          (*  real nuisance to have to take into account the possible presence of *)
                          (*  this node during semantic analysis, since basically parentheses have *)
                          (*  zero relevance to semantic analysis. *)

                          (*  Note: the level of parentheses always present in things like *)
                          (*  aggregates does not count, only the parentheses in the primary *)
                          (*  (EXPRESSION) affect the setting of the Paren_Count field. *)

                          (*---------------------------------- *)
                          (* 4.5  Short Circuit Control Forms  *)
                          (*---------------------------------- *)

                          (*  EXPRESSION ::= *)
                          (*    RELATION {and then RELATION} | RELATION {or else RELATION} *)

                          NAndThen =
                            (* Sloc points to AND of AND THEN *)
                            LeftOpnd : NClassNode 
                            RightOpnd : NClassNode 
                            Actions : ClassList 
                            (* plus fields for expression *)
                          . 

                          NOrElse =
                            (* Sloc points to OR of OR ELSE *)
                            LeftOpnd : NClassNode 
                            RightOpnd : NClassNode 
                            Actions : ClassList 
                            (* plus fields for expression *)
                          . 

                          (*  Note: The Actions field is used to hold actions associated with *)
                          (*  the right hand operand. These have to be treated specially since *)
                          (*  they are not unconditionally executed. See Insert_Actions for a *)
                          (*  more detailed description of how these actions are handled. *)

                          (*----------------------- *)
                          (* 4.5  Membership Tests  *)
                          (*----------------------- *)

                          (*  RELATION ::= *)
                          (*    SIMPLE_EXPRESSION [not] in RANGE *)
                          (*  | SIMPLE_EXPRESSION [not] in SUBTYPE_MARK *)

                          NIn =
                            (* Sloc points to IN *)
                            LeftOpnd : NClassNode 
                            RightOpnd : NClassNode 
                            (* plus fields for expression *)
                          . 

                          NNotIn =
                            (* Sloc points to NOT of NOT IN *)
                            LeftOpnd : NClassNode 
                            RightOpnd : NClassNode 
                            (* plus fields for expression *)
                          . 


                          (*---------------------- *)
                          (* 4.6  Type Conversion  *)
                          (*---------------------- *)

                          (*  TYPE_CONVERSION ::= *)
                          (*    SUBTYPE_MARK (EXPRESSION) | SUBTYPE_MARK (NAME) *)

                          (*  In the (NAME) case, the name is stored as the expression *)

                          (*  Note: the parser never generates a type conversion node, since it *)
                          (*  looks like an indexed component which is generated by preference. *)
                          (*  The semantic pass must correct this misidentification. *)

                          (*  Gigi handles conversions that involve no change in the root type, *)
                          (*  and also all conversions from integer to floating-point types. *)
                          (*  Conversions from floating-point to integer are only handled in *)
                          (*  the case where FloatTruncate flag set. Other conversions from *)
                          (*  floating-point to integer (involving rounding) and all conversions *)
                          (*  involving fixed-point types are handled by the expander. *)

                          (*  Sprint syntax if FloatTruncate set: X^(Y) *)
                          (*  Sprint syntax if ConversionOK set X?(Y) *)
                          (*  Sprint syntax if both flags set X?^(Y) *)

                          (*  Note: If either the operand or result type is fixed-point, Gigi will *)
                          (*  only see a type conversion node with ConversionOK set. The front end *)
                          (*  takes care of all handling of small's for fixed-point conversions. *)

                          NTypeConversion =
                            (* Sloc points to first token of subtype mark *)
                            SubtypeMark : NClassNode 
                            Expression : NClassNode 
                            [ DoOverflowCheck : BOOLEAN ] 
                            [ DoTagCheck : BOOLEAN ] 
                            [ DoLengthCheck : BOOLEAN ] 
                            [ FloatTruncate : BOOLEAN ] 
                            [ RoundedResult : BOOLEAN ] 
                            [ ConversionOK : BOOLEAN ] 
                            (* plus fields for expression *)
                          . 

                          (*  Note: if a range check is required, then the DoRangeCheck flag *)
                          (*  is set in the Expression with the check being done against the *)
                          (*  target type range (after the base type conversion, if any). *)

                          (*--------------------------- *)
                          (* 4.7  Qualified Expression  *)
                          (*--------------------------- *)

                          (*  QUALIFIED_EXPRESSION ::= *)
                          (*    SUBTYPE_MARK ' (EXPRESSION) | SUBTYPE_MARK ' AGGREGATE *)

                          (*  Note: the parentheses in the (EXPRESSION) case are deemed to enclose *)
                          (*  the expression, so the Expression field of this node always points *)
                          (*  to a parenthesized expression in this case (i.e. Paren_Count will *)
                          (*  always be non-zero for the referenced expression if is is not an *)
                          (*  aggregate). *)

                          NQualifiedExpression =
                            (* Sloc points to apostrophe *)
                            SubtypeMark : NClassNode 
                            Expression : NClassNode (*  expression or aggregate *)
                            (* plus fields for expression *)
                          . 

                          (*---------------- *)
                          (* 4.8  Allocator  *)
                          (*---------------- *)

                          (*  ALLOCATOR ::= *)
                          (*    new SUBTYPE_INDICATION | new QUALIFIED_EXPRESSION *)

                          (*  Sprint syntax (when storage pool present) *)
                          (*    new xxx (storage_pool = pool) *)

                          NAllocator =
                            (* Sloc points to NEW *)
                            Expression : NClassNode (*  subtype indication or qualified expression *)
                            StoragePool : NClassNode 
                            ProcedureToCall : NClassNode 
                            [ DoStorageCheck : BOOLEAN ] 
                            (* plus fields for expression *)
                          . 

                          (*------------------------------- *)
                          (* 6.4  Procedure Call Statement  *)
                          (*------------------------------- *)

                          (*  PROCEDURE_CALL_STATEMENT ::= *)
                          (*    procedure_NAME; | procedure_PREFIX ACTUAL_PARAMETER_PART; *)

                          (*  Note: the reason that a procedure call has expression fields is *)
                          (*  that it semantically resembles an expression, e.g. overloading is *)
                          (*  allowed and a type is concocted for semantic processing purposes. *)
                          (*  Certain of these fields, such as Parens are not relevant, but it *)
                          (*  is easier to just supply all of them together! *)

                          NProcedureCallStatement =
                            (* Sloc points to first token of name or prefix *)
                            Name : NClassNode (*  stores name or prefix *)
                            ParameterAssociations : ClassList (*  (points to a NoList object if no *)
                          (*   actual parameter part) *)
                            FirstNamedActual : NClassNode 
                            ControllingArgument : NClassNode (*  (points to an Empty object if not dispatching) *)
                            [ DoTagCheck : BOOLEAN ] 
                            [ ParameterListTruncated : BOOLEAN ] 
                            [ ABEIsCertain : BOOLEAN ] 
                            (* plus fields for expression *)
                          . 

                          (*  If any IN parameter requires a range check, then the corresponding *)
                          (*  argument expression has the DoRangeCheck flag set, and the range *)
                          (*  check is done against the formal type. Note that this argument *)
                          (*  expression may appear directly in the ParameterAssociations list, *)
                          (*  or may be a descendent of an NParameterAssociation node that *)
                          (*  appears in this list. *)

                          (*-------------------- *)
                          (* 6.4  Function Call  *)
                          (*-------------------- *)

                          (*  FUNCTION_CALL ::= *)
                          (*    function_NAME | function_PREFIX ACTUAL_PARAMETER_PART *)

                          (*  Note: the parser may generate an indexed component node or simply *)
                          (*  a name node instead of a function call node. The semantic pass must *)
                          (*  correct this misidentification. *)

                          NFunctionCall =
                            (* Sloc points to first token of name or prefix *)
                            Name : NClassNode (*  stores name or prefix *)
                            ParameterAssociations : ClassList (*  (points to a NoList object if no *)
                          (*   actual parameter part) *)
                            FirstNamedActual : NClassNode 
                            ControllingArgument : NClassNode (*  (points to an Empty object if not dispatching) *)
                            [ DoTagCheck : BOOLEAN ] 
                            [ ParameterListTruncated : BOOLEAN ] 
                            [ ABEIsCertain : BOOLEAN ] 
                            (* plus fields for expression *)
                          . 

                          (*------------------------------ *)
                          (* Code_Range ( Semantic node )  *)
                          (*------------------------------ *)

                          (*  This node is an expression node which generates a value of type *)
                          (*  Ada.Exceptions.PC_Range. The values correspond to one of the *)
                          (*  following: *)

                          (*    The Lo and Hi values (first byte and last byte) for the code *)
                          (*    generated for the begin-end sequence of a handled sequence of *)
                          (*    statements. In this case the NHandledSequenceOfStatements *)
                          (*    is referenced by the RightOpnd field of the NCodeRange node. *)
                          (*    Note that the range here does *not* include any code generated *)
                          (*    for the declarations of the handled sequence of statements. *)

                          (*    The Lo and Hi values (first byte and last byte) for the entire *)
                          (*    sequence of code generated for a subprogram body. In this case *)
                          (*    the NSubprogramBody is referenced by the RightOpnd field of *)
                          (*    the NCodeRange node. Note that the range here *does* include *)
                          (*    code generated for the declarations of the subprogram body. *)

                          (*  The resulting value is stored in the exception tables for use *)
                          (*  in comparison operations with Code_Loc values extracted from *)
                          (*  the current machine state. A Code_Loc value is considered to *)
                          (*  be in range of the given code range if it is greater than or *)
                          (*  equal to the Lo value and less than or equal to the Hi value. *)
                          (*  Since the PC generally points after an executed instruction, *)
                          (*  the Hi value should normally point to the first unused byte *)
                          (*  after the last byte of code. *)

                          (*  The N_Code_Range_Taken flag is set on the node referenced by *)
                          (*  the RightOpnd field, to indicate to gigi (and Sprint!) that *)
                          (*  the starting and ending addresses must be marked. *)

                          (*  The Sprint syntax coughs up bogus labels for this construction *)

                          NCodeRange =
                            (* Sloc is set to Sloc of referenced node *)
                            RightOpnd : NClassNode 
                            (* plus fields for expression *)
                          . 

                          (*----------------------------------- *)
                          (* Concat Multiple ( Semantic node )  *)
                          (*----------------------------------- *)

                          (*  During semantic analysis, this node is created if a sequence of *)
                          (*  concatenation nodes construct a single concatenation result. The *)
                          (*  creation of this node is used to optimize both compile time *)
                          (*  evaluation and run time processing for concatenation, by avoiding *)
                          (*  the construction of intermediate results. *)

                          (*  Sprint syntax: expression && expression && expression .. *)

                          (*  Note: Concat_Multiple nodes are not yet used ??? *)

                          NConcatMultiple =
                            (* Sloc points to first of the & operators *)
                            Expressions : ClassList (*  points to list of operands *)
                            (* plus fields for expression *)
                          . 

                          (*------------------------------------------ *)
                          (* Conditional Expression ( Semantic node )  *)
                          (*------------------------------------------ *)

                          (*  This node is used to represent an expression corresponding to the *)
                          (*  C construct (condition ? then-expression : else_expression), where *)
                          (*  Expressions is a three element list, whose first expression is the *)
                          (*  condition, and whose second and third expressions are the then and *)
                          (*  else expressions respectively. *)

                          (*  Note: the ThenActions and ElseActions fields always point to a *)
                          (*  NoList object in the tree passed to Gigi. These fields are used only *)
                          (*  for temporary processing purposes in the expander. *)

                          (*  Sprint syntax: (if expr then expr else expr) *)

                          NConditionalExpression =
                            Expressions : ClassList 
                            ThenActions : ClassList 
                            ElseActions : ClassList 
                            (* plus fields for expression *)
                          . 

                          (*--------------------------------- *)
                          (* Expanded_Name ( Semantic node )  *)
                          (*--------------------------------- *)

                          (*  The NExpandedName node is used to represent a selected component *)
                          (*  name that has been resolved to an expanded name. The semantic phase *)
                          (*  replaces NSelectedComponent nodes that represent names by the use *)
                          (*  of this node, leaving the NSelectedComponent node used only when *)
                          (*  the prefix is a record or protected type. *)

                          (*  The fields of the NExpandedName node are layed out identically *)
                          (*  to those of the NSelectedComponent node, allowing conversion of *)
                          (*  an expanded name node to a selected component node to be done *)
                          (*  easily, see Sinfo.CN.Change_Selected_Component_To_Expanded_Name. *)

                          (*  There is no special sprint syntax for an expanded name. *)

                          NExpandedName =
                            (* Sloc points to the period *)
                            [ Chars : NameId ] (*  copy of Chars field of selector name *)
                            Prefix : NClassNode 
                            SelectorName : NClassNode 
                            Entity : NClassNode 
                            [ RedundantUse : BOOLEAN ] 
                            [ HasPrivateView : BOOLEAN ] (*  set in generic units. *)
                            (* plus fields for expression *)
                          . 

                          (*------------------------------- *)
                          (* Handler_Loc ( Semantic node )  *)
                          (*------------------------------- *)

                          (*  This node is an expression node which generates a value of type *)
                          (*  Handler_Loc, referencing the starting address of an exception *)
                          (*  handler. The RightOpnd field of the NHandlerLoc node references *)
                          (*  the NExceptionHandler node. *)

                          (*  The value obtained is stored in the generated exception tables *)
                          (*  and will be used in a call to Enter_Handler at runtime if the *)
                          (*  referenced handler is activated. *)

                          (*  The Sprint syntax coughs up a bogus label for the construction *)

                          NHandlerLoc =
                            (* Sloc is set to Sloc of referenced node *)
                            RightOpnd : NClassNode 
                            (* plus fields for expression *)
                          . 

                          (*----------------------------- *)
                          (* Proc_Info ( Semantic node )  *)
                          (*----------------------------- *)

                          (*  This node is an expression node which generates a value of type *)
                          (*  Info_Type representing the procedure information for the subprogram *)
                          (*  whose body is referenced by the RightOpnd field of the node/ *)

                          (*  The value obtained is stored in the generated exception tables *)
                          (*  and will be used in a call to Pop_Frame at runtime to exit the *)
                          (*  frame of the relevant procedure. *)

                          (*  If Proc_Info values are not used on a given target, then the *)
                          (*  value generated is Null_Proc_Info. *)

                          (*  The Sprint syntax uses a bogus attribute 'Proc_Info *)

                          NProcInfo =
                            (* Sloc is set to Sloc of referenced node *)
                            RightOpnd : NClassNode 
                            (* plus fields for expression *)
                          . 

                          (*----------------------------------- *)
                          (* Raise_xxx_Error ( Semantic node )  *)
                          (*----------------------------------- *)

                          (*  One of these nodes is created during semantic analysis to replace *)
                          (*  a node for an expression that is determined to definitely raise *)
                          (*  the corresponding exception. *)

                          (*  The N_Raise_xxx_Error node may also stand alone in place *)
                          (*  of a declaration or statement, in which case it simply causes *)
                          (*  the exception to be raised (i.e. it is equivalent to a raise *)
                          (*  statement that raises the corresponding exception). This use *)
                          (*  is distinguished by the fact that the Etype in this case is *)
                          (*  Standard_Void_Type, In the subexprssion case, the Etype is the *)
                          (*  same as the type of the subexpression which it replaces. *)

                          (*  If Condition is empty, then the raise is unconditional. If the *)
                          (*  Condition field is non-empty, it is a boolean expression which *)
                          (*  is first evaluated, and the exception is raised only if the *)
                          (*  value of the expression is True. In the unconditional case, the *)
                          (*  creation of this node is usually accompanied by a warning message *)
                          (*  error. The creation of this node will usually be accompanied by a *)
                          (*  message (unless it appears within the right operand of a short *)
                          (*  circuit form whose left argument is static and decisively *)
                          (*  eliminates elaboration of the raise operation. *)

                          (*  Sprint syntax: [xxx_error] *)
                          (*             or: [xxx_error when condition] *)

                          NRaiseConstraintError =
                            Condition : NClassNode (*  (points to an Empty object if no condition) *)
                            (* Sloc is copied from the expression generating the exception *)
                            (* plus fields for expression *)
                          . 

                          NRaiseProgramError =
                            Condition : NClassNode (*  (points to an Empty object if no condition) *)
                            (* Sloc is copied from the construct generating the exception *)
                            (* plus fields for expression *)
                          . 

                          NRaiseStorageError =
                            Condition : NClassNode (*  (points to an Empty object if no condition) *)
                            (* Sloc is copied from the construct generating the exception *)
                            (* plus fields for expression *)
                          . 

                          (*----------------------------- *)
                          (* Reference ( Semantic node )  *)
                          (*----------------------------- *)

                          (*  For a number of purposes, we need to construct references to objects. *)
                          (*  These references are subsequently treated as normal access values. *)
                          (*  An example is the construction of the parameter block passed to a *)
                          (*  task entry. The NReference node is provided for this purpose. It is *)
                          (*  similar in effect to the use of the Unrestricted_Access attribute, *)
                          (*  and like Unrestricted_Access can be applied to objects which would *)
                          (*  not be valid prefixes for the Unchecked_Access attribute (e.g. *)
                          (*  objects which are not aliased, and slices). In addition it can be *)
                          (*  applied to composite type values as well as objects, including string *)
                          (*  values and aggregates. *)

                          (*  Note: we use the Prefix field for this expression so that the *)
                          (*  resulting node can be treated using common code with the attribute *)
                          (*  nodes for the 'Access and related attributes. Logically it would make *)
                          (*  more sense to call it an Expression field, but then we would have to *)
                          (*  special case the treatment of the NReference node. *)

                          (*  Sprint syntax: prefix'reference *)

                          NReference =
                            (* Sloc is copied from the expression *)
                            Prefix : NClassNode 
                            (* plus fields for expression *)
                          . 

                          (*---------------------------------------- *)
                          (* Unchecked Expression ( Semantic node )  *)
                          (*---------------------------------------- *)

                          (*  An unchecked expression is one that must be analyzed and resolved *)
                          (*  with all checks off, regardless of the current setting of scope *)
                          (*  suppress flags. *)

                          (*  Sprint syntax: `(expression). *)

                          (*  Note: this node is always removed from the tree (and replaced by *)
                          (*  its constituent expression) on completion of analysis, so it only *)
                          (*  appears in intermediate trees, and will never be seen by Gigi. *)

                          NUncheckedExpression =
                            (* Sloc is a copy of the Sloc of the expression *)
                            Expression : NClassNode 
                            (* plus fields for expression *)
                          . 

                          (*--------------------------------------------- *)
                          (* Unchecked Type Conversion ( Semantic node )  *)
                          (*--------------------------------------------- *)

                          (*  An unchecked type conversion node represents the semantic action *)
                          (*  corresponding to a call to an instantiation of Unchecked_Conversion. *)
                          (*  It is generated as a result of actual use of Unchecked_Conversion *)
                          (*  and also the expander generates unchecked type conversion nodes *)
                          (*  directly for expansion of complex semantic actions. *)

                          (*  Note: an unchecked type conversion is a variable as far as the *)
                          (*  semantics are concerned, which is convenient for the expander. *)
                          (*  This does not change what Ada source programs are legal, since *)
                          (*  clearly a function call to an instantiation of Unchecked_Conversion *)
                          (*  is not a variable in any case. *)

                          (*  Sprint syntax: subtype-mark!(expression). *)

                          NUncheckedTypeConversion =
                            (* Sloc points to related node in source *)
                            SubtypeMark : NClassNode 
                            Expression : NClassNode 
                            (* plus fields for expression *)
                          . 

(*%%%%%*) 
                        > (* End of different kinds of NClassNonOperatorExpression *) 
                      . (* End of NClassNonOperatorExpression *) 
                      NClassOperatorExpression 
                      = (* Common fields of NClassOperatorExpression *) 

                        [ Chars : NameId ] (* NameId for the operator *) 
                        RightOpnd : NClassNode (* right operand expression *) 
                        [ DoOverflowCheck : BOOLEAN ] (* set if overflow check needed *) 
                        [ Has_Private_View : BOOLEAN ] (* set in generic units. *) 

                        < NClassNonBinaryOperator 
                          = < (* Different kinds of NClassNonBinaryOperator  *) 

                              (* Unary operators *) 

                              (*---------------- *)
                              (* 4.5  Operators  *)
                              (*---------------- *)

                              (*  LOGICAL_OPERATOR             ::=  and | or  | xor *)

                              (*  RELATIONAL_OPERATOR          ::=  =   | /=  | <   | <= | > | >= *)

                              (*  BINARY_ADDING_OPERATOR       ::=  +   |  -  | & *)

                              (*  UNARY_ADDING_OPERATOR        ::=  +   |  - *)

                              (*  MULTIPLYING_OPERATOR         ::=  *   |  /  | mod | rem *)

                              (*  HIGHEST_PRECEDENCE_OPERATOR  ::=  **  | abs | not *)

                              (*  Sprint syntax if TreatFixedAsInteger is set: *)

                              (*     x #* y *)
                              (*     x #/ y *)
                              (*     x #mod y *)
                              (*     x #rem y *)

                              (*  Note: For the operators * / mod rem with fixed-point operands, Gigi *)
                              (*  will only be given nodes with the TreatFixedAsInteger flag set. *)
                              (*  All handling of smalls for multiplication and division is handled *)
                              (*  by the front end (mod and rem result only from expansion). Gigi *)
                              (*  thus never needs to worry about small values (for other operators *)
                              (*  operating on fixed-point, e.g. addition, the small value does not *)
                              (*  have any semantic effect anyway, these are always integer operations. *)

                              NOpPlus =
                                (* Sloc points to + (unary) *)
                                (* plus fields for unary operator *)
                                (* plus fields for expression *)
                              . 

                              NOpMinus =
                                (* Sloc points to - (unary) *)
                                (* plus fields for unary operator *)
                                (* plus fields for expression *)
                              . 

                              NOpAbs =
                                (* Sloc points to ABS *)
                                (* plus fields for unary operator *)
                                (* plus fields for expression *)
                              . 

                              NOpNot =
                                (* Sloc points to NOT *)
                                (* plus fields for unary operator *)
                                (* plus fields for expression *)
                              . 

                              (*  See also shift operators in section B.2 *)

                              (*  Note on fixed-point operations passed to Gigi: For adding operators, *)
                              (*  the semantics is to treat these simply as integer operations, with *)
                              (*  the small values being ignored (the bounds are already stored in *)
                              (*  units of small, so that constraint checking works as usual). For the *)
                              (*  case of multiply/divide/rem/mod operations, Gigi will only see fixed *)
                              (*  point operands if the TreatFixedAsInteger flag is set and will *)
                              (*  thus treat these nodes in identical manner, ignoring small values. *)

(*%%%%%*)
                            > (* End of different kinds of NClassNonBinaryOperator *) 
                          . (* End of NClassNonBinaryOperator *) 
                          NClassBinaryOperator 
                          = (* Common fields of NClassBinaryOperator *) 

                            LeftOpnd : NClassNode (* left operand expression *) 

                            < (* Different kinds of NClassBinaryOperator *)   

                              NOpAnd =
                                (* Sloc points to AND *)
                                [ DoLengthCheck : BOOLEAN ] 
                                (* plus fields for binary operator *)
                                (* plus fields for expression *)
                              . 

                              NOpOr =
                                (* Sloc points to OR *)
                                [ DoLengthCheck : BOOLEAN ] 
                                (* plus fields for binary operator *)
                                (* plus fields for expression *)
                              . 

                              NOpXor =
                                (* Sloc points to XOR *)
                                [ DoLengthCheck : BOOLEAN ] 
                                (* plus fields for binary operator *)
                                (* plus fields for expression *)
                              . 

                              NOpEq =
                                (* Sloc points to = *)
                                (* plus fields for binary operator *)
                                (* plus fields for expression *)
                              . 

                              NOpNe =
                                (* Sloc points to /= *)
                                (* plus fields for binary operator *)
                                (* plus fields for expression *)
                              . 

                              NOpLt =
                                (* Sloc points to < *)
                                (* plus fields for binary operator *)
                                (* plus fields for expression *)
                              . 

                              NOpLe =
                                (* Sloc points to <= *)
                                (* plus fields for binary operator *)
                                (* plus fields for expression *)
                              . 

                              NOpGt =
                                (* Sloc points to > *)
                                (* plus fields for binary operator *)
                                (* plus fields for expression *)
                              . 

                              NOpGe =
                                (* Sloc points to >= *)
                                (* plus fields for binary operator *)
                                (* plus fields for expression *)
                              . 

                              NOpAdd =
                                (* Sloc points to + (binary) *)
                                (* plus fields for binary operator *)
                                (* plus fields for expression *)
                              . 

                              NOpSubtract =
                                (* Sloc points to - (binary) *)
                                (* plus fields for binary operator *)
                                (* plus fields for expression *)
                              . 

                              NOpConcat =
                                (* Sloc points to & *)
                                [ IsComponentLeftOpnd : BOOLEAN ] 
                                [ IsComponentRightOpnd : BOOLEAN ] 
                                (* plus fields for binary operator *)
                                (* plus fields for expression *)
                              . 

                              NOpMultiply =
                                (* Sloc points to * *)
                                [ TreatFixedAsInteger : BOOLEAN ] 
                                [ RoundedResult : BOOLEAN ] 
                                (* plus fields for binary operator *)
                                (* plus fields for expression *)
                              . 

                              NOpDivide =
                                (* Sloc points to / *)
                                [ TreatFixedAsInteger : BOOLEAN ] 
                                [ DoDivisionCheck : BOOLEAN ] 
                                [ RoundedResult : BOOLEAN ] 
                                (* plus fields for binary operator *)
                                (* plus fields for expression *)
                              . 

                              NOpMod =
                                (* Sloc points to MOD *)
                                [ TreatFixedAsInteger : BOOLEAN ] 
                                [ DoDivisionCheck : BOOLEAN ] 
                                (* plus fields for binary operator *)
                                (* plus fields for expression *)
                              . 

                              NOpRem =
                                (* Sloc points to REM *)
                                [ TreatFixedAsInteger : BOOLEAN ] 
                                [ DoDivisionCheck : BOOLEAN ] 
                                (* plus fields for binary operator *)
                                (* plus fields for expression *)
                              . 

                              NOpExpon =
                                (* Sloc points to ** *)
                                (* plus fields for binary operator *)
                                (* plus fields for expression *)
                              . 

                              (*---------------------- *)
                              (* B.2  Shift Operators  *)
                              (*---------------------- *)

                              (*  Calls to the intrinsic shift functions are converted to one of *)
                              (*  the following shift nodes, which have the form of normal binary *)
                              (*  operator names. Note that for a given shift operation, one node *)
                              (*  covers all possible types, as for normal operators. *)

                              (*  Note: it is perfectly permissible for the expander to generate *)
                              (*  shift operation nodes directly, in which case they will be analyzed *)
                              (*  and parsed in the usual manner. *)

                              (*  Sprint syntax: shift-function-name!(expr, count) *)

                              (*  Note: the LeftOpnd field holds the first argument (the value to *)
                              (*  be shifted). The RightOpnd field holds the second argument (the *)
                              (*  shift count). The Chars field is the name of the intrinsic function. *)

                              NOpRotateLeft =
                                (* Sloc points to the function name *)
                                (* plus fields for binary operator *)
                                (* plus fields for expression *)
                                [ ShiftCountOK : BOOLEAN ] 
                              . 

                              NOpRotateRight =
                                (* Sloc points to the function name *)
                                (* plus fields for binary operator *)
                                (* plus fields for expression *)
                                [ ShiftCountOK : BOOLEAN ] 
                              . 

                              NOpShiftLeft =
                                (* Sloc points to the function name *)
                                (* plus fields for binary operator *)
                                (* plus fields for expression *)
                                [ ShiftCountOK : BOOLEAN ] 
                              . 

                              NOpShiftRightArithmetic =
                                (* Sloc points to the function name *)
                                (* plus fields for binary operator *)
                                (* plus fields for expression *)
                                [ ShiftCountOK : BOOLEAN ] 
                              . 

                              NOpShiftRight =
                                (* Sloc points to the function name *)
                                (* plus fields for binary operator *)
                                (* plus fields for expression *)
                                [ ShiftCountOK : BOOLEAN ] 
                              . 

(*%%%%%*) 


                            > (* End of different kinds of NClassBinaryOperator *) 
                          . (* End of NClassBinaryOperator *) 

                        > (* End of different kinds of NClassOperatorExpression *) 
                      . (* End of NClassOperatorExpression *) 


                    > (* End of NClassNonOperator/NClassOperator distinction *) 
                  . (* End of NClassExpression *) 

                > (* End of NClassNonExpression/NClassExpression distinction *)  
              . (* End of NClassSNode *) 

              NClassEntity 
              = (* Common fields of all entities *) 

                (*-------------------------- *)
                (* 3.1  Defining Identifier  *)
                (*-------------------------- *)

                (*  DEFINING_IDENTIFIER ::= IDENTIFIER *)

                (*  A defining identifier is an entity, which has additional fields *)
                (*  depending on the setting of the Ekind field. These additional *)
                (*  fields are defined (and access subprograms declared) in package *)
                (*  Entity_Info. *)

                (* The Gnat two level NKind/EKind classification is converted to cg inheritance
                   style typing as follows:  
                   In Gnat, all Entity nodes have one of these Nkinds: 
                     NDefiningIdentifier 
                     NDefiningCharacterLiteral 
                     NDefiningOperatorSymbol 
                   In Ada, a defining character literal can only belong to an enumeration
                   literal, so Ekind EEnumerationLiteral is given subtypes EEnumerationCharacter
                   And EEnumerationIdentifier.  

                   Similarly, In Ada, a defining operator symbol can only belong to a [generic]
                   function, so EFunction has subtypes EFunctionOperator and EFunctionIdentifier
                   and EGenericFunction has subtypes EGenericFunctionOperator and 
                   EGenericFunctionIdentifier

                   So a Gnat node of Nkind NDefiningCharacterLiteral becomes EEnumerationCharacter,
                   NDefiningOperatorSymbol becomes EFunctionOperator or EGenericFunctionOperator,
                   and NDefiningIdentifier becomes whatever E* type corresponds to its Ekind.

                   The common fields in the following group are considered in Gnat to belong to
                     NDefiningIdentifier 
                     NDefiningCharacterLiteral 
                     NDefiningOperatorSymbol 
                *) 

                [ Chars : NameId ] (* of identifier, character literal, operator symbol literal *) 
                NextEntity : NClassNode                
                Scope : NClassNode                          
                Homonym : NClassNode                        
                Etype : NClassNode 
                  (* Appears in all expression nodes, all direct names, and all *)
                  (* entities. Points to the entity for the related type. Set after *)
                  (* type resolution. Normally this is the actual subtype of the *)
                  (* expression. However, in certain contexts such as the right side *)
                  (* of an assignment, subscripts, arguments to calls, returned value *)
                  (* in a function, initial value etc. it is the desired target type. *)
                  (* In the event that this is different from the actual type, the *)
                  (* Do_Range_Check flag will be set if a range check is required. *)
                  (* During semantic analysis, this is used to point to a list of *)
                  (* N_Interpretation nodes to represent possible interpretations *)
                  (* resulting from overloading, see Sem_Type for further details. *)

                (* The following common fields are viewed in Gnat as common fields of every entity node *) 

                FreezeNode : NClassNode                    
                FirstRepItem : NClassNode                 

                [ AddressTaken : BOOLEAN ]                  
                [ HasConventionPragma : BOOLEAN ]          
                [ HasDelayedFreeze : BOOLEAN ]             
                [ HasGigiRepItem : BOOLEAN ]              
                [ HasHomonym : BOOLEAN ]                    
                [ HasPragmaElaborateBody : BOOLEAN ]      
                [ HasUnknownDiscriminants : BOOLEAN ]      
                [ IsBitPackedArray : BOOLEAN ]            
                [ IsCompilationUnit : BOOLEAN ]            
                [ IsCompletelyHidden : BOOLEAN ]           
                [ IsExported : BOOLEAN ]                    
                [ IsFirstSubtype : BOOLEAN ]               
                [ IsFormalSubprogram : BOOLEAN ]           
                [ IsImmediatelyVisible : BOOLEAN ]         
                [ IsImported : BOOLEAN ]                    
                [ IsGenericInstance : BOOLEAN ]            
                [ IsInternal : BOOLEAN ]                    
                [ IsItype : BOOLEAN ]                       
                [ IsLimitedComposite : BOOLEAN ]           
                [ IsLimitedRecord : BOOLEAN ]              
                [ IsPackedArrayType : BOOLEAN ]           
                [ IsPotentiallyUseVisible : BOOLEAN ]     
                [ IsPrivate : BOOLEAN ]                     
                [ IsPublic : BOOLEAN ]                      
                [ IsPure : BOOLEAN ]                        
                [ IsUncheckedUnion : BOOLEAN ]             
                [ NeedsDebugInfo : BOOLEAN ]               
                [ SuppressAccessChecks : BOOLEAN ]         
                [ SuppressAccessibilityChecks : BOOLEAN ]  
                [ SuppressDiscriminantChecks : BOOLEAN ]   
                [ SuppressDivisionChecks : BOOLEAN ]       
                [ SuppressElaborationChecks : BOOLEAN ]    
                [ SuppressElaborationWarnings : BOOLEAN ]  
                [ SuppressIndexChecks : BOOLEAN ]          
                [ SuppressLengthChecks : BOOLEAN ]         
                [ SuppressOverflowChecks : BOOLEAN ]       
                [ SuppressRangeChecks : BOOLEAN ]          
                [ SuppressStorageChecks : BOOLEAN ]        
                [ SuppressTagChecks : BOOLEAN ]            

                (* DeclarationNode : NClassNode                      (* Computed *) *)
                (* EnclosingDynamicScope : NClassEntity              (* Computed *) *)
                (* HasForeignConvention : BOOLEAN                    (* Computed *) *)
                (* ImplementationType : NClassEntity                 (* Computed *) *)
                (* IsDynamicScope : BOOLEAN                          (* Computed *) *)
                (* IsGenericUnit : BOOLEAN                           (* Computed *) *)
                (* IsLimitedType : BOOLEAN                           (* Computed *) *)
                (* NextOverloads : NClassEntity                      (* Computed *) *)
                (* UnderlyingType : NClassEntity                     (* Computed *) *)
                (* all classification functions                      (* Computed *) *)

(*%%%%%*)
                < NClassEntityNonType 
                  = < (* Different kinds of NClassEntityNonType *) 

                      EBlock =
                        [ ScopeDepth : Uint ]                    
                        FirstEntity : NClassEntity                   
                        LastEntity : NClassEntity                    
                        BlockNode : NClassEntity                     
                        [ DiscardNames : BOOLEAN ]                  
                        FinalizationChainEntity : NClassEntity      
                        EntryCancelParameter : NClassEntity         
                        [ HasMasterEntity : BOOLEAN ]              
                        [ HasNestedBlockWithHandler : BOOLEAN ]  
                        [ HasPendingInstantiations : BOOLEAN ]     
                        [ UsesSecStack : BOOLEAN ]                 
                      . 

                      EComponent =
                        OriginalRecordComponent : NClassEntity      
                        Prival : NClassEntity                         
                        DiscriminantCheckingFunc : NClassEntity     
                        [ ComponentFirstBit : Uint ]            
                        [ Esize : Uint ]                          
                        ComponentClause : NClassNode               
                        ProtectedOperation : NClassEntity            
                        [ DTEntryCount : Uint ]                 
                        EntryFormal : NClassEntity                   
                        [ HasBiasedRepresentation : BOOLEAN ]      
                        [ HasPerObjectConstraint : BOOLEAN ]      
                        [ IsAtomic : BOOLEAN ]                      
                        [ IsTag : BOOLEAN ]                         
                        [ IsVolatile : BOOLEAN ]                    
                        [ NeedsDiscrCheck : BOOLEAN ]              
                        (* NextComponent : NClassEntity              (* Computed *) *)
                        (* IsProtectedPrivate : BOOLEAN              (* Computed *) *)
                      . 

                      EConstant =
                        InterfaceName : NClassNode                 
                        RenamedObject : NClassNode                 
                        ActualSubtype : NClassEntity                 
                        FullView : NClassEntity                      
                        [ Esize : Uint ]                          
                        SizeCheckCode : NClassNode                
                        [ HasAlignmentClause : BOOLEAN ]           
                        [ HasBiasedRepresentation : BOOLEAN ]      
                        [ HasSizeClause : BOOLEAN ]                
                        [ IsAtomic : BOOLEAN ]                      
                        [ IsCommonObject : BOOLEAN ]               
                        [ IsPsected : BOOLEAN ]                     
                        [ IsStaticallyAllocated : BOOLEAN ]        
                        [ IsVolatile : BOOLEAN ]                    
                        [ NotAssigned : BOOLEAN ]                   
                        (* AddressClause : NClassNode                (* Computed *) *)
                        (* AlignmentClause : NClassNode              (* Computed *) *)
                        (* ConstantValue : NClassNode                (* Computed *) *)
                        (* SizeClause : NClassNode                   (* Computed *) *)
                      . 

                      EDiscriminant =
                        CorrespondingDiscriminant : NClassEntity     
                        OriginalRecordComponent : NClassEntity      
                        Discriminal : NClassNode                    
                        DiscriminantDefaultValue : NClassNode     
                        [ ComponentFirstBit : Uint ]            
                        ComponentClause : NClassNode               
                        CRDiscriminant : NClassEntity                
                        (* NextDiscriminant : NClassEntity            (* Computed *) *)
                        (* NextGirderDiscriminant : NClassEntity      (* Computed *) *)
                      . 

                      EClassEntry =
                        AcceptAddress : ClassElist                 
                        EntryParametersType : NClassEntity          
                        [ ScopeDepth : Uint ]                    
                        FirstEntity : NClassEntity                   
                        LastEntity : NClassEntity                    
                        ProtectedBodySubprogram : NClassEntity      
                        BarrierFunction : NClassNode               
                        FinalizationChainEntity : NClassEntity      
                        PrivalsChain : ClassElist                     (* for a protected entry *)
                        [ DefaultExpressionsProcessed : BOOLEAN ]  
                        [ EntryAccepted : BOOLEAN ]                 
                        [ IsASTEntry : BOOLEAN ]                      (* for entry only *)
                        [ NeedsNoActuals : BOOLEAN ]               
                        [ UsesSecStack : BOOLEAN ]                 
                        (* AddressClause : NClassNode                 (* Computed *) *)
                        (* FirstFormal : NClassEntity                 (* Computed *) *)
                        (* EntryIndexType : NClassEntity              (* Computed *) *)
                        (* NumberFormals : Pos                        (* Computed *) *)
                        < EEntry = . 
                          EEntryFamily = . 
                        > 
                      . 

                      EEntryIndexParameter =
                        EntryIndexConstant : NClassEntity           
                      . 

                      EEnumerationLiteral =
                        Alias : NClassEntity                          
                        EnumerationRepExpr : NClassNode           
                        [ EnumerationPos : Uint ]                
                        [ EnumerationRep : Uint ]                
                        (* NextLiteral : NClassEntity                 (* Computed *) *)
                        < EEnumerationCharacter = . 
                          EEnumerationIdentifier = . 
                        > 
                      . 

                      (*----------------------------------- *)
                      (* 3.5.1  Defining Character Literal  *)
                      (*----------------------------------- *)

                      (*  DEFINING_CHARACTER_LITERAL ::= CHARACTER_LITERAL *)

                      (*  A defining character literal is an entity, which has additional *)
                      (*  fields depending on the setting of the Ekind field. These *)
                      (*  additional fields are defined (and access subprograms declared) *)
                      (*  in package Entity_Info. *)

                      EException =
                        InterfaceName : NClassNode                 
                        RenamedEntity : NClassNode                 
                        [ ExceptionCode : Uint ]                 
                        [ DiscardNames : BOOLEAN ]                  
                        [ IsVMSException : BOOLEAN ]               
                      . 

                      EClassFunction =
                        InterfaceName : NClassNode                 
                        Alias : NClassEntity                          (* for a function *)
                        [ ScopeDepth : Uint ]                    
                        FirstEntity : NClassEntity                   
                        LastEntity : NClassEntity                    
                        ProtectedBodySubprogram : NClassEntity      
                        NextInlinedSubprogram : NClassEntity        
                        FinalizationChainEntity : NClassEntity      
                     (* RMB: 
                        GenericRenamings is not set by gnat and attempts to
                        fetch it produce constraint errors, since it is out
                        of range for an EList.  sem_ch12 contains an apparently
                        new mechanism using separate maps.  
                        GenericRenamings : ClassElist                 (* for an instance *)
                     *) 
                        PrivalsChain : ClassElist                     (* for a protected function *)
                        [ DTPosition : Uint ]                    
                        DTCEntity : NClassEntity                     
                        [ RenamingMap : Uint ]                   
                        CorrespondingEquality : NClassEntity          (* implicit /= only *)
                        ElaborationEntity : NClassEntity              (* all other cases *)
                        FirstFrame : NClassNode                    
                        [ Mechanism : MechanismType ]                 (* returns Mechanism_Type *)
                        [ DefaultExpressionsProcessed : BOOLEAN ]  
                        [ DiscardNames : BOOLEAN ]                  
                        [ ElaborateAllDesirable : BOOLEAN ]        
                        [ HasCompletion : BOOLEAN ]                 
                        [ HasControllingResult : BOOLEAN ]         
                        [ HasMasterEntity : BOOLEAN ]              
                        [ HasMissingReturn : BOOLEAN ]             
                        [ HasNestedBlockWithHandler : BOOLEAN ]  
                        [ HasPendingInstantiations : BOOLEAN ]     
                        [ HasRecursiveCall : BOOLEAN ]             
                        [ IsAbstract : BOOLEAN ]                    
                        [ IsConstructor : BOOLEAN ]                 
                        [ IsDestructor : BOOLEAN ]                  
                        [ IsDispatchingOperation : BOOLEAN ]       
                        [ IsInlined : BOOLEAN ]                     
                        [ IsIntrinsicSubprogram : BOOLEAN ]        
                        [ IsPrivateDescendant : BOOLEAN ]          
                        [ NeedsNoActuals : BOOLEAN ]               
                        [ ReturnPresent : BOOLEAN ]                 
                        [ ReturnsByRef : BOOLEAN ]                 
                        [ UsesSecStack : BOOLEAN ]                 
                        [ IsVisibleChildUnit : BOOLEAN ]          
                        (* AddressClause : NClassNode                 (* Computed *) *)
                        (* FirstFormal : NClassEntity                 (* Computed *) *)
                        (* NumberFormals : Pos                        (* Computed *) *)
                        < EFunction 
                          = FirstOptionalParameter : NClassEntity     (* non-generic case only *)
                            [ IsMachineCodeSubprogram : BOOLEAN ]     (* non-generic case only *)
                            [ IsCalled : BOOLEAN ]                    (* non-generic case only *)
                            < EFunctionOperator = . 
                              EFunctionIdentifier = . 
                            > 
                          . 
                          EGenericFunction 
                          = RenamedEntity : NClassNode                (* for a generic function *)
                            InnerInstances : ClassElist               (* for a generic function *)
                            < EGenericFunctionOperator = . 
                              EGenericFunctionIdentifier = . 
                            > 
                          .
                        > 
                      .  

                      (*------------------------------- *)
                      (* 6.1  Defining Operator Symbol  *)
                      (*------------------------------- *)

                      (*  DEFINING_OPERATOR_SYMBOL ::= OPERATOR_SYMBOL *)

                      (*  A defining operator symbol is an entity, which has additional *)
                      (*  fields depending on the setting of the Ekind field. These *)
                      (*  additional fields are defined (and access subprograms declared) *)
                      (*  in package Entity_Info. *)

                      EClassGenericParameter =
                        ProtectedFormal : NClassEntity               
                        ActualSubtype : NClassEntity                 
                        DefaultValue : NClassNode                  
                        EntryComponent : NClassEntity                
                        [ IsControllingFormal : BOOLEAN ]          
                        [ IsEntryFormal : BOOLEAN ]                
                        (* ParameterMode : FormalKind                 (* Computed *) *)
                        < EGenericInParameter = . 
                          EGenericInOutParameter = . 
                        > 
                      . 

                      EClassParameter =
                        ProtectedFormal : NClassEntity               
                        ActualSubtype : NClassEntity                 
                        DefaultValue : NClassNode                  
                        EntryComponent : NClassEntity                
                        DefaultExprFunction : NClassEntity          
                        ExtraFormalAccessibility : NClassEntity     
                        ExtraFormalConstrained : NClassEntity       
                        ExtraFormal : NClassEntity                   
                        UnsetReference : NClassNode                
                        [ Mechanism : MechanismType ]                 (* returns Mechanism_Type *)
                        [ IsControllingFormal : BOOLEAN ]          
                        [ IsEntryFormal : BOOLEAN ]                
                        [ IsOptionalParameter : BOOLEAN ]          
                        [ NotAssigned : BOOLEAN ]                   
                        (* ParameterMode : FormalKind                 (* Computed *) *)
                        < EInParameter = . 
                          EInOutParameter = .
                          EOutParameter = .
                        > 
                      . 

                      ELabel =
                        EnclosingScope : NClassEntity  
                        [ Reachable : BOOLEAN ]                      
                      . 

                      ELoop =
                        [ HasExit : BOOLEAN ]                       
                        [ HasMasterEntity : BOOLEAN ]              
                        [ HasNestedBlockWithHandler : BOOLEAN ]  
                      . 

                      ENamedInteger =
                        (* ConstantValue : NClassNode                 (* Computed *) *)
                      . 

                      ENamedReal =
                        (* ConstantValue : NClassNode                 (* Computed *) *)
                      . 

                      EOperator =
                        Alias : NClassEntity                          
                        FirstEntity : NClassEntity                   
                        LastEntity : NClassEntity                    
                        [ IsMachineCodeSubprogram : BOOLEAN ]    
                        [ IsIntrinsicSubprogram : BOOLEAN ]        
                        [ DefaultExpressionsProcessed : BOOLEAN ]  
                      . 

                      EClassPackage =
                        RenamedEntity : NClassNode                 
                        [ ScopeDepth : Uint ]                    
                        FirstEntity : NClassEntity                   
                        LastEntity : NClassEntity                    
                        AssociatedFormalPackage : NClassEntity      
                     (* RMB: 
                        GenericRenamings is not set by gnat and attempts to
                        fetch it produce constraint errors, since it is out
                        of range for an EList.  sem_ch12 contains an apparently
                        new mechanism using separate maps.  
                        GenericRenamings : ClassElist                 (* for an instance *)
                     *)
                        FirstPrivateEntity : NClassEntity           
                        [ RenamingMap : Uint ]                   
                        ElaborationEntity : NClassEntity             
                        FirstFrame : NClassNode                    
                     (* RMB: 
                        DependentInstances is not set by gnat and attempts to
                        fetch it produce constraint errors, since it is out
                        of range for an EList.  sem_ch12 contains an apparently
                        new mechanism using separate maps.  
                        DependentInstances : ClassElist               (* for an instance *)
                      *)
                        ShadowEntities : ClassList                
                        [ DiscardNames : BOOLEAN ]                  
                        [ ElaborateAllDesirable : BOOLEAN ]        
                        [ HasAllCallsRemote : BOOLEAN ]           
                        [ HasCompletion : BOOLEAN ]                 
                        [ HasMasterEntity : BOOLEAN ]              
                        [ InPackageBody : BOOLEAN ]                
                        [ InPrivatePart : BOOLEAN ]                
                        [ InUse : BOOLEAN ]                         
                        [ IsPreelaborated : BOOLEAN ]               
                        [ IsPrivateDescendant : BOOLEAN ]          
                        [ IsRemoteCallInterface : BOOLEAN ]       
                        [ IsRemoteTypes : BOOLEAN ]                
                        [ IsSharedPassive : BOOLEAN ]              
                        [ IsVisibleChildUnit : BOOLEAN ]          
                        < EPackage = . 
                          EGenericPackage = 
                            InnerInstances : ClassElist               (* for a generic package *)
                          . 
                        > 
                      . 

                      EPackageBody =
                        [ ScopeDepth : Uint ]                    
                        FirstEntity : NClassEntity                   
                        LastEntity : NClassEntity                    
                      . 

                      EClassProcedure =
                        InterfaceName : NClassNode                 
                        [ ScopeDepth : Uint ]                    
                        FirstEntity : NClassEntity                   
                        LastEntity : NClassEntity                    
                        ProtectedBodySubprogram : NClassEntity      
                        NextInlinedSubprogram : NClassEntity        
                        FinalizationChainEntity : NClassEntity      
                     (* RMB: 
                        GenericRenamings is not set by gnat and attempts to
                        fetch it produce constraint errors, since it is out
                        of range for an EList.  sem_ch12 contains an apparently
                        new mechanism using separate maps.  
                        GenericRenamings : ClassElist                 (* for an instance *)
                     *)
                        PrivalsChain : ClassElist                     (* for a protected procedure *)
                        [ DTPosition : Uint ]                    
                        DTCEntity : NClassEntity                     
                        [ RenamingMap : Uint ]                   
                        ElaborationEntity : NClassEntity             
                        FirstFrame : NClassNode                    
                        [ DefaultExpressionsProcessed : BOOLEAN ]  
                        [ DiscardNames : BOOLEAN ]                  
                        [ ElaborateAllDesirable : BOOLEAN ]        
                        [ HasCompletion : BOOLEAN ]                 
                        [ HasMasterEntity : BOOLEAN ]              
                        [ HasNestedBlockWithHandler : BOOLEAN ]  
                        [ HasPendingInstantiations : BOOLEAN ]     
                        [ IsAbstract : BOOLEAN ]                    
                        [ IsAsynchronous : BOOLEAN ]                
                        [ IsConstructor : BOOLEAN ]                 
                        [ IsDestructor : BOOLEAN ]                  
                        [ IsDispatchingOperation : BOOLEAN ]       
                        [ IsInlined : BOOLEAN ]                     
                        [ IsInterruptHandler : BOOLEAN ]           
                        [ IsIntrinsicSubprogram : BOOLEAN ]        
                        [ IsPrivateDescendant : BOOLEAN ]          
                        [ IsValuedProcedure : BOOLEAN ]            
                        [ NeedsNoActuals : BOOLEAN ]               
                        [ NoReturn : BOOLEAN ]                      
                        [ UsesSecStack : BOOLEAN ]                 
                        [ IsVisibleChildUnit : BOOLEAN ]          
                        (* AddressClause : NClassNode                 (* Computed *) *)
                        (* FirstFormal : NClassEntity                 (* Computed *) *)
                        (* NumberFormals : Pos                        (* Computed *) *)
                        < EProcedure = 
                            Alias : NClassEntity                      (* for a procedure *)
                            FirstOptionalParameter : NClassEntity     (* non-generic case only *)
                            [ IsMachineCodeSubprogram : BOOLEAN ]     (* non-generic case only *)
                            [ IsCalled : BOOLEAN ]                    (* non-generic subprogram *)
                          . 
                          EGenericProcedure = 
                            RenamedEntity : NClassNode                (* for a generic procedure *)
                            InnerInstances : ClassElist               (* for a generic procedure *)
                          . 
                        > 
                      . 

                      EProtectedBody =
                        ObjectRef : NClassEntity                     
                         (* any others??? First/Last Entity, ScopeDepth : Uint??? *)
                      . 

                      EProtectedObject = . 

                      ESubprogramBody =
                        [ ScopeDepth : Uint ]                    
                        FirstEntity : NClassEntity                   
                        LastEntity : NClassEntity                    
                        [ IsInlined : BOOLEAN ]                     
                      . 

                      ETaskBody =
                         (* any others??? First/Last Entity, ScopeDepth : Uint??? *)
                      . 

                      EVariable =
                        InterfaceName : NClassNode                 
                        RenamedObject : NClassNode                 
                        ActualSubtype : NClassEntity                 
                        [ Esize : Uint ]                          
                        UnsetReference : NClassNode                
                        SizeCheckCode : NClassNode                
                        [ HasAlignmentClause : BOOLEAN ]           
                        [ HasBiasedRepresentation : BOOLEAN ]      
                        [ HasSizeClause : BOOLEAN ]                
                        [ IsAtomic : BOOLEAN ]                      
                        [ IsCommonObject : BOOLEAN ]               
                        [ IsPsected : BOOLEAN ]                     
                        [ IsStaticallyAllocated : BOOLEAN ]        
                        [ IsVolatile : BOOLEAN ]                    
                        [ NotAssigned : BOOLEAN ]                   
                        (* AddressClause : NClassNode                (* Computed *) *)
                        (* AlignmentClause : NClassNode              (* Computed *) *)
                        (* SizeClause : NClassNode                   (* Computed *) *)
                      . 

                      EVoid =
                        (* Since  EVoid is the initial Ekind value of an entity when it is first
                           created , one might expect that no attributes would be defined on such
                           an  entity until its Ekind field is set. However, in practice, there
                           are  many instances in which fields of an EVoid entity are set in the
                           code  prior to setting the Ekind field. This is not well documented or
                           well  controlled, and needs cleaning up later. Meanwhile, the access
                           procedures  in the body of Einfo permit many, but not all, attributes
                           to  be applied to an EVoid entity, precisely so that this kind of
                           pre -setting of attributes works. This is really a hole in the dynamic
                           type  checking, since there is no assurance that the eventual Ekind
                           value  will be appropriate for the attributes set, and the consequence
                           is  that the dynamic type checking in the Einfo body is unnecessarily
                           weak . To be looked at systematically some time ???
                        *)
                      . 

(*%%%%%*) 

                    > (* End of different kinds of NClassEntityNonType *) 
                  . (* End of NClassEntityNonType *) 

                  NClassEntityType 
                  = (* Common fields of NClassEntityType *) 

                    FullView : NClassEntity                      
                    [ Esize : Uint ]                          
                    ClassWideType : NClassEntity                     (* base type only *)
                    ReferencedObject : NClassNode              
                    AssociatedNodeForItype : NClassNode      

                    [ DiscardNames : BOOLEAN ]                  
                    [ HasAliasedComponents : BOOLEAN ]         
                    [ HasAlignmentClause : BOOLEAN ]           
                    [ HasComplexRepresentation : BOOLEAN ]           (* base type only *)
                    [ HasNonStandardRep : BOOLEAN ]           
                    [ HasPrimitiveOperations : BOOLEAN ]             (* base type only *)
                    [ HasSizeClause : BOOLEAN ]                
                    [ HasSpecifiedLayout : BOOLEAN ]                 (* base type only *)
                    [ HasTask : BOOLEAN ]                            (* base type only *)
                    [ HasUncheckedUnion : BOOLEAN ]                  (* base type only *)
                    [ InUse : BOOLEAN ]                         
                    [ IsAbstract : BOOLEAN ]                    
                    [ IsAsynchronous : BOOLEAN ]                
                    [ IsAtomic : BOOLEAN ]                      
                    [ IsConstrSubtForUNominal : BOOLEAN ]   
                    [ IsConstrSubtForUNAliased : BOOLEAN ]  
                    [ IsControlled : BOOLEAN ]                       (* base type only *)
                    [ IsDeclaredInPackageBody : BOOLEAN ]    
                    [ IsFrozen : BOOLEAN ]                      
                    [ IsGenericActualType : BOOLEAN ]         
                    [ IsGenericType : BOOLEAN ]                
                    [ IsNonStaticSubtype : BOOLEAN ]          
                    [ IsPacked : BOOLEAN ]                           (* base type only *)
                    [ IsPrivateComposite : BOOLEAN ]           
                    [ IsRenamingOfObject : BOOLEAN ]          
                    [ IsTaggedType : BOOLEAN ]                 
                    [ IsVolatile : BOOLEAN ]                    
                    [ SizeKnownAtCompileTime : BOOLEAN ]     
                    [ StrictAlignment : BOOLEAN ]               
                    [ SuppressInitProc : BOOLEAN ]             

                    (* AlignmentClause : NClassNode                  (* Computed *) *)
                    (* AncestorSubtype : NClassEntity                (* Computed *) *)
                    (* BaseType : NClassEntity                       (* Computed *) *)
                    (* FirstSubtype : NClassEntity                   (* Computed *) *)
                    (* HasPrivateAncestor : BOOLEAN                  (* Computed *) *)
                    (* ImplementationBaseType : NClassEntity         (* Computed *) *)
                    (* IsByCopyType : BOOLEAN                        (* Computed *) *)
                    (* IsByReferenceType : BOOLEAN                   (* Computed *) *)
                    (* IsReturnByReferenceType : BOOLEAN             (* Computed *) *)
                    (* RequiresTransientScope : BOOLEAN              (* Computed *) *)
                    (* RootType : NClassEntity                       (* Computed *) *)
                    (* SizeClause : NClassNode                       (* Computed *) *)

(*%%%%%*)
                    < (* different kinds of NClassEntityType *) 

            (* Type and Subtype nodes *) 


                      EAccessProtectedSubprogramType =
                        EquivalentType : NClassEntity                
                        DirectlyDesignatedType : NClassEntity       
                        [ NeedsNoActuals : BOOLEAN ]               
                        (* plus type attributes *)
                      . 

                      EAccessSubprogramType =
                        EquivalentType : NClassEntity                (* remote types only *)
                        DirectlyDesignatedType : NClassEntity       
                        [ NeedsNoActuals : BOOLEAN ]  
                        (* plus type attributes *)
                      . 

                      EClassAccessType =
                        MasterId : NClassEntity                      
                        DirectlyDesignatedType : NClassEntity       
                        AssociatedStoragePool : NClassEntity        
                        AssociatedFinalChain : NClassEntity         
                        StorageSizeVariable : NClassEntity           (* root type only *)
                        [ HasStorageSizeClause : BOOLEAN ]           (* root type only *)
                        [ IsAccessConstant : BOOLEAN ]             
                        [ NoPoolAssigned : BOOLEAN ]                 (* root type only *)
                        (* plus type attributes *)
                        < EAccessType =  
                            [ HasPragmaControlled : BOOLEAN ]        (* base type only *)
                          .
                          EAccessSubtype = . 
                        > 
                      . 

                      EAccessAttributeType =
                        DirectlyDesignatedType : NClassEntity       
                        (* plus type attributes *)
                      . 

                      EAllocatorType =
                        DirectlyDesignatedType : NClassEntity       
                        (* plus type attributes *)
                      . 

                      EAnonymousAccessType =
                        DirectlyDesignatedType : NClassEntity       
                        StorageSizeVariable : NClassEntity           (* ??? is this needed ??? *) 
                        (* plus type attributes *)
                      . 

                      EClassArrayType =
                        FirstIndex : NClassNode                    
                        PackedArrayType : NClassEntity              
                        RelatedArrayObject : NClassEntity           
                        [ ComponentAlignment : ComponentAlignmentKind ] (* special *)  (* base type only *)
                        [ IsAliased : BOOLEAN ]                     
                        [ IsConstrained : BOOLEAN ]                 
                        (* NextIndex                                 (* Computed *) *)
                        (* NumberDimensions : Pos                    (* Computed *) *)
                        (* plus type attributes *)
                        < EArrayType =  
                            ComponentType : NClassEntity             (* base type only *)
                            [ ComponentSize : Uint ]                 (* base type only *)
                            [ HasAtomicComponents : BOOLEAN ]        (* base type only *)
                            [ HasComponentSizeClause : BOOLEAN ]     (* base type only *)
                            [ HasControlledComponent : BOOLEAN ]     (* base type only *)
                            [ HasPragmaPack : BOOLEAN ]              (* base type only *)
                            [ HasVolatileComponents : BOOLEAN ]      (* base type only *)
                          . 
                          EArraySubtype = . 
                        > 
                      . 

                      EClassClassWideType =
                        EquivalentType : NClassEntity   (* always points to an Empty object in type case *)
                        FirstEntity : NClassEntity                   
                        LastEntity : NClassEntity                    
                        (* FirstComponent : NClassEntity             (* Computed *) *)
                        (* plus type attributes *)
                        < EClassWideType =  
                            [ HasControlledComponent : BOOLEAN ]     (* base type only *)
                          . 
                          EClassWideSubtype = . 
                        > 
                      . 

                      EClassDecimalFixedPointType =
                        [ SmallValue : Ureal ]                    
                        [ DeltaValue : Ureal ]                    
                        [ DigitsValue : Uint ]                   
                        ScalarRange : NClassNode                   
                        [ RMSize : Uint ]                        
                        [ ScaleValue : Uint ]                    
                        [ HasMachineRadixClause : BOOLEAN ]       
                        [ IsUnsignedType : BOOLEAN ]               
                        [ MachineRadix10 : BOOLEAN ]               
                        (* TypeLowBound : NClassNode                 (* Computed *) *)
                        (* TypeHighBound : NClassNode                (* Computed *) *)
                        (* plus type attributes *)
                        < EDecimalFixedPointType = .
                          EDecimalFixedPointSubtype = . 
                        > 
                      . 

                      EClassEnumerationType =
                        LitNameTable : NClassEntity                 
                        FirstLiteral : NClassEntity                  
                        ScalarRange : NClassNode                   
                        [ RMSize : Uint ]                        
                        [ HasBiasedRepresentation : BOOLEAN ]      
                        [ HasEnumerationRepClause : BOOLEAN ]     
                        [ IsUnsignedType : BOOLEAN ]               
                        (* TypeLowBound : NClassNode                 (* Computed *) *)
                        (* TypeHighBound : NClassNode                (* Computed *) *)
                        (* plus type attributes *)
                        < EEnumerationType =  
                            EnumPosToRep : NClassEntity              (* type only, not subtype *)
                          . 
                          EEnumerationSubtype = . 
                        > 
                      . 

                      EClassFloatingPointType =
                        [ DigitsValue : Uint ]                   
                        ScalarRange : NClassNode                   
                        (* TypeLowBound : NClassNode                 (* Computed *) *)
                        (* TypeHighBound : NClassNode                (* Computed *) *)
                        (* plus type attributes *)
                        < EFloatingPointType = . 
                          EFloatingPointSubtype = . 
                        > 
                      . 

                      EGeneralAccessType =
                        MasterId : NClassEntity                      
                        DirectlyDesignatedType : NClassEntity       
                        AssociatedStoragePool : NClassEntity        
                        AssociatedFinalChain : NClassEntity         
                        StorageSizeVariable : NClassEntity           (* base type only *)
                        (* plus type attributes *)
                      . 

                      EIncompleteType =
                        DiscriminantConstraint : ClassElist        
                        PrivateDependents : ClassElist             
                        GirderConstraint : ClassElist              
                        ImplementationTypePrivate : NClassEntity    
                        [ HasDiscriminants : BOOLEAN ]              
                        (* FirstDiscriminant : NClassEntity          (* Computed *) *)
                        (* FirstGirderDiscriminant : NClassEntity    (* Computed *) *)
                        (* plus type attributes *)
                      . 

                      EClassLimitedPrivateType =
                        DiscriminantConstraint : ClassElist        
                        PrivateDependents : ClassElist             
                        PrivateView : NClassNode                   
                        FirstEntity : NClassEntity                   
                        LastEntity : NClassEntity                    
                        GirderConstraint : ClassElist              
                        ImplementationTypePrivate : NClassEntity    
                        [ HasCompletion : BOOLEAN ]                 
                        [ HasCompletionInBody : BOOLEAN ]         
                        [ HasDiscriminants : BOOLEAN ]              
                        (* FirstDiscriminant : NClassEntity          (* Computed *) *)
                        (* FirstGirderDiscriminant : NClassEntity    (* Computed *) *)
                        (* plus type attributes *)
                        < ELimitedPrivateType = . 
                          ELimitedPrivateSubtype = . 
                        > 
                      . 

                      EClassModularIntegerType =
                        ScalarRange : NClassNode                   
                        [ RMSize : Uint ]                        
                        [ HasBiasedRepresentation : BOOLEAN ]      
                        [ IsUnsignedType : BOOLEAN ]               
                        (* TypeLowBound : NClassNode                 (* Computed *) *)
                        (* TypeHighBound : NClassNode                (* Computed *) *)
                        (* plus type attributes *)
                        < EModularIntegerType =  
                            [ Modulus : Uint ]                       (* base type only *)
                            [ NonBinaryModulus : BOOLEAN ]           (* base type only *)
                          . 
                          EModularIntegerSubtype = . 
                        > 
                      . 

                      EClassOrdinaryFixedPointType =
                        [ SmallValue : Ureal ]                    
                        [ DeltaValue : Ureal ]                    
                        ScalarRange : NClassNode                   
                        [ RMSize : Uint ]                        
                        [ HasSmallClause : BOOLEAN ]               
                        [ IsUnsignedType : BOOLEAN ]               
                        (* TypeLowBound : NClassNode                 (* Computed *) *)
                        (* TypeHighBound : NClassNode                (* Computed *) *)
                        (* plus type attributes *)
                        < EOrdinaryFixedPointType = . 
                          EOrdinaryFixedPointSubtype = . 
                        > 
                      . 

                      EClassPrivateType =
                        (* [ IsControlled ] is base type only *)
                        DiscriminantConstraint : ClassElist        
                        PrivateDependents : ClassElist             
                        PrivateView : NClassNode                   
                        FirstEntity : NClassEntity                   
                        LastEntity : NClassEntity                    
                        PrimitiveOperations : ClassElist           
                        GirderConstraint : ClassElist              
                        ImplementationTypePrivate : NClassEntity    
                        [ HasCompletion : BOOLEAN ]                 
                        [ HasCompletionInBody : BOOLEAN ]         
                        [ HasDiscriminants : BOOLEAN ]              
                        (* FirstDiscriminant : NClassEntity          (* Computed *) *)
                        (* FirstGirderDiscriminant : NClassEntity    (* Computed *) *)
                        (* plus type attributes *)
                        < EPrivateType = . 
                          EPrivateSubtype =  
                            [ IsForAccessSubtype : BOOLEAN ]         (* subtype only *)
                          . 
                        > 
                      . 

                      EClassRecordType =
                        (* [ IsControlled ] is base type only *)
                        DiscriminantConstraint : ClassElist        
                        CorrespondingConcurrentType : NClassEntity  
                        FirstEntity : NClassEntity                   
                        LastEntity : NClassEntity                    
                        ParentSubtype : NClassEntity                 
                        PrimitiveOperations : ClassElist           
                        GirderConstraint : ClassElist              
                        [ HasDiscriminants : BOOLEAN ]              
                        [ HasExternalTagRepClause : BOOLEAN ]    
                        [ HasRecordRepClause : BOOLEAN ]          
                        [ IsConcurrentRecordType : BOOLEAN ]      
                        [ IsConstrained : BOOLEAN ]                 
                        (* FirstComponent : NClassEntity             (* Computed *) *)
                        (* FirstDiscriminant : NClassEntity          (* Computed *) *)
                        (* FirstGirderDiscriminant : NClassEntity    (* Computed *) *)
                        (* TagComponent : NClassEntity               (* Computed *) *)
                        (* plus type attributes *)
                        < ERecordType =  
                            CorrespondingRemoteType : NClassEntity   (* base type only *)
                            AccessDispTable : NClassEntity           (* base type only *)
                            [ ComponentAlignment : ComponentAlignmentKind ] 
                                                                     (* special *)  (* base type only *)
                            [ CPassByCopy : BOOLEAN ]                (* base type only *)
                            [ HasControlledComponent : BOOLEAN ]     (* base type only *)
                          . 
                          ERecordSubtype = . 
                        > 
                      . 

                      EClassRecordTypeWithPrivate =
                        (* [ IsControlled ] is base type only *)
                        DiscriminantConstraint : ClassElist        
                        PrivateDependents : ClassElist             
                        PrivateView : NClassNode                   
                        FirstEntity : NClassEntity                   
                        LastEntity : NClassEntity                    
                        PrimitiveOperations : ClassElist           
                        GirderConstraint : ClassElist              
                        ImplementationTypePrivate : NClassEntity    
                        [ HasCompletion : BOOLEAN ]                 
                        [ HasCompletionInBody : BOOLEAN ]         
                        [ HasDiscriminants : BOOLEAN ]              
                        [ HasRecordRepClause : BOOLEAN ]          
                        [ HasExternalTagRepClause : BOOLEAN ]    
                        [ IsConcurrentRecordType : BOOLEAN ]      
                        [ IsConstrained : BOOLEAN ]                 
                        (* FirstComponent : NClassEntity             (* Computed *) *)
                        (* FirstDiscriminant : NClassEntity          (* Computed *) *)
                        (* FirstGirderDiscriminant : NClassEntity    (* Computed *) *)
                        (* TagComponent : NClassEntity               (* Computed *) *)
                        (* plus type attributes *)
                        < ERecordTypeWithPrivate =  
                            AccessDispTable : NClassEntity           (* base type only *)
                            [ HasControlledComponent : BOOLEAN ]     (* base type only *)
                          . 
                          ERecordSubtypeWithPrivate = . 
                        > 
                      . 

                      EClassSignedIntegerType =
                        ScalarRange : NClassNode                   
                        [ RMSize : Uint ]                        
                        [ HasBiasedRepresentation : BOOLEAN ]      
                        [ IsUnsignedType : BOOLEAN ]               
                        (* TypeLowBound : NClassNode                 (* Computed *) *)
                        (* TypeHighBound : NClassNode                (* Computed *) *)
                        (* plus type attributes *)
                        < ESignedIntegerType = . 
                          ESignedIntegerSubtype = . 
                        > 
                      . 

                      EClassStringType =
                        FirstIndex : NClassNode                    
                        [ IsConstrained : BOOLEAN ]                 
                        (* NextIndex                                 (* Computed *) *)
                        (* NumberDimensions : Pos                    (* Computed *) *)
                        (* plus type attributes *)
                        < EStringType =  
                            ComponentType : NClassEntity             (* base type only *)
                          . 
                          EStringSubtype = . 
                        > 
                      . 

                      EStringLiteralSubtype =
                        FirstIndex : NClassNode                      (* always points to an Empty object *)
                        ComponentType : NClassEntity                 (* base type only *) (* Huh? *)
                        PackedArrayType : NClassEntity              
                        StringLiteralLowBound : NClassNode       
                        [ StringLiteralLength : Uint ]          
                        (* plus type attributes *)
                      . 

                      ESubprogramType =
                        DirectlyDesignatedType : NClassEntity       
                        (* FirstFormal : NClassEntity                (* Computed *) *)
                        (* NumberFormals : Pos                       (* Computed *) *)
                        (* plus type attributes *)
                      . 

                      EClassTaskType =
                        DiscriminantConstraint : ClassElist        
                        CorrespondingRecordType : NClassEntity      
                        [ ScopeDepth : Uint ]                    
                        FirstEntity : NClassEntity                   
                        LastEntity : NClassEntity                    
                        FinalizationChainEntity : NClassEntity       (* ??? *)
                        GirderConstraint : ClassElist              
                        FirstPrivateEntity : NClassEntity           
                        TaskBodyProcedure : NClassEntity            
                        [ HasDiscriminants : BOOLEAN ]              
                        [ HasMasterEntity : BOOLEAN ]              
                        [ HasPendingInstantiations : BOOLEAN ]     
                        [ UsesSecStack : BOOLEAN ]                   (* ??? *)
                        (* HasEntries : BOOLEAN                      (* Computed *) *)
                        (* plus type attributes *)
                        < ETaskType =  
                            StorageSizeVariable : NClassEntity       (* base type only *)
                            [ HasStorageSizeClause : BOOLEAN ]       (* base type only *)
                          . 
                          ETaskSubtype = . 
                        > 
                      . 

                      (* The following don't say "plus type attributes", but have (Sub)Type in their
                         names.  Which info do we believe? Conservatively, I have given them
                         the uncertain fields. *) 

                      EEnumTableType =
                        ComponentType : NClassEntity                 (* base type only *)
                        TableHighBound : NClassNode               
                      . 

                      EExceptionType =
                        EquivalentType : NClassEntity                
                      . 

                      EClassProtectedType =
                        DiscriminantConstraint : ClassElist        
                        CorrespondingRecordType : NClassEntity      
                        [ ScopeDepth : Uint ]                    
                        FirstEntity : NClassEntity                   
                        LastEntity : NClassEntity                    
                        FirstPrivateEntity : NClassEntity           
                        FinalizationChainEntity : NClassEntity       (* ??? *)
                        GirderConstraint : ClassElist              
                        EntryBodiesArray : NClassEntity             
                        [ HasDiscriminants : BOOLEAN ]              
                        [ UsesSecStack : BOOLEAN ]                   (* ??? *)
                        (* HasEntries : BOOLEAN                      (* Computed *) *)
                        < EProtectedType = 
                            [ HasControlledComponent : BOOLEAN ]     (* base type only *)
                            [ HasInterruptHandler : BOOLEAN ]        (* base type only *)
                          . 
                          EProtectedSubtype = . 
                        > 
                      . 

(*%%%%%*) 

                    > (* End of different kinds of NClassEntityType *) 
                  . (* End of NClassEntityType *) 

                > (* End of NClassEntityNonType/NClassEntityType distinction *)  
              . (* End of NClassEntity *) 

            > (* End of NClassSNode/NClassEntity node distinction *) 
          . (* End of NClassNonEmpty *) 

        > (* End of Empty/NodeNonEmpty distinction *) 
      . (* End of NClassNode *) 

    > (* List/Node distinction *) 
  . (* End of ClassListOrNode *) 

(* End of file Gnat.cg *) 

