
(* file MThree6.puma 

   Generation of specialized tree converter from Gnat tree to 
   semantically equivalent cg tree. 
   Rodney M. Bates 10-97 

*)

TRAFO GenGnat 
TREE Tree
PUBLIC GnatModule 

GLOBAL {

(* IMPORT IO; This is already generated by puma *) 
FROM IO		IMPORT WriteS, WriteNl;
IMPORT Idents , Errors ; 
FROM Idents	IMPORT tIdent;
FROM Sets       IMPORT IsElement;
FROM Tree	IMPORT
   NoTree	, tTree		, 
   Class	, Child		, Attribute	, 
   NoCodeAttr	, NoCodeClass	, Low           , 
   iNoTree	, Options       , 
   itTree	, iMain		, iModule	, f		,
   WI	        , ForallClasses	, ForallAttributes, 
   IdentifyClass ;

IMPORT Positions , Strings;

VAR Node : tTree;
VAR gNodeClass : tTree ; 
VAR gEntityClass : tTree ; 
VAR gIdentNext : tIdent ;
VAR gIdentPrev : tIdent ;
VAR gIdentEinfo : tIdent ;
VAR gIdentSinfo : tIdent ;
VAR gIdentNClassNode : tIdent ;
VAR gIdentNClassEntity : tIdent ;
VAR gFieldInterface : tIdent ;
VAR gString : Strings . tString ; 

PROCEDURE WG ( Ident : tIdent ) 
; VAR I : CARDINAL 
; VAR LString : Strings . tString 
; VAR LPrevChar , LChar , LNextChar : CHAR 
; VAR LLength : CARDINAL 
; BEGIN 
    Idents . GetString ( Ident , LString ) 
  ; LLength := Strings . Length ( LString )  
  ; IF LLength > 0 
    THEN 
    ; I := 1 
    ; LPrevChar := ' ' 
    ; LChar := Strings . Char ( LString , 1 ) 
    ; LOOP 
        IF I < LLength 
        THEN 
          INC ( I )
        ; LNextChar := Strings . Char ( LString , I ) 
        ELSIF I = LLength  
        THEN 
          INC ( I )
        ; LNextChar := ' ' 
        ELSE EXIT 
        END (* IF *) 
      ; IF  ( ( ( 'a' <= LPrevChar ) AND ( LPrevChar <= 'z' ) ) 
              AND ( ( ( '0' <= LChar ) AND ( LChar <= '9' ) ) 
                    OR ( ( 'A' <= LChar ) AND ( LChar <= 'Z' ) ) 
                  ) 
            ) OR ( ( ( 'A' <= LPrevChar ) AND ( LPrevChar <= 'Z' ) ) 
                   AND ( ( 'A' <= LChar ) AND ( LChar <= 'Z' ) ) 
                   AND ( ( 'a' <= LNextChar ) AND ( LNextChar <= 'z' ) ) 
                 ) 
        THEN IO . WriteC ( f , '_' ) 
        END (* IF *) 
      ; IO . WriteC ( f , LChar ) 
      ; LPrevChar := LChar 
      ; LChar := LNextChar 
      END (* LOOP *) 
    END (* IF *) 
  END WG; 

PROCEDURE IsDescendedFrom ( Descendent : tTree ; Ancestor : tTree ) : BOOLEAN 
; VAR LClass : tTree 
; BEGIN
    IF Ancestor = NoTree THEN RETURN FALSE 
    ELSIF Tree . IsType ( Ancestor , Tree . NoClass ) THEN RETURN FALSE 
    ELSIF NOT Tree . IsType ( Ancestor , Tree . Class ) 
    THEN 
      Errors . MessageI
        ( 'IsDescendedFrom, Ancestor not Class' 
        , Errors . Fatal 
        , Positions . NoPosition 
        , Errors . Integer 
        , SYSTEM . ADR ( Ancestor ^ . Kind )  
        ) 
    ELSE 
      LClass := Descendent 
    ; LOOP 
        IF LClass = Ancestor THEN RETURN TRUE 
        ELSIF LClass  = NoTree THEN RETURN FALSE 
        ELSIF Tree . IsType ( LClass , Tree . NoClass ) THEN RETURN FALSE 
        ELSIF NOT Tree . IsType ( LClass , Tree . Class ) 
        THEN 
          Errors . MessageI
            ( 'IsDescendedFrom, LClass not Class' 
            , Errors . Fatal 
            , Positions . NoPosition 
            , Errors . Integer 
            , SYSTEM . ADR ( LClass ^ . Kind )
            ) 
        ELSE 
          LClass := LClass ^ . Class . BaseClass 
        END (* IF *) 
      END (* LOOP *) 
    END (* IF *) 
  END IsDescendedFrom ; 
}


(*
BEGIN 
  { Strings . ArrayToString ( 'Next' , gString ) ; 
    gIdentNext := Idents . MakeIdent ( gString ) ;
    Strings . ArrayToString ( 'Prev' , gString ) ; 
    gIdentPrev := Idents . MakeIdent ( gString ) ;
    Strings . ArrayToString ( 'Einfo' , gString ) ; 
    gIdentEinfo := Idents . MakeIdent ( gString ) ;
    Strings . ArrayToString ( 'Sinfo' , gString ) ; 
    gIdentSinfo := Idents . MakeIdent ( gString ) ;
    Strings . ArrayToString ( 'NClassNode' , gString ) ; 
    gIdentNClassNode := Idents . MakeIdent ( gString ) ;
    Strings . ArrayToString ( 'NClassEntity' , gString ) ; 
    gIdentNClassEntity := Idents . MakeIdent ( gString ) ;
    gNodeClass := IdentifyClass ( NoTree , gIdentNClassNode ) ; 
    gEntityClass := IdentifyClass ( NoTree , gIdentNClassEntity ) ; 
  }
*)

PROCEDURE GnatModule (t: Tree)

Ag (..) :- {
      IF IsElement (ORD ('~'), Options) THEN

        Strings . ArrayToString ( 'Next' , gString ) ; 
        gIdentNext := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Prev' , gString ) ; 
        gIdentPrev := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Einfo' , gString ) ; 
        gIdentEinfo := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Sinfo' , gString ) ; 
        gIdentSinfo := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'NClassNode' , gString ) ; 
        gIdentNClassNode := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'NClassEntity' , gString ) ; 
        gIdentNClassEntity := Idents . MakeIdent ( gString ) ;
        gNodeClass := IdentifyClass ( NoTree , gIdentNClassNode ) ; 
        gEntityClass := IdentifyClass ( NoTree , gIdentNClassEntity ) ; 


	!TYPE yyPtrtTree	= REF ! WI (itTree); !;!
	!!
	!TYPE yytMap = ARRAY OF ! WI (itTree); ! ;!
	!TYPE yytMapRef = REF yytMap ;!
	!!
        !VAR yyNodeMapRef : yytMapRef ;!
        !VAR yyListMapRef : yytMapRef ;!
        !VAR yyElistMapRef : yytMapRef ;!
        !VAR yyElmtMapRef : yytMapRef ;!
        !!
        !PROCEDURE yyInitMap ( MapRef : yytMapRef ) !
        ! = BEGIN !
        !     FOR I := 0 TO NUMBER ( MapRef ) !
        !     DO MapRef ^ [ I ] := ! WI ( iNoTree ) ; !!
        !     END (* FOR *) !
        ! END yyInitMap ; !
        !!
	!PROCEDURE yyConvert! WI (iMain); !!
        !   ( yyt : GnatTypes . Union_Id ; yyNew : yyPtrtTree )!
        !=BEGIN!
	!  LOOP!
        !    IF GnatTypes . List_Low_Bound <= yyt AND yyt <= GnatTypes . List_High_bound!
        !    THEN !
	!      IF yyt = GnatTypes . No_List!
        !      THEN yyNew ^ := NEW ( ! WI ( iMain ) ; ! . NoList )!
        !      ; RETURN!
        !      END (* IF *) !
        !    ; WITH WNewRef = yyListMapRef ^ [ yyt ] !
        !      DO!
        !        IF WNewRef # ! WI ( iNoTree ) ; !!
        !        THEN yyNew ^ := WNewRef ; RETURN END (* IF *) !
        !      ; VAR LNewList : Tree . List := NEW ( Tree . List ) ;!
        !        ; BEGIN!
        !            WNewRef := LNewList!
        !          ; yyNew ^ := WNewRef!
        !          ; yyConvert ( Lists . Parent ( yyt ) , ADR ( LNewList . Parent ) ) !
        !          ; yyConvert ( Lists . Last ( yyt ) , ADR ( LNewList . Last ) ) !
        !          ; yyt := Lists . First ( yyt ) !
        !          ; yyNew := ADR ( WNewRef . Last )!
        !          END (* BEGIN *) !
        !      END (* WITH WNewRef *) !
        !    ELSIF GnatTypes . Elist_Low_Bound <= yyt AND yyt <= GnatTypes . Elist_High_bound!
        !    THEN !
	!      IF yyt = GnatTypes . No_Elist!
        !      THEN yyNew ^ := NEW ( ! WI ( iMain ) ; ! . NoElist ) ; RETURN END !
        !    ; WITH WNewRef = yyElistMapRef ^ [ yyt ] !
        !      DO!
        !        IF WNewRef # ! WI ( iNoTree ) ; !!
        !        THEN yyNew ^ := WNewRef ; RETURN END (* IF *) !
        !      ; VAR LNewElist : Tree . Elist := NEW ( Tree . Elist ) ;!
        !        ; BEGIN!
        !            WNewRef := LNewElist!
        !          ; yyNew ^ := WNewRef!
        !          ; yyConvert ( Elists . Last_Elmt ( yyt ) , ADR ( LNewElist . LastElmt ) ) !
        !          ; yyt := Elists . First_Elmt ( yyt ) !
        !          ; yyNew := ADR ( WNewRef . LastElmt )!
        !          END (* BEGIN *) !
        !      END (* WITH WNewRef *) !
        !    ELSIF GnatTypes . Elmt_Low_Bound <= yyt AND yyt <= GnatTypes . Elmt_High_bound!
        !    THEN !
	!      IF yyt = GnatTypes . No_Elmt!
        !      THEN yyNew ^ := NEW ( ! WI ( iMain ) ; ! . NoElmt ) ; RETURN END !
        !    ; WITH WNewRef = yyElmtMapRef ^ [ yyt ] !
        !      DO!
        !        IF WNewRef # ! WI ( iNoTree ) ; !!
        !        THEN yyNew ^ := WNewRef!
        !        ; RETURN!
        !        END (* IF *) !
        !      ; VAR LNewElmt : Tree . Elmt := NEW ( Tree . Elist ) ;!
        !        ; BEGIN!
        !            WNewRef := LNewElmt!
        !          ; yyNew ^ := WNewRef!
        !          ; yyConvert ( Elists . Node ( yyt ) , ADR ( LNewElmt . Node ) ) !
        !          ; yyt := Elmts . Next_Elmt ( yyt ) !
        !          ; yyNew := ADR ( WNewRef . NextElmt )!
        !          END (* BEGIN *) !
        !      END (* WITH WNewRef *) !
        !    ELSIF GnatTypes . Node_Low_Bound <= yyt AND yyt <= GnatTypes . Node_High_bound!
        !    THEN !
	!      IF yyt = GnatTypes . Empty!
        !      THEN yyNew ^ := NEW ( ! WI ( iMain ) ; ! . Empty ) ; RETURN END !
        !    ; WITH WNewRef = yyNodeMapRef ^ [ yyt ] !
        !      DO!
        !        IF WNewRef # ! WI ( iNoTree ) ; !!
        !        THEN yyNew ^ := WNewRef!
        !        ; RETURN!
        !        END (* IF *) !
        !      ; CASE GnatUtils . Kind ( yyt ) OF!
	ForallClasses ( Classes , Convert);
        !        END (* CASE *)!
        !      END (* WITH WNewRef *) !
        !    ELSE <* ASSERT FALSE *> !
        !    END (* IF *) !
        !  END (* LOOP *) !
	! END yyConvert! WI (iMain); !;!
	!!
	!PROCEDURE GnatConvert! WI (iMain); ! ( GnatTree : Gnattypes . Node_Id ) !
        ! : ! WI (itTree); !!
	!=VAR yyNew	: ! WI (itTree); !;!
	! BEGIN!
	!  !
        !  yyNodeMapRef := NEW ( yytMapRef , Atree . Last_Node_Id ( ) ) ; !
        !  yyInitMap ( yyNodeMapRef ) ; !
        !  yyListMapRef := NEW ( yytMapRef , Nlists . Last_List_Id ( ) ) ; !
        !  yyInitMap ( yyListMapRef ) ; !
        !  yyElistMapRef := NEW ( yytMapRef , Elists . Last_Elist_Id ( ) ) ; !
        !  yyInitMap ( yyElistMapRef ) ; !
        !  yyElmtMapRef := NEW ( yytMapRef , Elists . Last_Elmt_Id ( ) ) ; !
        !  yyInitMap ( yyElmtMapRef ) ; !
        !!
	!  yyConvert! WI (iMain); ! ( GnatTree , ADR ( yyNew ) ) ;!
        !!
        !  yyNodeMapRef := NIL ; !
        !  yyListMapRef := NIL ; !
        !  yyElistMapRef := NIL ; !
        !  yyElmtMapRef := NIL ; !
        !!
	!  RETURN yyNew;!
	! END GnatConvert! WI (iMain); !;!
	!!
      END (* IF *) 
}; .


PROCEDURE Convert (t: Tree)

Class (..) :- {
	IF ( ( NoCodeClass * Properties ) = { } ) 
           AND ( Extensions ^ . Kind = Tree . NoClass ) (* Low IN Properties ) is not set *) 
           AND IsDescendedFrom ( t , gNodeClass ) 
        THEN
           IF IsDescendedFrom ( t , gEntityClass ) 
           THEN gFieldInterface := gIdentEinfo 
           ELSE gFieldInterface := gIdentSinfo 
           END (* IF *);   
	   !        | ! WI ( iMain ) ; ! . Nk! WI (Name); !!
           !        => VAR LNewNode := NEW ( ! WI ( iMain ) ; ! . ! WI ( Name ) ; ! )!
           !           ; BEGIN!
           !               WNewRef := LNewNode!
           !             ; yyNew ^ := WNewRef!
	   ForallAttributes (t, Convert);
           !             ; yyConvert ( Nlists . Prev ( yyt ) , ADR ( LNewNode . Prev ) ) !
           (* Field Next of Node is the builtin tail-recursion eliminated iterator *) 
           !             ; yyt := Nlists . Next ( yyt ) !
           !             ; yyNew := ADR ( WNewRef . Next )!
           !             END (* BEGIN *) !
	END;
}; .

Child (..) :- {
        IF ( Name <> gIdentNext ) AND ( Name <> gIdentPrev ) 
        THEN 
           !             ; yyConvert ( ! WI ( gFieldInterface ) ; ! . ! WG ( Name ) ; 
                                     ! ( yyt ) , ADR ( LNewNode . ! WI ( Name ) ; ! ) ) !
	END;
}; .
Attribute (..) :- {
	IF ( NoCodeAttr * Properties ) = {} 
        THEN 
(*         !             ; LNewNode . ! WI ( Name ) ; 
                           ! := ! WI ( gFieldInterface ) ; ! . ! WG ( Name ) ; ! ( yyt )!
*)
	   !             ; copy! WI (Type); ! ( LNewNode . ! WI ( Name ) ; 
                           ! , ! WI ( gFieldInterface ) ; ! . ! WG ( Name ) ; ! ( yyt ) )!
	END;
}; .


 (* End of file MThree6.puma *) 


