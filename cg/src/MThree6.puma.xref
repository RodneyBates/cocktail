     1 
     2 (* file MThree6.puma 
c    3 
c    4    Generation of specialized tree converter from Gnat tree to 
c    5    semantically equivalent cg tree. 
c    6    Rodney M. Bates 10-97 
c    7 
c    8 *)
     9 
    10 TRAFO GenGnat                                                                 *     *
    11 TREE Tree                                                                     *     *
    12 PUBLIC GnatModule                                                             *     *
    13 
    14 GLOBAL {                                                                      *
    15 
    16 (* IMPORT IO; This is already generated by puma *) 
    17 FROM IO         IMPORT WriteS, WriteNl;                                       *     *     *     *     *
    18 IMPORT Idents , Errors ;                                                     17     *     *
    19 FROM Idents     IMPORT tIdent;                                               17    18    18     *
    20 FROM Sets       IMPORT IsElement;                                            19     *    19     *
    21 FROM Tree       IMPORT                                                       20    11    20
    22    NoTree       , tTree         ,                                             *     *
    23    Class        , Child         , Attribute     ,                             *     *     *
    24    NoCodeAttr   , NoCodeClass   , Link          , Low           ,             *     *     *     *
    25    iNoTree      , Options       ,                                             *     *
    26    itTree       , iMain         , iModule       , f             ,             *     *     *     *
    27    WI           , ForallClasses , ForallAttributes,                           *     *     *
    28    IdentifyClass ;                                                            *
    29 
    30 IMPORT Positions , Strings;                                                  21     *     *
    31 
    32 VAR debug1 : BOOLEAN ;                                                        *     *     *
    33 
    34 VAR Node : tTree;                                                            32     *    22
    35 VAR gNClassNonEmptyClass : tTree ;                                           34     *    34
    36 VAR gEntityClass : tTree ;                                                   35     *    35
    37 VAR gIdentNodeNumber : tIdent ;                                              36     *    19
    38 VAR gIdentNext : tIdent ;                                                    37     *    37
    39 VAR gIdentPrev : tIdent ;                                                    38     *    38
    40 VAR gIdentIsListMember : tIdent ;                                            39     *    39
    41 VAR gIdentLink : tIdent ;                                                    40     *    40
    42 VAR gIdentSloc : tIdent ;                                                    41     *    41
    43 VAR gIdentIsRewriteSubstitution : tIdent ;                                   42     *    42
    44 VAR gIdentIsRewriteInsertion : tIdent ;                                      43     *    43
    45 VAR gIdentComesFromSource : tIdent ;                                         44     *    44
    46 VAR gIdentAnalyzed : tIdent ;                                                45     *    45
    47 VAR gIdentErrorPosted : tIdent ;                                             46     *    46
    48 VAR gIdentParenCount : tIdent ;                                              47     *    47
    49 VAR gIdentHasDynamicLengthCheck : tIdent ;                                   48     *    48
    50 VAR gIdentHasDynamicRangeCheck : tIdent ;                                    49     *    49
    51 VAR gIdentDiscriminantConstraint : tIdent ;                                  50     *    50
    52 VAR gIdentPrimitiveOperations : tIdent ;                                     51     *    51
    53 VAR gIdentPrivalsChain : tIdent ;                                            52     *    52
    54 VAR gIdentPrivateDependents : tIdent ;                                       53     *    53
    55 VAR gIdentGirderConstraint : tIdent ;                                        54     *    54
    56 VAR gIdentDefiningIdentifier : tIdent ;                                      55     *    55
    57 VAR gIdentMechanism : tIdent ;                                               56     *    56
    58 
    59 
    60 VAR gIdentChars : tIdent ;                                                   57     *    57
    61 VAR gIdentNextEntity : tIdent ;                                              60     *    60
    62 VAR gIdentScope : tIdent ;                                                   61     *    61
    63 VAR gIdentHomonym : tIdent ;                                                 62     *    62
    64 VAR gIdentEtype : tIdent ;                                                   63     *    63
    65 VAR gIdentEinfo : tIdent ;                                                   64     *    64
    66 VAR gIdentSinfo : tIdent ;                                                   65     *    65
    67 VAR gIdentGnatUtils : tIdent ;                                               66     *    66
    68 VAR gIdentGnatAdaUtils : tIdent ;                                            67     *    67
    69 VAR gIdentAtree : tIdent ;                                                   68     *    68
    70 VAR gIdentNlists : tIdent ;                                                  69     *    69
    71 VAR gIdentNClassNonEmpty : tIdent ;                                          70     *    70
    72 VAR gIdentNClassEntity : tIdent ;                                            71     *    71
    73 VAR gFieldInterface : tIdent ;                                               72     *    72
    74 VAR gString : Strings . tString ;                                            73     *    30     *
    75 
    76 (* Convert an M3-style identifier (mixed case) back to Gnat-style (underscores) *)
    77 PROCEDURE WG ( Ident : tIdent )                                               *     *     *    73
    78 ; VAR I : CARDINAL                                                           74     *     *
    79 ; VAR LString : Strings . tString                                            78     *    74    74
    80 ; VAR LPrevChar , LChar , LNextChar : CHAR                                   79     *     *     *     *
    81 ; VAR LLength : CARDINAL                                                     80     *    78
    82 ; BEGIN                                                                       *
    83     Idents . GetString ( Ident , LString )                                   19     *    77    79
    84   ; LLength := Strings . Length ( LString )                                  81    79     *    83
    85   ; IF LLength > 0                                                            *    84
    86     THEN                                                                      *
    87     ; I := 1                                                                 78
    88     ; LPrevChar := ' '                                                       80
    89     ; LChar := Strings . Char ( LString , 1 )                                80    84     *    84
    90     ; LOOP                                                                    *
    91         IF I < LLength                                                       85    87    85
    92         THEN                                                                 86
    93           INC ( I )                                                           *    91
    94         ; LNextChar := Strings . Char ( LString , I )                        80    89    89    89    93
    95         ELSIF I = LLength                                                     *    94    91
    96         THEN                                                                 92
    97           INC ( I )                                                          93    95
    98         ; LNextChar := ' '                                                   94
    99         ELSE EXIT                                                             *     *
   100         END (* IF *)                                                          *
   101       ; IF  ( ( ( 'a' <= LPrevChar ) AND ( LPrevChar <= 'z' ) )              91    88     *     *
   102               AND ( ( ( '0' <= LChar ) AND ( LChar <= '9' ) )               101    89     *     *
   103                     OR ( ( 'A' <= LChar ) AND ( LChar <= 'Z' ) )              *   102   102     *
   104                   ) 
   105             ) OR ( ( ( 'A' <= LPrevChar ) AND ( LPrevChar <= 'Z' ) )        103   101   103     *
   106                    AND ( ( 'A' <= LChar ) AND ( LChar <= 'Z' ) )            105   103     *     *
   107                    AND ( ( 'a' <= LNextChar ) AND ( LNextChar <= 'z' ) )    106    98     *     *
   108                  ) 
   109         THEN IO . WriteC ( f , '_' )                                         96    17     *    26
   110         END (* IF *)                                                        100
   111       ; IO . WriteC ( f , LChar )                                           109   109   109   106
   112       ; LPrevChar := LChar                                                  105   111
   113       ; LChar := LNextChar                                                  112   107
   114       END (* LOOP *)                                                        110
   115     END (* IF *)                                                            114
   116   END WG;                                                                   115    77
   117 
   118 PROCEDURE IsDescendedFrom ( Descendent : tTree ; Ancestor : tTree ) : BOOLEAN      77     *     *    36     *     *    32
   119 ; VAR LClass : tTree                                                         81     *   118
   120 ; BEGIN                                                                      82
   121     IF Ancestor = NoTree THEN RETURN FALSE                                  101   118    22   109     *     *
   122     ELSIF Tree . IsType ( Ancestor , Tree . NoClass ) THEN RETURN FALSE      95    21     *   121     *     *   121   121
                                                                                   121
   123     ELSIF NOT Tree . IsType ( Ancestor , Tree . Class )                     122     *   122   122   122     *    23
   124     THEN                                                                    122
   125       Errors . MessageI                                                      18     *
   126         ( 'IsDescendedFrom, Ancestor not Class' 
   127         , Errors . Fatal                                                    125     *
   128         , Positions . NoPosition                                             30     *
   129         , Errors . Integer                                                  127     *
   130         , SYSTEM . ADR ( Ancestor ^ . Kind )                                  *     *   123     *
   131         ) 
   132     ELSE                                                                     99
   133       LClass := Descendent                                                  119   118
   134     ; LOOP                                                                   90
   135         IF LClass = Ancestor THEN RETURN TRUE                               121   133   130   124   122     *
   136         ELSIF LClass  = NoTree THEN RETURN FALSE                            123   135   121   135   135   122
   137         ELSIF Tree . IsType ( LClass , Tree . NoClass ) THEN RETURN FALSE         136   123   123   136     *   122   136
                                                                                   136   136
   138         ELSIF NOT Tree . IsType ( LClass , Tree . Class )                   137   123   137   137   137     *   123
   139         THEN                                                                137
   140           Errors . MessageI                                                 129   125
   141             ( 'IsDescendedFrom, LClass not Class' 
   142             , Errors . Fatal                                                140   127
   143             , Positions . NoPosition                                        128   128
   144             , Errors . Integer                                              142   129
   145             , SYSTEM . ADR ( LClass ^ . Kind )                              130   130   138   130
   146             ) 
   147         ELSE                                                                132
   148           LClass := LClass ^ . Class . BaseClass                            145     *   138     *
   149         END (* IF *)                                                        116
   150       END (* LOOP *)                                                        149
   151     END (* IF *)                                                            150
   152   END IsDescendedFrom ;                                                     151   118
   153 
   154 PROCEDURE PackageName ( FieldName : tIdent ) : tIdent                       118     *     *    77     *
   155 ; BEGIN                                                                     120
   156     IF FieldName = gIdentNext                                               135   154    38
   157     THEN RETURN gIdentNlists                                                139   137    70
   158     ELSIF FieldName = gIdentPrev                                            138   156    39
   159     THEN RETURN gIdentNlists                                                157   157   157
   160     ELSIF FieldName = gIdentLink                                            158   158    41
   161     THEN RETURN gIdentGnatAdaUtils                                          159   159    68
   162     ELSIF FieldName = gIdentNextEntity                                      160   160    61
   163     THEN RETURN gIdentSinfo                                                 161   161    66
   164     ELSIF FieldName = gIdentScope                                           162   162    62
   165     THEN RETURN gIdentSinfo                                                 163   163   163
   166     ELSIF FieldName = gIdentHomonym                                         164   164    63
   167     THEN RETURN gIdentSinfo                                                 165   165   165
   168     ELSIF FieldName = gIdentEtype                                           166   166    64
   169     THEN RETURN gIdentSinfo                                                 167   167   167
   170     ELSIF FieldName = gIdentDiscriminantConstraint                          168   168    51
   171     THEN RETURN gIdentGnatAdaUtils                                          169   169   161
   172     ELSIF FieldName = gIdentPrimitiveOperations                             170   170    52
   173     THEN RETURN gIdentGnatAdaUtils                                          171   171   171
   174     ELSIF FieldName = gIdentPrivalsChain                                    172   172    53
   175     THEN RETURN gIdentGnatAdaUtils                                          173   173   173
   176     ELSIF FieldName = gIdentPrivateDependents                               174   174    54
   177     THEN RETURN gIdentGnatAdaUtils                                          175   175   175
   178     ELSIF FieldName = gIdentGirderConstraint                                176   176    55
   179     THEN RETURN gIdentGnatAdaUtils                                          177   177   177
   180     ELSIF FieldName = gIdentDefiningIdentifier                              178   178    56
   181     THEN RETURN gIdentGnatAdaUtils                                          179   179   179
   182     ELSIF FieldName = gIdentMechanism                                       180   180    57
   183     THEN RETURN gIdentGnatAdaUtils                                          181   181   181
   184     ELSIF FieldName = gIdentIsListMember                                    182   182    40
   185     THEN RETURN gIdentNlists                                                183   183   159
   186     ELSIF FieldName = gIdentSloc                                            184   184    42
   187     THEN RETURN gIdentAtree                                                 185   185    69
   188     ELSIF FieldName = gIdentIsRewriteSubstitution                           186   186    43
   189     THEN RETURN gIdentAtree                                                 187   187   187
   190     ELSIF FieldName = gIdentIsRewriteInsertion                              188   188    44
   191     THEN RETURN gIdentAtree                                                 189   189   189
   192     ELSIF FieldName = gIdentComesFromSource                                 190   190    45
   193     THEN RETURN gIdentAtree                                                 191   191   191
   194     ELSIF FieldName = gIdentAnalyzed                                        192   192    46
   195     THEN RETURN gIdentAtree                                                 193   193   193
   196     ELSIF FieldName = gIdentErrorPosted                                     194   194    47
   197     THEN RETURN gIdentAtree                                                 195   195   195
   198     ELSIF FieldName = gIdentParenCount                                      196   196    48
   199     THEN RETURN gIdentAtree                                                 197   197   197
   200     ELSIF FieldName = gIdentHasDynamicLengthCheck                           198   198    49
   201     THEN RETURN gIdentSinfo                                                 199   199   169
   202     ELSIF FieldName = gIdentHasDynamicRangeCheck                            200   200    50
   203     THEN RETURN gIdentSinfo                                                 201   201   201
   204     ELSIF FieldName = gIdentChars                                           202   202    60
   205     THEN RETURN gIdentSinfo                                                 203   203   203
   206     ELSE RETURN gFieldInterface                                             147   205    73
   207     END (* IF *)                                                            152
   208   END PackageName ;                                                         207   154
   209 
   210 CONST UseQualifiers = FALSE ;                                                 *     *   137
   211 
   212 PROCEDURE WriteQualifier ( Name : tIdent )                                  154     *     *   154
   213 ; BEGIN                                                                     155
   214     IF IsElement ( ORD ( '%' ) , Options )                                  156    20     *    25
   215     THEN                                                                    205
   216       WI ( PackageName ( Name ) ) ;                                          27   208   212
   217       WriteS ( f , " . " )                                                   17   111
   218     END (* IF *)                                                            208
   219   END WriteQualifier ;                                                      218   212
   220 
   221 } (* End of GLOBAL *) 
   222 
   223 (*
c  224 BEGIN 
c  225   {  }
c  226 *)
   227 
   228 PROCEDURE GnatModule (t: Tree)                                              212    12     *   138
   229 
   230 Ag (..) :- {                                                                  *
   231       IF IsElement (ORD ('~'), Options) THEN                                214   214   214   214   215
   232 
   233         debug1 := IsElement ( ORD ( 'Z' ) , Options ) ;                      32   231   231   231
   234 
   235         Strings . ArrayToString ( 'NodeNumber' , gString ) ;                 94     *    74
   236         gIdentNodeNumber := Idents . MakeIdent ( gString ) ;                 37    83     *   235
   237         Strings . ArrayToString ( 'Next' , gString ) ;                      235   235   236
   238         gIdentNext := Idents . MakeIdent ( gString ) ;                      156   236   236   237
   239         Strings . ArrayToString ( 'Prev' , gString ) ;                      237   237   238
   240         gIdentPrev := Idents . MakeIdent ( gString ) ;                      158   238   238   239
   241         Strings . ArrayToString ( 'IsListMember' , gString ) ;              239   239   240
   242         gIdentIsListMember := Idents . MakeIdent ( gString ) ;              184   240   240   241
   243         Strings . ArrayToString ( 'Link' , gString ) ;                      241   241   242
   244         gIdentLink := Idents . MakeIdent ( gString ) ;                      160   242   242   243
   245         Strings . ArrayToString ( 'Sloc' , gString ) ;                      243   243   244
   246         gIdentSloc := Idents . MakeIdent ( gString ) ;                      186   244   244   245
   247         Strings . ArrayToString ( 'IsRewriteSubstitution' , gString ) ;     245   245   246
   248         gIdentIsRewriteSubstitution := Idents . MakeIdent ( gString ) ;     188   246   246   247
   249         Strings . ArrayToString ( 'IsRewriteInsertion' , gString ) ;        247   247   248
   250         gIdentIsRewriteInsertion := Idents . MakeIdent ( gString ) ;        190   248   248   249
   251         Strings . ArrayToString ( 'ComesFromSource' , gString ) ;           249   249   250
   252         gIdentComesFromSource := Idents . MakeIdent ( gString ) ;           192   250   250   251
   253         Strings . ArrayToString ( 'Analyzed' , gString ) ;                  251   251   252
   254         gIdentAnalyzed := Idents . MakeIdent ( gString ) ;                  194   252   252   253
   255         Strings . ArrayToString ( 'ErrorPosted' , gString ) ;               253   253   254
   256         gIdentErrorPosted := Idents . MakeIdent ( gString ) ;               196   254   254   255
   257         Strings . ArrayToString ( 'ParenCount' , gString ) ;                255   255   256
   258         gIdentParenCount := Idents . MakeIdent ( gString ) ;                198   256   256   257
   259         Strings . ArrayToString ( 'HasDynamicLengthCheck' , gString ) ;     257   257   258
   260         gIdentHasDynamicLengthCheck := Idents . MakeIdent ( gString ) ;     200   258   258   259
   261         Strings . ArrayToString ( 'DiscriminantConstraint' , gString ) ;    259   259   260
   262         gIdentDiscriminantConstraint := Idents . MakeIdent ( gString ) ;    170   260   260   261
   263         Strings . ArrayToString ( 'PrimitiveOperations' , gString ) ;       261   261   262
   264         gIdentPrimitiveOperations := Idents . MakeIdent ( gString ) ;       172   262   262   263
   265         Strings . ArrayToString ( 'PrivalsChain' , gString ) ;              263   263   264
   266         gIdentPrivalsChain := Idents . MakeIdent ( gString ) ;              174   264   264   265
   267         Strings . ArrayToString ( 'PrivateDependents' , gString ) ;         265   265   266
   268         gIdentPrivateDependents := Idents . MakeIdent ( gString ) ;         176   266   266   267
   269         Strings . ArrayToString ( 'GirderConstraint' , gString ) ;          267   267   268
   270         gIdentGirderConstraint := Idents . MakeIdent ( gString ) ;          178   268   268   269
   271         Strings . ArrayToString ( 'DefiningIdentifier' , gString ) ;        269   269   270
   272         gIdentDefiningIdentifier := Idents . MakeIdent ( gString ) ;        180   270   270   271
   273         Strings . ArrayToString ( 'Mechanism' , gString ) ;                 271   271   272
   274         gIdentMechanism := Idents . MakeIdent ( gString ) ;                 182   272   272   273
   275         Strings . ArrayToString ( 'HasDynamicRangeCheck' , gString ) ;      273   273   274
   276         gIdentHasDynamicRangeCheck := Idents . MakeIdent ( gString ) ;      202   274   274   275
   277         Strings . ArrayToString ( 'Chars' , gString ) ;                     275   275   276
   278         gIdentChars := Idents . MakeIdent ( gString ) ;                     204   276   276   277
   279         Strings . ArrayToString ( 'NextEntity' , gString ) ;                277   277   278
   280         gIdentNextEntity := Idents . MakeIdent ( gString ) ;                162   278   278   279
   281         Strings . ArrayToString ( 'Scope' , gString ) ;                     279   279   280
   282         gIdentScope := Idents . MakeIdent ( gString ) ;                     164   280   280   281
   283         Strings . ArrayToString ( 'Homonym' , gString ) ;                   281   281   282
   284         gIdentHomonym := Idents . MakeIdent ( gString ) ;                   166   282   282   283
   285         Strings . ArrayToString ( 'Etype' , gString ) ;                     283   283   284
   286         gIdentEtype := Idents . MakeIdent ( gString ) ;                     168   284   284   285
   287         Strings . ArrayToString ( 'Einfo' , gString ) ;                     285   285   286
   288         gIdentEinfo := Idents . MakeIdent ( gString ) ;                      65   286   286   287
   289         Strings . ArrayToString ( 'Sinfo' , gString ) ;                     287   287   288
   290         gIdentSinfo := Idents . MakeIdent ( gString ) ;                     205   288   288   289
   291         Strings . ArrayToString ( 'GnatUtils' , gString ) ;                 289   289   290
   292         gIdentGnatUtils := Idents . MakeIdent ( gString ) ;                  67   290   290   291
   293         Strings . ArrayToString ( 'GnatAdaUtils' , gString ) ;              291   291   292
   294         gIdentGnatAdaUtils := Idents . MakeIdent ( gString ) ;              183   292   292   293
   295         Strings . ArrayToString ( 'Atree' , gString ) ;                     293   293   294
   296         gIdentAtree := Idents . MakeIdent ( gString ) ;                     199   294   294   295
   297         Strings . ArrayToString ( 'Nlists' , gString ) ;                    295   295   296
   298         gIdentNlists := Idents . MakeIdent ( gString ) ;                    185   296   296   297
   299         Strings . ArrayToString ( 'NClassNonEmpty' , gString ) ;            297   297   298
   300         gIdentNClassNonEmpty := Idents . MakeIdent ( gString ) ;             71   298   298   299
   301         gNClassNonEmptyClass := IdentifyClass ( NoTree , gIdentNClassNonEmpty ) ;        35    28   136   300
   302         Strings . ArrayToString ( 'NClassEntity' , gString ) ;              299   299   300
   303         gIdentNClassEntity := Idents . MakeIdent ( gString ) ;               72   300   300   302
   304         gEntityClass := IdentifyClass ( NoTree , gIdentNClassEntity ) ;      36   301   301   303
   305 
   306 
   307         !TYPE yyPtrtTree        = UNTRACED REF ! WI (itTree); !;!             *     *     *     *   216    26
   308         !!
   309         !TYPE yytMapArray = ARRAY OF ! WI (itTree); ! ;!                    307     *     *     *   307   307
   310         !TYPE yytMapRef = REF yytMapArray ;!                                309     *   307   309
   311         !!
   312         !VAR yyNodeMapRef : yytMapRef ;!                                    119     *   310
   313         !VAR yyListMapRef : yytMapRef ;!                                    312     *   312
   314         !VAR yyElistMapRef : yytMapRef ;!                                   313     *   313
   315         !VAR yyElmtMapRef : yytMapRef ;!                                    314     *   314
   316         !VAR yyNextNodeNumber : INTEGER := 1 ;!                             315     *     *
   317         !!
   318         !PROCEDURE yyConvert! WI (iMain); !!                                228     *   309    26
   319         !   ( FId : GnatTypes . Union_Id !                                    *     *     *
   320         !   ; FNew : yyPtrtTree !                                             *   307
   321         !   ; FCallerId : GnatTypes . Union_Id !                              *   319   319
   322         !   ; FCallerField : TEXT !                                           *     *
   323         !   )!
   324         !=VAR LKind : ! WI ( iMain ) ; ! . SHORTCARD !                      316     *   318   318     *
   325         !;VAR LId := FId!                                                   324     *   319
   326         !;VAR LNew := FNew!                                                 325     *   320
   327         !;VAR LCallerId := FCallerId!                                       326     *   321
   328         !;VAR LCallerField := FCallerField!                                 327     *   322
   329         !;BEGIN!                                                            213
   330         !  LOOP!                                                            134
   331         !    IF GnatTypes . List_Low_Bound <= LId !                         231   321     *   325
   332         !       AND LId < GnatTypes . List_Low_Bound + NUMBER ( yyListMapRef ^ )!       107   331   331   331     *   313
   333         !    THEN (* This is a list node. *) !                              231
   334         !      IF LId = GnatTypes . No_List!                                331   332   332     *
   335         !      THEN!                                                        333
   336         !        VAR LNewList := NEW ( ! WI ( iMain ) ; ! . NoList )!       328     *     *   324   324     *
   337         !                   (* Multiple copies of NoList nodes *)!
   338         !      ; BEGIN!                                                     329
   339         !          LNew ^ := LNewList!                                      326   336
   340         !        ; LNew ^ . Kind := Tree . NkNoList!                        339   145   228     *
   341         !        ; LNewList . NodeNumber := yyNextNodeNumber!               339     *   316
   342         !        ; INC ( yyNextNodeNumber )!                                 97   341
   343         !        ; RETURN!                                                  206
   344         !        END (* BEGIN *)!                                           219
   345         !      END (* IF *) !                                               344
   346         !    ; WITH WNewRef = yyListMapRef ^ [ LId - GnatTypes . List_Low_Bound ] !       *     *   332   334   334   332
   347         !      DO!                                                            *
   348         !        IF WNewRef # ! WI ( iNoTree ) ; !!                         334   346   336    25
   349         !        THEN LNew ^ := WNewRef ; RETURN END (* IF *) !             335   340   348   343   345
   350         !      ; VAR LNewList : Tree . List := NEW ( ! WI ( iMain ) ; ! . List ) !      336   341   340     *   336   348
                                                                                   336     *
   351         !        ; BEGIN!                                                   338
   352         !            WNewRef := LNewList!                                   349   350
   353         !          ; LNew ^ := LNewList!                                    349   352
   354         !          ; LNew ^ . Kind := Tree . NkList!                        353   340   350     *
   355         !          ; LNewList . NodeNumber := yyNextNodeNumber!             353   341   342
   356         !          ; INC ( yyNextNodeNumber )!                              342   355
   357         !          ; yyConvert! WI (iMain); !!                              318   350   350
   358         !               ( Nlists . Parent ( LId ) , ADR ( LNewList . Parent )!      *     *   346   145   355     *
   359         @               , LId , " Parent" ) @                               358
   360         !          ; yyConvert! WI (iMain); !!                              357   357   357
   361         !               ( Nlists . Last ( LId ) , ADR ( LNewList . Last )!        358     *   359   358   358     *
   362         @               , LId , "Last" ) @                                  361
   363         !          ; LCallerId := LId!                                      327   362
   364         @          ; LCallerField := "First"@                               328
   365         !          ; LId := Nlists . First ( LId ) !                        363   361     *     *
   366         !          ; LNew := ADR ( LNewList . First )!                      354   361   361   365
   367         !          END (* BEGIN *) !                                        349
   368         !      END (* WITH WNewRef *) !                                     367
   369         !    ELSIF GnatTypes . Elist_Low_Bound <= LId!                      204   346     *   365
   370         !          AND LId < GnatTypes . Elist_Low_Bound + NUMBER ( yyElistMapRef ^ \   332   369   369   369   332   314
      \)!
   371         !    THEN (* This is an Elist node. *) !                            349
   372         !      IF LId = GnatTypes . No_Elist!                               348   370   370     *
   373         !      THEN!                                                        371
   374         !        VAR LNewElist := NEW ( ! WI ( iMain ) ; ! . NoElist ) !    350     *   350   360   360     *
   375         !                   (* Multiple copies of NoElist nodes *)!
   376         !      ; BEGIN!                                                     351
   377         !          LNew ^ := LNewElist!                                     366   374
   378         !        ; LNew ^ . Kind := Tree . NkNoElist!                       377   354   354     *
   379         !        ; LNewElist . NodeNumber := yyNextNodeNumber!              377   355   356
   380         !        ; INC ( yyNextNodeNumber )!                                356   379
   381         !        ; RETURN  !                                                349
   382         !        END (* BEGIN *)!                                           368
   383         !      END (* IF *) !                                               382
   384         !    ; WITH WNewRef = yyElistMapRef ^ [ LId - GnatTypes . Elist_Low_Bound ] \   346   352   370   372   372   370
      \!
   385         !      DO!                                                          347
   386         !        IF WNewRef # ! WI ( iNoTree ) ; !!                         372   384   374   348
   387         !        THEN LNew ^ := WNewRef ; RETURN END (* IF *) !             373   378   386   381   383
   388         !      ; VAR LNewElist : Tree . Elist := NEW ( ! WI ( iMain ) ; ! . Elist ) \   374   379   378     *   374   386
                                                                                   374     *
      \!
   389         !        ; BEGIN!                                                   376
   390         !            WNewRef := LNewElist!                                  387   388
   391         !          ; LNew ^ := LNewElist!                                   387   390
   392         !          ; LNew ^ . Kind := Tree . NkElist!                       391   378   388     *
   393         !          ; LNewElist . NodeNumber := yyNextNodeNumber!            391   379   380
   394         !          ; INC ( yyNextNodeNumber )!                              380   393
   395         !          ; yyConvert! WI (iMain);!!                               360   388   388
   396         !               ( Elists . Last_Elmt ( LId ) , ADR ( LNewElist . LastElmt )!      *     *   384   366   393     *
   397         @               , LId , "Last_Elmt" ) @                             396
   398         !          ; LCallerId := LId!                                      363   397
   399         @          ; LCallerField := "First_Elmt"@                          364
   400         !          ; LId := Elists . First_Elmt ( LId ) !                   398   396     *     *
   401         !          ; LNew := ADR ( LNewElist . FirstElmt )!                 392   396   396     *
   402         !          END (* BEGIN *) !                                        387
   403         !      END (* WITH WNewRef *) !                                     402
   404         !    ELSIF GnatTypes . Elmt_Low_Bound <= LId!                       369   384     *   400
   405         !          AND LId < GnatTypes . Elmt_Low_Bound + NUMBER ( yyElmtMapRef ^ )!    370   404   404   404   370   315
   406         !    THEN (* This is an Elmt node. *) !                             387
   407         !      IF LId = GnatTypes . No_Elmt!                                386   405   405     *
   408         !      THEN!                                                        406
   409         !        VAR LNewElmt := NEW ( ! WI ( iMain ) ; ! . NoElmt ) !      388     *   388   395   395     *
   410         !                   (* Multiple copies of NoElmt nodes *)!
   411         !      ; BEGIN!                                                     389
   412         !          LNew ^ := LNewElmt !                                     401   409
   413         !        ; LNew ^ . Kind := Tree . NkNoElmt!                        412   392   392     *
   414         !        ; LNewElmt . NodeNumber := yyNextNodeNumber!               412   393   394
   415         !        ; INC ( yyNextNodeNumber )!                                394   414
   416         !        ; RETURN !                                                 387
   417         !        END (* BEGIN *)!                                           403
   418         !      END (* IF *) !                                               417
   419         !    ; WITH WNewRef = yyElmtMapRef ^ [ LId - GnatTypes . Elmt_Low_Bound ] !     384   390   405   407   407   405
   420         !      DO!                                                          385
   421         !        IF WNewRef # ! WI ( iNoTree ) ; !!                         407   419   409   386
   422         !        THEN LNew ^ := WNewRef!                                    408   413   421
   423         !        ; RETURN!                                                  416
   424         !        END (* IF *) !                                             418
   425         !      ; VAR LNewElmt : Tree . Elmt := NEW ( ! WI ( iMain ) ; ! . Elmt ) !      409   414   413     *   409   421
                                                                                   409     *
   426         !        ; BEGIN!                                                   411
   427         !            WNewRef := LNewElmt!                                   422   425
   428         !          ; LNew ^ := LNewElmt!                                    422   427
   429         !          ; LNew ^ . Kind := Tree . NkElmt!                        428   413   425     *
   430         !          ; LNewElmt . NodeNumber := yyNextNodeNumber!             428   414   415
   431         !          ; INC ( yyNextNodeNumber )!                              415   430
   432         !          ; yyConvert! WI (iMain); !!                              395   425   425
   433         !               ( Elists . Node ( LId ) , ADR ( LNewElmt . Node )!        400    34   419   401   430     *
   434         @               , LId , "Node" ) @                                  433
   435         !          ; LCallerId := LId!                                      398   434
   436         @          ; LCallerField := "Next_Elmt"@                           399
   437         !          ; LId := Elists . Next_Elmt ( LId ) !                    435   433     *     *
   438         !          ; LNew := ADR ( LNewElmt . NextElmt )!                   429   433   433     *
   439         !          END (* BEGIN *) !                                        424
   440         !      END (* WITH WNewRef *) !                                     439
   441         !    ELSIF GnatTypes . Node_Low_Bound <= LId!                       404   419     *   437
   442         !          AND LId < GnatTypes . Node_Low_Bound + NUMBER ( yyNodeMapRef ^ )!    405   441   441   441   405   312
   443         !    THEN (* This is an ordinary node. *) !                         422
   444         !      IF LId = GnatTypes . Empty!                                  421   442   442     *
   445         !      THEN!                                                        443
   446         !        VAR LNewNode := NEW ( ! WI ( iMain ) ; ! . NNoNode ) !     425     *   425   432   432     *
   447         !                   (* Multiple copies of Empty nodes *)!
   448         !      ; BEGIN !                                                    426
   449         !          LNew ^ := LNewNode !                                     438   446
   450         !        ; LNew ^ . Kind := Tree . NkNNoNode!                       449   429   429     *
   451         !        ; LNewNode . NodeNumber := yyNextNodeNumber!               449   430   431
   452         !        ; INC ( yyNextNodeNumber )!                                431   451
   453         !        ; RETURN !                                                 423
   454         !        END (* BEGIN *) !                                          440
   455         !      END (* IF *) !                                               454
   456         !    ; WITH WNewRef = yyNodeMapRef [ LId - GnatTypes . Node_Low_Bound ] !       419   427   442   444   444   442
   457         !      DO!                                                          420
   458         !        IF WNewRef # ! WI ( iNoTree ) ; !!                         444   456   446   421
   459         !        THEN LNew ^ := WNewRef!                                    445   450   458
   460         !        ; RETURN!                                                  453
   461         !        END (* IF *) !                                             455
   462         !      ; LKind := GnatUtils . Kind ( LId )!                         324     *   450   456
   463         !      ; CASE LKind OF!                                               *   462   309
   464         ForallClasses ( Classes , Convert);                                  27     *     *
   465         !        END (* CASE *)!                                            461
   466         !      END (* WITH WNewRef *) !                                     465
   467         !    ELSE (* Bad UnionId *)  !                                      206
   468         @      Wr . PutText ( Stdio . stdout , "Bad union id, " )@            *     *     *     *
   469         !    ; Wr . PutText ( Stdio . stdout , Fmt . Int ( LCallerId ) )!   468   468   468   468     *     *   435
   470         !    ; Wr . PutChar ( Stdio . stdout , ':' )!                       469     *   469   469
   471         !    ; Wr . PutText ( Stdio . stdout , LCallerField )!              470   469   470   470   436
   472         !    ; Wr . PutChar ( Stdio . stdout , '=' )!                       471   470   471   471
   473         !    ; Wr . PutText ( Stdio . stdout , Fmt . Int ( LId ) )!         472   471   472   472   469   469   462
   474         !    ; Wr . PutText ( Stdio . stdout , Wr . EOL )!                  473   473   473   473     *     *
   475         !    ; Wr . Flush ( Stdio . stdout )!                               474     *   474   474
   476         !    ; LNew ^ := NIL!                                               459     *
   477         !    ; RETURN!                                                      460
   478         !    END (* IF *) !                                                 466
   479         !  END (* LOOP *) !                                                 478
   480         ! END yyConvert! WI (iMain); !;!                                    479   432   458   446
   481         !!
   482         IF debug1                                                           458   233
   483         THEN                                                                459
   484         !PROCEDURE yyWriteHex ( VAR yyx : ARRAY OF CHAR ) !                 318     *   446     *   309   463    80
   485         !=BEGIN!                                                            448
   486         !  FOR yyi := 0 TO NUMBER ( yyx ) - 1 DO!                             *     *     *   442   484   457
   487         !   Wr . PutText ( Stdio . stdout , Fmt . Pad ( Fmt . Int ( ORD ( yyx [ yyi \   475   474   475   475   473     *
                                                                                     *   473   233   486   486
      \] ) , 16 ) , 2 , '0' ) ) ;!
   488         !   Wr . PutChar ( Stdio . stdout , ' ' ) ;!                        487   472   487   487
   489         !  END ;!                                                           480
   490         ! END yyWriteHex ;!                                                 489   484
   491         !!
   492         END (* IF debug1 *) ;                                               490
   493         !PROCEDURE GnatConvert! WI (iMain); ! ( GnatTree : GnatTypes . Node_Id ) !      484     *   480   480     *   456
                                                                                     *
   494         ! : ! WI (itTree); !!                                               493   309
   495         !=VAR LNew      : ! WI (itTree); !;!                                484   476   494   494
   496         ! BEGIN!                                                            485
   497         !  !
   498         !  yyNodeMapRef := NEW ( yytMapRef , Atree . Last_Node_Id ( )  - GnatTypes .\   456   446   315     *     *   493
      \ Node_Low_Bound + 1 ) ;!                                                    456
   499         IF debug1                                                           482   482
   500         THEN                                                                483
   501         @  Wr . PutText ( Stdio . stdout , "Last_Node_Id = " ) ; @          488   487   488   488
   502         !  Wr . PutText ( Stdio . stdout , Fmt . Int ( Atree . Last_Node_Id ( ) ) ) \   501   501   501   501   487   487
                                                                                   498   498
      \; !
   503         !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; !                   502   502   502   502     *   474
   504         @  Wr . PutText ( Stdio . stdout , "yyNodeMapRef = " ) ; @          503   503   503   503
   505         !  yyWriteHex ( LOOPHOLE ( yyNodeMapRef , ARRAY [ 0..BYTESIZE ( yytMapRef ) \   490     *   498   484     *   498
      \- 1 ] OF CHAR ) ) ; !                                                       484   484
   506         !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; !                   504   504   504   504     *   503
   507         @  Wr . PutText ( Stdio . stdout , "NUMBER = " ) ; @                506   506   506   506
   508         !  Wr . PutText ( Stdio . stdout , Fmt . Int ( NUMBER ( yyNodeMapRef ^ ) ) )\   507   507   507   507   502   502
                                                                                   486   505
      \ ; !
   509         !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; !                   508   508   508   508     *   506
   510         !  Wr . Flush ( Stdio . stdout ) ; !                                509   475   509   509
   511         END (* IF debug1 *) ;                                               492
   512         !  yyListMapRef := NEW ( yytMapRef , Nlists . Last_List_Id ( ) - GnatTypes .\   346   498   505   365     *   498
      \ List_Low_Bound + 1 ) ;!                                                    346
   513         IF debug1                                                           499   499
   514         THEN                                                                500
   515         @  Wr . PutText ( Stdio . stdout , "Last_List_Id = " ) ; @          510   509   510   510
   516         !  Wr . PutText ( Stdio . stdout , Fmt . Int ( Nlists . Last_List_Id ( ) ) )\   515   515   515   515   508   508
                                                                                   512   512
      \ ; !
   517         !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; !                   516   516   516   516     *   509
   518         @  Wr . PutText ( Stdio . stdout , "yyListMapRef = " ) ; @          517   517   517   517
   519         !  yyWriteHex ( LOOPHOLE ( yyListMapRef , ARRAY [ 0..BYTESIZE ( yytMapRef ) \   505   505   512   505   505   512
      \- 1 ] OF CHAR ) ) ; !                                                       505   505
   520         !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; !                   518   518   518   518     *   517
   521         @  Wr . PutText ( Stdio . stdout , "NUMBER = " ) ; @                520   520   520   520
   522         !  Wr . PutText ( Stdio . stdout , Fmt . Int ( NUMBER ( yyListMapRef ^ ) ) )\   521   521   521   521   516   516
                                                                                   508   519
      \ ; !
   523         !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; !                   522   522   522   522     *   520
   524         !  Wr . Flush ( Stdio . stdout ) ; !                                523   510   523   523
   525         END (* IF debug1 *) ;                                               511
   526         !  yyElistMapRef := NEW ( yytMapRef , Elists . Last_Elist_Id ( ) - GnatTypes\   384   512   519   437     *   512
      \ . Elist_Low_Bound + 1 ) ;!                                                 384
   527         IF debug1                                                           513   513
   528         THEN                                                                514
   529         @  Wr . PutText ( Stdio . stdout , "Last_Elist_Id = " ) ; @         524   523   524   524
   530         !  Wr . PutText ( Stdio . stdout , Fmt . Int ( Elists . Last_Elist_Id ( ) ) \   529   529   529   529   522   522
                                                                                   526   526
      \) ; !
   531         !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; !                   530   530   530   530     *   523
   532         @  Wr . PutText ( Stdio . stdout , "yyElistMapRef = " ) ; @         531   531   531   531
   533         !  yyWriteHex ( LOOPHOLE ( yyElistMapRef , ARRAY [ 0..BYTESIZE ( yytMapRef )\   519   519   526   519   519   526
      \ - 1 ] OF CHAR ) ) ; !                                                      519   519
   534         !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; !                   532   532   532   532     *   531
   535         @  Wr . PutText ( Stdio . stdout , "NUMBER = " ) ; @                534   534   534   534
   536         !  Wr . PutText ( Stdio . stdout , Fmt . Int ( NUMBER ( yyElistMapRef ^ ) ) \   535   535   535   535   530   530
                                                                                   522   533
      \) ; !
   537         !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; !                   536   536   536   536     *   534
   538         !  Wr . Flush ( Stdio . stdout ) ; !                                537   524   537   537
   539         END (* IF debug1 *) ;                                               525
   540         !  yyElmtMapRef := NEW ( yytMapRef , Elists . Last_Elmt_Id ( ) - GnatTypes .\   419   526   533   530     *   526
      \ Elmt_Low_Bound + 1 ) ;!                                                    419
   541         IF debug1                                                           527   527
   542         THEN                                                                528
   543         @  Wr . PutText ( Stdio . stdout , "Last_Elmt_Id = " ) ; @          538   537   538   538
   544         !  Wr . PutText ( Stdio . stdout , Fmt . Int ( Elists . Last_Elmt_Id ( ) ) )\   543   543   543   543   536   536
                                                                                   540   540
      \ ; !
   545         !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; !                   544   544   544   544     *   537
   546         @  Wr . PutText ( Stdio . stdout , "yyElmtMapRef = " ) ; @          545   545   545   545
   547         !  yyWriteHex ( LOOPHOLE ( yyElmtMapRef , ARRAY [ 0..BYTESIZE ( yytMapRef ) \   533   533   540   533   533   540
      \- 1 ] OF CHAR ) ) ; !                                                       533   533
   548         !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; !                   546   546   546   546     *   545
   549         @  Wr . PutText ( Stdio . stdout , "NUMBER = " ) ; @                548   548   548   548
   550         !  Wr . PutText ( Stdio . stdout , Fmt . Int ( NUMBER ( yyElmtMapRef ^ ) ) )\   549   549   549   549   544   544
                                                                                   536   547
      \ ; !
   551         !  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; !                   550   550   550   550     *   548
   552         !  Wr . Flush ( Stdio . stdout ) ; !                                551   538   551   551
   553         END (* IF debug1 *) ;                                               539
   554         !!
   555         !  yyConvert! WI (iMain); !!                                        480   495   493
   556         @    ( GnatTree , ADR ( LNew ) , 0 , "<ROOT>" ) ;@                  493   438   495
   557         !!
   558         !  yyNodeMapRef := NIL ; !                                          508   476
   559         !  yyListMapRef := NIL ; !                                          522   558
   560         !  yyElistMapRef := NIL ; !                                         536   559
   561         !  yyElmtMapRef := NIL ; !                                          550   560
   562         !!
   563         !  RETURN LNew;!                                                    477   556
   564         ! END GnatConvert! WI (iMain); !;!                                  553   493   555   555
   565         !!
   566       END (* IF *)                                                          564
   567 }; .
   568 
   569 
   570 PROCEDURE Convert (t: Tree)                                                 493   464   228   450
   571 
   572 Class (..) :- {                                                             148
   573         IF ( ( NoCodeClass * Properties ) = { } )                           541    24     *
   574            AND ( Extensions ^ . Kind = Tree . NoClass ) (* Low IN Properties ) is no\   442     *   462   570   137
c     \t set *) 
   575            AND IsDescendedFrom ( t , gNClassNonEmptyClass )                 574   152   570   301
   576         THEN                                                                542
   577            !        | ! WI ( iMain ) ; ! . Nk! WI (Name); !!                564   564     *     *   216
   578            !        => VAR LNewNode := NEW ( ! WI ( iMain ) ; ! . ! WI ( Name ) ; ! \   495   451   540   577   577     *
                                                                                   577
      \)!
   579            !           ; BEGIN!                                             496
   580            !               WNewRef := LNewNode!                             459   578
   581            !             ; LNew ^ := WNewRef!                               563   580
   582            !             ; LNew ^ . Kind := LKind!                          581   574   463
   583            !             ; LNewNode . NodeNumber := yyNextNodeNumber!       580   451   452
   584            !             ; INC ( yyNextNodeNumber )!                        452   583
   585            ConvertAttrs (t);                                                  *   575
   586            !             (* Field Next of Node is the builtin tail-recursion elimina\
c     \ted iterator *) !
   587            !             ; LCallerId := LId!                                469   473
   588            @             ; LCallerField := "Next"@                          471
   589            !             ; LId := Nlists . Next ( LId ) !                   587   516     *     *
   590            !             ; LNew := ADR ( LNewNode . Next )!                 582   556   583   589
   591            !             END (* BEGIN *) !                                  566
   592         END;                                                                591
   593 }; .
   594 
   595 PROCEDURE ConvertAttrs (t: Tree)                                            570   585   585   574
   596 
   597 Class (..) :- {                                                             572
   598         IF ( ( NoCodeClass * Properties ) = { } )                           573   573   573
   599         THEN                                                                576
   600            ConvertAttrs ( t^.Class.BaseClass);                              595   595   597   148
   601            IF IsDescendedFrom ( t , gEntityClass )                          598   575   600   304
   602            THEN gFieldInterface := gIdentEinfo                              599   206   288
   603            ELSE gFieldInterface := gIdentSinfo                              467   602   290
   604            END (* IF *);                                                    592
   605            ConvertAttrs (t^.Class.Attributes);                              600   601   600     *
   606         END;                                                                604
   607 }; .
   608 
   609 Child (..) :- {                                                              23
   610         IF Name = gIdentNext                                                601   578   238
   611         THEN                                                                602
   612            !             (* Next is handled last, as tail recursion elimination *) !
   613         ELSE                                                                603
   614            !             ; yyConvert! WI (iMain); !!                        555   578   578
   615            !                 ( ! WriteQualifier ( Name ) ; WG ( Name ) ;    219   610   116     *
   616                                  ! ( LId ) , ADR ( LNewNode . ! WI ( Name ) ; ! )!      589   590   590   614   615
   617            @                 , LId , "@ WG ( Name ) ; @" ) @                616
   618         END (* IF *) ;                                                      606
   619         ConvertAttrs ( t^.Child.Next);                                      605   605   609   590
   620 }; .
   621 Attribute (..) :- {                                                          23
   622         IF ( NoCodeAttr * Properties ) = {}                                 610    24   598
   623         THEN                                                                611
   624           IF Name = gIdentNodeNumber                                        622   616   236
   625           THEN (* Handled specially *)                                      623
   626           ELSIF Link IN Properties                                          441    24     *   622
   627           THEN                                                              625
   628            !             ; yyConvert! WI (iMain); !!                        614   616   614
   629            !                 ( ! WriteQualifier ( Name ) ; WG ( Name ) ;    615   624   615     *
   630                                  ! ( LId ) , ADR ( LNewNode . ! WI ( Name ) ; ! )!      617   616   616   628   629
   631            @                 , LId , "@ WG ( Name ) ; @" ) @                630
   632           ELSE                                                              613
   633 (*         !             ; LNewNode . ! WI ( Name ) ; 
c  634                            ! := ! WriteQualifier ( Name ) ; WG ( Name ) ; ! ( LId )!
c  635 *)
   636            !             ; copy! WI (Type); ! ( LNewNode . ! WI ( Name ) ;          *   630     *   630     *   630
   637                            ! , ! WriteQualifier ( Name ) ; WG ( Name ) ; ! ( LId ) )\   629   636   629     *   631
      \!
   638           END (* IF *)                                                      618
   639         END;                                                                638
   640         ConvertAttrs ( t^.Attribute.Next);                                  619   619   621   619
   641 }; .
   642 
   643 
   644  (* End of file MThree6.puma *) 
   645 
   646 
Cross reference: 

-A-
 ADR                            130   145   358   361   366   396   401   433   438   556   590   616   630 
 Ag                             230 
 Ancestor                       118   121   122   123   130   135 
 AND                            101   102   102   103   105   106   106   107   107   332   370   405   442   574   575 
 ARRAY                          309   484   505   519   533   547 
 ArrayToString                  235   237   239   241   243   245   247   249   251   253   255   257   259   261   263   265   267 
                                269   271   273   275   277   279   281   283   285   287   289   291   293   295   297   299   302 
 Atree                          498   502 
 Attribute                       23   621   640 
 Attributes                     605 

-B-
 BaseClass                      148   600 
 BEGIN                           82   120   155   213   329   338   351   376   389   411   426   448   485   496   579 
 BOOLEAN                         32   118 
 BYTESIZE                       505   519   533   547 

-C-
 CARDINAL                        78    81 
 CASE                           463 
 CHAR                            80   484   505   519   533   547 
 Char                            89    94 
 Child                           23   609   619 
 Class                           23   123   138   148   572   597   600   605 
 Classes                        464 
 CONST                          210 
 Convert                        464   570 
 ConvertAttrs                   585   595   600   605   619   640 
 copy                           636 

-D-
 debug1                          32   233   482   499   513   527   541 
 Descendent                     118   133 
 DO                             347   385   420   457   486 

-E-
 Elist                          388   388 
 Elists                         396   400   433   437   526   530   540   544 
 Elist_Low_Bound                369   370   384   526 
 Elmt                           425   425 
 Elmt_Low_Bound                 404   405   419   540 
 ELSE                            99   132   147   206   467   603   613   632 
 ELSIF                           95   122   123   136   137   138   158   160   162   164   166   168   170   172   174   176   178 
                                180   182   184   186   188   190   192   194   196   198   200   202   204   369   404   441   626 
 Empty                          444 
 END                            100   110   114   115   116   149   150   151   152   207   208   218   219   344   345   349   367 
                                368   382   383   387   402   403   417   418   424   439   440   454   455   461   465   466   478 
                                479   480   489   490   492   511   525   539   553   564   566   591   592   604   606   618   638 
                                639 
 EOL                            474   503   506   509   517   520   523   531   534   537   545   548   551 
 Errors                          18   125   127   129   140   142   144 
 EXIT                            99 
 Extensions                     574 

-F-
 f                               26   109   111   217 
 FALSE                          121   122   136   137   210 
 Fatal                          127   142 
 FCallerField                   322   328 
 FCallerId                      321   327 
 FId                            319   325 
 FieldName                      154   156   158   160   162   164   166   168   170   172   174   176   178   180   182   184   186 
                                188   190   192   194   196   198   200   202   204 
 First                          365   366 
 FirstElmt                      401 
 First_Elmt                     400 
 Flush                          475   510   524   538   552 
 Fmt                            469   473   487   487   502   508   516   522   530   536   544   550 
 FNew                           320   326 
 FOR                            486 
 ForallAttributes                27 
 ForallClasses                   27   464 
 FROM                            17    19    20    21 

-G-
 GenGnat                         10 
 gEntityClass                    36   304   601 
 GetString                       83 
 gFieldInterface                 73   206   602   603 
 gIdentAnalyzed                  46   194   254 
 gIdentAtree                     69   187   189   191   193   195   197   199   296 
 gIdentChars                     60   204   278 
 gIdentComesFromSource           45   192   252 
 gIdentDefiningIdentifier        56   180   272 
 gIdentDiscriminantConstraint    51   170   262 
 gIdentEinfo                     65   288   602 
 gIdentErrorPosted               47   196   256 
 gIdentEtype                     64   168   286 
 gIdentGirderConstraint          55   178   270 
 gIdentGnatAdaUtils              68   161   171   173   175   177   179   181   183   294 
 gIdentGnatUtils                 67   292 
 gIdentHasDynamicLengthCheck     49   200   260 
 gIdentHasDynamicRangeCheck      50   202   276 
 gIdentHomonym                   63   166   284 
 gIdentIsListMember              40   184   242 
 gIdentIsRewriteInsertion        44   190   250 
 gIdentIsRewriteSubstitution     43   188   248 
 gIdentLink                      41   160   244 
 gIdentMechanism                 57   182   274 
 gIdentNClassEntity              72   303   304 
 gIdentNClassNonEmpty            71   300   301 
 gIdentNext                      38   156   238   610 
 gIdentNextEntity                61   162   280 
 gIdentNlists                    70   157   159   185   298 
 gIdentNodeNumber                37   236   624 
 gIdentParenCount                48   198   258 
 gIdentPrev                      39   158   240 
 gIdentPrimitiveOperations       52   172   264 
 gIdentPrivalsChain              53   174   266 
 gIdentPrivateDependents         54   176   268 
 gIdentScope                     62   164   282 
 gIdentSinfo                     66   163   165   167   169   201   203   205   290   603 
 gIdentSloc                      42   186   246 
 GLOBAL                          14 
 GnatConvert                    493   564 
 GnatModule                      12   228 
 GnatTree                       493   556 
 GnatTypes                      319   321   331   332   334   346   369   370   372   384   404   405   407   419   441   442   444 
                                456   493   498   512   526   540 
 GnatUtils                      462 
 gNClassNonEmptyClass            35   301   575 
 gString                         74   235   236   237   238   239   240   241   242   243   244   245   246   247   248   249   250 
                                251   252   253   254   255   256   257   258   259   260   261   262   263   264   265   266   267 
                                268   269   270   271   272   273   274   275   276   277   278   279   280   281   282   283   284 
                                285   286   287   288   289   290   291   292   293   294   295   296   297   298   299   300   302 
                                303 

-I-
 I                               78    87    91    93    94    95    97 
 Ident                           77    83 
 IdentifyClass                   28   301   304 
 Idents                          18    19    83   236   238   240   242   244   246   248   250   252   254   256   258   260   262 
                                264   266   268   270   272   274   276   278   280   282   284   286   288   290   292   294   296 
                                298   300   303 
 IF                              85    91   101   121   135   156   214   231   331   334   348   372   386   407   421   444   458 
                                482   499   513   527   541   573   598   601   610   622   624 
 iMain                           26   318   324   336   350   357   360   374   388   395   409   425   432   446   480   493   555 
                                564   577   578   614   628 
 iModule                         26 
 IMPORT                          17    18    19    20    21    30 
 IN                             626 
 INC                             93    97   342   356   380   394   415   431   452   584 
 iNoTree                         25   348   386   421   458 
 Int                            469   473   487   502   508   516   522   530   536   544   550 
 INTEGER                        316 
 Integer                        129   144 
 IO                              17   109   111 
 IsDescendedFrom                118   152   575   601 
 IsElement                       20   214   231   233 
 IsType                         122   123   137   138 
 itTree                          26   307   309   494   495 

-K-
 Kind                           130   145   340   354   378   392   413   429   450   462   574   582 

-L-
 Last                           361   361 
 LastElmt                       396 
 Last_Elist_Id                  526   530 
 Last_Elmt                      396 
 Last_Elmt_Id                   540   544 
 Last_List_Id                   512   516 
 Last_Node_Id                   498   502 
 LCallerField                   328   364   399   436   471   588 
 LCallerId                      327   363   398   435   469   587 
 LChar                           80    89   102   102   103   103   106   106   111   112   113 
 LClass                         119   133   135   136   137   138   145   148   148 
 Length                          84 
 LId                            325   331   332   334   346   358   359   361   362   363   365   365   369   370   372   384   396 
                                397   398   400   400   404   405   407   419   433   434   435   437   437   441   442   444   456 
                                462   473   587   589   589   616   617   630   631   637 
 Link                            24   626 
 List                           350   350 
 List_Low_Bound                 331   332   346   512 
 LKind                          324   462   463   582 
 LLength                         81    84    85    91    95 
 LNew                           326   339   340   349   353   354   366   377   378   387   391   392   401   412   413   422   428 
                                429   438   449   450   459   476   495   556   563   581   582   590 
 LNewElist                      374   377   379   388   390   391   393   396   401 
 LNewElmt                       409   412   414   425   427   428   430   433   438 
 LNewList                       336   339   341   350   352   353   355   358   361   366 
 LNewNode                       446   449   451   578   580   583   590   616   630   636 
 LNextChar                       80    94    98   107   107   113 
 LOOP                            90   134   330 
 LOOPHOLE                       505   519   533   547 
 Low                             24 
 LPrevChar                       80    88   101   101   105   105   112 
 LString                         79    83    84    89    94 

-M-
 MakeIdent                      236   238   240   242   244   246   248   250   252   254   256   258   260   262   264   266   268 
                                270   272   274   276   278   280   282   284   286   288   290   292   294   296   298   300   303 
 MessageI                       125   140 

-N-
 Name                           212   216   577   578   610   615   615   616   624   629   629   630   636   637   637 
 NEW                            336   350   374   388   409   425   446   498   512   526   540   578 
 Next                           589   590   619   640 
 NextElmt                       438 
 Next_Elmt                      437 
 NIL                            476   558   559   560   561 
 Nk                             577 
 NkElist                        392 
 NkElmt                         429 
 NkList                         354 
 NkNNoNode                      450 
 NkNoElist                      378 
 NkNoElmt                       413 
 NkNoList                       340 
 Nlists                         358   361   365   512   516   589 
 NNoNode                        446 
 NoClass                        122   137   574 
 NoCodeAttr                      24   622 
 NoCodeClass                     24   573   598 
 Node                            34   433   433 
 NodeNumber                     341   355   379   393   414   430   451   583 
 Node_Id                        493 
 Node_Low_Bound                 441   442   456   498 
 NoElist                        374 
 NoElmt                         409 
 NoList                         336 
 NoPosition                     128   143 
 NOT                            123   138 
 NoTree                          22   121   136   301   304 
 No_Elist                       372 
 No_Elmt                        407 
 No_List                        334 
 NUMBER                         332   370   405   442   486   508   522   536   550 

-O-
 OF                             309   463   484   505   519   533   547 
 Options                         25   214   231   233 
 OR                             103   105 
 ORD                            214   231   233   487 

-P-
 PackageName                    154   208   216 
 Pad                            487 
 Parent                         358   358 
 Positions                       30   128   143 
 PROCEDURE                       77   118   154   212   228   318   484   493   570   595 
 Properties                     573   598   622   626 
 PUBLIC                          12 
 PutChar                        470   472   488 
 PutText                        468   469   471   473   474   487   501   502   503   504   506   507   508   509   515   516   517 
                                518   520   521   522   523   529   530   531   532   534   535   536   537   543   544   545   546 
                                548   549   550   551 

-R-
 REF                            307   310 
 RETURN                         121   122   135   136   137   157   159   161   163   165   167   169   171   173   175   177   179 
                                181   183   185   187   189   191   193   195   197   199   201   203   205   206   343   349   381 
                                387   416   423   453   460   477   563 

-S-
 Sets                            20 
 SHORTCARD                      324 
 Stdio                          468   469   470   471   472   473   474   475   487   488   501   502   503   504   506   507   508 
                                509   510   515   516   517   518   520   521   522   523   524   529   530   531   532   534   535 
                                536   537   538   543   544   545   546   548   549   550   551   552 
 stdout                         468   469   470   471   472   473   474   475   487   488   501   502   503   504   506   507   508 
                                509   510   515   516   517   518   520   521   522   523   524   529   530   531   532   534   535 
                                536   537   538   543   544   545   546   548   549   550   551   552 
 Strings                         30    74    79    84    89    94   235   237   239   241   243   245   247   249   251   253   255 
                                257   259   261   263   265   267   269   271   273   275   277   279   281   283   285   287   289 
                                291   293   295   297   299   302 
 SYSTEM                         130   145 

-T-
 t                              228   570   575   585   595   600   601   605   619   640 
 TEXT                           322 
 THEN                            86    92    96   109   121   122   124   135   136   137   139   157   159   161   163   165   167 
                                169   171   173   175   177   179   181   183   185   187   189   191   193   195   197   199   201 
                                203   205   215   231   333   335   349   371   373   387   406   408   422   443   445   459   483 
                                500   514   528   542   576   599   602   611   623   625   627 
 tIdent                          19    37    38    39    40    41    42    43    44    45    46    47    48    49    50    51    52 
                                 53    54    55    56    57    60    61    62    63    64    65    66    67    68    69    70    71 
                                 72    73    77   154   154   212 
 TO                             486 
 TRAFO                           10 
 TREE                            11 
 Tree                            11    21   122   122   123   123   137   137   138   138   228   340   350   354   378   388   392 
                                413   425   429   450   570   574   595 
 TRUE                           135 
 tString                         74    79 
 tTree                           22    34    35    36   118   118   119 
 TYPE                           307   309   310 
 Type                           636 

-U-
 Union_Id                       319   321 
 UNTRACED                       307 
 UseQualifiers                  210 

-V-
 VAR                             32    34    35    36    37    38    39    40    41    42    43    44    45    46    47    48    49 
                                 50    51    52    53    54    55    56    57    60    61    62    63    64    65    66    67    68 
                                 69    70    71    72    73    74    78    79    80    81   119   312   313   314   315   316   324 
                                325   326   327   328   336   350   374   388   409   425   446   484   495   578 

-W-
 WG                              77   116   615   629   637 
 WI                              27   216   307   309   318   324   336   348   350   357   360   374   386   388   395   409   421 
                                425   432   446   458   480   493   494   495   555   564   577   577   578   578   614   616   628 
                                630   636   636 
 WITH                           346   384   419   456 
 WNewRef                        346   348   349   352   384   386   387   390   419   421   422   427   456   458   459   580   581 
 Wr                             468   469   470   471   472   473   474   474   475   487   488   501   502   503   503   504   506 
                                506   507   508   509   509   510   515   516   517   517   518   520   520   521   522   523   523 
                                524   529   530   531   531   532   534   534   535   536   537   537   538   543   544   545   545 
                                546   548   548   549   550   551   551   552 
 WriteC                         109   111 
 WriteNl                         17 
 WriteQualifier                 212   219   615   629   637 
 WriteS                          17   217 

-Y-
 yyConvert                      318   357   360   395   432   480   555   614   628 
 yyElistMapRef                  314   370   384   526   533   536   560 
 yyElmtMapRef                   315   405   419   540   547   550   561 
 yyi                            486   487 
 yyListMapRef                   313   332   346   512   519   522   559 
 yyNextNodeNumber               316   341   342   355   356   379   380   393   394   414   415   430   431   451   452   583   584 
 yyNodeMapRef                   312   442   456   498   505   508   558 
 yyPtrtTree                     307   320 
 yytMapArray                    309   310 
 yytMapRef                      310   312   313   314   315   498   505   512   519   526   533   540   547 
 yyWriteHex                     484   490   505   519   533   547 
 yyx                            484   486   487 

end cross reference, 1800 occurrences of 246 identifiers.
