
(* file MThree5.puma 
   Modula-3 generation of lazy attribute evaluator. 
   Rodney M. Bates Oct 97 
   Extensively modified from file mod5.puma, which had these header comments:  
   /* Ich, Doktor Josef Grosch, Informatiker, 4.3.1992 */
*) 

TRAFO EvalMThree3
TREE Tree
PUBLIC EvalModule ToBit0

GLOBAL {

FROM SYSTEM     IMPORT ADR, TSIZE;
FROM General	IMPORT Max;
FROM DynArray	IMPORT MakeArray;
FROM IO		IMPORT WriteS, WriteNl, WriteI, WriteB, StdOutput;
FROM Texts	IMPORT WriteText;
FROM Sets	IMPORT tSet, MakeSet, ReleaseSet, Include, Exclude, Minimum,
			Maximum, IsElement, WriteSet, IsEmpty, Extract;
FROM Relations	IMPORT IsRelated;
FROM TreeMThree2	IMPORT GetIterator, Iterator, WriteLine;
FROM EvalMThree	IMPORT Class;
FROM Errors	IMPORT Error, Short, MessageI;
FROM Positions	IMPORT NoPosition;
IMPORT EvalMThree;

FROM Tree	IMPORT
   NoTree	, tTree		, Referenced	, NoCodeClass	,
   Computed	, Reverse	, Write		, Read		,
   Inherited	, Synthesized	, Input		, Output	,
   Virtual	, Test		, Left		, Right		,
   HasOutput	, NonBaseComp	, Dummy		, Trace		,
   Demand	, Funct		, NoClass	, Options	,
   TreeRoot	, iModule	, iMain		, itTree	,
   ForallClasses, ForallAttributes, f		, WI	, WN	,
   ClassCount	, IdentifyClass	, IdentifyAttribute, 
   tBitIndex	, tBitInfo	, iNoTree	, QueryTree	;

VAR
   i, i2, j, k, n, MaxBit, MaxInstCount, Check: SHORTCARD;
   Node, Attr, ChildsClass	: tTree;
   Success, IsStable		: BOOLEAN;
   BitIndexSize			: LONGINT;
   gBitIndex			: tBitIndex;
   InhIndices			: tSet;
   InhIndexSize			: LONGINT;
   InhIndexCount		: POINTER TO ARRAY [1..1000000] OF SHORTCARD;

PROCEDURE GenCall (t: tTree; j: SHORTCARD);
   BEGIN
      WITH t^.Class.Instance^ [j] DO
	 IF ({Synthesized, Left} <= Properties) THEN
	    k := ToBit0 (t, j);
	    !IFNOTIN (! WN ( k ); !, TNode . yyHead . yyIsComp ) ! 
	    !yyS! WN (k); ! ( TNode ) ; (* ! WI (Attribute^.Child.Name); ! *) END;!
	 ELSIF ({Inherited, Left} <= Properties) THEN
	    k := ToBit0 (t, j);
	    !IFNOTIN (! WN ( k ); ! , TNode . yyHead . yyIsComp ) ! 
   IF IsElement (ORD ('Z'), Options) AND (Trace IN t^.Class.Properties) THEN
	    !yyVisitParent ( TNode ) ; ! 
	    !yyI [ TNode . yyHead . yyOffset + ! WN (k); ! ] ( TNode . yyHead . yyParent ) ; (* ! 
	    WI (Attribute^.Child.Name); ! *) ! 
	    @yyWriteVisit ( TNode . yyHead . yyParent , "?") ; END ;@
   ELSE
	    !yyI [ TNode . yyHead . yyOffset + ! WN (k); ! ] ( TNode . yyHead . yyParent ) ; (* ! 
	    WI (Attribute^.Child.Name); ! *) END ;!
   END;
	 ELSIF ({Inherited, Right} <= Properties) THEN
	    k := ToBit1 (Selector, j - t^.Class.AttrCount - Selector^.Child.InstOffset);
	    !IFNOTIN (! WN (k); ! , TNode . ! WI (Class^.Class.Name);
	    ! . ! WI (Selector^.Child.Name); ! . yyHead.yyIsComp ) ! 
	    k := ToBit2 (t, Selector, j);
	    !yyI! WN (k); ! ( TNode ) ; (* ! WI (Selector^.Child.Name);
	    !:! WI (Attribute^.Child.Name); ! *) END ;!
	 ELSIF ({Synthesized, Right} <= Properties) THEN
	    k := ToBit1 (Selector, j - t^.Class.AttrCount - Selector^.Child.InstOffset);
	    !IFNOTIN (! WN (k); ! , TNode . ! WI (Class^.Class.Name);
	    ! . ! WI (Selector^.Child.Name); ! . yyHead . yyIsComp ) ! 
   IF IsElement (ORD ('Z'), Options) AND (Trace IN t^.Class.Properties) THEN
	    @yyWriteVisit ( TNode , "@ WI (Selector^.Child.Name); @" ) ;@ 
	    !yyS! WN (k);
	    ! ( TNode . ! WI (Class^.Class.Name); ! . ! WI (Selector^.Child.Name);
	    ! ) ; (* ! WI (Selector^.Child.Name); !:! WI (Attribute^.Child.Name); ! *) ! 
	    !yyVisitParent ( TNode . ! WI (Class^.Class.Name); ! . ! WI (Selector^.Child.Name); ! ) ; END ;!
   ELSE
	    !yyS! WN (k);
	    ! ( TNode . ! WI (Class^.Class.Name); ! . ! WI (Selector^.Child.Name);
	    ! ) ; (* ! WI (Selector^.Child.Name); !:! WI (Attribute^.Child.Name); ! *) END ;!
   END;
	 END;
      END;
   END GenCall;

PROCEDURE GenEvalAttr (t: tTree; i: INTEGER);
   BEGIN
      Class := t;
      WITH t^.Class.Instance^ [i] DO
   IF IsElement (ORD ('X'), Options) AND (Trace IN t^.Class.Properties) THEN
	 @yyWriteEval ( TNode , "@ WI (Attribute^.Child.Name); @" ) ;@
	 IF (Action # ADR (Action)) AND NOT (Virtual IN Properties) THEN
	    GenEvaluator (Action);
	    EvalMThree.GenEvaluator (Action); !!
	    IF Test IN Properties THEN
	       !writeBOOLEAN ( yyb ) yyWriteNl ( ) ;!
	    ELSIF (Attribute^.Kind = Tree.Child) OR (Attribute^.Attribute.Type = itTree) THEN
	       !write! WI (itTree);
	       ! ( TNode . ! WI (t^.Class.Name); ! . ! WI (Attribute^.Child.Name); ! )!
	    ELSE
	       !write! WI (Attribute^.Child.Type);
	       ! ( TNode . ! WI (t^.Class.Name); ! . ! WI (Attribute^.Child.Name); ! ) yyWriteNl ( ) ;!
	    END;
	 ELSE
	    !yyWriteNl ( ) ;!
	 END;
   ELSIF IsElement (ORD ('Y'), Options) AND (Trace IN t^.Class.Properties) THEN
	 @yyWriteEval ( TNode , "@ WI (Attribute^.Child.Name); @") ;@
	 IF (Action # ADR (Action)) AND NOT (Virtual IN Properties) THEN
	    GenEvaluator (Action);
	    EvalMThree.GenEvaluator (Action);
	 END;
   ELSE
	 IF (Action # ADR (Action)) AND NOT (Virtual IN Properties) THEN
	    GenEvaluator (Action);
	    EvalMThree.GenEvaluator (Action);
	 END;
   END;
      END;
   END GenEvalAttr;
}

PROCEDURE EvalModule (t: Tree)
	
Ag (..) :- {
	MaxBit := 0;
	MaxInstCount := 0;
	ForallClasses (Classes, CompBitInfo);
	MakeSet (InhIndices, MaxInstCount);
	InhIndexSize := MaxInstCount;
	MakeArray (InhIndexCount, InhIndexSize, TSIZE (SHORTCARD));
	FOR i := 1 TO MaxInstCount DO InhIndexCount^ [i] := 0; END;
	ForallClasses (Classes, CompInhIndices);
	!# define IFNOTIN(b, s) IF NOT ((b) IN (s)) THEN!
	!# define REMOTE_SYN(i, b, c, n, t, a) n.t.a!
	!# define REMOTE_INH(i, b, k, n, t, a) n.t.a!
        !# define INCLUDE(s, b) WITH yyTemp = ( s ) DO yyTemp := yyTemp + ! WI (iMain); ! . BitSet { b } END ;!
	EvalMThree.EvalModuleHead (t);
	!!
	!VAR yyI: ARRAY [0..! WN (Maximum (InhIndices)); !] OF ! WI (iMain); !.tProcTree;!
	!!
	!PROCEDURE yyAbort (yyt: ! WI (iMain); !.! WI (itTree); !);!
	! BEGIN!
	@  Wr . PutText ( Stdio . Stderr, "Error: module @ WI (EvalName); @, cyclic dependencies" ) ;@
	!  Wr . PutText ( Stdio . Stderr , Wr . EOL ) ;!
	!  ! WI (iMain); ! . yyExit ( ) ;!
	! END yyAbort;!
	!!
      IF NOT IsElement (ORD ('9'), Options) THEN
	!!
	!PROCEDURE Eval ( yyt : ! WI (iMain); ! . ! WI (itTree); ! )!
	!=BEGIN ! WI (iMain); ! . Init! WI (iModule); ! ( yyt ) ; yyE ( yyt ) ; END Eval ;!
      ELSE
	!!
	!VAR xxStack : INTEGER ;!
	!!
	!PROCEDURE Eval ( yyt : ! WI (iMain); ! . ! WI (itTree); ! )!
	!=VAR xxHigh : BOOLEAN ;!
	! BEGIN!
	!  xxStack := LAST ( INTEGER ) ;!
	!  ! WI (iMain); ! . Init! WI (iModule); ! ( yyt ) ; yyE ( yyt ) ;!
	@  Wr . PutText ( Stdio . Stdout , "Stacksize " ) ;@
	!  Wr . PutText ( Stdio . Stdout!
        !               , Fmt . Int ( LOOPHOLE ( ADR ( xxHigh ) , INTEGER ) - xxStack ) ) ;!
	!  Wr . PutText ( Stdio . Stdout , Wr . EOL );!
	! END Eval ;!
      END;
	!!
	REPEAT IsStable := TRUE; ForallClasses (Classes, CompOutput); UNTIL IsStable;
	!PROCEDURE yyE ( yyt : ! WI (iMain); ! . ! WI (itTree); ! ) =!
	WriteLine (TreeRoot^.Ag.EvalCodes^.Codes.LocalLine);
	WriteText (f, TreeRoot^.Ag.EvalCodes^.Codes.Local);
	Node := TreeRoot^.Ag.Modules;
	WHILE Node^.Kind = Tree.Module DO
	   WriteLine (Node^.Module.EvalCodes^.Codes.LocalLine);
	   WriteText (f, Node^.Module.EvalCodes^.Codes.Local);
	   Node := Node^.Module.Next;
	END;
      IF IsElement (ORD ('9'), Options) THEN
	! VAR xxLow : BOOLEAN ;!
	! BEGIN!
        !  xxStack := MIN ( xxStack , LOOPHOLE ( ADR ( xxLow ) , INTEGER ) ) ;!
(* FIX THIS^ This only works for stacks which grow toward zero. *)
      ELSE
	! BEGIN!
      END;
	!  LOOP!
	!   IF ( yyt = ! WI (iMain); ! . ! WI (iNoTree); ! ) OR ( 0 IN yyt . yyHead . yyIsComp ) THEN RETURN ; END ;!
	!   INCLUDE ( yyt . yyHead . yyIsComp , 0 )!
	!   TYPECASE yyt OF!
	ForallClasses (Classes, GenE);
	!   ELSE RETURN ;!
	!   END ;!
	!  END ;!
	! END yyE ;!
	!!
	FOR i := 2 TO MaxBit DO
	   n := 0;			(* are there any SYN attributes ? *)
	   ForallClasses (Classes, CountSynAttr);
	   IF n > 0 THEN
	      !PROCEDURE yyS! WN (i - 1); ! ( yyt : ! WI (iMain); ! . ! WI (itTree); ! )=!
	      WriteLine (TreeRoot^.Ag.EvalCodes^.Codes.LocalLine);
	      WriteText (f, TreeRoot^.Ag.EvalCodes^.Codes.Local);
	      Node := TreeRoot^.Ag.Modules;
	      WHILE Node^.Kind = Tree.Module DO
		 WriteLine (Node^.Module.EvalCodes^.Codes.LocalLine);
		 WriteText (f, Node^.Module.EvalCodes^.Codes.Local);
		 Node := Node^.Module.Next;
	      END;
      IF IsElement (ORD ('9'), Options) THEN
	      ! VAR xxLow : BOOLEAN ;!
	      ! BEGIN!
              !  xxStack := MIN ( xxStack , LOOPHOLE ( ADR ( xxLow ) , INTEGER ) ) ;!
(* FIX THIS^ This only works for stacks which grow toward zero. *)
      ELSE
	      ! BEGIN!
      END;
      IF IsElement (ORD ('5'), Options) THEN
	      ! IFNOTIN (! WN (i - 1); !, yyt . yyHead . yyIsDone )!
	      !  INCLUDE  (yyt . yyHead . yyIsDone, ! WN (i - 1); ! )!
              !ELSE yyAbort ( yyt ) ; END ;!
      END;
	      IF n > 1 THEN
		 !  TYPECASE yyt OF!
		 ForallClasses (Classes, GenS);
		 !  END ;!
	      ELSE
		 ForallClasses (Classes, GenS);
	      END;
	      !  INCLUDE ( yyt . yyHead . yyIsComp , ! WN (i - 1); ! )!
	      ! END yyS! WN (i - 1); ! ;!
	      !!
	   END;
	END;
	FOR i := Minimum (InhIndices) TO Maximum (InhIndices) DO
	   IF IsElement (i, InhIndices) THEN
	      !PROCEDURE yyI! WN (i); !  (yyt : ! WI (iMain); ! . ! WI (itTree); ! )=!
	      WriteLine (TreeRoot^.Ag.EvalCodes^.Codes.LocalLine);
	      WriteText (f, TreeRoot^.Ag.EvalCodes^.Codes.Local);
	      Node := TreeRoot^.Ag.Modules;
	      WHILE Node^.Kind = Tree.Module DO
		 WriteLine (Node^.Module.EvalCodes^.Codes.LocalLine);
		 WriteText (f, Node^.Module.EvalCodes^.Codes.Local);
		 Node := Node^.Module.Next;
	      END;
      IF IsElement (ORD ('9'), Options) THEN
	      ! VAR xxLow : BOOLEAN ;!
	      ! BEGIN!
	      !  xxStack := MIN ( xxStack , LOOPHOLE ( ADR ( xxLow ) , INTEGER ) ) ;!
(* FIX THIS^ This only works for stacks which grow toward zero. *)
      ELSE
	      ! BEGIN!
      END;
	      Check := 0;
	      IF InhIndexCount^ [i] > 1 THEN
		 !  TYPECASE yyt  OF!
		 ForallClasses (Classes, EvalModule);
		 !  END ;!
	      ELSE
		 ForallClasses (Classes, EvalModule);
	      END;
	      IF Check # InhIndexCount^ [i] THEN
	         MessageI ("internal error in yyI", Error, NoPosition, Short, ADR (i));
	      END;
	      ! END yyI! WN (i); ! ;!
	      !!
	   END;
	END;
	!PROCEDURE Begin! WI (EvalName); !!
	!=BEGIN!
	WriteLine (EvalCodes^.Codes.BeginLine);
	WriteText (f, EvalCodes^.Codes.Begin);
	Node := Modules;
	WHILE Node^.Kind = Tree.Module DO
	   WriteLine (Node^.Module.EvalCodes^.Codes.BeginLine);
	   WriteText (f, Node^.Module.EvalCodes^.Codes.Begin);
	   Node := Node^.Module.Next;
	END;
	! END Begin! WI (EvalName); ! ;!
	!!
	!PROCEDURE Close! WI (EvalName); !!
	!=BEGIN!
	WriteLine (EvalCodes^.Codes.CloseLine);
	WriteText (f, EvalCodes^.Codes.Close);
	Node := Modules;
	WHILE Node^.Kind = Tree.Module DO
	   WriteLine (Node^.Module.EvalCodes^.Codes.CloseLine);
	   WriteText (f, Node^.Module.EvalCodes^.Codes.Close);
	   Node := Node^.Module.Next;
	END;
	! END Close! WI (EvalName); ! ;!
	!!
	!BEGIN!
      IF IsElement (ORD ('X'), Options) THEN
	! yyf := Stdio . Stdout ;!
      END;
	FOR i := Minimum (InhIndices) TO Maximum (InhIndices) DO
	   IF IsElement (i, InhIndices) THEN
	      ! yyI [ ! WN (i); ! ] := yyI! WN (i); ! ;!
	   END;
	END;
	!END ! WI (EvalName); ! .!
}; .
Class (..) :-
	NoCodeClass * Properties = {{}};
	i <= InstCount;
	a: SHORTCARD;
{	a := ToAttr (t, i);
	IF a = 0 THEN RETURN; END;
	WITH Instance^ [a] DO
	   IF {Inherited, Right} <= Properties THEN
	      Class := t;
	      IF InhIndexCount^ [i] > 1 THEN
		 !   | ! WI (iMain); ! . t! WI (Name); ! ( TNode ) =>!
	      END;
	      INC (Check);
	      k := ToBit1 (Selector, a - AttrCount - Selector^.Child.InstOffset);
      IF IsElement (ORD ('5'), Options) THEN
	      ! IFNOTIN (! WN (k); !, TNode . ! WI (Class^.Class.Name);
	      ! . ! WI (Selector^.Child.Name); ! . yyHead . yyIsDone )!
	      !  INCLUDE ( TNode . ! WI (Class^.Class.Name); ! . ! WI (Selector^.Child.Name);
	      ! . yyHead . yyIsDone , ! WN (k); ! )!
              ! ELSE yyAbort ( TNode ) ;!
              ! END ;!
      END;
	      FOR j := 1 TO InstCount DO
		 IF IsRelated (a, j, DP) THEN
		    GenCall (t, j);
		 END;
	      END;
      IF IsElement (ORD ('X'), Options) AND (Trace IN t^.Class.Properties) THEN
	      @yyWriteEval ( TNode , "@ WI (Selector^.Child.Name); !:! WI (Attribute^.Child.Name); @" ) ;@
	      IF (Action # ADR (Action)) AND NOT (Virtual IN Properties) THEN
		 GenEvaluator (Action);
		 EvalMThree.GenEvaluator (Action); !!
		 IF (Attribute^.Kind = Tree.Child) OR (Attribute^.Attribute.Type = itTree) THEN
		    !write! WI (itTree);
		    ! ( TNode . ! WI (Name); ! . ! WI (Selector^.Child.Name);
		    ! . ! WI (Selector^.Child.Type); ! . ! WI (Attribute^.Child.Name); ! )!
		 ELSE
		    !write! WI (Attribute^.Child.Type);
		    ! ( TNode . ! WI (Name); ! . ! WI (Selector^.Child.Name);
		    ! . ! WI (Selector^.Child.Type); ! . ! WI (Attribute^.Child.Name); ! )!
                    !yyWriteNl ( ) ;!
		 END;
	      ELSE
		 !yyWriteNl ( ) ;!
	      END;
      ELSIF IsElement (ORD ('Y'), Options) AND (Trace IN t^.Class.Properties) THEN
	      @yyWriteEval ( TNode , "@ WI (Selector^.Child.Name); !:! WI (Attribute^.Child.Name); @" ) ;@
	      IF (Action # ADR (Action)) AND NOT (Virtual IN Properties) THEN
		 GenEvaluator (Action);
		 EvalMThree.GenEvaluator (Action);
	      END;
      ELSE
	      IF (Action # ADR (Action)) AND NOT (Virtual IN Properties) THEN
		 GenEvaluator (Action);
		 EvalMThree.GenEvaluator (Action);
	      END;
      END;
	      IF NOT (Input IN Properties) AND (Attribute^.Kind = Tree.Child) THEN
		 !WITH yyTemp = TNode . ! WI (Name); ! . ! WI (Selector^.Child.Name);
		 ! . ! WI (Selector^.Child.Type); ! . ! WI (Attribute^.Child.Name);
		 ! . yyHead DO!
                 ! IF yyTemp . yyParent = ! WI (iMain); ! . ! WI (iNoTree); ! THEN! 
                 !   yyOffset := ! 
		 WN (Selector^.Child.Class^.Class.BitCount + Attribute^.Child.BitOffset); ! ;!
		 !   yyTemp . yyParent := TNode . ! WI (Name); ! . ! WI (Selector^.Child.Name); ! ;!
		 WI (iMain); ! . Init! WI (iModule); ! ( TNode . ! WI (Name); ! . ! WI (Selector^.Child.Name); 
		 ! . ! WI (Selector^.Child.Type); ! . ! WI (Attribute^.Child.Name); ! ) ;!
                 ! END ;!
                 !END ;!
	      END;
	      FOR i2 := 1 TO InstCount DO	(* add group members *)
		 IF Instance^[i2].Action = Action THEN
		    WITH Instance^[i2] DO
		       IF Synthesized IN Properties THEN
			  k := ToBit0 (Class, i2);
			  !   INCLUDE ( TNode . yyHead . yyIsComp , ! WN (k); ! )!
		       ELSIF Inherited IN Properties THEN
			  k := ToBit1 (Selector, i2 - AttrCount - Selector^.Child.InstOffset);
			  !   INCLUDE ( TNode .! WI (Class^.Class.Name); ! . ! WI (Selector^.Child.Name);
			  ! . yyHead . yyIsComp , ! WN (k); ! )!
		       END;
		    END;
		 END;
	      END;
	   END;
	END;
}; .

PROCEDURE CompBitInfo (t: Tree)

Class (..) :-
	BitIndexSize := AttrCount;
	MakeArray (BitIndex, BitIndexSize, TSIZE (tBitInfo));
	i := 1;
	gBitIndex := BitIndex;
	ForallAttributes (t, CompBitInfo);
	MaxBit := Max (i, MaxBit);
	MaxInstCount := Max (InstCount, MaxInstCount);
	.
Child (..) ;
Attribute (..) :-
	({{Input, Test, Dummy}} * Properties = {{}});
	INC (i);
	gBitIndex^ [AttrIndex].ToBit := i;
	gBitIndex^ [i].ToAttr := AttrIndex;
	.

PROCEDURE CompInhIndices (t: Tree)

Class (..) :-
	b: INTEGER;
{	FOR j := AttrCount + 1 TO InstCount DO
	   WITH Instance^ [j] DO
	      IF Inherited IN Properties THEN
		 b := ToBit2 (t, Selector, j);
		 Include (InhIndices, b);
		 INC (InhIndexCount^ [b]);
	      END;
	   END;
	END;
};	.

PROCEDURE CountSynAttr (t: Tree)

Class (..) :-
	NoCodeClass * Properties = {{}};
	i <= BitCount;
{	WITH Instance^ [BitIndex^ [i].ToAttr] DO
	   IF ({Synthesized, Left} <= Properties) AND NOT (Test IN Properties) THEN
	      INC (n);
	   END;
	END;
};	.

(* Not used.  Not converted to M3: 
PROCEDURE WriteType (t: Tree)

Class (..) :-
	NoCodeClass * Properties = {{}};
	Trace IN Properties;
	!| ! WI (TreeRoot^.Ag.TreeName); !.! WI (Name); !: yyWriteS ('! WI (Name); !');!
	.
*) 

PROCEDURE GenS (t: Tree)

Class (..) :-
	NoCodeClass * Properties = {{}};
	i <= BitCount;
{	WITH Instance^ [BitIndex^ [i].ToAttr] DO
	   IF ({Synthesized, Left} <= Properties) AND NOT (Test IN Properties) THEN
	      Class := t;
	      IF n > 1 THEN
		 !   | ! WI (iMain); ! . t! WI (Name); ! ( TNode ) =>!
              ELSE
                 !   WITH TNode = NARROW ( yyt , ! WI (iMain); ! . t! WI (Name); ! ) DO!
	      END;
	      FOR j := 1 TO InstCount DO
		 IF IsRelated (BitIndex^ [i].ToAttr, j, DP) THEN
		    GenCall (t, j);
		 END;
	      END;
	      GenEvalAttr (t, BitIndex^ [i].ToAttr);
	      IF NOT (Input IN Properties) AND (Attribute^.Kind = Tree.Child) THEN
		 !WITH yyTemp = TNode . ! WI (Name); ! . ! WI (Attribute^.Child.Name);
		 ! . yyHead DO!
                 ! IF yyTemp . yyParent = ! WI (iMain); ! . ! WI (iNoTree); ! THEN!
                 !   yyOffset := ! 
		 WN (BitCount + Attribute^.Child.BitOffset); !;!
                 !   yyParent := TNode ;! 
		 WI (iMain); ! . Init! WI (iModule); ! ( TNode . ! WI (Name); ! . ! WI (Attribute^.Child.Name); ! ) ;!
                 ! END ;!
                 !END ;!
	      END;
	      FOR i2 := 1 TO InstCount DO	(* add group members *)
		 IF Instance^[i2].Action = Action THEN
		    WITH Instance^[i2] DO
		       IF Synthesized IN Properties THEN
			  k := ToBit0 (Class, i2);
			  IF k # i - 1 THEN
			     !   INCLUDE ( TNode . yyHead . yyIsComp , ! WN (k); ! )!
			  END;
		       ELSIF Inherited IN Properties THEN
			  k := ToBit1 (Selector, i2 - AttrCount - Selector^.Child.InstOffset);
			  !   INCLUDE ( TNode . ! WI (Class^.Class.Name); ! . ! WI (Selector^.Child.Name);
			  ! . yyHead . yyIsComp , ! WN (k); ! )!
		       END;
		    END;
		 END;
	      END;
	      IF n > 1 THEN
              ELSE
                 !   END (* WITH TNode *)!
	      END;
              
	   END;
	END;
}; .

PROCEDURE GenE (t: Tree)

Class (..) :-
	ToCompute: tSet;
{	GetIterator (t);
	n := 0;
	j := 2;
	LOOP
	   IF j > InstCount THEN EXIT; END;
	   WITH Instance^ [j] DO
	      IF {Dummy, Output, Test} * Properties # {} THEN
	         IF (Test IN Properties) OR
		    ({Synthesized, Left} <= Properties) OR
		    ({Inherited,  Right} <= Properties) OR
		    ({Inherited,   Left} <= Properties) AND
		    NOT (Input IN Properties) AND (Attribute^.Kind = Tree.Child) OR
		    ({Synthesized, Right, Dummy} <= Properties) AND (Selector # Iterator) AND
		    (HasOutput IN Selector^.Child.Class^.Class.Properties) THEN
		    INC (n); EXIT;
		 END;
	      END;
	   END;
	   INC (j);
	END;
	IF (n = 0) AND ((Iterator = NoTree) OR NOT (HasOutput IN Iterator^.Child.Class^.Class.Properties)) THEN RETURN; END;

	Class := t;
	!   | ! WI (iMain); ! . t! WI (Name); ! ( TNode ) =>!
	FOR j := 2 TO InstCount DO
	   WITH Instance^ [j] DO
	      IF {Dummy, Output} * Properties # {} THEN
		 IF ({Synthesized, Left} <= Properties) OR
		    ({Inherited,  Right} <= Properties) OR
		    ({Inherited,   Left} <= Properties) AND
		    NOT (Input IN Properties) AND (Attribute^.Kind = Tree.Child) THEN
		    GenCall (t, j);
		 ELSIF ({Synthesized, Right, Dummy} <= Properties) AND (Selector # Iterator) AND
		    (HasOutput IN Selector^.Child.Class^.Class.Properties) THEN
      IF IsElement (ORD ('Z'), Options) AND (Trace IN t^.Class.Properties) THEN
		    @yyWriteVisit ( TNode , "@ WI (Selector^.Child.Name); @" ) ;@
      END;
		    !yyE ( TNode . ! WI (Name); ! . ! WI (Selector^.Child.Name); ! ) ;!
      IF IsElement (ORD ('Z'), Options) AND (Trace IN t^.Class.Properties) THEN
		    !yyVisitParent ( TNode . ! WI (Name); ! . ! WI (Selector^.Child.Name); ! ) ;!
      END;
		 END;
	      END;
	   END;
	END;

	MakeSet (ToCompute, InstCount);
	FOR i := 2 TO AttrCount DO
	   WITH Instance^ [i] DO
	      IF Test IN Properties THEN
		 FOR j := 2 TO InstCount DO
		    IF IsRelated (i, j, DP) THEN
		       IF {Synthesized, Inherited} * Instance^ [j].Properties # {} THEN
			  Include (ToCompute, j);
		       END;
		    END;
		 END;
	      END;
	   END;
	END;
	FOR i := 2 TO InstCount DO
	   WITH Instance^ [i] DO
	      IF ({Synthesized, Left, Output} <= Properties) OR
		 ({Inherited,  Right, Output} <= Properties) THEN
		 Exclude (ToCompute, i);
	      END;
	   END;
	END;
	WHILE NOT IsEmpty (ToCompute) DO
	   GenCall (t, Extract (ToCompute));
	END;
	ReleaseSet (ToCompute);
	FOR i := 2 TO AttrCount DO
	   IF Test IN Instance^ [i].Properties THEN
	      GenEvalAttr (t, i);
	   END;
	END;

	IF (Iterator = NoTree) OR NOT (HasOutput IN Iterator^.Child.Class^.Class.Properties) THEN
	   !RETURN ;!
	ELSE
   IF IsElement (ORD ('Z'), Options) AND (Trace IN t^.Class.Properties) THEN
	   @yyWriteVisit ( TNode , "@ WI (Iterator^.Child.Name); @" ) ;@
   END;
	   !yyt := TNode . ! WI (Name); ! . ! WI (Iterator^.Child.Name); ! ;!
	END;
}; .

PROCEDURE CompOutput (t: Tree)

Class (..) :-
   NOT (HasOutput IN Properties);
   Success := FALSE;
   ForallAttributes (t, CompOutput);
   ForallClasses (Extensions, CompOutput2);
   Success;
   INCL (Properties, HasOutput);
   IsStable := FALSE;
   .
Child (..) :-
   (Output IN Properties) OR (HasOutput IN Class^.Class.Properties);
   Success := TRUE;
   .
Attribute (..) :-
   ({{Test, Output}} * Properties # {{}});
   Success := TRUE;
   .

PROCEDURE CompOutput2 (t: Tree)

Class (..) :-
   HasOutput IN Properties;
   Success := TRUE;
   .

FUNCTION ToBit0 (Class, INTEGER) INTEGER
   class, i ? RETURN class^.Class.BitIndex^ [i].ToBit - 1; .

FUNCTION ToBit1 (Child, INTEGER) INTEGER
   Selector, i ? RETURN Selector^.Child.Class^.Class.BitIndex^ [i].ToBit - 1; .

FUNCTION ToBit2 (Class, Child, SHORTCARD) INTEGER
   class, Selector, i RETURN _ ?
{  WITH Selector^.Child DO
      RETURN class^.Class.BitCount + BitOffset +
	 Class^.Class.BitIndex^ [i - class^.Class.AttrCount - InstOffset].ToBit - 1;
   END;
}; .

FUNCTION ToAttr (Class, INTEGER) INTEGER
   LOCAL { VAR a: SHORTCARD; }
   class, i RETURN _ ?
{  WITH class^.Class DO
      FOR a := AttrCount + 1 TO InstCount DO
	 WITH Instance^ [a] DO
	    IF ({Input, Test, Dummy} * Properties = {}) AND
	       (ToBit2 (class, Selector, a) = i) THEN RETURN a; END;
	 END;
      END;
   END;
   RETURN 0;
}; .

PROCEDURE GenEvaluator (t: Tree)

Assign (..) ;
Copy (..) :-
   GenEvaluator (Arguments);
   .
TargetCode (..) :-
   GenEvaluator (Code);
   .
Check (..) :-
   GenEvaluator (Condition);
   GenEvaluator (Statement);
   GenEvaluator (Actions);
   .
Designator (..) ;
Ident (..) ;
Any (..) ;
Anys (..) :-
   GenEvaluator (Next);
   .
Remote (..) :-
   TheClass: Class; k: INTEGER;
   TheClass := IdentifyClass (TreeRoot^.Ag.Classes, Type);
{  IF TheClass # NoTree THEN
      Attr := IdentifyAttribute (TheClass, Attribute);
      IF Attr # NoTree THEN
	 WITH Attr^.Attribute DO
	    k := ToBit0 (TheClass, AttrIndex);
	    IF Synthesized IN Properties THEN
	       !IFNOTIN ( ! WN (k); ! , ! EvalMThree.GenEvaluator (Designators);
	       ! . yyHead . yyIsComp )!
               ! yyS! WN (k); ! ( ! 
	       EvalMThree.GenEvaluator (Designators); ! ) ;!
               !END ;!
	    ELSIF Inherited IN Properties THEN
	       !IFNOTIN ( ! WN (k); ! , ! EvalMThree.GenEvaluator (Designators);
	       ! . yyHead . yyIsComp ) yyI [! 
	       EvalMThree.GenEvaluator (Designators); ! . yyHead . yyOffset + ! WN (k);
	       ! ] ( ! EvalMThree.GenEvaluator (Designators); ! . yyHead . yyParent ) ;!
               !END ;!
	    END; 
	 END;
      END;
   END;
   GenEvaluator (Next);
}; .
