
(* file MThree6.puma 

   Generation of specialized tree converter from Gnat tree to 
   semantically equivalent cg tree. 
   Rodney M. Bates 10-97 

*)

TRAFO GenGnat 
TREE Tree
PUBLIC GnatModule 

GLOBAL {

(* IMPORT IO; This is already generated by puma *) 
FROM IO		IMPORT WriteS, WriteNl;
IMPORT Idents , Errors ; 
FROM Idents	IMPORT tIdent;
FROM Sets       IMPORT IsElement;
FROM Tree	IMPORT
   NoTree	, tTree		, 
   Class	, Child		, Attribute	, 
   NoCodeAttr	, NoCodeClass	, Link          , Low           ,
   iNoTree	, Options       , 
   itTree	, iMain		, iModule	, f		,
   WI	        , ForallClasses	, ForallAttributes, 
   IdentifyClass ;

IMPORT Positions , Strings;

VAR Node : tTree;
VAR gNClassNonEmptyClass : tTree ; 
VAR gEntityClass : tTree ; 
VAR gIdentNext : tIdent ;
VAR gIdentPrev : tIdent ;
VAR gIdentIsListMember : tIdent ;
VAR gIdentLink : tIdent ;
VAR gIdentSloc : tIdent ;
VAR gIdentIsRewriteSubstitution : tIdent ;
VAR gIdentIsRewriteInsertion : tIdent ;
VAR gIdentComesFromSource : tIdent ;
VAR gIdentAnalyzed : tIdent ;
VAR gIdentErrorPosted : tIdent ;
VAR gIdentParenCount : tIdent ;
VAR gIdentHasDynamicLengthCheck : tIdent ;
VAR gIdentHasDynamicRangeCheck : tIdent ;
VAR gIdentDiscriminantConstraint : tIdent ;
VAR gIdentPrimitiveOperations : tIdent ;
VAR gIdentPrivalsChain : tIdent ;
VAR gIdentPrivateDependents : tIdent ;
VAR gIdentGirderConstraint : tIdent ;
VAR gIdentMechanism : tIdent ;


VAR gIdentChars : tIdent ;
VAR gIdentNextEntity : tIdent ;
VAR gIdentScope : tIdent ;
VAR gIdentHomonym : tIdent ;
VAR gIdentEtype : tIdent ;
VAR gIdentEinfo : tIdent ;
VAR gIdentSinfo : tIdent ;
VAR gIdentGnatUtils : tIdent ;
VAR gIdentGnatAdaUtils : tIdent ;
VAR gIdentAtree : tIdent ;
VAR gIdentNlists : tIdent ;
VAR gIdentNClassNonEmpty : tIdent ;
VAR gIdentNClassEntity : tIdent ;
VAR gFieldInterface : tIdent ;
VAR gString : Strings . tString ; 

(* Convert an M3-style identifier (mixed case) back to Gnat-style (underscores) *)
PROCEDURE WG ( Ident : tIdent ) 
; VAR I : CARDINAL 
; VAR LString : Strings . tString 
; VAR LPrevChar , LChar , LNextChar : CHAR 
; VAR LLength : CARDINAL 
; BEGIN 
    Idents . GetString ( Ident , LString ) 
  ; LLength := Strings . Length ( LString )  
  ; IF LLength > 0 
    THEN 
    ; I := 1 
    ; LPrevChar := ' ' 
    ; LChar := Strings . Char ( LString , 1 ) 
    ; LOOP 
        IF I < LLength 
        THEN 
          INC ( I )
        ; LNextChar := Strings . Char ( LString , I ) 
        ELSIF I = LLength  
        THEN 
          INC ( I )
        ; LNextChar := ' ' 
        ELSE EXIT 
        END (* IF *) 
      ; IF  ( ( ( 'a' <= LPrevChar ) AND ( LPrevChar <= 'z' ) ) 
              AND ( ( ( '0' <= LChar ) AND ( LChar <= '9' ) ) 
                    OR ( ( 'A' <= LChar ) AND ( LChar <= 'Z' ) ) 
                  ) 
            ) OR ( ( ( 'A' <= LPrevChar ) AND ( LPrevChar <= 'Z' ) ) 
                   AND ( ( 'A' <= LChar ) AND ( LChar <= 'Z' ) ) 
                   AND ( ( 'a' <= LNextChar ) AND ( LNextChar <= 'z' ) ) 
                 ) 
        THEN IO . WriteC ( f , '_' ) 
        END (* IF *) 
      ; IO . WriteC ( f , LChar ) 
      ; LPrevChar := LChar 
      ; LChar := LNextChar 
      END (* LOOP *) 
    END (* IF *) 
  END WG; 

PROCEDURE IsDescendedFrom ( Descendent : tTree ; Ancestor : tTree ) : BOOLEAN 
; VAR LClass : tTree 
; BEGIN
    IF Ancestor = NoTree THEN RETURN FALSE 
    ELSIF Tree . IsType ( Ancestor , Tree . NoClass ) THEN RETURN FALSE 
    ELSIF NOT Tree . IsType ( Ancestor , Tree . Class ) 
    THEN 
      Errors . MessageI
        ( 'IsDescendedFrom, Ancestor not Class' 
        , Errors . Fatal 
        , Positions . NoPosition 
        , Errors . Integer 
        , SYSTEM . ADR ( Ancestor ^ . Kind )  
        ) 
    ELSE 
      LClass := Descendent 
    ; LOOP 
        IF LClass = Ancestor THEN RETURN TRUE 
        ELSIF LClass  = NoTree THEN RETURN FALSE 
        ELSIF Tree . IsType ( LClass , Tree . NoClass ) THEN RETURN FALSE 
        ELSIF NOT Tree . IsType ( LClass , Tree . Class ) 
        THEN 
          Errors . MessageI
            ( 'IsDescendedFrom, LClass not Class' 
            , Errors . Fatal 
            , Positions . NoPosition 
            , Errors . Integer 
            , SYSTEM . ADR ( LClass ^ . Kind )
            ) 
        ELSE 
          LClass := LClass ^ . Class . BaseClass 
        END (* IF *) 
      END (* LOOP *) 
    END (* IF *) 
  END IsDescendedFrom ; 

PROCEDURE PackageName ( FieldName : tIdent ) : tIdent 
; BEGIN 
    IF FieldName = gIdentNext 
    THEN RETURN gIdentNlists
    ELSIF FieldName = gIdentPrev 
    THEN RETURN gIdentNlists
    ELSIF FieldName = gIdentLink 
    THEN RETURN gIdentGnatAdaUtils
    ELSIF FieldName = gIdentNextEntity
    THEN RETURN gIdentSinfo
    ELSIF FieldName = gIdentScope
    THEN RETURN gIdentSinfo
    ELSIF FieldName = gIdentHomonym
    THEN RETURN gIdentSinfo
    ELSIF FieldName = gIdentEtype
    THEN RETURN gIdentSinfo
    ELSIF FieldName = gIdentDiscriminantConstraint
    THEN RETURN gIdentGnatAdaUtils
    ELSIF FieldName = gIdentPrimitiveOperations
    THEN RETURN gIdentGnatAdaUtils
    ELSIF FieldName = gIdentPrivalsChain
    THEN RETURN gIdentGnatAdaUtils
    ELSIF FieldName = gIdentPrivateDependents
    THEN RETURN gIdentGnatAdaUtils
    ELSIF FieldName = gIdentGirderConstraint
    THEN RETURN gIdentGnatAdaUtils
    ELSIF FieldName = gIdentMechanism
    THEN RETURN gIdentGnatAdaUtils
    ELSIF FieldName = gIdentIsListMember  
    THEN RETURN gIdentNlists
    ELSIF FieldName = gIdentSloc
    THEN RETURN gIdentAtree
    ELSIF FieldName = gIdentIsRewriteSubstitution
    THEN RETURN gIdentAtree
    ELSIF FieldName = gIdentIsRewriteInsertion
    THEN RETURN gIdentAtree
    ELSIF FieldName = gIdentComesFromSource
    THEN RETURN gIdentAtree
    ELSIF FieldName = gIdentAnalyzed
    THEN RETURN gIdentAtree
    ELSIF FieldName = gIdentErrorPosted
    THEN RETURN gIdentAtree
    ELSIF FieldName = gIdentParenCount
    THEN RETURN gIdentAtree
    ELSIF FieldName = gIdentHasDynamicLengthCheck
    THEN RETURN gIdentSinfo
    ELSIF FieldName = gIdentHasDynamicRangeCheck
    THEN RETURN gIdentSinfo
    ELSIF FieldName = gIdentChars
    THEN RETURN gIdentSinfo
    ELSE RETURN gFieldInterface 
    END (* IF *) 
  END PackageName ;

CONST UseQualifiers = FALSE ; 

PROCEDURE WriteQualifier ( Name : tIdent ) 
; BEGIN  
    IF IsElement ( ORD ( '%' ) , Options )  
    THEN 
      WI ( PackageName ( Name ) ) ; 
      WriteS ( f , " . " )  
    END (* IF *) 
  END WriteQualifier ; 

} (* End of GLOBAL *) 

(*
BEGIN 
  {  }
*)

PROCEDURE GnatModule (t: Tree)

Ag (..) :- {
      IF IsElement (ORD ('~'), Options) THEN

        Strings . ArrayToString ( 'Next' , gString ) ; 
        gIdentNext := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Prev' , gString ) ; 
        gIdentPrev := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'IsListMember' , gString ) ; 
        gIdentIsListMember := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Link' , gString ) ; 
        gIdentLink := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Sloc' , gString ) ; 
        gIdentSloc := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'IsRewriteSubstitution' , gString ) ; 
        gIdentIsRewriteSubstitution := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'IsRewriteInsertion' , gString ) ; 
        gIdentIsRewriteInsertion := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'ComesFromSource' , gString ) ; 
        gIdentComesFromSource := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Analyzed' , gString ) ; 
        gIdentAnalyzed := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'ErrorPosted' , gString ) ; 
        gIdentErrorPosted := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'ParenCount' , gString ) ; 
        gIdentParenCount := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'HasDynamicLengthCheck' , gString ) ; 
        gIdentHasDynamicLengthCheck := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'DiscriminantConstraint' , gString ) ; 
        gIdentDiscriminantConstraint := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'PrimitiveOperations' , gString ) ; 
        gIdentPrimitiveOperations := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'PrivalsChain' , gString ) ; 
        gIdentPrivalsChain := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'PrivateDependents' , gString ) ; 
        gIdentPrivateDependents := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'GirderConstraint' , gString ) ; 
        gIdentGirderConstraint := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Mechanism' , gString ) ; 
        gIdentMechanism := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'HasDynamicRangeCheck' , gString ) ; 
        gIdentHasDynamicRangeCheck := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Chars' , gString ) ; 
        gIdentChars := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'NextEntity' , gString ) ; 
        gIdentNextEntity := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Scope' , gString ) ; 
        gIdentScope := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Homonym' , gString ) ; 
        gIdentHomonym := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Etype' , gString ) ; 
        gIdentEtype := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Einfo' , gString ) ; 
        gIdentEinfo := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Sinfo' , gString ) ; 
        gIdentSinfo := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'GnatUtils' , gString ) ; 
        gIdentGnatUtils := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'GnatAdaUtils' , gString ) ; 
        gIdentGnatAdaUtils := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Atree' , gString ) ; 
        gIdentAtree := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Nlists' , gString ) ; 
        gIdentNlists := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'NClassNonEmpty' , gString ) ; 
        gIdentNClassNonEmpty := Idents . MakeIdent ( gString ) ;
        gNClassNonEmptyClass := IdentifyClass ( NoTree , gIdentNClassNonEmpty ) ; 
        Strings . ArrayToString ( 'NClassEntity' , gString ) ; 
        gIdentNClassEntity := Idents . MakeIdent ( gString ) ;
        gEntityClass := IdentifyClass ( NoTree , gIdentNClassEntity ) ; 


	!TYPE yyPtrtTree	= UNTRACED REF ! WI (itTree); !;!
	!!
	!TYPE yytMapArray = ARRAY OF ! WI (itTree); ! ;!
	!TYPE yytMapRef = REF yytMapArray ;!
	!!
        !VAR yyNodeMapRef : yytMapRef ;!
        !VAR yyListMapRef : yytMapRef ;!
        !VAR yyElistMapRef : yytMapRef ;!
        !VAR yyElmtMapRef : yytMapRef ;!
        !!
	!PROCEDURE yyConvert! WI (iMain); !!
        !   ( yyt : GnatTypes . Union_Id ; yyNew : yyPtrtTree )!
        !=VAR LKind : ! WI ( iMain ) ; ! . SHORTCARD ;!
        ! BEGIN!
	!  LOOP!
        !    IF GnatTypes . List_Low_Bound <= yyt AND yyt <= GnatTypes . List_High_Bound!
        !    THEN (* This is a list node. *) !
	!      IF yyt = GnatTypes . No_List!
        !      THEN yyNew ^ := NEW ( ! WI ( iMain ) ; ! . NoList )!
        !                   (* Multiple copies of NoList nodes *)!
        !      ; yyNew ^ . Kind := Tree . NkNoList!
        !      ; RETURN!
        !      END (* IF *) !
        !    ; WITH WNewRef = yyListMapRef ^ [ yyt - GnatTypes . List_Low_Bound ] !
        !      DO!
        !        IF WNewRef # ! WI ( iNoTree ) ; !!
        !        THEN yyNew ^ := WNewRef ; RETURN END (* IF *) !
        !      ; VAR LNewList : Tree . List := NEW ( ! WI ( iMain ) ; ! . List ) !
        !        ; BEGIN!
        !            WNewRef := LNewList!
        !          ; yyNew ^ := LNewList!
        !          ; yyNew ^ . Kind := Tree . NkList!
        !          ; yyConvert! WI (iMain); ! ( Nlists . Parent ( yyt ) , ADR ( LNewList . Parent ) ) !
        !          ; yyConvert! WI (iMain); ! ( Nlists . Last ( yyt ) , ADR ( LNewList . Last ) ) !
        !          ; yyt := Nlists . First ( yyt ) !
        !          ; yyNew := ADR ( LNewList . First )!
        !          END (* BEGIN *) !
        !      END (* WITH WNewRef *) !
        !    ELSIF GnatTypes . Elist_Low_Bound <= yyt AND yyt <= GnatTypes . Elist_High_Bound!
        !    THEN (* This is an Elist node. *) !
	!      IF yyt = GnatTypes . No_Elist!
        !      THEN yyNew ^ := NEW ( ! WI ( iMain ) ; ! . NoElist ) !
        !      ; yyNew ^ . Kind := Tree . NkNoElist!
        !      ; RETURN  !
        !      END (* IF *) !
        !    ; WITH WNewRef = yyElistMapRef ^ [ yyt - GnatTypes . Elist_Low_Bound ] !
        !      DO!
        !        IF WNewRef # ! WI ( iNoTree ) ; !!
        !        THEN yyNew ^ := WNewRef ; RETURN END (* IF *) !
        !      ; VAR LNewElist : Tree . Elist := NEW ( ! WI ( iMain ) ; ! . Elist ) !
        !        ; BEGIN!
        !            WNewRef := LNewElist!
        !          ; yyNew ^ := LNewElist!
        !          ; yyNew ^ . Kind := Tree . NkElist!
        !          ; yyConvert! WI (iMain); ! ( Elists . Last_Elmt ( yyt ) , ADR ( LNewElist . LastElmt ) ) !
        !          ; yyt := Elists . First_Elmt ( yyt ) !
        !          ; yyNew := ADR ( LNewElist . FirstElmt )!
        !          END (* BEGIN *) !
        !      END (* WITH WNewRef *) !
        !    ELSIF GnatTypes . Elmt_Low_Bound <= yyt AND yyt <= GnatTypes . Elmt_High_Bound!
        !    THEN (* This is an Elmt node. *) !
	!      IF yyt = GnatTypes . No_Elmt!
        !      THEN yyNew ^ := NEW ( ! WI ( iMain ) ; ! . NoElmt ) !
        !      ; yyNew ^ . Kind := Tree . NkNoElmt!
        !      ; RETURN !
        !      END (* IF *) !
        !                   (* Multiple copies of NoElmt nodes *)!
        !    ; WITH WNewRef = yyElmtMapRef ^ [ yyt - GnatTypes . Elmt_Low_Bound ] !
        !      DO!
        !        IF WNewRef # ! WI ( iNoTree ) ; !!
        !        THEN yyNew ^ := WNewRef!
        !        ; RETURN!
        !        END (* IF *) !
        !      ; VAR LNewElmt : Tree . Elmt := NEW ( ! WI ( iMain ) ; ! . Elmt ) !
        !        ; BEGIN!
        !            WNewRef := LNewElmt!
        !          ; yyNew ^ := LNewElmt!
        !          ; yyNew ^ . Kind := Tree . NkElmt!
        !          ; yyConvert! WI (iMain); ! ( Elists . Node ( yyt ) , ADR ( LNewElmt . Node ) ) !
        !          ; yyt := Elists . Next_Elmt ( yyt ) !
        !          ; yyNew := ADR ( LNewElmt . NextElmt )!
        !          END (* BEGIN *) !
        !      END (* WITH WNewRef *) !
        !    ELSIF GnatTypes . Node_Low_Bound <= yyt AND yyt <= GnatTypes . Node_High_Bound!
        !    THEN (* This is an ordinary node. *) !
	!      IF yyt = GnatTypes . Empty!
        !      THEN yyNew ^ := NEW ( ! WI ( iMain ) ; ! . NNoNode ) !
        !                   (* Multiple copies of Empty nodes *)!
        !      ; yyNew ^ . Kind := Tree . NkNNoNode!
        !      ; RETURN !
        !      END (* IF *) !
        !    ; WITH WNewRef = yyNodeMapRef [ yyt - GnatTypes . Node_Low_Bound ] !
        !      DO!
        !        IF WNewRef # ! WI ( iNoTree ) ; !!
        !        THEN yyNew ^ := WNewRef!
        !        ; RETURN!
        !        END (* IF *) !
        !      ; LKind := GnatUtils . Kind ( yyt )!
        !      ; CASE LKind OF!
	ForallClasses ( Classes , Convert);
        !        END (* CASE *)!
        !      END (* WITH WNewRef *) !
        !    ELSE <* ASSERT FALSE *> !
        !    END (* IF *) !
        !  END (* LOOP *) !
	! END yyConvert! WI (iMain); !;!
	!!
	!PROCEDURE GnatConvert! WI (iMain); ! ( GnatTree : GnatTypes . Node_Id ) !
        ! : ! WI (itTree); !!
	!=VAR yyNew	: ! WI (itTree); !;!
	! BEGIN!
	!  !
        !  yyNodeMapRef := NEW ( yytMapRef , Atree . Last_Node_Id ( )  - GnatTypes . Node_Low_Bound + 1 ) ;!
        !  yyListMapRef := NEW ( yytMapRef , Nlists . Last_List_Id ( ) - GnatTypes . List_Low_Bound + 1 ) ;!
        !  yyElistMapRef := NEW ( yytMapRef , Elists . Last_Elist_Id ( ) - GnatTypes . Elist_Low_Bound + 1 ) ;!
        !  yyElmtMapRef := NEW ( yytMapRef , Elists . Last_Elmt_Id ( ) - GnatTypes . Elmt_Low_Bound + 1 ) ;!
        !!
	!  yyConvert! WI (iMain); ! ( GnatTree , ADR ( yyNew ) ) ;!
        !!
        !  yyNodeMapRef := NIL ; !
        !  yyListMapRef := NIL ; !
        !  yyElistMapRef := NIL ; !
        !  yyElmtMapRef := NIL ; !
        !!
	!  RETURN yyNew;!
	! END GnatConvert! WI (iMain); !;!
	!!
      END (* IF *) 
}; .


PROCEDURE Convert (t: Tree)

Class (..) :- {
	IF ( ( NoCodeClass * Properties ) = { } ) 
           AND ( Extensions ^ . Kind = Tree . NoClass ) (* Low IN Properties ) is not set *) 
           AND IsDescendedFrom ( t , gNClassNonEmptyClass ) 
        THEN
	   !        | ! WI ( iMain ) ; ! . Nk! WI (Name); !!
           !        => VAR LNewNode := NEW ( ! WI ( iMain ) ; ! . ! WI ( Name ) ; ! )!
           !           ; BEGIN!
           !               WNewRef := LNewNode!
           !             ; yyNew ^ := WNewRef!
           !             ; yyNew ^ . Kind := LKind!
	   ConvertAttrs (t);
           !             (* Field Next of Node is the builtin tail-recursion eliminated iterator *) !
           !             ; yyt := Nlists . Next ( yyt ) !
           !             ; yyNew := ADR ( LNewNode . Next )!
           !             END (* BEGIN *) !
	END;
}; .

PROCEDURE ConvertAttrs (t: Tree)

Class (..) :- {
	IF ( ( NoCodeClass * Properties ) = { } ) 
        THEN
           ConvertAttrs ( t^.Class.BaseClass); 
           IF IsDescendedFrom ( t , gEntityClass ) 
           THEN gFieldInterface := gIdentEinfo 
           ELSE gFieldInterface := gIdentSinfo 
           END (* IF *);   
	   ConvertAttrs (t^.Class.Attributes);
	END;
}; .

Child (..) :- {
        IF Name = gIdentNext
        THEN 
           !             (* Next is handled last, as tail recursion elimination *) !
        ELSE 
           !             ; yyConvert! WI (iMain); ! ( ! WriteQualifier ( Name ) ; WG ( Name ) ; 
                                     ! ( yyt ) , ADR ( LNewNode . ! WI ( Name ) ; ! ) ) !
        END (* IF *) ; 
        ConvertAttrs ( t^.Child.Next); 
}; .
Attribute (..) :- {
	IF ( NoCodeAttr * Properties ) = {} 
        THEN 
          IF Link IN Properties 
          THEN 
           !             ; yyConvert! WI (iMain); ! ( ! WriteQualifier ( Name ) ; WG ( Name ) ; 
                                     ! ( yyt ) , ADR ( LNewNode . ! WI ( Name ) ; ! ) ) !
          ELSE 
(*         !             ; LNewNode . ! WI ( Name ) ; 
                           ! := ! WriteQualifier ( Name ) ; WG ( Name ) ; ! ( yyt )!
*)
	   !             ; copy! WI (Type); ! ( LNewNode . ! WI ( Name ) ; 
                           ! , ! WriteQualifier ( Name ) ; WG ( Name ) ; ! ( yyt ) )!
          END (* IF *) 
	END;
        ConvertAttrs ( t^.Attribute.Next); 
}; .


 (* End of file MThree6.puma *) 


