
(* file MThree2.puma *) 

(* Modula-3 generation of Tree io, etc. 
   Rodney M. Bates Oct 1997 
   Extensively modified from file mod2.puma, which had these header comments:  
     (* Ich, Doktor Josef Grosch, Informatiker, 26.1.1989 *)
     (* Modified Rodney M. Bates: 
        RMB Dec 1995: Made tree writer reduce the amount of space on the
                      left of deeply indented lines by replacing whole
                      multiples of yyIndentFactor (initially = 20) blanks
                      by a modula-2 style comment containing a count of 
                      the blanks replaced. 

     *)
   Dec 1997 Added <*LINE...*> pragma output with -# option  
   Jan 1999 Added html tree dumper generation 
   Jan 1999 Added cases to Mark, WriteTREEm and WriteTREEHtml to follow 
            LINK Attributes 
   Jan 1999 changed procedure name yWriteNode to yyyWriteNode, to avoid
            possible conflict with yWrite<Class>, where <Class> = "Node"
*)

TRAFO TreeMThree2
TREE Tree
PUBLIC TreeIO TreeIOInit GetIterator

EXPORT  {
FROM Positions  IMPORT tPosition;

VAR Iterator    : Tree.tTree;

PROCEDURE WriteLine (Line: tPosition);
}

GLOBAL  {

IMPORT Idents , Strings ; 
FROM IO         IMPORT WriteS, WriteNl;
FROM Sets       IMPORT IsElement;
FROM Idents     IMPORT tIdent;
FROM Positions  IMPORT tPosition;

FROM Tree       IMPORT
   NoTree       , tTree         , Options       , ClassCount    ,
   f            , WI    , WN    , iInteger      , itTree        ,
   iNoTree      , iModule       , iMain         , HasChildren   ,
   HasAttributes, NoCodeAttr    , NoCodeClass   , Link          , 
   ForallClassesExtensionsFirst, ForallAttributes, Reverse      ;

VAR
   iClassName   : Idents . tIdent;
   sBOOLEAN     : Strings . tString;
   iBOOLEAN     : Idents . tIdent;
   RevChild     : tTree;

PROCEDURE WriteLine (Line: tPosition);
   BEGIN
      IF Line.Line # 0 THEN
         !(* line ! WN (Line.Line); @ "@ WI (Line.File); @" *)@
         IF IsElement (ORD ('#'), Options) THEN 
           !<*LINE ! WN (Line.Line); @ "@ WI (Line.File); @" *>@
         END; 
      END;
   END WriteLine;
} (* End of GLOBAL *) 

BEGIN { 

  Strings . ArrayToString ( "BOOLEAN" , sBOOLEAN ) ; 
  iBOOLEAN := Idents . MakeIdent ( sBOOLEAN ) ; 

} (* End of BEGIN *)  

PROCEDURE TreeIO (t: Tree)

Ag (..) :- {
        !!
      IF IsElement (ORD ('w'), Options) 
         OR IsElement (ORD ('o'), Options) 
         OR IsElement (ORD ( '^' ), Options) THEN
        !VAR yyf        : Wr . T ;!
      END; 
      IF IsElement (ORD ('r'), Options) THEN 
(* These are used only by the Ascii reader, which is  not generated for M3.
        !VAR yyLabel    : CARDINAL ;!
        !VAR yyKind     : CARDINAL ;!
        !VAR yyc        : CHAR;!
*)
      END;  
        !!
      IF IsElement (ORD (','), Options) THEN
        !PROCEDURE yyMark  (yyt : ! WI (itTree); ! )!
        !=BEGIN!
        !  LOOP!
        !   IF yyt = ! WI (iNoTree); ! THEN RETURN; END;!
        !   INC ( yyt . yyHead . yyMark ) ;!
        !   IF yyt . yyHead . yyMark > 1 THEN RETURN; END;!
        !!
        !   TYPECASE yyt OF!
        Mark ( Classes ) ; 
        !   ELSE RETURN ;!
        !   END ;!
        !  END ;!
        ! END yyMark ;!
        !!
      END;
      IF IsElement (ORD (';'), Options) THEN
        !CONST yyInitTreeStoreSize      = 32 ;!
        !!
        !TYPE yytTreeStore = ARRAY OF ! WI (itTree); ! ;!
        !!
        !VAR yyTreeStorePtr     : REF yytTreeStore ;!
        !VAR yyLabelCount       : CARDINAL ;!
        !VAR yyRecursionLevel   : CARDINAL ;!
        !!
        !PROCEDURE yyMapToLabel ( yyTree : ! WI (itTree); ! ) : CARDINAL!
        !=VAR yyi       : CARDINAL ;!
        ! VAR LNewTreeStorePtr : REF yytTreeStore ;!
        ! BEGIN!
        !  FOR yyi := 0 TO yyLabelCount - 1 DO!
        !   IF yyTreeStorePtr ^ [ yyi ] = yyTree THEN RETURN yyi ; END ;!
        !  END ;!
        !  IF yyLabelCount = NUMBER ( yyTreeStorePtr ^ ) THEN!
        !     LNewTreeStorePtr := NEW ( REF yytTreeStore , NUMBER ( yyTreeStorePtr ^ ) * 2 ) ;!
        !     SUBARRAY ( LNewTreeStorePtr ^ , 0 , NUMBER ( yyTreeStorePtr ^ ) ) := yyTreeStorePtr ^ ; !
        !     yyTreeStorePtr := LNewTreeStorePtr ; !
        !  END;!
        !  yyi := yyLabelCount ;!
        !  yyTreeStorePtr ^ [ yyi ] := yyTree ;!
        !  INC ( yyLabelCount ) ;!
        !  RETURN yyi ;!
        ! END yyMapToLabel;!
        !!
       IF IsElement (ORD ('r'), Options) THEN 
(* This is used only by the Ascii reader, which is  not generated for M3.
        !PROCEDURE yyMapToTree ( yyLabel : CARDINAL ) : ! WI (itTree); !!
        !=BEGIN RETURN yyTreeStorePtr ^ [ yyLabel ] ; END yyMapToTree ;!
        !!
*) 
       END;
      END;
      IF IsElement (ORD ('w'), Options) OR
         IsElement (ORD ('^'), Options) OR
         IsElement (ORD ('o'), Options) THEN
        !PROCEDURE yyWriteNl ( ) = BEGIN Wr . PutText ( yyf , Wr . EOL ) ; END yyWriteNl ;!
        !!
        !PROCEDURE yyWriteSelector ( yys : TEXT ) !
        !=BEGIN Wr . PutText  ( yyf , yys ) ; !
        @   Wr . PutText ( yyf , Fmt . Pad ( "" , MAX ( 0 , 16 - Text . Length ( yys ) ) ) ) ;@
        @   Wr . PutText (yyf, " = " ) ;@
        ! END yyWriteSelector ;!
        !!
        !VAR LittleEndian := TRUE ; !
        !!
        !PROCEDURE yyWriteHex ( VAR yyx : ARRAY OF CHAR ) !
        !=BEGIN!
        !  IF LittleEndian!
        !  THEN!
        !   FOR yyi := NUMBER ( yyx ) - 1 TO 0 BY - 1 DO!
        !    Wr . PutText ( yyf , Fmt . Pad ( Fmt . Int ( ORD ( yyx [ yyi ] ) , 16 ) , 2 , '0' ) ) ;!
        (* !    Wr . PutChar ( yyf, ' ' ) ;! *) 
        !   END ;!
        !  ELSE!
        !   FOR yyi := 0 TO NUMBER ( yyx ) - 1 DO!
        !    Wr . PutText ( yyf , Fmt . Pad ( Fmt . Int ( ORD ( yyx [ yyi ] ) , 16 ) , 2 , '0' ) ) ;!
        (* !    Wr . PutChar ( yyf, ' ' ) ;! *) 
        !   END ;!
        !  END!
        ! END yyWriteHex ;!
        !!
      END;
      IF IsElement (ORD ('o'), Options) THEN
        !PROCEDURE yyWriteAdr ( yyt : ! WI (itTree); ! )!
        !=BEGIN!
        !  IF yyt = ! WI (iNoTree); ! THEN!
        @   Wr . PutText ( yyf , "@ WI (iNoTree); @" ) ;@
        !  ELSE!
        !   yyWriteHex ( LOOPHOLE ( yyt , ARRAY [ 0 .. 3 ] OF CHAR ) ) ;!
(* ^Revisit this. *) 
        !  END ;!
        !  yyWriteNl ( ) ;!
        ! END yyWriteAdr;!
        !!
        ForallClassesExtensionsFirst (Classes, WriteNode);
        !PROCEDURE Write! WI (iModule); !Node ( f : Wr . T ; Tree : ! WI (itTree); ! ) !
        !=BEGIN!
        !  yyf := f ;!
        !  IF Tree = ! WI (iNoTree); ! THEN!
        @   Wr . PutText ( yyf , "@ WI (iNoTree); @" ) ; yyWriteNl ( ) ; RETURN ;@
        !  END ;!
        !!
        !  TYPECASE Tree OF!
        WriteNodeName ( Classes ) ;
        !  ELSE!
        !  END ;!
        ! END Write! WI (iModule); !Node ;!
        !!
      END;
      (* Generate ascii writer, original Cocktail format *) 
      IF IsElement (ORD ('w'), Options) THEN
        !VAR yyIndentLevel      : INTEGER ;!
        !VAR yyActualIndent , yyIndentQuotient , yyIndentRemainder : INTEGER ;!
        !CONST yyIndentFactor = 20 ; !
        !!
        !PROCEDURE yySetIndentInfo ( ) !
        ! =BEGIN !
        !   yyIndentQuotient := yyIndentLevel DIV yyIndentFactor ; !
        !   yyIndentRemainder := yyIndentLevel MOD yyIndentFactor ; !
        !   yyActualIndent !
        !     := 10 * ORD ( yyIndentQuotient > 0 ) !
        !        + yyIndentRemainder !
        !  END yySetIndentInfo ; !
        !!
        !PROCEDURE Write! WI (iModule); ! ( f : Wr . T ; Tree : ! WI (itTree); ! ) !
        !=VAR yySaveLevel : INTEGER ;!
        ! BEGIN!
        !  yyf := f ;!
        !  IF yyRecursionLevel = 0 THEN yyLabelCount := 0 END ;!
        !  INC ( yyRecursionLevel ) ;!
        !  yyMark ( Tree ) ;!
        !  yySaveLevel := yyIndentLevel ;!
        !  yyIndentLevel := 0 ;!
        !  yySetIndentInfo ( ) ; !
        !  yyWrite! WI (iModule); ! ( Tree );!
        !  yyIndentLevel := yySaveLevel ;!
        !  yySetIndentInfo ( ) ; !
        !  DEC ( yyRecursionLevel ) ;!
        ! END Write! WI (iModule); ! ;!
        !!
        !PROCEDURE yyIndentSelector ( yys : TEXT )!
        !=BEGIN !
        !   IF yyIndentQuotient > 0 !
        !   THEN Wr . PutChar ( yyf , '(' ) ; Wr . PutChar ( yyf , '*' ) ;!
        !     Wr . PutText ( yyf , Fmt . Pad ( Fmt . Int ( yyIndentQuotient * yyIndentFactor ) , 6 ) ) ; !
        !     Wr . PutChar ( yyf , '*' ) ; Wr . PutChar ( yyf , ')' ) ;!
        !   END ; !
        @   Wr . PutText ( yyf , Fmt . Pad ( "" , yyIndentRemainder ) ) ;@
        !   yyWriteSelector ( yys ) ; !
        ! END yyIndentSelector ;!
        !!
        !PROCEDURE yyIndentSelectorTree ( yys : TEXT ; yyt : ! WI (itTree); ! )!
        !=BEGIN yyIndentSelector  ( yys ) ; write! WI (itTree); ! (yyt) END yyIndentSelectorTree ;!
        !!
        ForallClassesExtensionsFirst (Classes, WriteAttributes);
        !PROCEDURE yyWrite! WI (iModule); ! ( yyt : ! WI (itTree); ! )!
        !=VAR yyLevel : CARDINAL ;!
        ! BEGIN!
        !  yyLevel := yyIndentLevel ;!
        !  LOOP!
        !   IF yyt = ! WI (iNoTree); ! THEN!
        @    Wr . PutText ( yyf , " @ WI (iNoTree); @" ) ; yyWriteNl ( ) ; EXIT ; @
        !   ELSIF yyt . yyHead . yyMark = 0 THEN!
        !    Wr . PutChar ( yyf, '^') ;!
        !    Wr . PutText  ( yyf , Fmt . Int ( yyMapToLabel ( yyt ) ) ) ; yyWriteNl ( ) ; EXIT ;!
        !   ELSIF yyt . yyHead . yyMark > 1 THEN!
        !    yyWriteNl ( ) ;!
        !    Wr . PutText ( yyf , Fmt . Pad ( Fmt . Int ( yyMapToLabel ( yyt ) ) , 6 ) ) ;!
        !    Wr . PutChar ( yyf , ':') ;!
        @    Wr . PutText ( yyf , Fmt . Pad ( "" , MAX ( 0 , yyActualIndent - 7 ) ) ) ;@
        !   ELSE!
        !    Wr . PutChar ( yyf , ' ' ) ;!
        !   END ;!
        !   yyt . yyHead . yyMark := 0 ;!
        !   INC ( yyIndentLevel , 2 ) ;!
        !   yySetIndentInfo ( ) ; !
        !!
        !   TYPECASE yyt OF!
        WriteClassName ( Classes );
        !   ELSE EXIT ;!
        !   END ;!
        !  END ;!
        !  yyIndentLevel := yyLevel ;!
        !  yySetIndentInfo ( ) ; !
        ! END yyWrite! WI (iModule); ! ;!
        !!
      END;
      (* Generate html dumper *) 
      IF IsElement (ORD ('^'), Options) THEN
        !PROCEDURE yyNodeTag ( yyt : ! WI ( itTree ) ; ! ) : TEXT !
        !=BEGIN!
        @   RETURN "Node" & Fmt . Int ( yyMapToLabel ( yyt ) ) @
        ! END yyNodeTag ; !
        !!
        ! PROCEDURE yyNodeKind ( yyt : ! WI ( itTree ) ; ! ) : TEXT !
        ! =BEGIN!
        !   IF yyt = ! WI (iNoTree); !!
        !   THEN!
        @    RETURN "NIL" @
        !   ELSE!
        !    TYPECASE yyt OF!
        NodeKinds ( Classes ) ; 
        !    ELSE ! 
        @     RETURN "<Unknown>" @
        !    END (* TYPECASE *) !
        !   END (* IF *) !
        !  END yyNodeKind ; !
        !!
        !PROCEDURE Write! WI (iModule); !Html !
        @  ( f : Wr . T ; Tree : @ WI (itTree); @ ; Title : TEXT := "" @
        !  ; SuppressNullFields : BOOLEAN := FALSE ) !
        !!
        @=CONST IndentString = "  " ; @ 
        !!
        ! PROCEDURE WriteChildOrLink !
        !   ( Name , Type : TEXT ; Value : ! WI ( itTree ) ; ! ; IsLink : BOOLEAN := FALSE ) !
        ! =VAR LNodeTag : TEXT ; !
        !  BEGIN !
        !   IF Value # NIL OR NOT SuppressNullFields ! 
        !   THEN !
        !    Wr . PutText ( yyf , IndentString ) ; !
        !    Wr . PutText ( yyf , Name ) ; !
        @    Wr . PutText ( yyf , " : " ) ; @
        !    Wr . PutText ( yyf , Type ) ; !
        !    IF IsLink  !
        !    THEN !
        @      Wr . PutText ( yyf , " LINK" ) ; @
        !    END (* IF *) ; !
        @    Wr . PutText ( yyf , " = " ) ; @
        !    LNodeTag := yyNodeTag ( Value ) ; !
        @    Wr . PutText ( yyf , "<a href=\"#" ) ; @
        !    Wr . PutText ( yyf , LNodeTag ) ; !
        @    Wr . PutText ( yyf , "\">REF " ) ; @
        !    Wr . PutText ( yyf , LNodeTag ) ; !
        @    Wr . PutText ( yyf , "(" ) ; @
        !    yyWriteHex ( LOOPHOLE ( Value , ARRAY [ 0 .. 3 ] OF CHAR ) ) ; !
        @    Wr . PutText ( yyf , ")" ) ; @
        !    Wr . PutText ( yyf , yyNodeKind ( Value ) ) ; !
        @    Wr . PutText ( yyf , "</a>" ) ; @
        !    yyWriteNl ( ) ; !
        !   END (* IF *) ! 
        !  END WriteChildOrLink ; !
        !!
        ! PROCEDURE WriteBOOLEANAttribute !
        !   ( Name : TEXT ; Value : BOOLEAN ) !
        ! =BEGIN !
        !   IF Value OR NOT SuppressNullFields ! 
        !   THEN !
        !    Wr . PutText ( yyf , IndentString ) ; !
        !    Wr . PutText ( yyf , Name ) ; !
        @    Wr . PutText ( yyf , " : " ) ; @
        @    Wr . PutText ( yyf , "BOOLEAN = " ) ; @ 
        !    writeBOOLEAN ( Value ) ! 
        !    yyWriteNl ( ) ; !
        !   END (* IF *) ! 
        !  END WriteBOOLEANAttribute ; !
        !!
     (* ! PROCEDURE WriteAttributeHeader !
        !   ( Name , Type : TEXT ) !
        ! =BEGIN !
        !   Wr . PutText ( yyf , IndentString ) ; !
        !   Wr . PutText ( yyf , Name ) ; !
        @   Wr . PutText ( yyf , " : " ) ; @
        !   Wr . PutText ( yyf , Type ) ; !
        @   Wr . PutText ( yyf , " = " ) ; @
        !  END WriteAttribute ; !
        !! *) 
        ForallClassesExtensionsFirst ( Classes , WriteHtmlNodes ) ;
        ! PROCEDURE WriteHtmlRecurse ( yyt : ! WI ( itTree ) ; ! )!
        ! =BEGIN!
        !   LOOP!
        !    IF yyt = ! WI (iNoTree); ! OR yyt . yyHead . yyMark = 0!
        !    THEN!
        !     EXIT!
        !    ELSE!
        !     yyt . yyHead . yyMark := 0 ;!
        !     TYPECASE yyt OF!
        WriteHtmlCases ( Classes );
        !     ELSE EXIT! 
        !     END (* TYPECASE *)!
        !    END (* IF *)!
        !   END (* LOOP *)!
        !  END WriteHtmlRecurse ;!
        !!
        ! BEGIN (* Write! WI (iModule); !Html *)!
        !  yyf := f ;!
        !  IF yyRecursionLevel = 0 THEN yyLabelCount := 0 END ;!
        !  INC ( yyRecursionLevel ) ;!
        !  yyMark ( Tree ) ;!
        @  Wr . PutText ( yyf , "<html> " ) ; yyWriteNl ( ) ; @ 
        @  Wr . PutText ( yyf , "<head>" ) ; yyWriteNl ( ) ; @ 
        @  Wr . PutText ( yyf , "<title>" ) ; @ 
        @  Wr . PutText ( yyf , "Tree \"" ) ; @ 
        @  Wr . PutText ( yyf , Title ) ; @ 
        @  Wr . PutText ( yyf , "\"</title>" ) ; yyWriteNl ( ) ; @ 
        @  Wr . PutText ( yyf , "</head>" ) ; yyWriteNl ( ) ; @ 
        @  Wr . PutText ( yyf , "<body>" ) ; yyWriteNl ( ) ; @ 
        @  Wr . PutText ( yyf , "<pre>" ) ; yyWriteNl ( ) ; @ 
        !  yyWriteNl ( ) ; !
        !  WriteHtmlRecurse ( Tree );!
        @  Wr . PutText ( yyf , "</pre>" ) ; yyWriteNl ( ) ; @ 
        @  Wr . PutText ( yyf , "</body>" ) ; yyWriteNl ( ) ; @ 
        @  Wr . PutText ( yyf , "</html>" ) ; yyWriteNl ( ) ; @ 
        !  DEC ( yyRecursionLevel ) ;!
        ! END Write! WI (iModule); !Html ;!
        !!
      END;
(* Ascii reader not generated for M3.  Prefer to use Pickle. to avoid UNSAFE constructs which
   Ascii reader would need. 
      IF IsElement (ORD ('r'), Options) THEN 
        !PROCEDURE Read! WI (iModule); !        (f: Rd.T): ! WI (itTree); !;!
        ! VAR yyt       : ! WI (itTree); !;!
        ! BEGIN!
        !  yyf := f;!
        !  IF yyRecursionLevel = 0 THEN yyLabelCount := 0; END;!
        !  INC (yyRecursionLevel);!
        !  IF NOT yyIsInitialized THEN!
        !   yyInitKindToIdent; yyIsInitialized := TRUE;!
        !  END;!
        !  yyRead! WI (iModule); ! (SYSTEM.ADR (yyt));!
        !  DEC (yyRecursionLevel);!
        !  RETURN yyt;!
        ! END Read! WI (iModule); !;!
        !!
        !PROCEDURE yyRead! WI (iModule); ! (yyt: yyPtrtTree);!
        ! BEGIN!
        !  LOOP!
        !   CASE IO.ReadC (yyf) OF!
        !   | '^': yyLabel := IO.ReadI (yyf); yyReadNl; yyt^ := yyMapToTree (yyLabel); RETURN;!
        !   | 12C, '0': yyLabel := IO.ReadI (yyf); yyc := IO.ReadC (yyf);!
        !    Layout.SkipSpaces (yyf); Strings.ReadL (yyf, yys);!
        !    yyKind := yyMapToKind (yys); yyt^ := Make! WI (iMain); ! (yyKind);!
        @    IF yyLabel # yyMapToLabel (yyt^) THEN Wr . PutText ( Stdio . stderr , "@ WI (iModule); @: error in Read@ 
        WI (iModule); @" ) ; Wr . PutText ( Stdio . stderr , Wr . EOL ) ; yyExit ; END ;@
        !   ELSE!
        !    Layout.SkipSpaces (yyf); Strings.ReadL (yyf, yys);!
        !    yyKind := yyMapToKind (yys);!
        !    IF yyKind = 0 THEN yyt^ := ! WI (iNoTree); !; RETURN; END;!
        !    yyt^ := Make! WI (iMain); ! (yyKind);!
        !   END;!
        !!
        !   CASE yyKind OF!
        ForallClassesExtensionsFirst (Classes, ReadAttributes);
        !   ELSE RETURN;!
        !   END;!
        !  END;!
        ! END yyRead! WI (iModule); !;!
        !!
        !VAR yyKindToIdent      : ARRAY [0 .. ! WN (ClassCount); !] OF Idents.tIdent;!
        !VAR yyIsInitialized    : BOOLEAN;!
        !!
        !PROCEDURE yyMapToKind (VAR yys: Strings.tString): CARDINAL;!
        ! VAR yyi       : Idents.tIdent;!
        ! VAR yyk       : CARDINAL;!
        ! BEGIN!
        !  yyi := Idents.MakeIdent (yys);!
        !  FOR yyk := 0 TO ! WN (ClassCount); ! DO!
        !   IF yyKindToIdent [yyk] = yyi THEN RETURN yyk; END;!
        !  END;!
        !  RETURN 0;!
        ! END yyMapToKind;!
        !!
        !PROCEDURE yyInitKindToIdent2 (yya: ARRAY OF CHAR; yyKind: CARDINAL);!
        ! VAR yys       : Strings.tString;!
        ! BEGIN!
        !  Strings.ArrayToString (yya, yys);!
        !  yyKindToIdent [yyKind] := Idents.MakeIdent (yys);!
        ! END yyInitKindToIdent2;!
        !!
        !PROCEDURE yyInitKindToIdent;!
        ! BEGIN!
        !  yyInitKindToIdent2 ('! WI (iNoTree); !', 0);!
        ForallClassesExtensionsFirst (Classes, InitKindToIdent);
        ! END yyInitKindToIdent;!
        !!
        !PROCEDURE yyReadNl; BEGIN IO.ReadNl (yyf); END yyReadNl;!
        !!
        !PROCEDURE yyReadIdent (): Idents.tIdent;!
        ! VAR yys       : Strings.tString;!
        ! BEGIN!
        !  Strings.ReadL (yyf, yys);!
        !  IO.UnRead (yyf);!
        !  RETURN Idents.MakeIdent (yys);!
        ! END yyReadIdent;!
        !!
        !PROCEDURE yyReadHex (VAR yyx: ARRAY OF SYSTEM.BYTE);!
        ! VAR yyi       : INTEGER;!
        ! BEGIN!
        !  FOR yyi := 0 TO INTEGER (HIGH (yyx)) DO!
        !   yyx [yyi] := SYSTEM.BYTE (CHR (CARDINAL (IO.ReadN (yyf, 16))));!
        !  END;!
        ! END yyReadHex;!
        !!
        !PROCEDURE yySkip;!
        ! BEGIN!
        !  REPEAT UNTIL IO.ReadC (yyf) = '='; yyc := IO.ReadC (yyf);!
        ! END yySkip;!
        !!
      END;
*) 
      IF IsElement (ORD ('p'), Options) 
         OR IsElement (ORD ('g'), Options) THEN
        !TYPE AtomSpecialTyp = Pickle . Special OBJECT!
        !  OVERRIDES!
        !    write := WriteAtom!
        !  ; read := ReadAtom!
        !  END ;!
        !!
        !PROCEDURE WriteAtom ( Self : AtomSpecialTyp ; r : REFANY ; wr : Pickle . Writer )!
        !  RAISES { Pickle . Error , Wr . Failure , Thread . Alerted }!
        != VAR LText : TEXT := Atom . ToText ( NARROW ( r , Atom . T ) )!
        !      (* Why does M3 accept this without the NARROW? *) !
        !; VAR LLength : INTEGER := Text . Length ( LText )!
        !; BEGIN!
        !    wr . writeInt ( LLength ) !
        !  ; FOR i := 0 TO LLength !
        !    DO!
        !      Wr . PutChar ( wr . wr , Text . GetChar ( LText , i ) )!
        !    END (* FOR *) !
        !  END WriteAtom ;!
        !!
        !PROCEDURE ReadAtom !
        !  ( Self : AtomSpecialTyp ; rd : Pickle . Reader ; id : Pickle . RefID ) !
        !  : REFANY!
        !  RAISES { Pickle . Error , Rd . EndOfFile , Rd . Failure , Thread . Alerted }!
        != VAR LLength : INTEGER := rd . readInt ( ) !
        !; VAR LChars : REF ARRAY OF CHAR := NEW ( REF ARRAY OF CHAR , LLength ) !
        !; BEGIN!
        !    FOR i := 0 TO LLength !
        !    DO !
        !      LChars ^ [ i ] := Rd . GetChar ( rd . rd )!
        !    END (* FOR *) !
        !  ; RETURN Atom . FromText ( Text . FromChars ( LChars ^ ) )!
        !  END ReadAtom ;!
        !!
      END; 
      IF IsElement (ORD ('p'), Options) THEN
        !PROCEDURE Put! WI (iModule); ! ( f : Wr . T ; Tree : ! WI (itTree); ! )!
        !=BEGIN!
        !   Pickle . Write ( f , Tree )!
        ! END Put! WI (iModule); ! ;!
        !!
      END;
      IF IsElement (ORD ('g'), Options) THEN
        !PROCEDURE Get! WI (iModule); ! ( f : Rd . T ) : ! WI (itTree); 
        != BEGIN!
        !    RETURN NARROW ( Pickle . Read ( f ) , ! WI ( itTree ) ; ! )!
        !  END Get! WI (iModule); ! ;!
        !!
      END;
}; .


PROCEDURE TreeIOInit (t: Tree)

Ag (..) :- {
      IF IsElement (ORD ('p'), Options) 
         OR IsElement (ORD ('g'), Options) THEN
        !Pickle . RegisterSpecial ( NEW ( AtomSpecialTyp , sc := TYPECODE ( Atom . T ) ) ) ;!
      END; 
}; .


PROCEDURE WriteNodeName (t: Tree)

Class (..) :- {
        WriteNodeName ( Extensions ) ; 
        IF (NoCodeClass * Properties) = {} THEN
           !   | ! WI (Name); ! ( TNode ) =>!
           @        Wr . PutText ( yyf , "@ WI (Name); @" ) ; yyWriteNl ( ) ;@ 
           IF ({HasChildren, HasAttributes} * Properties) # {} THEN
             !        yyyWriteNode! WI (Name); ! ( TNode ) ;!
           END;
           !!
        END;
        WriteNodeName ( Next ) ; 
}; .


PROCEDURE WriteNode (t: Tree)

Class (..) :- {
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           !PROCEDURE yyyWriteNode! WI (Name); ! ( yyt : ! WI ( Name ); ! )!
           !=BEGIN!
           IF (BaseClass^.Kind = Tree.Class) AND                (* NOT Top ? *)
              (({HasChildren, HasAttributes} * BaseClass^.Class.Properties) # {}) THEN
           !  yyyWriteNode! WI (BaseClass^.Class.Name); ! (yyt); !
           END;
           iClassName := Name; (* unused, at present *) 
           ForallAttributes (Attributes, WriteNode);
           ! END yyyWriteNode! WI (Name); !;!
           !!
        END;
}; .
Child (..) :- {
        @  yyWriteSelector ( "@ WI (Name); @" ) ;@ 
        ! yyWriteAdr ( yyt . ! WI (Name); ! ) ;!
}; .
Attribute (..) :- {
        IF (NoCodeAttr * Properties) = {} THEN
         IF Link IN Properties 
         THEN
           @  yyWriteSelector ( "@ WI (Name); @" ) ;@ 
           ! yyWriteAdr ( yyt . ! WI (Name); ! ) ;!
         ELSE  
           @  yyWriteSelector ( "@ WI (Name); @" ) ; write@ WI (Type);
           ! ( yyt . ! WI (Name) ; ! ) yyWriteNl ( ) ;!
         END; 
        END;
}; .


PROCEDURE Mark (t: Tree)

Class (..) :- {
        Mark ( Extensions ) ; 
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           !    | ! WI (Name); ! ( TNode ) => !
           GetIterator (t);
           iClassName := Name; (* unused, at present *) 
           ForallAttributes (t, Mark);
           IF Iterator = NoTree THEN
              !RETURN ;!
           ELSE
              !yyt := TNode . ! WI (Iterator^.Child.Name); ! ;!
           END;
        END;
        Mark ( Next ) ; 
}; .

Child (..) :- {
        IF t # Iterator THEN
           !yyMark ( TNode . ! WI (Name); !);!
        END;
}; .

Attribute (..) :- {
        IF Link IN Properties THEN
           !yyMark ( TNode . ! WI (Name); !);!
        END;
}; .


PROCEDURE WriteClassName (t: Tree)

Class (..) :- {
        WriteClassName ( Extensions ) ; 
        IF (NoCodeClass * Properties) = {} THEN
           !   | ! WI (Name); ! ( TNode ) => !
           IF ({HasChildren, HasAttributes} * Properties) # {} THEN
              !       yWrite! WI (Name); ! ( TNode ) ; !
              GetIterator (t);
              IF Iterator = NoTree THEN
                !       EXIT ;!
              ELSE
                 @       yyIndentSelector ( "@ WI (Iterator^.Child.Name); @" ) ;@ 
                 !       yyt := TNode . ! WI (Iterator^.Child.Name); ! ;!
              END ;
           ELSE
              @       Wr . PutText ( yyf , "@ WI (Name); @" ) ; yyWriteNl ( ) ; EXIT ;@
           END;
        END;
        WriteClassName ( Next ) ; 
}; .


PROCEDURE WriteAttributes (t: Tree)

Class (..) :- {
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           !PROCEDURE yWrite! WI (Name); ! ( yyt : ! WI ( Name ); ! )!
           !=BEGIN!
           @  Wr . PutText ( yyf , "@ WI (Name); @" ) ; yyWriteNl ( ) ;@
           GetIterator (t);
           iClassName := Name; (* unused, at present *) 
           ForallAttributes (t, WriteAttributes);
           ! END yWrite! WI (Name); ! ;!
           !!
        END;
}; .
Child (..) :- {
        IF t # Iterator THEN
           @  yyIndentSelectorTree ( "@ WI (Name); @" , yyt . @ WI (Name); @ ) ;@
        END;
}; .
Attribute (..) :- {
        IF (NoCodeAttr * Properties) = {} THEN 
         IF Link IN Properties 
         THEN
           @  yyIndentSelectorTree ( "@ WI (Name); @" , yyt . @ WI (Name); @ ) ;@
         ELSE 
           @  yyIndentSelector ( "@ WI (Name); @" ) ; @ 
           !write! WI (Type); ! ( yyt . ! WI (Name); ! ) yyWriteNl ( ) ;!
         END (* IF *) ; 
        END;
}; .

(* Html writer support routines *) 

PROCEDURE NodeKinds ( t : Tree ) 

Class ( .. ) 
:- { NodeKinds ( Extensions ) ; 
     IF ( NoCodeClass * Properties = { } ) 
     THEN
       !     | ! WI ( Name ) ; ! => ! 
       @         RETURN "@ WI ( Name ) ; @" ; @
     END (* IF *) ; 
     NodeKinds ( Next ) 
   } ; . 

PROCEDURE WriteHtmlNodes ( t : Tree ) 

Class ( .. ) 
:- { 
     IF ( NoCodeClass * Properties = { } ) 
     THEN
       ! PROCEDURE Write! WI ( Name ) ; !Html ( TNode : ! WI ( Name ) ; ! ) ! 
       ! =VAR LNodeTag : TEXT ; !
       !  BEGIN !
       !    LNodeTag := yyNodeTag ( TNode ) ; !
       @    Wr . PutText ( yyf , "<a name=\"" ) ; @
       !    Wr . PutText ( yyf , LNodeTag ) ; !
       @    Wr . PutText ( yyf , "\">DEF " ) ; @
       !    Wr . PutText ( yyf , LNodeTag ) ; !
       @    Wr . PutText ( yyf , "(" ) ; @
       !    yyWriteHex ( LOOPHOLE ( TNode , ARRAY [ 0 .. 3 ] OF CHAR ) ) ; !
       @    Wr . PutText ( yyf , ")@ WI ( Name ) ; @</a>" ) ; @
       !    yyWriteNl ( ) ; !
       IF ( { HasChildren , HasAttributes } * Properties # { } ) 
       THEN 
         ForallAttributes ( t , WriteHtmlNodes ) ; 
       END (* IF *) ; 
       !    yyWriteNl ( ) ; !
       !  END Write! WI ( Name ) ; !Html ; !
       !!
     END (* IF *) ; 
   } ; . 

Child ( .. ) 
:- { @    WriteChildOrLink ( "@ WI ( Name ) ; @" , "@ WI ( Type ) ; 
     @" , TNode . @ WI ( Name ) ; @ ) ; @
   } ; . 

Attribute ( .. ) 
:- { IF (NoCodeAttr * Properties) = {} 
     THEN 
       IF Link IN Properties 
       THEN 
         @    WriteChildOrLink ( "@ WI ( Name ) ; @" , "@ WI ( Type ) ; 
         @" , TNode . @ WI ( Name ) ; @ , TRUE ) ; @
       ELSIF Type = iBOOLEAN 
       THEN 
         @    WriteBOOLEANAttribute ( "@ WI ( Name ) ; @" , TNode . @ WI ( Name ) ; @ ) ; @
       ELSE
         @    Wr . PutText ( yyf , IndentString & "@ WI ( Name ) ; @ : @ WI ( Type ) ; @ = " ) ; @
         !    write! WI ( Type ) ; ! ( TNode . ! WI ( Name ) ; ! ) !
         (* ^ No semicolon, as the write<type> macro expands to include it *) 
         !    yyWriteNl ( ) ; !
       END (* IF *) ; 
     END (* IF *) ; 
   } ; . 

PROCEDURE WriteHtmlCases ( t : Tree ) 

Class ( .. ) 
:- { WriteHtmlCases ( Extensions ) ; 
     IF ( NoCodeClass * Properties = { } ) 
     THEN
       !     | ! WI ( Name ) ; ! ( TNode ) => !
       !         Write! WI ( Name ) ; !Html ( TNode ) ; !
       IF ( { HasChildren , HasAttributes } * Properties # { } ) 
       THEN 
         GetIterator ( t ) ; 
         ForallAttributes ( t , WriteHtmlCases ) ;  
         IF Iterator = NoTree THEN
           !         EXIT ;!
         ELSE
           !         yyt := TNode . ! WI ( Iterator ^ . Child . Name ) ; ! ; !
         END;
       END (* IF *) 
     END (* IF *) ;  
     WriteHtmlCases ( Next ) ;  
   } ; . 

Child ( .. )  
:- { IF t # Iterator 
     THEN
         !         WriteHtmlRecurse ( TNode . ! WI ( Name ) ; ! ) ;!
     END (* IF *) ; 
   } ; . 

Attribute ( .. )  
:- { IF Link IN Properties  
     THEN
         !         WriteHtmlRecurse ( TNode . ! WI ( Name ) ; ! ) ;!
     END (* IF *) ; 
   } ; . 

(* Ascii reader not generated for M3.  Prefer to use Pickle. to avoid UNSAFE constructs which
   Ascii reader would need. 

PROCEDURE ReadAttributes (t: Tree)

Class (..) :- {
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           !| ! WI (Name); !:!
           GetIterator (t);
           iClassName := Name;
           ForallAttributes (t, ReadAttributes);
           IF Iterator = NoTree THEN
              !RETURN;!
           ELSE
              !yySkip; yyt := SYSTEM.ADR (yyt^^.! WI (iClassName); !.! WI (Iterator^.Child.Name); !);!
           END;
        END;
}; .
Child (..) :- {
        IF t # Iterator THEN
           !yySkip; read! WI (itTree); ! (SYSTEM.ADR (yyt^^.! WI (iClassName); !.! WI (Name); !))!
        END;
}; .
Attribute (..) :- {
        IF (NoCodeAttr * Properties) = {} THEN 
           !yySkip; read! WI (Type); ! (yyt^^.! WI (iClassName); !.! WI (Name); !) yyReadNl;!
        END;
}; .

PROCEDURE InitKindToIdent (t: Tree)

Class (..) :- {
        IF (NoCodeClass * Properties) = {} THEN
           !  yyInitKindToIdent2 ('! WI (Name); !', ! WI (Name); !);!
        END;
}; .

*)


PROCEDURE GetIterator (t: Tree)

Class (..) :- {
        Iterator := NoTree;
        RevChild := NoTree;
        ForallAttributes (t, GetIterator);
        IF RevChild # NoTree THEN Iterator := RevChild; END;
}; .
Child (..) :- {
        Iterator := t;
        IF Reverse IN Properties THEN RevChild := t; END;
}; .


