
(* file MThree2.puma 
   Modula-3 generation of Tree io, etc. 
   Rodney M. Bates Oct 97 
   Extensively modified from file mod2.puma, which had these header comments:  
     (* Ich, Doktor Josef Grosch, Informatiker, 26.1.1989 *)
     (* Modified Rodney M. Bates: 
        RMB Dec 95: Made tree writer reduce the amount of space on the
                    left of deeply indented lines by replacing whole
                    multiples of yyIndentFactor (initially = 20) blanks
                    by a modula-2 style comment containing a count of 
                    the blanks replaced. 

     *) 
*)

TRAFO TreeMThree2
TREE Tree
PUBLIC TreeIO TreeIOInit GetIterator

EXPORT	{
FROM Positions	IMPORT tPosition;

VAR Iterator	: Tree.tTree;

PROCEDURE WriteLine (Line: tPosition);
}

GLOBAL	{


FROM IO         IMPORT WriteS, WriteNl;
FROM Sets	IMPORT IsElement;
FROM Idents	IMPORT tIdent;
FROM Positions	IMPORT tPosition;

FROM Tree	IMPORT
   NoTree	, tTree		, Options	, ClassCount	,
   f		, WI	, WN	, iInteger	, itTree	,
   iNoTree	, iModule	, iMain		, HasChildren	,
   HasAttributes, NoCodeAttr	, NoCodeClass	,
   ForallClassesExtensionsFirst, ForallAttributes, Reverse	;

VAR
   iClassName	: tIdent;
   RevChild	: tTree;

PROCEDURE WriteLine (Line: tPosition);
   BEGIN
      IF Line.Line # 0 THEN
	 !(* line ! WN (Line.Line); @ "@ WI (Line.File); @" *)@
      END;
   END WriteLine;
}

PROCEDURE TreeIO (t: Tree)

Ag (..) :- {
	!!
      IF IsElement (ORD ('w'), Options) 
         OR IsElement (ORD ('o'), Options) THEN
	!VAR yyf	: Wr . T ;!
      END; 
	!VAR yyLabel	: CARDINAL ;!
	!VAR yyKind	: CARDINAL ;!
	!VAR yyc	: CHAR;!
	!!
      IF IsElement (ORD (','), Options) THEN
	!PROCEDURE yyMark  (yyt : ! WI (itTree); ! )!
	!=BEGIN!
	!  LOOP!
	!   IF yyt = ! WI (iNoTree); ! THEN RETURN; END;!
	!   INC ( yyt . yyHead . yyMark ) ;!
	!   IF yyt . yyHead . yyMark > 1 THEN RETURN; END;!
	!!
	!   TYPECASE yyt OF!
        Mark ( Classes ) ; 
	!   ELSE RETURN ;!
	!   END ;!
	!  END ;!
	! END yyMark ;!
	!!
      END;
      IF IsElement (ORD (';'), Options) THEN
        !CONST yyInitTreeStoreSize	= 32 ;!
	!!
        !TYPE yytTreeStore = ARRAY OF ! WI (itTree); ! ;!
        !! 
        !VAR yyTreeStorePtr	: REF yytTreeStore ;!
	!VAR yyLabelCount	: CARDINAL ;!
	!VAR yyRecursionLevel	: CARDINAL ;!
	!!
	!PROCEDURE yyMapToLabel ( yyTree : ! WI (itTree); ! ) : CARDINAL!
	!=VAR yyi	: CARDINAL ;!
        ! VAR LNewTreeStorePtr : REF yytTreeStore ;!
	! BEGIN!
	!  FOR yyi := 0 TO yyLabelCount - 1 DO!
	!   IF yyTreeStorePtr ^ [ yyi ] = yyTree THEN RETURN yyi ; END ;!
	!  END ;!
	!  IF yyLabelCount = NUMBER ( yyTreeStorePtr ^ ) THEN!
        !     LNewTreeStorePtr := NEW ( yytTreeStore , NUMBER ( yyTreeStorePtr ^ ) * 2 ) ;!  
        !     SUBARRAY ( LNewTreeStorePtr ^ , 0 , NUMBER ( yyTreeStorePtr ^ ) ) := yyTreeStorePtr ^ ; ! 
        !     yyTreeStorePtr := LNewTreeStorePtr ; !
	!  END;!
        !  yyi := yyLabelCount ;! 
	!  yyTreeStorePtr ^ [ yyi ] := yyTree ;!
	!  INC ( yyLabelCount ) ;!
	!  RETURN yyi ;!
	! END yyMapToLabel;!
	!!
	!PROCEDURE yyMapToTree ( yyLabel : SHORTCARD ) : ! WI (itTree); !!
	!=BEGIN RETURN yyTreeStorePtr ^ [ yyLabel ] ; END yyMapToTree ;!
	!!
      END;
      IF IsElement (ORD ('w'), Options) OR
	 IsElement (ORD ('o'), Options) THEN
	!PROCEDURE yyWriteNl ( ) = BEGIN Wr . PutText ( yyf , Wr . EOL ) ; END yyWriteNl ;!
	!!
	!PROCEDURE yyWriteSelector ( yys : TEXT ) !
	!=BEGIN Wr . PutText  ( yyf , yys ) ; !
        @   Wr . PutText ( yyf , Fmt . Pad ( "" , 16 - Text . Length ( yys ) ) ) ;@
        @   Wr . PutText (yyf, " = " ) ;@
        ! END yyWriteSelector ;!
	!!
	!PROCEDURE yyWriteHex ( VAR yyx : ARRAY OF CHAR ) !
	!=VAR yyi	: INTEGER ;!
	! BEGIN!
	!  FOR yyi := 0 TO NUMBER ( yyx ) - 1 DO!
	!   Wr . PutText ( yyf , Fmt . Pad ( Fmt . Int ( ORD ( yyx [ yyi ] ) , 16 ) , 2 , '0' ) ) ;!
	!   Wr . PutChar ( yyf, ' ' ) ;!
	!  END ;!
	! END yyWriteHex ;!
	!!
      END;
      IF IsElement (ORD ('o'), Options) THEN
	!PROCEDURE yyWriteAdr ( yyt : ! WI (itTree); ! )!
	!=BEGIN!
	!  IF yyt = ! WI (iNoTree); ! THEN!
	@   Wr . PutText ( yyf , "@ WI (iNoTree); @" ) ;@
	!  ELSE!
	!   yyWriteHex ( LOOPHOLE ( yyt , ARRAY [ 0 .. 3 ] OF CHAR ) ) ;!
(* ^Revisit this. *) 
	!  END ;!
	!  yyWriteNl ( ) ;!
	! END yyWriteAdr;!
	!!
	ForallClassesExtensionsFirst (Classes, WriteNode);
	!PROCEDURE Write! WI (iModule); !Node ( f : Wr . T ; Tree : ! WI (itTree); ! ) !
	!=BEGIN!
	!  yyf := f ;!
	!  IF Tree = ! WI (iNoTree); ! THEN!
	@   Wr . PutText ( yyf , "@ WI (iNoTree); @" ) ; yyWriteNl ( ) ; RETURN ;@
	!  END ;!
	!!
	!  TYPECASE Tree OF!
	WriteNodeName ( Classes ) ;
	!  ELSE!
	!  END ;!
	! END Write! WI (iModule); !Node ;!
	!!
      END;
      IF IsElement (ORD ('w'), Options) THEN
	!VAR yyIndentLevel	: INTEGER ;!
	!VAR yyActualIndent , yyIndentQuotient , yyIndentRemainder : INTEGER ;!
        !CONST yyIndentFactor = 20 ; ! 
        !!
        !PROCEDURE yySetIndentInfo ( ) !
        ! =BEGIN !
        !   yyIndentQuotient := yyIndentLevel DIV yyIndentFactor ; ! 
        !   yyIndentRemainder := yyIndentLevel MOD yyIndentFactor ; !
        !   yyActualIndent ! 
        !     := 10 * ORD ( yyIndentQuotient > 0 ) ! 
        !        + yyIndentRemainder !
        !  END yySetIndentInfo ; !
	!!
	!PROCEDURE Write! WI (iModule); ! ( f : Wr . T ; Tree : ! WI (itTree); ! ) !
	!=VAR yySaveLevel : INTEGER ;!
	! BEGIN!
	!  yyf := f ;!
	!  IF yyRecursionLevel = 0 THEN yyLabelCount := 0 END ;!
	!  INC ( yyRecursionLevel ) ;!
	!  yyMark ( Tree ) ;!
	!  yySaveLevel := yyIndentLevel ;!
	!  yyIndentLevel := 0 ;!
        !  yySetIndentInfo ( ) ; ! 
	!  yyWrite! WI (iModule); ! ( Tree );!
	!  yyIndentLevel := yySaveLevel ;!
        !  yySetIndentInfo ( ) ; ! 
	!  DEC ( yyRecursionLevel ) ;!
	! END Write! WI (iModule); ! ;!
	!!
	!PROCEDURE yyIndentSelector ( yys : TEXT )!
	!=BEGIN ! 
        !   IF yyIndentQuotient > 0 ! 
        !   THEN Wr . PutChar ( yyf , '(' ) ; Wr . PutChar ( yyf , '*' ) ;!
        !     Wr . PutText ( yyf , Fmt . Pad ( yyIndentQuotient * yyIndentFactor , 6 ) ) ; !
        !     Wr . PutChar ( yyf , '*' ) ; Wr . PutChar ( yyf , ')' ) ;!
        @     Wr . PutText ( yyf , Fmt . Pad ( "" , yyIndentRemainder ) ) ;@
        @   ELSE Wr . PutText ( yyf , Fmt . Pad ( "" , yyIndentRemainder ) ) ;@
        !   END ; ! 
        !   yyWriteSelector ( yys ) ; !
        ! END yyIndentSelector ;!
	!!
	!PROCEDURE yyIndentSelectorTree ( yys : TEXT ; yyt : ! WI (itTree); ! )!
	!=BEGIN yyIndentSelector  ( yys ) ; write! WI (itTree); ! (yyt) END yyIndentSelectorTree ;!
	!!
	ForallClassesExtensionsFirst (Classes, WriteAttributes);
	!PROCEDURE yyWrite! WI (iModule); ! ( yyt : ! WI (itTree); ! )!
	!=VAR yyLevel : CARDINAL ;!
	! BEGIN!
	!  yyLevel := yyIndentLevel ;!
	!  LOOP!
	!   IF yyt = ! WI (iNoTree); ! THEN!
	@    Wr . PutText ( yyf , " @ WI (iNoTree); @" ) ; yyWriteNl ( ) ; EXIT ; @
	!   ELSIF yyt . yyHead . yyMark = 0 THEN!
	!    Wr . PutChar ( yyf, '^') ;!
        !    Wr . PutText  ( yyf , yyMapToLabel ( yyt ) ) ; yyWriteNl ( ) ; EXIT ;!
	!   ELSIF yyt . yyHead . yyMark > 1 THEN!
	!    yyWriteNl ( ) ;!
        !    Wr . PutText ( yyf , Fmt . Pad ( yyMapToLabel ( yyt ) , 6 ) ) ;!
        !    Wr . PutChar ( yyf , ':') ;!
	@    Wr . PutText ( yyf , Fmt . Pad ( "" , yyActualIndent - 7 ) ) ;@
	!   ELSE!
	!    Wr . PutChar ( yyf , ' ' ) ;!
	!   END ;!
	!   yyt . yyHead . yyMark := 0 ;!
	!   INC ( yyIndentLevel , 2 ) ;!
        !   yySetIndentInfo ( ) ; ! 
	!!
	!   TYPECASE yyt OF!
	WriteClassName ( Classes );
	!   ELSE EXIT ;!
	!   END ;!
	!  END ;!
	!  yyIndentLevel := yyLevel ;!
        !  yySetIndentInfo ( ) ; ! 
	! END yyWrite! WI (iModule); ! ;!
	!!
      END;
(* Ascii reader not generated for M3.  Prefer to use pkl. to avoid UNSAFE constructs which
   Ascii reader would need. 
      IF IsElement (ORD ('r'), Options) THEN 
	!PROCEDURE Read! WI (iModule); !        (f: Rd.T): ! WI (itTree); !;!
	! VAR yyt	: ! WI (itTree); !;!
	! BEGIN!
	!  yyf := f;!
	!  IF yyRecursionLevel = 0 THEN yyLabelCount := 0; END;!
	!  INC (yyRecursionLevel);!
	!  IF NOT yyIsInitialized THEN!
	!   yyInitKindToIdent; yyIsInitialized := TRUE;!
	!  END;!
	!  yyRead! WI (iModule); ! (SYSTEM.ADR (yyt));!
	!  DEC (yyRecursionLevel);!
	!  RETURN yyt;!
	! END Read! WI (iModule); !;!
	!!
	!PROCEDURE yyRead! WI (iModule); ! (yyt: yyPtrtTree);!
	! BEGIN!
	!  LOOP!
	!   CASE IO.ReadC (yyf) OF!
	!   | '^': yyLabel := IO.ReadI (yyf); yyReadNl; yyt^ := yyMapToTree (yyLabel); RETURN;!
	!   | 12C, '0': yyLabel := IO.ReadI (yyf); yyc := IO.ReadC (yyf);!
	!    Layout.SkipSpaces (yyf); Strings.ReadL (yyf, yys);!
	!    yyKind := yyMapToKind (yys); yyt^ := Make! WI (iMain); ! (yyKind);!
	@    IF yyLabel # yyMapToLabel (yyt^) THEN Wr . PutText ( Stdio . stderr , "@ WI (iModule); @: error in Read@ 
	WI (iModule); @" ) ; Wr . PutText ( Stdio . stderr , Wr . EOL ) ; yyExit ; END ;@
	!   ELSE!
	!    Layout.SkipSpaces (yyf); Strings.ReadL (yyf, yys);!
	!    yyKind := yyMapToKind (yys);!
	!    IF yyKind = 0 THEN yyt^ := ! WI (iNoTree); !; RETURN; END;!
	!    yyt^ := Make! WI (iMain); ! (yyKind);!
	!   END;!
	!!
	!   CASE yyKind OF!
	ForallClasses (Classes, ReadAttributes);
	!   ELSE RETURN;!
	!   END;!
	!  END;!
	! END yyRead! WI (iModule); !;!
	!!
	!VAR yyKindToIdent	: ARRAY [0 .. ! WN (ClassCount); !] OF Idents.tIdent;!
	!VAR yyIsInitialized	: BOOLEAN;!
	!!
	!PROCEDURE yyMapToKind (VAR yys: Strings.tString): CARDINAL;!
	! VAR yyi	: Idents.tIdent;!
	! VAR yyk	: CARDINAL;!
	! BEGIN!
	!  yyi := Idents.MakeIdent (yys);!
	!  FOR yyk := 0 TO ! WN (ClassCount); ! DO!
	!   IF yyKindToIdent [yyk] = yyi THEN RETURN yyk; END;!
	!  END;!
	!  RETURN 0;!
	! END yyMapToKind;!
	!!
	!PROCEDURE yyInitKindToIdent2 (yya: ARRAY OF CHAR; yyKind: CARDINAL);!
	! VAR yys	: Strings.tString;!
	! BEGIN!
	!  Strings.ArrayToString (yya, yys);!
	!  yyKindToIdent [yyKind] := Idents.MakeIdent (yys);!
	! END yyInitKindToIdent2;!
	!!
	!PROCEDURE yyInitKindToIdent;!
	! BEGIN!
	!  yyInitKindToIdent2 ('! WI (iNoTree); !', 0);!
	ForallClasses (Classes, InitKindToIdent);
	! END yyInitKindToIdent;!
	!!
	!PROCEDURE yyReadNl; BEGIN IO.ReadNl (yyf); END yyReadNl;!
	!!
	!PROCEDURE yyReadIdent (): Idents.tIdent;!
	! VAR yys	: Strings.tString;!
	! BEGIN!
	!  Strings.ReadL (yyf, yys);!
	!  IO.UnRead (yyf);!
	!  RETURN Idents.MakeIdent (yys);!
	! END yyReadIdent;!
	!!
	!PROCEDURE yyReadHex (VAR yyx: ARRAY OF SYSTEM.BYTE);!
	! VAR yyi	: INTEGER;!
	! BEGIN!
	!  FOR yyi := 0 TO INTEGER (HIGH (yyx)) DO!
	!   yyx [yyi] := SYSTEM.BYTE (CHR (CARDINAL (IO.ReadN (yyf, 16))));!
	!  END;!
	! END yyReadHex;!
	!!
	!PROCEDURE yySkip;!
	! BEGIN!
	!  REPEAT UNTIL IO.ReadC (yyf) = '='; yyc := IO.ReadC (yyf);!
	! END yySkip;!
	!!
      END;
*) 
      IF IsElement (ORD ('p'), Options) 
         OR IsElement (ORD ('g'), Options) THEN
        !PROCEDURE WriteAtom ( r : REFANY ) : TEXT!
        != BEGIN!
        !    RETURN Atom . ToText ( r ) ;! 
        !  END WriteAtom ;!
        !!
        !PROCEDURE ReadAtom ( READONLY Bytes : ARRAY OF CHAR ) : REFANY!
        != BEGIN!
        !    RETURN Atom . FromText ( Text . FromChars ( Bytes ) )!
        !  END ReadAtom ;!
        !!
      END; 
      IF IsElement (ORD ('p'), Options) THEN
	!PROCEDURE Put! WI (iModule); ! ( f : Wr . T ; Tree : ! WI (itTree); ! )!
	!=BEGIN!
        !   Pkl . Write ( Tree , f )!
	! END Put! WI (iModule); ! ;!
	!!
      END;
      IF IsElement (ORD ('g'), Options) THEN
	!PROCEDURE Get! WI (iModule); ! ( f : Rd . T ) : ! WI (itTree); 
	!= BEGIN!
        !    RETURN NARROW ( Pkl . Read ( f ) , ! WI ( itTree ) ; ! )!
        !  END Get! WI (iModule); ! ;!
	!!
      END;
}; .


PROCEDURE TreeIOInit (t: Tree)

Ag (..) :- {
      IF IsElement (ORD ('p'), Options) 
         OR IsElement (ORD ('g'), Options) THEN
        !Pkl . RegisterBytes ( TYPECODE ( Atom . T ) , WriteAtom , ReadAtom ) ;!
      END; 
}; .


PROCEDURE WriteNodeName (t: Tree)

Class (..) :- {
        WriteNodeName ( Extensions ) ; 
	IF (NoCodeClass * Properties) = {} THEN
	   !   | ! WI (Name); ! ( TNode ) =>!
           @        Wr . PutText ( yyf , "@ WI (Name); @" ) ; yyWriteNl ( ) ;@ 
	   IF ({HasChildren, HasAttributes} * Properties) # {} THEN
	     !        yWriteNode! WI (Name); ! ( TNode ) ;! 
	   END;
	   !!
	END;
        WriteNodeName ( Next ) ; 
}; .


PROCEDURE WriteNode (t: Tree)

Class (..) :- {
	IF ((NoCodeClass * Properties) = {}) AND
	   (({HasChildren, HasAttributes} * Properties) # {}) THEN
	   !PROCEDURE yWriteNode! WI (Name); ! ( yyt : ! WI ( Name ); ! )!
	   !=BEGIN!
	   IF (BaseClass^.Kind = Tree.Class) AND		(* NOT Top ? *)
	      (({HasChildren, HasAttributes} * BaseClass^.Class.Properties) # {}) THEN
	   !  yWriteNode! WI (BaseClass^.Class.Name); ! (yyt); !
	   END;
	   iClassName := Name;
	   ForallAttributes (Attributes, WriteNode);
	   ! END yWriteNode! WI (Name); !;!
	   !!
	END;
}; .
Child (..) :- {
	@  yyWriteSelector ( "@ WI (Name); @" ) ;@ 
	! yyWriteAdr ( yyt . ! WI (Name); ! ) ;!
}; .
Attribute (..) :- {
	IF (NoCodeAttr * Properties) = {} THEN 
	   @  yyWriteSelector ( "@ WI (Name); @" ) ; write@ WI (Type);
	   ! ( yyt . ! WI (Name) ; ! ) yyWriteNl ( ) ;!
	END;
}; .


PROCEDURE Mark (t: Tree)

Class (..) :- {
        Mark ( Extensions ) ; 
	IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
	   !    | ! WI (Name); ! ( TNode ) => !
	   GetIterator (t);
	   iClassName := Name;
	   ForallAttributes (t, Mark);
	   IF Iterator = NoTree THEN
	      !RETURN ;!
	   ELSE
	      !yyt := TNode . ! WI (Iterator^.Child.Name); ! ;!
	   END;
	END;
        Mark ( Next ) ; 
}; .
Child (..) :- {
	IF t # Iterator THEN
	   !yyMark (yyt . ! WI (iClassName); ! . ! WI (Name); !);!
	END;
}; .


PROCEDURE WriteClassName (t: Tree)

Class (..) :- {
        WriteClassName ( Extensions ) ; 
	IF (NoCodeClass * Properties) = {} THEN
	   !   | ! WI (Name); ! ( TNode ) => ! 
	   IF ({HasChildren, HasAttributes} * Properties) # {} THEN
	      !       yWrite! WI (Name); ! ( TNode ) ; ! 
	      GetIterator (t);
	      IF Iterator = NoTree THEN
	        !       EXIT ;!
	      ELSE
		 @       yyIndentSelector ( "@ WI (Iterator^.Child.Name); @" ) ;@ 
		 !       yyt := TNode . ! WI (Iterator^.Child.Name); ! ;!
	      END ;
	   ELSE
	      @       Wr . PutText ( yyf , "@ WI (Name); @" ) ; yyWriteNl ( ) ; EXIT ;@
	   END;
	END;
        WriteClassName ( Next ) ; 
}; .


PROCEDURE WriteAttributes (t: Tree)

Class (..) :- {
        WriteAttributes ( Extensions ) ; 
	IF ((NoCodeClass * Properties) = {}) AND
	   (({HasChildren, HasAttributes} * Properties) # {}) THEN
	   !PROCEDURE yWrite! WI (Name); ! ( yyt : ! WI ( Name ); ! )!
	   !=BEGIN!
	   @  Wr . PutText ( yyf , "@ WI (Name); @" ) ; yyWriteNl ( ) ;@
	   GetIterator (t);
	   iClassName := Name;
	   ForallAttributes (t, WriteAttributes);
	   ! END yWrite! WI (Name); ! ;!
	   !!
	END;
        WriteAttributes ( Next ) ; 
}; .
Child (..) :- {
	IF t # Iterator THEN
	   @  yyIndentSelectorTree ( "@ WI (Name); @" , yyt . @ WI (iClassName); @ . @ WI (Name); @ ) ;@
	END;
}; .
Attribute (..) :- {
	IF (NoCodeAttr * Properties) = {} THEN 
	   @  yyIndentSelector ( "@ WI (Name); @" ) ; @ 
	   !write! WI (Type); ! ( yyt . ! WI (Name); ! ) yyWriteNl ( ) ;!
	END;
}; .

(* Ascii reader not generated for M3.  Prefer to use pkl. to avoid UNSAFE constructs which
   Ascii reader would need. 

PROCEDURE ReadAttributes (t: Tree)

Class (..) :- {
	IF ((NoCodeClass * Properties) = {}) AND
	   (({HasChildren, HasAttributes} * Properties) # {}) THEN
	   !| ! WI (Name); !:!
	   GetIterator (t);
	   iClassName := Name;
	   ForallAttributes (t, ReadAttributes);
	   IF Iterator = NoTree THEN
	      !RETURN;!
	   ELSE
	      !yySkip; yyt := SYSTEM.ADR (yyt^^.! WI (iClassName); !.! WI (Iterator^.Child.Name); !);!
	   END;
	END;
}; .
Child (..) :- {
	IF t # Iterator THEN
	   !yySkip; read! WI (itTree); ! (SYSTEM.ADR (yyt^^.! WI (iClassName); !.! WI (Name); !))!
	END;
}; .
Attribute (..) :- {
	IF (NoCodeAttr * Properties) = {} THEN 
	   !yySkip; read! WI (Type); ! (yyt^^.! WI (iClassName); !.! WI (Name); !) yyReadNl;!
	END;
}; .

PROCEDURE InitKindToIdent (t: Tree)

Class (..) :- {
	IF (NoCodeClass * Properties) = {} THEN
	   !  yyInitKindToIdent2 ('! WI (Name); !', ! WI (Name); !);!
	END;
}; .

*)


PROCEDURE GetIterator (t: Tree)

Class (..) :- {
	Iterator := NoTree;
	RevChild := NoTree;
	ForallAttributes (t, GetIterator);
	IF RevChild # NoTree THEN Iterator := RevChild; END;
}; .
Child (..) :- {
	Iterator := t;
	IF Reverse IN Properties THEN RevChild := t; END;
}; .

