
(* file mod0.puma: cg generation of input to rex and lalr. *) 

(* Modified Rodney M. Bates: 
  10-95: Put new line after each record field
         of generated node types, so as to not choke lalr with input
         lines longer that 255 chars.
  11-95: Wrote modified parser generator procedure GrammarDep and its
         subordinate procedures ClassListDep, ChildDep, ActionsDep, 
         which respect attribute dependencies. However, it is not
         clear this is what is wanted, since they can then perform
         semantic actions in an order which violates their placement 
         in the rules.  
         -e option uses the new generation method. 
   9-97: Changed to use IOUtils.WriteBackslash 
  10-97: Removed unused IMPORT of TreeIO
  10-97: Eliminated the record variants in parse and scan attributes for 
         Modula-3 (i.e. flatten the records)
  
*)

TRAFO GramMod
TREE Tree
PUBLIC ParsSpec ScanSpec

GLOBAL {

FROM IO		IMPORT WriteS, WriteNl;
FROM Strings	IMPORT tString, ArrayToString;
FROM StringMem	IMPORT WriteString;
FROM Idents	IMPORT NoIdent, tIdent, MakeIdent;
FROM Texts	IMPORT WriteText;
FROM Sets	IMPORT IsElement, Include;
FROM SYSTEM     IMPORT ADR;
FROM IOUtils    IMPORT WriteBackslash ; 

FROM Tree	IMPORT Left , Right , First , Dummy , 
   NoTree	, tTree		, Input		, Reverse	,
   Class	, NoClass	, Child		, Attribute	,
   ActionPart	, HasSelector	, HasAttributes	, NoCodeAttr	,
   Referenced	, Options	, TreeRoot	, QueryTree	,
   ClassCount	, iNoTree	, itTree	, Generated	,
   f		, WI, WE, WN	, ForallClasses	, ForallAttributes,
   Nonterminal	, Terminal	, IdentifyAttribute,
   String	, iPosition	;

IMPORT Strings;

VAR
   Node, ActClass, TheClass, TheAttr	: tTree;
   iOper, iLeft, iRight, iNone, iPrec, iRule	: tIdent;
   ActActionIndex, PrevActionIndex, i	: SHORTCARD;
   IsImplicit				: BOOLEAN;
   s					: tString;

PROCEDURE GetBaseClass (Class: tTree): tTree;
   BEGIN
      WHILE Class^.Class.BaseClass^.Kind # NoClass DO
	 Class := Class^.Class.BaseClass;
      END;
      RETURN Class;
   END GetBaseClass;

PROCEDURE IsLast (Class, Action: tTree): BOOLEAN;
   VAR Found, Last: BOOLEAN;
   BEGIN
      IsLast2 (Class, Action, Found, Last);
      RETURN Last;
   END IsLast;

PROCEDURE IsLast2 (t, Action: tTree; VAR pFound, pLast: BOOLEAN);
   VAR Found, Last: BOOLEAN;
   BEGIN
      CASE t^.Kind OF
      | Class:
	    IsLast2 (t^.Class.Attributes, Action, pFound, pLast);
	    IF pFound OR NOT pLast THEN RETURN; END;
	    IsLast2 (t^.Class.BaseClass, Action, pFound, pLast);
      | Child:
	    IsLast2 (t^.Child.Next, Action, Found, Last);
	    pFound := Found;
	    IF Found THEN
	       pLast := Last;
	    ELSE
	       pLast := FALSE;
	    END;
      | Attribute:
	    IsLast2 (t^.Attribute.Next, Action, pFound, pLast);
      | ActionPart:
	    IsLast2 (t^.ActionPart.Next, Action, Found, Last);
	    pFound := Found OR (Action = t);
	    IF Found THEN
	       pLast := Last;
	    ELSE
	       pLast := Last AND (Action = t);
	    END;
      ELSE
	    pFound := FALSE;
	    pLast  := TRUE;
      END;
   END IsLast2;
}

BEGIN {
   ArrayToString ("OPER"	, s); iOper	:= MakeIdent (s);
   ArrayToString ("RIGHT"	, s); iRight	:= MakeIdent (s);
   ArrayToString ("LEFT"	, s); iLeft	:= MakeIdent (s);
   ArrayToString ("NONE"	, s); iNone	:= MakeIdent (s);
   ArrayToString ("PREC"	, s); iPrec	:= MakeIdent (s);
   ArrayToString ("RULE"	, s); iRule	:= MakeIdent (s);
}

PROCEDURE ParsSpec (t: Tree)

Ag (..) :- {
	IF ScannerName # NoIdent THEN
	   WriteS (f, "SCANNER "); WI (ScannerName);
	END;
	WriteS (f, " PARSER "); WI (ParserName); WriteNl (f);
	WriteS (f, "GLOBAL {"); WriteNl (f);
	WriteText (f, ParserCodes^.Codes.Global);
	Node := Modules;
	WHILE Node^.Kind = Tree.Module DO
	   WriteText (f, Node^.Module.ParserCodes^.Codes.Global);
	   Node := Node^.Module.Next;
	END;
	WriteS (f, "TYPE"); WriteNl (f);
        ParsVariant (Classes);
	WriteNl (f);
       IF IsElement ( ORD ( 'K' ) , Options ) THEN (* Modula-3 *) 
	WriteS (f, "tParsAttribute = RECORD"); WriteNl (f);
       ELSE
	WriteS (f, "tParsAttribute = RECORD CASE : SHORTCARD OF"); WriteNl (f);
	WriteS (f, "  0: Scan: "); 
       END; 
	IF ScannerName # NoIdent THEN WI (ScannerName); ELSE WriteS (f, "Scanner"); END;
	WriteS (f, ".tScanAttribute;"); WriteNl (f);
	i := 0;
	Node := Classes;
	WHILE Node^.Kind = Class DO
	  WITH Node^.Class DO
	     IF {Nonterminal, Referenced, HasAttributes} <= Properties THEN
	       INC (i);
               IF NOT IsElement ( ORD ( 'K' ) , Options ) THEN (* NOT Modula-3 *) 
	         WriteS (f, "| "); WN (i); WriteS (f, ": "); 
               END ; 
	       IF (String IN Properties) AND NOT (HasSelector IN Properties) THEN
		 WriteS (f, "(* "); WE (Name); WriteS (f, " *) yy"); WN (Name);
		 WriteS (f, ": yy"); WN (Name); WriteS (f, ";"); WriteNl (f);
	       ELSE
		 WI (Selector); WriteS (f, ": yy"); WI (Selector); WriteS (f, ";"); WriteNl (f);
	       END;
	     END;
	     Node := Next;
	  END;
	END;
        IF NOT IsElement ( ORD ( 'K' ) , Options ) THEN (* NOT Modula-3 *) 
	 WriteS (f, " END ;"); WriteNl (f);
        END ; 
	WriteS (f, "END ;"); WriteNl (f);
	WriteS (f, "}"); WriteNl (f);
	WriteNl (f);
	WriteS (f, "EXPORT {"); WriteNl (f);
	WriteText (f, ParserCodes^.Codes.Export);
	Node := Modules;
	WHILE Node^.Kind = Tree.Module DO
	  WriteText (f, Node^.Module.ParserCodes^.Codes.Export);
	  Node := Node^.Module.Next;
	END;
	WriteS (f, "}"); WriteNl (f);
	WriteNl (f);
	WriteS (f, "LOCAL {"); WriteNl (f);
	WriteText (f, ParserCodes^.Codes.Local);
	Node := Modules;
	WHILE Node^.Kind = Tree.Module DO
	  WriteText (f, Node^.Module.ParserCodes^.Codes.Local);
	  Node := Node^.Module.Next;
	END;
	WriteS (f, "}"); WriteNl (f);
	WriteNl (f);
	WriteS (f, "BEGIN {"); WriteNl (f);
	WriteText (f, ParserCodes^.Codes.Begin);
	Node := Modules;
	WHILE Node^.Kind = Tree.Module DO
	  WriteText (f, Node^.Module.ParserCodes^.Codes.Begin);
	  Node := Node^.Module.Next;
	END;
	WriteS (f, "}"); WriteNl (f);
	WriteNl (f);
	WriteS (f, "CLOSE {"); WriteNl (f);
	WriteText (f, ParserCodes^.Codes.Close);
	Node := Modules;
	WHILE Node^.Kind = Tree.Module DO
	  WriteText (f, Node^.Module.ParserCodes^.Codes.Close);
	  Node := Node^.Module.Next;
	END;
	WriteS (f, "}"); WriteNl (f);
	WriteNl (f);
	WriteS (f, "TOKEN"); WriteNl (f);
	WriteNl (f);
	ForallClasses (Classes, Token);
	WriteNl (f);
	WriteS (f, "OPER"); WriteNl (f);
	WriteNl (f);
	PrecDefs (Precs);
	WriteNl (f);
	WriteS (f, "RULE"); WriteNl (f);
	WriteNl (f);
	ForallClasses (Classes, ParsSpec);
}; .
Class (..) :- {
	IF {Nonterminal, Referenced} <= Properties THEN
	   TheClass := t;
           IF IsElement ( ORD ( 'e' ) , Options )
           THEN
	     GrammarDep (t)
           ELSE
	     Grammar (t)
           END 
	END;
}; .


PROCEDURE ScanSpec (t: Tree)

Ag (..) :- {
	WriteS (f, "m"); WriteNl (f);
	WriteS (f, "TYPE"); WriteNl (f);
	ForallClasses (Classes, ScanVariant);
	WriteNl (f);
	WriteS (f, "tScanAttribute = RECORD"); WriteNl (f);
	WriteS (f, "Position: tPosition;"); WriteNl (f);
        IF IsElement ( ORD ( 'K' ) , Options ) THEN (* Modula-3 *) 
	 ForallClasses (Classes, ScanAttr);
        ELSE 
         WriteS (f, "CASE : SHORTCARD OF"); WriteNl (f);
	 ForallClasses (Classes, ScanAttr);
	 WriteS (f, " END ;"); WriteNl (f);
        END ; 
	WriteS (f, "END ;"); WriteNl (f);
	WriteNl (f);
	WriteS (f, "PROCEDURE ErrorAttribute (Token: INTEGER; VAR pAttribute: tScanAttribute);"); WriteNl (f);
	WriteS (f, "%%"); WriteNl (f);
	WriteS (f, "PROCEDURE ErrorAttribute (Token: INTEGER; VAR pAttribute: tScanAttribute);"); WriteNl (f);
	WriteS (f, "BEGIN"); WriteNl (f);
	WriteS (f, " pAttribute.Position := Attribute.Position;"); WriteNl (f);
	WriteS (f, " CASE Token OF"); WriteNl (f);
	ForallClasses (Classes, ErrorActions);
	WriteS (f, " ELSE"); WriteNl (f);
	WriteS (f, " END;"); WriteNl (f);
	WriteS (f, "END ErrorAttribute;"); WriteNl (f);
	WriteS (f, "%%"); WriteNl (f);
	ForallClasses (Classes, ScanSpec);
}; .
Class (..) :- {
	IF {Terminal, Referenced} <= Properties THEN
	   WN (Code);
	   IF HasAttributes IN Properties THEN	WriteS (f, " S "); 
	   ELSE					WriteS (f, " N "); 
	   END;
	   IF (String IN Properties) AND NOT (HasSelector IN Properties) THEN
	      WriteS (f, "yy"); WN (Code);
	   ELSE
	      WI (Selector);
	   END;
	   WriteS (f, " "); WI (Name); WriteNl (f);
	END;
}; .


PROCEDURE ErrorActions (t: Tree)

Class (..) :- {
	IF {Terminal, Referenced, HasAttributes} <= Properties THEN
	  WriteS (f, " | (* "); WE (Name); WriteS (f, " *) "); WN (Code); WriteS (f, ": "); WriteNl (f);
	  TheClass := t;
	  ForallAttributes (t, ErrorActions);
	END;
}; .
ActionPart (..) :- {
	ErrorActions (Actions);
}; .
Assign (..) :- {
	ErrorActions (Results); WriteS (f, ":="); ErrorActions (Arguments); WriteS (f, ";"); WriteNl (f);
	ErrorActions (Next);
}; .
Copy (..) :- {
	ErrorActions (Results); WriteS (f, " := "); ErrorActions (Arguments); WriteS (f, ";"); WriteNl (f);
	ErrorActions (Next);
}; .
TargetCode (..) :- {
	ErrorActions (Code); WriteS (f, ";"); WriteNl (f);
	ErrorActions (Next);
}; .
Order (..) :- {
	ErrorActions (Next);
}; .
Check (..) :- {
	IF Statement # NoTree THEN
	   IF Condition # NoTree THEN
	      WriteS (f, "IF NOT ("); ErrorActions (Condition); WriteS (f, ") THEN "); ErrorActions (Statement); WriteS (f, "; END;"); WriteNl (f);
	   ELSE
	      ErrorActions (Statement); WriteS (f, ";"); WriteNl (f);
	   END;
	ELSE
	   WriteS (f, "IF "); ErrorActions (Condition); WriteS (f, " THEN END;"); WriteNl (f);
	END;
	ErrorActions (Next);
}; .
Designator (..) :- {
	WI (Selector); WriteS (f, ":"); WI (Attribute);
	ErrorActions (Next);
}; .
Ident (..) :- {
	TheAttr := IdentifyAttribute (TheClass, Attribute);
	IF TheAttr # NoTree THEN
	   WriteS (f, "pAttribute"); 
	   IF Attribute = iPosition THEN
           ELSIF (String IN TheClass^.Class.Properties) AND NOT (HasSelector IN TheClass^.Class.Properties) THEN
	      WriteS (f, ".yy"); WN (TheClass^.Class.Code);
	   ELSE
	      WriteS (f, "."); WI (TheClass^.Class.Selector);
	   END;
	   WriteS (f, "."); 
	END;
	WI (Attribute);
	ErrorActions (Next);
}; .
Any (..) :- {
	WriteString (f, Code);
	ErrorActions (Next);
}; .
Anys (..) :- {
	ErrorActions (Layouts);
	ErrorActions (Next);
}; .
LayoutAny (..) :- {
	WriteString (f, Code);
	ErrorActions (Next);
}; .


PROCEDURE ScanVariant (t: Tree)

Class (..) :- {
	IF {Terminal, Referenced, HasAttributes} <= Properties THEN
          IF (String IN Properties) AND NOT (HasSelector IN Properties) THEN
	    WriteS (f, "(* "); WE (Name); WriteS (f, " *) yy"); WN (Code); WriteS (f, " = RECORD "); 
	  ELSE
	    WriteS (f, "yy"); WI (Selector); WriteS (f, " = RECORD "); 
	  END;
	  TheClass := t;
	  ForallAttributes (t, RecordField);
	  WriteS (f, "END;"); WriteNl (f);
	END;
}; .


PROCEDURE ScanAttr (t: Tree)

Class (..) :- {
	IF {Terminal, Referenced, HasAttributes} <= Properties THEN
          IF NOT IsElement ( ORD ( 'K' ) , Options ) THEN (* NOT Modula-3 *) 
	   WriteS (f, "| "); WN (Code); WriteS (f, ": "); 
          END ; 
          IF (String IN Properties) AND NOT (HasSelector IN Properties) THEN
	    WriteS (f, "(* "); WE (Name); WriteS (f, " *) yy"); WN (Code); WriteS (f, ": yy"); WN (Code); WriteS (f, ";"); WriteNl (f);
	  ELSE
	    WI (Selector); WriteS (f, ": yy"); WI (Selector); WriteS (f, ";"); WriteNl (f);
	  END;
	END;
}; .


PROCEDURE ParsVariant (t: Tree)

Class (..) :- {
	IF {Nonterminal, Referenced, HasAttributes} <= Properties THEN
          IF (String IN Properties) AND NOT (HasSelector IN Properties) THEN
	    WriteS (f, "(* "); WE (Name); WriteS (f, " *) yy"); WN (Name); WriteS (f, " = RECORD "); 
	  ELSE
	    WriteS (f, "yy"); WI (Selector); WriteS (f, " = RECORD "); 
	  END;
	  TheClass := t;
	  GenExt (Extensions);
	  ForallAttributes (Attributes, RecordField);
	  WriteS (f, "END;"); WriteNl (f);
	END;
	ParsVariant (Next);
}; .


PROCEDURE GenExt (t: Tree)

Class (..) :- {
	ForallAttributes (Attributes, RecordField);
	GenExt (Extensions);
	GenExt (Next);
}; .


PROCEDURE Token (t: Tree)

Class (..) :- {
	IF {Terminal, Referenced} <= Properties THEN
	   WriteName (Name); WriteS (f, " = "); WN (Code); WriteNl (f);
	END;
}; .


PROCEDURE RecordField	/* TheClass	*/ (t: Tree)

Attribute (..) :- {
	IF (NoCodeAttr * Properties) = {} THEN 
	   IF (Nonterminal IN TheClass^.Class.Properties) OR (Name # iPosition) THEN
	      WI (Name); WriteS (f, ": "); WI (Type); WriteS (f, "; "); WriteNl (f);
	   END;
	END;
}; .


PROCEDURE PrecDefs (t: Tree)

LeftAssoc (..) :- {
	WriteS (f, "LEFT "); PrecDefs (Names); WriteNl (f);
	PrecDefs (Next);
}; .
RightAssoc (..) :- {
	WriteS (f, "RIGHT"); PrecDefs (Names); WriteNl (f);
	PrecDefs (Next);
}; .
NonAssoc (..) :- {
	WriteS (f, "NONE "); PrecDefs (Names); WriteNl (f);
	PrecDefs (Next);
}; .
Name (..) :- {
	WriteS (f, " "); WI (Name);
	PrecDefs (Next);
}; .


/* Original Grammar, Rule, Implicit: */

PROCEDURE Grammar (t: Tree)

Class (..) :- {
	IF Extensions^.Kind = Tree.NoClass THEN		(* Low ? *)
	   WITH TheClass^.Class DO
	      IF String IN Properties THEN WriteS (f, "yy"); WN (Name); ELSE WriteName (Name); END;
	   END;
	   WriteS (f, " : "); 
	   ActClass := t;
	   PrevActionIndex := 0;
	   IsImplicit := FALSE;
	   ForallAttributes (t, Rule);
	   IF Prec # NoIdent THEN WriteS (f, "PREC "); WI (Prec); WriteS (f, " "); END;
	   WriteS (f, "."); WriteNl (f);
	   PrevActionIndex := 0;
	   IsImplicit := TRUE;
	   ForallAttributes (t, Implicit);
	ELSE
	   Rule (Extensions);
	END;
}; .


PROCEDURE Rule (t: Tree)

Class (..) :- {
	Grammar (t);
	Rule (Next);
}; .
Child (..) :- {
	IF {String, Nonterminal} <= Class^.Class.Properties THEN WriteS (f, "yy"); WN (Type); ELSE WriteName (Type); END; WriteS (f, " "); 
}; .
ActionPart (..) :- {
	IF IsLast (ActClass, t) THEN
	   WriteS (f, "{"); 
	   IF PrevActionIndex # 0 THEN
	      Node := GetBaseClass (TheClass);
	      WITH Node^.Class DO
		 IF HasAttributes IN Properties THEN
		    WriteS (f, " $$."); 
		    IF String IN Properties THEN WriteS (f, "yy"); WN (Name); ELSE WI (Name); END;
		    WriteS (f, " := $"); WN (PrevActionIndex); WriteS (f, "."); 
		    IF String IN Properties THEN WriteS (f, "yy"); WN (Name); ELSE WI (Name); END;
		    WriteS (f, ";"); WriteNl (f);
		 END;
	      END;
	   END;
	   Rule (Actions);
	   WriteS (f, "} "); 
	ELSE
	   WriteS (f, "xx"); WN (Name); WriteS (f, " "); 
	END;
	PrevActionIndex := ParsIndex;
}; .
Assign (..) :- {
	Rule (Results); WriteS (f, ":="); Rule (Arguments); WriteS (f, ";"); WriteNl (f);
	Rule (Next);
}; .
Copy (..) :- {
	Rule (Results); WriteS (f, " := "); Rule (Arguments); WriteS (f, ";"); WriteNl (f);
	Rule (Next);
}; .
TargetCode (..) :- {
	Rule (Code); WriteS (f, ";"); WriteNl (f);
	Rule (Next);
}; .
Order (..) :- {
	Rule (Next);
}; .
Check (..) :- {
	IF Statement # NoTree THEN
	   IF Condition # NoTree THEN
	      WriteS (f, "IF NOT ("); Rule (Condition); WriteS (f, ") THEN "); Rule (Statement); WriteS (f, "; END;"); WriteNl (f);
	   ELSE
	      Rule (Statement); WriteS (f, ";"); WriteNl (f);
	   END;
	ELSE
	   WriteS (f, "IF "); Rule (Condition); WriteS (f, " THEN END;"); WriteNl (f);
	END;
	Rule (Next);
}; .
Designator (..) :- {
	TheAttr := IdentifyAttribute (ActClass, Selector);
	IF TheAttr # NoTree THEN
	  Node := TheAttr^.Child.Class;
	  IF Node # NoTree THEN
	    WriteS (f, "$"); 
	    IF NOT IsImplicit THEN
	       WN (TheAttr^.Child.ParsIndex);
	    ELSE
	       WN (SHORTINT (TheAttr^.Child.ParsIndex + 1 - ActActionIndex));
	    END;
	    IF Nonterminal IN Node^.Class.Properties THEN	(* nonterminal *)
	      Node := GetBaseClass (Node);
	      IF (String IN Node^.Class.Properties) AND NOT (HasSelector IN Node^.Class.Properties) THEN
	        WriteS (f, ".yy"); WN (Node^.Class.Name);
	      ELSE
	        WriteS (f, "."); WI (Node^.Class.Name);
	      END;
	    ELSE						(* terminal *)
	      WriteS (f, ".Scan"); 
	      IF Attribute = iPosition THEN
	      ELSIF (String IN Node^.Class.Properties) AND NOT (HasSelector IN Node^.Class.Properties) THEN
	        WriteS (f, ".yy"); WN (Node^.Class.Code);
	      ELSE
	        WriteS (f, "."); WI (Node^.Class.Selector);
	      END;
	    END;
	    WriteS (f, "."); WI (Attribute);
	  ELSE
	    WI (Selector); WriteS (f, ":"); WI (Attribute);
	  END;
	ELSE
	  WI (Selector); WriteS (f, ":"); WI (Attribute);
	END;
	Rule (Next);
}; .
Ident (..) :- {
	TheAttr := IdentifyAttribute (ActClass, Attribute);
	Node := GetBaseClass (TheClass);
	IF TheAttr # NoTree THEN
	  IF (String IN Node^.Class.Properties) AND NOT (HasSelector IN Node^.Class.Properties) THEN
	    WriteS (f, "$$.yy"); WN (Node^.Class.Name); WriteS (f, "."); WI (Attribute);
	  ELSE
	    WriteS (f, "$$."); WI (Node^.Class.Name); WriteS (f, "."); WI (Attribute);
	  END;
	ELSE
	  WI (Attribute);
	END;
	Rule (Next);
}; .
Any (..) :- {
	WriteString (f, Code);
	Rule (Next);
}; .
Anys (..) :- {
	Rule (Layouts);
	Rule (Next);
}; .
LayoutAny (..) :- {
	WriteString (f, Code);
	Rule (Next);
}; .


PROCEDURE Implicit (t: Tree)

ActionPart (..) :- {
	IF NOT (Generated IN Properties) AND NOT IsLast (ActClass, t) THEN
	   INCL (Properties, Generated);
	   ActActionIndex := ParsIndex;
	   WriteS (f, "xx"); WN (Name); WriteS (f, " : {"); 
	   IF PrevActionIndex # 0 THEN
	      Node := GetBaseClass (TheClass);
	      WITH Node^.Class DO
		 IF HasAttributes IN Properties THEN
		    WriteS (f, " $$."); 
		    IF String IN Properties THEN WriteS (f, "yy"); WN (Name); ELSE WI (Name); END;
		    WriteS (f, " := $"); WN (SHORTINT (PrevActionIndex + 1 - ActActionIndex)); WriteS (f, "."); 
		    IF String IN Properties THEN WriteS (f, "yy"); WN (Name); ELSE WI (Name); END;
		    WriteS (f, ";"); WriteNl (f);
		 END;
	      END;
	   END;
	   Rule (Actions);
	   WriteS (f, "} ."); WriteNl (f);
	END;
	PrevActionIndex := ParsIndex;
}; .

/* New GrammarDep, ClassListDep, ChildDep, ActionsDep: */

PROCEDURE ClassListDep (t: Tree)

Class (..) :- {
	GrammarDep (t);
	ClassListDep (Next);
}; .

PROCEDURE GrammarDep (t: Tree)

LOCAL { VAR i : SHORTCARD ; VAR BracesGenerated : BOOLEAN ; } 

Class (..) :- {
	IF Extensions^.Kind = Tree.NoClass THEN		(* Low ? *)
	   WITH TheClass^.Class DO
	      IF String IN Properties 
              THEN WriteS (f, "yy"); WN (Name); ELSE WriteName (Name); END;
	   END;
	   WriteS (f, " : "); 
	   ForallAttributes (t, ChildDep);
           WriteNl (f);
           BracesGenerated := FALSE ; 
           FOR i := 1 TO InstCount
           DO
             WITH Instance ^ [ Instance ^ [ i ] . Order ] 
             DO
               IF ( { Left , First } <= Properties )
                  AND NOT ( Dummy IN Properties ) 
                  AND ( Action <> ADR ( Action ) ) 
               THEN
                 ActClass := t ; 
                 IF BracesGenerated
                 THEN 
                   WriteS (f, "   "); 
                 ELSE  
                   WriteS (f, " { "); 
                   BracesGenerated := TRUE ; 
                 END ; 
                 ActionsDep ( Action ) ; 
                 WriteNl (f);
               END 
             END
           END ; 
           IF BracesGenerated
           THEN
             WriteS (f, " } "); WriteNl (f);
           END ; 
	   IF Prec # NoIdent THEN WriteS (f, "PREC "); WI (Prec); WriteS (f, " "); END;
	   WriteS (f, "."); WriteNl (f);
	ELSE
	   ClassListDep (Extensions);
	END;
}; .


PROCEDURE ChildDep (t: Tree)

Child (..) :- { 
	IF {String, Nonterminal} <= Class^.Class.Properties 
        THEN WriteS (f, "yy"); WN (Type); ELSE WriteName (Type); END; WriteS (f, " "); 
}; .

PROCEDURE ActionsDep (t: Tree)

Assign (..) :- { 
	ActionsDep (Results); WriteS (f, ":="); ActionsDep (Arguments); WriteS (f, ";"); WriteNl (f);
	ActionsDep (Next);
}; .
Copy (..) :- {  
	ActionsDep (Results); WriteS (f, " := "); ActionsDep (Arguments); WriteS (f, ";"); WriteNl (f);
	ActionsDep (Next);
}; .
TargetCode (..) :- {  
	ActionsDep (Code); WriteS (f, ";"); WriteNl (f);
	ActionsDep (Next);
}; .
Order (..) :- {  
	ActionsDep (Next);
}; .
Check (..) :- {  
	IF Statement # NoTree THEN
	   IF Condition # NoTree THEN
	      WriteS (f, "IF NOT ("); ActionsDep (Condition); WriteS (f, ") THEN "); ActionsDep (Statement); WriteS (f, "; END;"); WriteNl (f);
	   ELSE
	      ActionsDep (Statement); WriteS (f, ";"); WriteNl (f);
	   END;
	ELSE
	   WriteS (f, "IF "); ActionsDep (Condition); WriteS (f, " THEN END;"); WriteNl (f);
	END;
	ActionsDep (Next);
}; .
Designator (..) :- { 
	TheAttr := IdentifyAttribute (ActClass, Selector);
	IF TheAttr # NoTree THEN
	  Node := TheAttr^.Child.Class;
	  IF Node # NoTree THEN
	    WriteS (f, "$"); 
            WN ( TheAttr^.Child.ChildIndex ) ; 
	    IF Nonterminal IN Node^.Class.Properties THEN  (* nonterminal *)
	      Node := GetBaseClass (Node);
	      IF (String IN Node^.Class.Properties) 
                 AND NOT (HasSelector IN Node^.Class.Properties) THEN
	        WriteS (f, ".yy"); WN (Node^.Class.Name);
	      ELSE
	        WriteS (f, "."); WI (Node^.Class.Name);
	      END;
	    ELSE						(* terminal *)
	      WriteS (f, ".Scan"); 
	      IF Attribute = iPosition THEN
	      ELSIF (String IN Node^.Class.Properties) 
                    AND NOT (HasSelector IN Node^.Class.Properties) THEN
	        WriteS (f, ".yy"); WN (Node^.Class.Code);
	      ELSE
	        WriteS (f, "."); WI (Node^.Class.Selector);
	      END;
	    END;
	    WriteS (f, "."); WI (Attribute);
	  ELSE
	    WI (Selector); WriteS (f, ":"); WI (Attribute);
	  END;
	ELSE
	  WI (Selector); WriteS (f, ":"); WI (Attribute);
	END;
	ActionsDep (Next);
}; .
Ident (..) :- { 
	TheAttr := IdentifyAttribute (ActClass, Attribute);
	IF TheAttr # NoTree THEN
          Node := GetBaseClass (TheClass);
	  IF (String IN Node^.Class.Properties) 
             AND NOT (HasSelector IN Node^.Class.Properties) THEN
	    WriteS (f, "$$.yy"); WN (Node^.Class.Name); WriteS (f, "."); WI (Attribute);
	  ELSE
	    WriteS (f, "$$."); WI (Node^.Class.Name); WriteS (f, "."); WI (Attribute);
	  END;
	ELSE
	  WI (Attribute);
	END;
	ActionsDep (Next);
}; .
Any (..) :- { 
	WriteString (f, Code); 
	ActionsDep (Next);
}; .
Anys (..) :- { 
	ActionsDep (Layouts); 
	ActionsDep (Next);
}; .
LayoutAny (..) :- { 
	WriteString (f, Code); 
	ActionsDep (Next);
}; .


PROCEDURE WriteName (Name: tIdent)

(iOper);
(iLeft);
(iRight);
(iNone);
(iPrec);
(iRule)	:-	    WriteBackslash ( f ) ;  WI (Name); .
_	:-	    WI (Name); .

