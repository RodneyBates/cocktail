
(* This file was mechanically generated by puma. *)

IMPLEMENTATION MODULE GramMod;








IMPORT SYSTEM, System, IO, Tree;
(* line 26 "" *)


FROM IO		IMPORT WriteS, WriteNl;
FROM Strings	IMPORT tString, ArrayToString;
FROM StringMem	IMPORT WriteString;
FROM Idents	IMPORT NoIdent, tIdent, MakeIdent;
FROM Texts	IMPORT WriteText;
FROM Sets	IMPORT IsElement, Include;
FROM SYSTEM     IMPORT ADR;
FROM IOUtils    IMPORT WriteBackslash ; 

FROM Tree	IMPORT Left , Right , First , Dummy , 
   NoTree	, tTree		, Input		, Reverse	,
   Class	, NoClass	, Child		, Attribute	,
   ActionPart	, HasSelector	, HasAttributes	, NoCodeAttr	,
   Referenced	, Options	, TreeRoot	, QueryTree	,
   ClassCount	, iNoTree	, itTree	, Generated	,
   f		, WI, WE, WN	, ForallClasses	, ForallAttributes,
   Nonterminal	, Terminal	, IdentifyAttribute,
   String	, iPosition	;

IMPORT Strings;

VAR
   Node, ActClass, TheClass, TheAttr	: tTree;
   iOper, iLeft, iRight, iNone, iPrec, iRule	: tIdent;
   ActActionIndex, PrevActionIndex, i	: SHORTCARD;
   IsImplicit				: BOOLEAN;
   s					: tString;

PROCEDURE GetBaseClass (Class: tTree): tTree;
   BEGIN
      WHILE Class^.Class.BaseClass^.Kind # NoClass DO
	 Class := Class^.Class.BaseClass;
      END;
      RETURN Class;
   END GetBaseClass;

PROCEDURE IsLast (Class, Action: tTree): BOOLEAN;
   VAR Found, Last: BOOLEAN;
   BEGIN
      IsLast2 (Class, Action, Found, Last);
      RETURN Last;
   END IsLast;

PROCEDURE IsLast2 (t, Action: tTree; VAR pFound, pLast: BOOLEAN);
   VAR Found, Last: BOOLEAN;
   BEGIN
      CASE t^.Kind OF
      | Class:
	    IsLast2 (t^.Class.Attributes, Action, pFound, pLast);
	    IF pFound OR NOT pLast THEN RETURN; END;
	    IsLast2 (t^.Class.BaseClass, Action, pFound, pLast);
      | Child:
	    IsLast2 (t^.Child.Next, Action, Found, Last);
	    pFound := Found;
	    IF Found THEN
	       pLast := Last;
	    ELSE
	       pLast := FALSE;
	    END;
      | Attribute:
	    IsLast2 (t^.Attribute.Next, Action, pFound, pLast);
      | ActionPart:
	    IsLast2 (t^.ActionPart.Next, Action, Found, Last);
	    pFound := Found OR (Action = t);
	    IF Found THEN
	       pLast := Last;
	    ELSE
	       pLast := Last AND (Action = t);
	    END;
      ELSE
	    pFound := FALSE;
	    pLast  := TRUE;
      END;
   END IsLast2;






































































































PROCEDURE yyAbort (yyFunction: ARRAY OF CHAR);
 BEGIN
  IO.WriteS (IO.StdError, 'Error: module GramMod, routine ');
  IO.WriteS (IO.StdError, yyFunction);
  IO.WriteS (IO.StdError, ' failed');
  IO.WriteNl (IO.StdError);
  Exit;
 END yyAbort;

PROCEDURE yyIsEqual (yya, yyb: ARRAY OF SYSTEM.BYTE): BOOLEAN;
 VAR yyi       : INTEGER;
 BEGIN
  FOR yyi := 0 TO INTEGER (HIGH (yya)) DO
   IF yya [yyi] # yyb [yyi] THEN RETURN FALSE; END;
  END;
  RETURN TRUE;
 END yyIsEqual;

PROCEDURE ParsSpec (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Ag:
(* line 115 "" *)
     WITH t^.Ag DO
(* line 115 "" *)
      
	IF ScannerName # NoIdent THEN
	   WriteS (f, "SCANNER "); WI (ScannerName);
	END;
	WriteS (f, " PARSER "); WI (ParserName); WriteNl (f);
	WriteS (f, "GLOBAL {"); WriteNl (f);
	WriteText (f, ParserCodes^.Codes.Global);
	Node := Modules;
	WHILE Node^.Kind = Tree.Module DO
	   WriteText (f, Node^.Module.ParserCodes^.Codes.Global);
	   Node := Node^.Module.Next;
	END;
	WriteS (f, "TYPE"); WriteNl (f);
        ParsVariant (Classes);
	WriteNl (f);
       IF IsElement ( ORD ( 'K' ) , Options ) THEN  
	WriteS (f, "tParsAttribute = RECORD"); WriteNl (f);
       ELSE
	WriteS (f, "tParsAttribute = RECORD CASE : SHORTCARD OF"); WriteNl (f);
	WriteS (f, "  0: Scan: "); 
       END; 
	IF ScannerName # NoIdent THEN WI (ScannerName); ELSE WriteS (f, "Scanner"); END;
	WriteS (f, ".tScanAttribute;"); WriteNl (f);
	i := 0;
	Node := Classes;
	WHILE Node^.Kind = Class DO
	  WITH Node^.Class DO
	     IF {Nonterminal, Referenced, HasAttributes} <= Properties THEN
	       INC (i);
               IF NOT IsElement ( ORD ( 'K' ) , Options ) THEN  
	         WriteS (f, "| "); WN (i); WriteS (f, ": "); 
               END ; 
	       IF (String IN Properties) AND NOT (HasSelector IN Properties) THEN
		 WriteS (f, "(* "); WE (Name); WriteS (f, " *) yy"); WN (Name);
		 WriteS (f, ": yy"); WN (Name); WriteS (f, ";"); WriteNl (f);
	       ELSE
		 WI (Selector); WriteS (f, ": yy"); WI (Selector); WriteS (f, ";"); WriteNl (f);
	       END;
	     END;
	     Node := Next;
	  END;
	END;
        IF NOT IsElement ( ORD ( 'K' ) , Options ) THEN  
	 WriteS (f, " END ;"); WriteNl (f);
        END ; 
	WriteS (f, "END ;"); WriteNl (f);
	WriteS (f, "}"); WriteNl (f);
	WriteNl (f);
	WriteS (f, "EXPORT {"); WriteNl (f);
	WriteText (f, ParserCodes^.Codes.Export);
	Node := Modules;
	WHILE Node^.Kind = Tree.Module DO
	  WriteText (f, Node^.Module.ParserCodes^.Codes.Export);
	  Node := Node^.Module.Next;
	END;
	WriteS (f, "}"); WriteNl (f);
	WriteNl (f);
	WriteS (f, "LOCAL {"); WriteNl (f);
	WriteText (f, ParserCodes^.Codes.Local);
	Node := Modules;
	WHILE Node^.Kind = Tree.Module DO
	  WriteText (f, Node^.Module.ParserCodes^.Codes.Local);
	  Node := Node^.Module.Next;
	END;
	WriteS (f, "}"); WriteNl (f);
	WriteNl (f);
	WriteS (f, "BEGIN {"); WriteNl (f);
	WriteText (f, ParserCodes^.Codes.Begin);
	Node := Modules;
	WHILE Node^.Kind = Tree.Module DO
	  WriteText (f, Node^.Module.ParserCodes^.Codes.Begin);
	  Node := Node^.Module.Next;
	END;
	WriteS (f, "}"); WriteNl (f);
	WriteNl (f);
	WriteS (f, "CLOSE {"); WriteNl (f);
	WriteText (f, ParserCodes^.Codes.Close);
	Node := Modules;
	WHILE Node^.Kind = Tree.Module DO
	  WriteText (f, Node^.Module.ParserCodes^.Codes.Close);
	  Node := Node^.Module.Next;
	END;
	WriteS (f, "}"); WriteNl (f);
	WriteNl (f);
	WriteS (f, "TOKEN"); WriteNl (f);
	WriteNl (f);
	ForallClasses (Classes, Token);
	WriteNl (f);
	WriteS (f, "OPER"); WriteNl (f);
	WriteNl (f);
	PrecDefs (Precs);
	WriteNl (f);
	WriteS (f, "RULE"); WriteNl (f);
	WriteNl (f);
	ForallClasses (Classes, ParsSpec);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Class:
(* line 211 "" *)
     WITH t^.Class DO
(* line 211 "" *)
      
	IF {Nonterminal, Referenced} <= Properties THEN
	   TheClass := t;
           IF IsElement ( ORD ( 'e' ) , Options )
           THEN
	     GrammarDep (t)
           ELSE
	     Grammar (t)
           END 
	END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ParsSpec;

PROCEDURE ScanSpec (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Ag:
(* line 226 "" *)
     WITH t^.Ag DO
(* line 226 "" *)
      
	WriteS (f, "m"); WriteNl (f);
	WriteS (f, "TYPE"); WriteNl (f);
	ForallClasses (Classes, ScanVariant);
	WriteNl (f);
	WriteS (f, "tScanAttribute = RECORD"); WriteNl (f);
	WriteS (f, "Position: tPosition;"); WriteNl (f);
        IF IsElement ( ORD ( 'K' ) , Options ) THEN  
	 ForallClasses (Classes, ScanAttr);
        ELSE 
         WriteS (f, "CASE : SHORTCARD OF"); WriteNl (f);
	 ForallClasses (Classes, ScanAttr);
	 WriteS (f, " END ;"); WriteNl (f);
        END ; 
	WriteS (f, "END ;"); WriteNl (f);
	WriteNl (f);
	WriteS (f, "PROCEDURE ErrorAttribute (Token: INTEGER; VAR pAttribute: tScanAttribute);"); WriteNl (f);
	WriteS (f, "%%"); WriteNl (f);
	WriteS (f, "PROCEDURE ErrorAttribute (Token: INTEGER; VAR pAttribute: tScanAttribute);"); WriteNl (f);
	WriteS (f, "BEGIN"); WriteNl (f);
	WriteS (f, " pAttribute.Position := Attribute.Position;"); WriteNl (f);
	WriteS (f, " CASE Token OF"); WriteNl (f);
	ForallClasses (Classes, ErrorActions);
	WriteS (f, " ELSE"); WriteNl (f);
	WriteS (f, " END;"); WriteNl (f);
	WriteS (f, "END ErrorAttribute;"); WriteNl (f);
	WriteS (f, "%%"); WriteNl (f);
	ForallClasses (Classes, ScanSpec);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Class:
(* line 255 "" *)
     WITH t^.Class DO
(* line 255 "" *)
      
	IF {Terminal, Referenced} <= Properties THEN
	   WN (Code);
	   IF HasAttributes IN Properties THEN	WriteS (f, " S "); 
	   ELSE					WriteS (f, " N "); 
	   END;
	   IF (String IN Properties) AND NOT (HasSelector IN Properties) THEN
	      WriteS (f, "yy"); WN (Code);
	   ELSE
	      WI (Selector);
	   END;
	   WriteS (f, " "); WI (Name); WriteNl (f);
	END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ScanSpec;

PROCEDURE ErrorActions (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 273 "" *)
     WITH t^.Class DO
(* line 273 "" *)
      
	IF {Terminal, Referenced, HasAttributes} <= Properties THEN
	  WriteS (f, " | (* "); WE (Name); WriteS (f, " *) "); WN (Code); WriteS (f, ": "); WriteNl (f);
	  TheClass := t;
	  ForallAttributes (t, ErrorActions);
	END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.ActionPart:
(* line 280 "" *)
     WITH t^.ActionPart DO
(* line 280 "" *)
      
	ErrorActions (Actions);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Assign:
(* line 283 "" *)
     WITH t^.Assign DO
(* line 283 "" *)
      
	ErrorActions (Results); WriteS (f, ":="); ErrorActions (Arguments); WriteS (f, ";"); WriteNl (f);
	ErrorActions (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Copy:
(* line 287 "" *)
     WITH t^.Copy DO
(* line 287 "" *)
      
	ErrorActions (Results); WriteS (f, " := "); ErrorActions (Arguments); WriteS (f, ";"); WriteNl (f);
	ErrorActions (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TargetCode:
(* line 291 "" *)
     WITH t^.TargetCode DO
(* line 291 "" *)
      
	ErrorActions (Code); WriteS (f, ";"); WriteNl (f);
	ErrorActions (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Order:
(* line 295 "" *)
     WITH t^.Order DO
(* line 295 "" *)
      
	ErrorActions (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Check:
(* line 298 "" *)
     WITH t^.Check DO
(* line 298 "" *)
      
	IF Statement # NoTree THEN
	   IF Condition # NoTree THEN
	      WriteS (f, "IF NOT ("); ErrorActions (Condition); WriteS (f, ") THEN "); ErrorActions (Statement); WriteS (f, "; END;"); WriteNl (f);
	   ELSE
	      ErrorActions (Statement); WriteS (f, ";"); WriteNl (f);
	   END;
	ELSE
	   WriteS (f, "IF "); ErrorActions (Condition); WriteS (f, " THEN END;"); WriteNl (f);
	END;
	ErrorActions (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Designator:
(* line 310 "" *)
     WITH t^.Designator DO
(* line 310 "" *)
      
	WI (Selector); WriteS (f, ":"); WI (Attribute);
	ErrorActions (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Ident:
(* line 314 "" *)
     WITH t^.Ident DO
(* line 314 "" *)
      
	TheAttr := IdentifyAttribute (TheClass, Attribute);
	IF TheAttr # NoTree THEN
	   WriteS (f, "pAttribute"); 
	   IF Attribute = iPosition THEN
           ELSIF (String IN TheClass^.Class.Properties) AND NOT (HasSelector IN TheClass^.Class.Properties) THEN
	      WriteS (f, ".yy"); WN (TheClass^.Class.Code);
	   ELSE
	      WriteS (f, "."); WI (TheClass^.Class.Selector);
	   END;
	   WriteS (f, "."); 
	END;
	WI (Attribute);
	ErrorActions (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Any:
(* line 329 "" *)
     WITH t^.Any DO
(* line 329 "" *)
      
	WriteString (f, Code);
	ErrorActions (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Anys:
(* line 333 "" *)
     WITH t^.Anys DO
(* line 333 "" *)
      
	ErrorActions (Layouts);
	ErrorActions (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.LayoutAny:
(* line 337 "" *)
     WITH t^.LayoutAny DO
(* line 337 "" *)
      
	WriteString (f, Code);
	ErrorActions (Next);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ErrorActions;

PROCEDURE ScanVariant (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 345 "" *)
     WITH t^.Class DO
(* line 345 "" *)
      
	IF {Terminal, Referenced, HasAttributes} <= Properties THEN
          IF (String IN Properties) AND NOT (HasSelector IN Properties) THEN
	    WriteS (f, "(* "); WE (Name); WriteS (f, " *) yy"); WN (Code); WriteS (f, " = RECORD "); 
	  ELSE
	    WriteS (f, "yy"); WI (Selector); WriteS (f, " = RECORD "); 
	  END;
	  TheClass := t;
	  ForallAttributes (t, RecordField);
	  WriteS (f, "END;"); WriteNl (f);
	END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END ScanVariant;

PROCEDURE ScanAttr (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 361 "" *)
     WITH t^.Class DO
(* line 361 "" *)
      
	IF {Terminal, Referenced, HasAttributes} <= Properties THEN
          IF NOT IsElement ( ORD ( 'K' ) , Options ) THEN  
	   WriteS (f, "| "); WN (Code); WriteS (f, ": "); 
          END ; 
          IF (String IN Properties) AND NOT (HasSelector IN Properties) THEN
	    WriteS (f, "(* "); WE (Name); WriteS (f, " *) yy"); WN (Code); WriteS (f, ": yy"); WN (Code); WriteS (f, ";"); WriteNl (f);
	  ELSE
	    WI (Selector); WriteS (f, ": yy"); WI (Selector); WriteS (f, ";"); WriteNl (f);
	  END;
	END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END ScanAttr;

PROCEDURE ParsVariant (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 377 "" *)
     WITH t^.Class DO
(* line 377 "" *)
      
	IF {Nonterminal, Referenced, HasAttributes} <= Properties THEN
          IF (String IN Properties) AND NOT (HasSelector IN Properties) THEN
	    WriteS (f, "(* "); WE (Name); WriteS (f, " *) yy"); WN (Name); WriteS (f, " = RECORD "); 
	  ELSE
	    WriteS (f, "yy"); WI (Selector); WriteS (f, " = RECORD "); 
	  END;
	  TheClass := t;
	  GenExt (Extensions);
	  ForallAttributes (Attributes, RecordField);
	  WriteS (f, "END;"); WriteNl (f);
	END;
	ParsVariant (Next);
;
      RETURN;
     END (* WITH *) ;

  END;
 END ParsVariant;

PROCEDURE GenExt (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 395 "" *)
     WITH t^.Class DO
(* line 395 "" *)
      
	ForallAttributes (Attributes, RecordField);
	GenExt (Extensions);
	GenExt (Next);
;
      RETURN;
     END (* WITH *) ;

  END;
 END GenExt;

PROCEDURE Token (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 404 "" *)
     WITH t^.Class DO
(* line 404 "" *)
      
	IF {Terminal, Referenced} <= Properties THEN
	   WriteName (Name); WriteS (f, " = "); WN (Code); WriteNl (f);
	END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END Token;

PROCEDURE RecordField (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Attribute) THEN
(* line 413 "" *)
     WITH t^.Attribute DO
(* line 413 "" *)
      
	IF (NoCodeAttr * Properties) = {} THEN 
	   IF (Nonterminal IN TheClass^.Class.Properties) OR (Name # iPosition) THEN
	      WI (Name); WriteS (f, ": "); WI (Type); WriteS (f, "; "); WriteNl (f);
	   END;
	END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END RecordField;

PROCEDURE PrecDefs (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.LeftAssoc:
(* line 424 "" *)
     WITH t^.LeftAssoc DO
(* line 424 "" *)
      
	WriteS (f, "LEFT "); PrecDefs (Names); WriteNl (f);
	PrecDefs (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.RightAssoc:
(* line 428 "" *)
     WITH t^.RightAssoc DO
(* line 428 "" *)
      
	WriteS (f, "RIGHT"); PrecDefs (Names); WriteNl (f);
	PrecDefs (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.NonAssoc:
(* line 432 "" *)
     WITH t^.NonAssoc DO
(* line 432 "" *)
      
	WriteS (f, "NONE "); PrecDefs (Names); WriteNl (f);
	PrecDefs (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Name:
(* line 436 "" *)
     WITH t^.Name DO
(* line 436 "" *)
      
	WriteS (f, " "); WI (Name);
	PrecDefs (Next);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END PrecDefs;

PROCEDURE Grammar (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 446 "" *)
     WITH t^.Class DO
(* line 446 "" *)
      
	IF Extensions^.Kind = Tree.NoClass THEN		
	   WITH TheClass^.Class DO
	      IF String IN Properties THEN WriteS (f, "yy"); WN (Name); ELSE WriteName (Name); END;
	   END;
	   WriteS (f, " : "); 
	   ActClass := t;
	   PrevActionIndex := 0;
	   IsImplicit := FALSE;
	   ForallAttributes (t, Rule);
	   IF Prec # NoIdent THEN WriteS (f, "PREC "); WI (Prec); WriteS (f, " "); END;
	   WriteS (f, "."); WriteNl (f);
	   PrevActionIndex := 0;
	   IsImplicit := TRUE;
	   ForallAttributes (t, Implicit);
	ELSE
	   Rule (Extensions);
	END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END Grammar;

PROCEDURE Rule (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 469 "" *)
     WITH t^.Class DO
(* line 469 "" *)
      
	Grammar (t);
	Rule (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 473 "" *)
     WITH t^.Child DO
(* line 473 "" *)
      
	IF {String, Nonterminal} <= Class^.Class.Properties THEN WriteS (f, "yy"); WN (Type); ELSE WriteName (Type); END; WriteS (f, " "); 
;
      RETURN;
     END (* WITH *) ;

  | Tree.ActionPart:
(* line 476 "" *)
     WITH t^.ActionPart DO
(* line 476 "" *)
      
	IF IsLast (ActClass, t) THEN
	   WriteS (f, "{"); 
	   IF PrevActionIndex # 0 THEN
	      Node := GetBaseClass (TheClass);
	      WITH Node^.Class DO
		 IF HasAttributes IN Properties THEN
		    WriteS (f, " $$."); 
		    IF String IN Properties THEN WriteS (f, "yy"); WN (Name); ELSE WI (Name); END;
		    WriteS (f, " := $"); WN (PrevActionIndex); WriteS (f, "."); 
		    IF String IN Properties THEN WriteS (f, "yy"); WN (Name); ELSE WI (Name); END;
		    WriteS (f, ";"); WriteNl (f);
		 END;
	      END;
	   END;
	   Rule (Actions);
	   WriteS (f, "} "); 
	ELSE
	   WriteS (f, "xx"); WN (Name); WriteS (f, " "); 
	END;
	PrevActionIndex := ParsIndex;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Assign:
(* line 498 "" *)
     WITH t^.Assign DO
(* line 498 "" *)
      
	Rule (Results); WriteS (f, ":="); Rule (Arguments); WriteS (f, ";"); WriteNl (f);
	Rule (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Copy:
(* line 502 "" *)
     WITH t^.Copy DO
(* line 502 "" *)
      
	Rule (Results); WriteS (f, " := "); Rule (Arguments); WriteS (f, ";"); WriteNl (f);
	Rule (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TargetCode:
(* line 506 "" *)
     WITH t^.TargetCode DO
(* line 506 "" *)
      
	Rule (Code); WriteS (f, ";"); WriteNl (f);
	Rule (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Order:
(* line 510 "" *)
     WITH t^.Order DO
(* line 510 "" *)
      
	Rule (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Check:
(* line 513 "" *)
     WITH t^.Check DO
(* line 513 "" *)
      
	IF Statement # NoTree THEN
	   IF Condition # NoTree THEN
	      WriteS (f, "IF NOT ("); Rule (Condition); WriteS (f, ") THEN "); Rule (Statement); WriteS (f, "; END;"); WriteNl (f);
	   ELSE
	      Rule (Statement); WriteS (f, ";"); WriteNl (f);
	   END;
	ELSE
	   WriteS (f, "IF "); Rule (Condition); WriteS (f, " THEN END;"); WriteNl (f);
	END;
	Rule (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Designator:
(* line 525 "" *)
     WITH t^.Designator DO
(* line 525 "" *)
      
	TheAttr := IdentifyAttribute (ActClass, Selector);
	IF TheAttr # NoTree THEN
	  Node := TheAttr^.Child.Class;
	  IF Node # NoTree THEN
	    WriteS (f, "$"); 
	    IF NOT IsImplicit THEN
	       WN (TheAttr^.Child.ParsIndex);
	    ELSE
	       WN (SHORTINT (TheAttr^.Child.ParsIndex + 1 - ActActionIndex));
	    END;
	    IF Nonterminal IN Node^.Class.Properties THEN	
	      Node := GetBaseClass (Node);
	      IF (String IN Node^.Class.Properties) AND NOT (HasSelector IN Node^.Class.Properties) THEN
	        WriteS (f, ".yy"); WN (Node^.Class.Name);
	      ELSE
	        WriteS (f, "."); WI (Node^.Class.Name);
	      END;
	    ELSE						
	      WriteS (f, ".Scan"); 
	      IF Attribute = iPosition THEN
	      ELSIF (String IN Node^.Class.Properties) AND NOT (HasSelector IN Node^.Class.Properties) THEN
	        WriteS (f, ".yy"); WN (Node^.Class.Code);
	      ELSE
	        WriteS (f, "."); WI (Node^.Class.Selector);
	      END;
	    END;
	    WriteS (f, "."); WI (Attribute);
	  ELSE
	    WI (Selector); WriteS (f, ":"); WI (Attribute);
	  END;
	ELSE
	  WI (Selector); WriteS (f, ":"); WI (Attribute);
	END;
	Rule (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Ident:
(* line 561 "" *)
     WITH t^.Ident DO
(* line 561 "" *)
      
	TheAttr := IdentifyAttribute (ActClass, Attribute);
	Node := GetBaseClass (TheClass);
	IF TheAttr # NoTree THEN
	  IF (String IN Node^.Class.Properties) AND NOT (HasSelector IN Node^.Class.Properties) THEN
	    WriteS (f, "$$.yy"); WN (Node^.Class.Name); WriteS (f, "."); WI (Attribute);
	  ELSE
	    WriteS (f, "$$."); WI (Node^.Class.Name); WriteS (f, "."); WI (Attribute);
	  END;
	ELSE
	  WI (Attribute);
	END;
	Rule (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Any:
(* line 575 "" *)
     WITH t^.Any DO
(* line 575 "" *)
      
	WriteString (f, Code);
	Rule (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Anys:
(* line 579 "" *)
     WITH t^.Anys DO
(* line 579 "" *)
      
	Rule (Layouts);
	Rule (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.LayoutAny:
(* line 583 "" *)
     WITH t^.LayoutAny DO
(* line 583 "" *)
      
	WriteString (f, Code);
	Rule (Next);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Rule;

PROCEDURE Implicit (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.ActionPart) THEN
(* line 591 "" *)
     WITH t^.ActionPart DO
(* line 591 "" *)
      
	IF NOT (Generated IN Properties) AND NOT IsLast (ActClass, t) THEN
	   INCL (Properties, Generated);
	   ActActionIndex := ParsIndex;
	   WriteS (f, "xx"); WN (Name); WriteS (f, " : {"); 
	   IF PrevActionIndex # 0 THEN
	      Node := GetBaseClass (TheClass);
	      WITH Node^.Class DO
		 IF HasAttributes IN Properties THEN
		    WriteS (f, " $$."); 
		    IF String IN Properties THEN WriteS (f, "yy"); WN (Name); ELSE WI (Name); END;
		    WriteS (f, " := $"); WN (SHORTINT (PrevActionIndex + 1 - ActActionIndex)); WriteS (f, "."); 
		    IF String IN Properties THEN WriteS (f, "yy"); WN (Name); ELSE WI (Name); END;
		    WriteS (f, ";"); WriteNl (f);
		 END;
	      END;
	   END;
	   Rule (Actions);
	   WriteS (f, "} ."); WriteNl (f);
	END;
	PrevActionIndex := ParsIndex;
;
      RETURN;
     END (* WITH *) ;

  END;
 END Implicit;

PROCEDURE ClassListDep (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 618 "" *)
     WITH t^.Class DO
(* line 618 "" *)
      
	GrammarDep (t);
	ClassListDep (Next);
;
      RETURN;
     END (* WITH *) ;

  END;
 END ClassListDep;

PROCEDURE GrammarDep (t: Tree.tTree);
(* line 625 "" *)
 VAR i : SHORTCARD ; VAR BracesGenerated : BOOLEAN ; 

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 627 "" *)
     WITH t^.Class DO
(* line 627 "" *)
      
	IF Extensions^.Kind = Tree.NoClass THEN		
	   WITH TheClass^.Class DO
	      IF String IN Properties 
              THEN WriteS (f, "yy"); WN (Name); ELSE WriteName (Name); END;
	   END;
	   WriteS (f, " : "); 
	   ForallAttributes (t, ChildDep);
           WriteNl (f);
           BracesGenerated := FALSE ; 
           FOR i := 1 TO InstCount
           DO
             WITH Instance ^ [ Instance ^ [ i ] . Order ] 
             DO
               IF ( { Left , First } <= Properties )
                  AND NOT ( Dummy IN Properties ) 
                  AND ( Action <> ADR ( Action ) ) 
               THEN
                 ActClass := t ; 
                 IF BracesGenerated
                 THEN 
                   WriteS (f, "   "); 
                 ELSE  
                   WriteS (f, " { "); 
                   BracesGenerated := TRUE ; 
                 END ; 
                 ActionsDep ( Action ) ; 
                 WriteNl (f);
               END 
             END
           END ; 
           IF BracesGenerated
           THEN
             WriteS (f, " } "); WriteNl (f);
           END ; 
	   IF Prec # NoIdent THEN WriteS (f, "PREC "); WI (Prec); WriteS (f, " "); END;
	   WriteS (f, "."); WriteNl (f);
	ELSE
	   ClassListDep (Extensions);
	END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END GrammarDep;

PROCEDURE ChildDep (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Child) THEN
(* line 672 "" *)
     WITH t^.Child DO
(* line 672 "" *)
       
	IF {String, Nonterminal} <= Class^.Class.Properties 
        THEN WriteS (f, "yy"); WN (Type); ELSE WriteName (Type); END; WriteS (f, " "); 
;
      RETURN;
     END (* WITH *) ;

  END;
 END ChildDep;

PROCEDURE ActionsDep (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Assign:
(* line 679 "" *)
     WITH t^.Assign DO
(* line 679 "" *)
       
	ActionsDep (Results); WriteS (f, ":="); ActionsDep (Arguments); WriteS (f, ";"); WriteNl (f);
	ActionsDep (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Copy:
(* line 683 "" *)
     WITH t^.Copy DO
(* line 683 "" *)
        
	ActionsDep (Results); WriteS (f, " := "); ActionsDep (Arguments); WriteS (f, ";"); WriteNl (f);
	ActionsDep (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TargetCode:
(* line 687 "" *)
     WITH t^.TargetCode DO
(* line 687 "" *)
        
	ActionsDep (Code); WriteS (f, ";"); WriteNl (f);
	ActionsDep (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Order:
(* line 691 "" *)
     WITH t^.Order DO
(* line 691 "" *)
        
	ActionsDep (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Check:
(* line 694 "" *)
     WITH t^.Check DO
(* line 694 "" *)
        
	IF Statement # NoTree THEN
	   IF Condition # NoTree THEN
	      WriteS (f, "IF NOT ("); ActionsDep (Condition); WriteS (f, ") THEN "); ActionsDep (Statement); WriteS (f, "; END;"); WriteNl (f);
	   ELSE
	      ActionsDep (Statement); WriteS (f, ";"); WriteNl (f);
	   END;
	ELSE
	   WriteS (f, "IF "); ActionsDep (Condition); WriteS (f, " THEN END;"); WriteNl (f);
	END;
	ActionsDep (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Designator:
(* line 706 "" *)
     WITH t^.Designator DO
(* line 706 "" *)
       
	TheAttr := IdentifyAttribute (ActClass, Selector);
	IF TheAttr # NoTree THEN
	  Node := TheAttr^.Child.Class;
	  IF Node # NoTree THEN
	    WriteS (f, "$"); 
            WN ( TheAttr^.Child.ChildIndex ) ; 
	    IF Nonterminal IN Node^.Class.Properties THEN  
	      Node := GetBaseClass (Node);
	      IF (String IN Node^.Class.Properties) 
                 AND NOT (HasSelector IN Node^.Class.Properties) THEN
	        WriteS (f, ".yy"); WN (Node^.Class.Name);
	      ELSE
	        WriteS (f, "."); WI (Node^.Class.Name);
	      END;
	    ELSE						
	      WriteS (f, ".Scan"); 
	      IF Attribute = iPosition THEN
	      ELSIF (String IN Node^.Class.Properties) 
                    AND NOT (HasSelector IN Node^.Class.Properties) THEN
	        WriteS (f, ".yy"); WN (Node^.Class.Code);
	      ELSE
	        WriteS (f, "."); WI (Node^.Class.Selector);
	      END;
	    END;
	    WriteS (f, "."); WI (Attribute);
	  ELSE
	    WI (Selector); WriteS (f, ":"); WI (Attribute);
	  END;
	ELSE
	  WI (Selector); WriteS (f, ":"); WI (Attribute);
	END;
	ActionsDep (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Ident:
(* line 740 "" *)
     WITH t^.Ident DO
(* line 740 "" *)
       
	TheAttr := IdentifyAttribute (ActClass, Attribute);
	IF TheAttr # NoTree THEN
          Node := GetBaseClass (TheClass);
	  IF (String IN Node^.Class.Properties) 
             AND NOT (HasSelector IN Node^.Class.Properties) THEN
	    WriteS (f, "$$.yy"); WN (Node^.Class.Name); WriteS (f, "."); WI (Attribute);
	  ELSE
	    WriteS (f, "$$."); WI (Node^.Class.Name); WriteS (f, "."); WI (Attribute);
	  END;
	ELSE
	  WI (Attribute);
	END;
	ActionsDep (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Any:
(* line 755 "" *)
     WITH t^.Any DO
(* line 755 "" *)
       
	WriteString (f, Code); 
	ActionsDep (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Anys:
(* line 759 "" *)
     WITH t^.Anys DO
(* line 759 "" *)
       
	ActionsDep (Layouts); 
	ActionsDep (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.LayoutAny:
(* line 763 "" *)
     WITH t^.LayoutAny DO
(* line 763 "" *)
       
	WriteString (f, Code); 
	ActionsDep (Next);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ActionsDep;

PROCEDURE WriteName (Name: tIdent);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF ( Name  =   (iOper)  ) THEN
(* line 771 "" *)
(* line 776 "" *)
      WriteBackslash (f);
(* line 776 "" *)
      WI (Name);
      RETURN;

  END;
  IF ( Name  =   (iLeft)  ) THEN
(* line 771 "" *)
(* line 776 "" *)
      WriteBackslash (f);
(* line 776 "" *)
      WI (Name);
      RETURN;

  END;
  IF ( Name  =   (iRight)  ) THEN
(* line 771 "" *)
(* line 776 "" *)
      WriteBackslash (f);
(* line 776 "" *)
      WI (Name);
      RETURN;

  END;
  IF ( Name  =   (iNone)  ) THEN
(* line 771 "" *)
(* line 776 "" *)
      WriteBackslash (f);
(* line 776 "" *)
      WI (Name);
      RETURN;

  END;
  IF ( Name  =   (iPrec)  ) THEN
(* line 771 "" *)
(* line 776 "" *)
      WriteBackslash (f);
(* line 776 "" *)
      WI (Name);
      RETURN;

  END;
  IF ( Name  =   (iRule)  ) THEN
(* line 771 "" *)
(* line 776 "" *)
      WriteBackslash (f);
(* line 776 "" *)
      WI (Name);
      RETURN;

  END;
(* line 777 "" *)
(* line 777 "" *)
      WI (Name);
      RETURN;

 END WriteName;

PROCEDURE BeginGramMod;
 BEGIN
(* line 104 "" *)

   ArrayToString ("OPER"	, s); iOper	:= MakeIdent (s);
   ArrayToString ("RIGHT"	, s); iRight	:= MakeIdent (s);
   ArrayToString ("LEFT"	, s); iLeft	:= MakeIdent (s);
   ArrayToString ("NONE"	, s); iNone	:= MakeIdent (s);
   ArrayToString ("PREC"	, s); iPrec	:= MakeIdent (s);
   ArrayToString ("RULE"	, s); iRule	:= MakeIdent (s);


 END BeginGramMod;

PROCEDURE CloseGramMod;
 BEGIN

 END CloseGramMod;

PROCEDURE yyExit;
 BEGIN
  IO.CloseIO; System.Exit (1);
 END yyExit;

BEGIN
 yyf   := IO.StdOutput;
 Exit  := yyExit;
 BeginGramMod;
END GramMod.

