
(* This file was mechanically generated by puma. *)

IMPLEMENTATION MODULE TreeAda2;








IMPORT SYSTEM, System, IO, Tree;
(* line 43 "" *)


IMPORT Idents , Strings ; 
FROM IO         IMPORT WriteS, WriteNl;
FROM Sets       IMPORT IsElement , IsEmpty , Extract , Exclude ;
FROM Idents     IMPORT tIdent;
FROM Positions  IMPORT tPosition;
FROM Semantics IMPORT TypeCount ; 

FROM Tree       IMPORT
   NoTree       , tTree         , Options       , ClassCount    ,
   f            , WI    , WN    , iInteger      , itTree        ,
   iNoTree      , iModule       , iMain         , HasChildren   ,
   HasAttributes, NoCodeAttr    , NoCodeClass   , Link          , 
   ForallClassesExtensionsFirst, ForallAttributes, Reverse      ,
   TypeNames ;

VAR
   iClassName   : Idents . tIdent;
   sBOOLEAN     : Strings . tString;
   iBOOLEAN     : Idents . tIdent;
   RevChild     : tTree;

PROCEDURE WriteLine (Line: tPosition);
   BEGIN
      IF Line.Line # 0 THEN
         WriteS (f, "-- From line "); WN (Line.Line); WriteS (f, ' of file "'); WI (Line.File); WriteS (f, '"'); WriteNl (f);
         IF IsElement (ORD ('#'), Options) THEN 
           WriteS (f, "PRAGMA LINE ( "); WN (Line.Line); WriteS (f, ' , "'); WI (Line.File); WriteS (f, '" ) ; '); WriteNl (f);
         END; 
      END;
   END WriteLine;






































































































PROCEDURE yyAbort (yyFunction: ARRAY OF CHAR);
 BEGIN
  IO.WriteS (IO.StdError, 'Error: module TreeAda2, routine ');
  IO.WriteS (IO.StdError, yyFunction);
  IO.WriteS (IO.StdError, ' failed');
  IO.WriteNl (IO.StdError);
  Exit;
 END yyAbort;

PROCEDURE yyIsEqual (yya, yyb: ARRAY OF SYSTEM.BYTE): BOOLEAN;
 VAR yyi       : INTEGER;
 BEGIN
  FOR yyi := 0 TO INTEGER (HIGH (yya)) DO
   IF yya [yyi] # yyb [yyi] THEN RETURN FALSE; END;
  END;
  RETURN TRUE;
 END yyIsEqual;

PROCEDURE TreeIO (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 1: yyR1: RECORD
  LTypeId: tIdent;
  END;
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Ag) THEN
(* line 86 "" *)
    WITH yyTempo.yyR1 DO  
     WITH t^.Ag DO
(* line 87 "" *)
      ;
(* line 88 "" *)
      
        WriteNl (f);
      IF IsElement (ORD ('w'), Options) 
         OR IsElement (ORD ('w'), Options) THEN 
        WriteS (f, "yyf : Text_Io . File_Type ; "); WriteNl (f);
 
      END; 
      IF IsElement (ORD ('r'), Options) THEN 

      END;  
        WriteNl (f);
      IF IsElement (ORD (','), Options) THEN
        WriteS (f, "PROCEDURE yyMark  ( Tree : "); WI (itTree); WriteS (f, " ) "); WriteNl (f);
        WriteS (f, "IS "); WriteNl (f);
        WriteS (f, "  yyt : "); WI ( itTree ) ; WriteS (f, " := Tree ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "BEGIN "); WriteNl (f);
        WriteS (f, "  LOOP"); WriteNl (f);
        WriteS (f, "    IF yyt = "); WI (iNoTree); WriteS (f, " THEN RETURN ; END IF ;"); WriteNl (f);
        WriteS (f, "    yyt . ALL . yyHead . yyMark := yyt . ALL . yyHead . yyMark + 1 ; "); WriteNl (f);
        WriteS (f, "    IF yyt . ALL . yyHead . yyMark > 1 THEN RETURN ; END IF ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "    CASE yyt . ALL . Kind IS"); WriteNl (f);
        Mark ( Classes ) ; 
        WriteS (f, "    WHEN OTHERS => RETURN ; "); WriteNl (f);
        WriteS (f, "    END CASE ; "); WriteNl (f);
        WriteS (f, "  END LOOP ;"); WriteNl (f);
        WriteS (f, "END yyMark ;"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD (';'), Options) THEN
        WriteS (f, "yyInitTreeStoreSize : CONSTANT := 32 ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "TYPE yytTreeStore IS ARRAY ( INTEGER RANGE <> ) OF "); WI (itTree); WriteS (f, " ; "); WriteNl (f);
        WriteS (f, "TYPE yytTreeStorePtr IS ACCESS yytTreeStore ; "); 
        WriteNl (f);
        WriteS (f, "yyTreeStorePtr : yytTreeStorePtr := NULL ; "); WriteNl (f);
        WriteS (f, "yyLabelCount : NATURAL := 0 ; "); WriteNl (f);
        WriteS (f, "yyInitialTreeStoreCount : CONSTANT NATURAL := 2000 ; "); WriteNl (f);
        WriteS (f, "yyRecursionLevel : NATURAL ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "FUNCTION yyMapToLabel ( yyTree : "); WI (itTree); WriteS (f, " ) RETURN NATURAL "); WriteNl (f);
        WriteS (f, "IS "); WriteNl (f);
        WriteS (f, "  yyi : NATURAL ; "); WriteNl (f);
        WriteS (f, "  LNewTreeStorePtr : yytTreeStorePtr ; "); WriteNl (f);
        WriteS (f, "BEGIN"); WriteNl (f);
        WriteS (f, "  FOR yyi IN 0 .. yyLabelCount - 1 "); WriteNl (f);
        WriteS (f, "  LOOP "); WriteNl (f);
        WriteS (f, "    IF yyTreeStorePtr . ALL ( yyi ) = yyTree THEN RETURN yyi ; END IF ; "); WriteNl (f);
        WriteS (f, "  END LOOP ; "); WriteNl (f);
        WriteS (f, "  IF yyTreeStorePtr = NULL "); WriteNl (f);
        WriteS (f, "  THEN "); WriteNl (f);
        WriteS (f, "    yyTreeStorePtr := NEW yytTreeStore ( 0 .. yyInitialTreeStoreCount - 1 ) ; "); WriteNl (f);
        WriteS (f, "  END IF ; "); WriteNl (f);
        WriteS (f, "  IF yyLabelCount = yyTreeStorePtr . ALL __ADA_TICK__ LENGTH "); WriteNl (f);
        WriteS (f, "  THEN "); WriteNl (f);
        WriteS (f, "     LNewTreeStorePtr "); WriteNl (f);
        WriteS (f, "       := NEW yytTreeStore ( 0 .. yyTreeStorePtr . ALL __ADA_TICK__ LENGTH * 2 - 1 ) ;"); WriteNl (f);
        WriteS (f, "     LNewTreeStorePtr . ALL ( yyTreeStorePtr . ALL __ADA_TICK__ RANGE ) "); WriteNl (f);
        WriteS (f, "       := yyTreeStorePtr . ALL ; "); WriteNl (f);
        WriteS (f, "     yyTreeStorePtr := LNewTreeStorePtr ; "); WriteNl (f);
        WriteS (f, "  END IF ; "); WriteNl (f);
        WriteS (f, "  yyi := yyLabelCount ; "); WriteNl (f);
        WriteS (f, "  yyTreeStorePtr . ALL ( yyi ) := yyTree ; "); WriteNl (f);
        WriteS (f, "  yyLabelCount := yyLabelCount + 1 ; "); WriteNl (f);
        WriteS (f, "  RETURN yyi ;"); WriteNl (f);
        WriteS (f, " END yyMapToLabel ; "); WriteNl (f);
        WriteNl (f);
       IF IsElement (ORD ('r'), Options) THEN 
 
       END;
      END;
      IF IsElement (ORD ('w'), Options) OR
         IsElement (ORD ('^'), Options) OR
         IsElement (ORD ('o'), Options) THEN
        WriteS (f, 'PROCEDURE yyWriteNl IS BEGIN Text_Io . Put_Line ( "" ) ; END yyWriteNl ; '); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyWriteSelector ( yys : STRING ) "); WriteNl (f);
        WriteS (f, "IS "); WriteNl (f);
        WriteS (f, "  SUBTYPE LPadSt IS STRING ( 1 .. 16 - yys __ADA_TICK__ LENGTH ) ; "); WriteNl (f);
        WriteS (f, "BEGIN "); WriteNl (f);
        WriteS (f, "  Text_Io . Put ( yys ) ; "); WriteNl (f);
        WriteS (f, "  Text_Io . Put ( LPadSt __ADA_TICK__ ( OTHERS => ' ' ) ) ; "); WriteNl (f);
        WriteS (f, '  Text_Io . Put ( " = " ) ; '); WriteNl (f);
        WriteS (f, "END yyWriteSelector ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "LittleEndian : BOOLEAN := TRUE ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "TYPE Byte IS RANGE 0 .. 255 ; "); WriteNl (f);
        WriteS (f, "TYPE Bytes IS ARRAY ( INTEGER RANGE <> ) OF BYTE ; "); WriteNl (f);
        WriteS (f, "PACKAGE BYTE_Text_Io IS NEW Text_Io . Integer_Io ( BYTE ) ; "); WriteNl (f);
        WriteS (f, ""); 
        WriteS (f, "PROCEDURE yyWriteHex ( yyx : Bytes ) "); WriteNl (f);
        WriteS (f, "IS BEGIN"); WriteNl (f);
        WriteS (f, "  IF LittleEndian"); WriteNl (f);
        WriteS (f, "  THEN"); WriteNl (f);
        WriteS (f, "    FOR yyi IN REVERSE yyx __ADA_TICK__ RANGE LOOP "); WriteNl (f);
        WriteS (f, "      Byte_Text_Io . Put ( yyx ( yyi ) , 2 , 16 ) ; "); WriteNl (f);
      
        WriteS (f, "    END LOOP ; "); WriteNl (f);
        WriteS (f, "  ELSE"); WriteNl (f);
        WriteS (f, "    FOR yyi IN yyx __ADA_TICK__ RANGE LOOP "); WriteNl (f);
        WriteS (f, "      Byte_Text_Io . Put ( yyx ( yyi ) , 2 , 16 ) ; "); WriteNl (f);
      
        WriteS (f, "    END LOOP ; "); WriteNl (f);
        WriteS (f, "  END IF ; "); WriteNl (f);
        WriteS (f, "END yyWriteHex ;"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('o'), Options) 
         OR IsElement (ORD ('^'), Options) THEN
        WriteS (f, "SUBTYPE "); WI ( itTree ) ; WriteS (f, "Bytes IS Bytes ( 1 .. "); WI ( itTree ) ; WriteS (f, " __ADA_TICK__ Size / 8 ) ; "); WriteNl (f);
        WriteS (f, "FUNCTION "); WI(itTree); WriteS (f, "ToBytes IS NEW Unchecked_Conversion "); WriteNl (f);
        WriteS (f, "  ( "); WI (itTree); WriteS (f, " , "); WI ( itTree ) ; WriteS (f, "Bytes ) ; "); 
        WriteNl (f);
        WriteS (f, "PROCEDURE yyWriteAdr ( yyt : "); WI (itTree); WriteS (f, " ) "); WriteNl (f);
        WriteS (f, "IS BEGIN "); WriteNl (f);
        WriteS (f, "  IF yyt = "); WI (iNoTree); WriteS (f, " THEN "); WriteNl (f);
        WriteS (f, '   Text_Io . Put ("'); WI (iNoTree); WriteS (f, '" ) ; '); WriteNl (f);
        WriteS (f, "  ELSE "); WriteNl (f);
        WriteS (f, "   yyWriteHex ( "); WI(itTree); WriteS (f, "ToBytes ( yyt ) ) ;"); WriteNl (f);
        WriteS (f, "  END IF ; "); WriteNl (f);
        WriteS (f, "  yyWriteNl ;"); WriteNl (f);
        WriteS (f, "END yyWriteAdr ; "); WriteNl (f);
        WriteNl (f);
	IF itTree <= TypeCount THEN Exclude (TypeNames, itTree); END;
	WHILE NOT IsEmpty (TypeNames) DO
	  LTypeId := Extract (TypeNames);
        WriteS (f, "SUBTYPE "); WI ( LTypeId ) ; WriteS (f, "Bytes IS Bytes ( 1 .. "); WI ( LTypeId ) ; WriteS (f, " __ADA_TICK__ Size / 8 ) ; "); WriteNl (f);
          WriteS (f, "FUNCTION "); WI ( LTypeId ) ; WriteS (f, "ToBytes IS NEW Unchecked_Conversion "); WriteNl (f);
          WriteS (f, "  ( "); WI ( LTypeId ) ; WriteS (f, " , "); WI ( LTypeId ) ; WriteS (f, "Bytes ) ; "); WriteNl (f);
          WriteNl (f);
        END  ; 
      END;
      IF IsElement (ORD ('o'), Options) THEN 
        ForallClassesExtensionsFirst (Classes, WriteNode);
        WriteS (f, "PROCEDURE Write"); WI (iModule); WriteS (f, "Node "); WriteNl (f);
        WriteS (f, " ( Tree : "); WI (itTree); WriteS (f, " ) "); WriteNl (f);
        WriteS (f, "IS BEGIN"); WriteNl (f);
        WriteS (f, "  IF Tree = "); WI (iNoTree); WriteS (f, " THEN "); WriteNl (f);
        WriteS (f, '    Text_Io . Put ( "'); WI (iNoTree); WriteS (f, '" ) ; yyWriteNl ; RETURN ; '); WriteNl (f);
        WriteS (f, "  END IF ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  CASE Tree . ALL . Kind IS "); WriteNl (f);
        WriteNodeName ( Classes ) ;
        WriteS (f, "  WHEN OTHERS => NULL ; "); WriteNl (f);
        WriteS (f, "  END CASE ;"); WriteNl (f);
        WriteS (f, "END Write"); WI (iModule); WriteS (f, "Node ;"); WriteNl (f);
        WriteNl (f);
      END;
       
      IF IsElement (ORD ('w'), Options) THEN
      
      END;
       
      IF IsElement (ORD ('^'), Options) THEN
        WriteS (f, "FUNCTION yyNodeTag ( yyt : "); WI ( itTree ) ; WriteS (f, " ) RETURN STRING "); WriteNl (f);
        WriteS (f, "IS BEGIN "); WriteNl (f);
        WriteS (f, "  IF yyt = NULL "); WriteNl (f);
        WriteS (f, '  THEN RETURN "NIL" ; '); WriteNl (f);
        WriteS (f, "  ELSE "); 
        WriteS (f, '    RETURN "Node" '); WriteS (f, "& INTEGER __ADA_TICK__ IMAGE ( yyMapToLabel ( yyt ) ) ; "); WriteNl (f);
        WriteS (f, "  END IF ; "); 
        WriteS (f, " END yyNodeTag ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "FUNCTION yyNodeKind ( yyt : "); WI ( itTree ) ; WriteS (f, " ) RETURN STRING "); WriteNl (f);
        WriteS (f, "IS BEGIN"); WriteNl (f);
        WriteS (f, "  IF yyt = "); WI (iNoTree); WriteNl (f);
        WriteS (f, "  THEN "); WriteNl (f);
        WriteS (f, '    RETURN "NIL"  ; '); WriteNl (f);
        WriteS (f, "  ELSE"); WriteNl (f);
        WriteS (f, "    CASE yyt . ALL . Kind IS "); WriteNl (f);
        NodeKinds ( Classes ) ; 
        WriteS (f, "    WHEN OTHERS => "); 
        WriteS (f, '      RETURN "<Unknown>" ; '); WriteNl (f);
        WriteS (f, "    END CASE ; "); WriteNl (f);
        WriteS (f, "   END IF ; "); WriteNl (f);
        WriteS (f, "  END yyNodeKind ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE Write"); WI (iModule); WriteS (f, "Html "); WriteNl (f);
        WriteS (f, '  ( f : Text_Io . File_Type ; Tree : '); WI (itTree); WriteS (f, ' ; Title : STRING := "" '); WriteNl (f);
        WriteS (f, "  ; SuppressNullFields : BOOLEAN := FALSE ) "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "IS "); WriteNl (f);
        WriteS (f, '  IndentString : CONSTANT STRING := "  " ; '); 
        WriteNl (f);
        WriteS (f, "  PROCEDURE WriteChildOrLink "); WriteNl (f);
        WriteS (f, "    ( Name , TypeName : STRING ; Value : "); WI ( itTree ) ; WriteS (f, " ; IsLink : BOOLEAN := FALSE ) "); WriteNl (f);
        WriteS (f, "  IS "); WriteNl (f);
        WriteS (f, "   LNodeTag : STRING := yyNodeTag ( Value ) ; "); WriteNl (f);
        WriteS (f, "  BEGIN "); WriteNl (f);
        WriteS (f, "   IF Value /= NULL OR NOT SuppressNullFields "); 
        WriteS (f, "   THEN "); WriteNl (f);
        WriteS (f, "    Text_Io . Put ( IndentString ) ; "); WriteNl (f);
        WriteS (f, "    Text_Io . Put ( Name ) ; "); WriteNl (f);
        WriteS (f, '    Text_Io . Put ( " : " ) ; '); WriteNl (f);
        WriteS (f, "    Text_Io . Put ( TypeName ) ; "); WriteNl (f);
        WriteS (f, "    IF IsLink "); WriteNl (f);
        WriteS (f, "    THEN "); WriteNl (f);
        WriteS (f, '      Text_Io . Put ( " LINK" ) ; '); WriteNl (f);
        WriteS (f, "    END IF ; "); WriteNl (f);
        WriteS (f, '    Text_Io . Put ( " = " ) ; '); WriteNl (f);
        WriteS (f, '    Text_Io . Put ( "<a href=__ADA_DQUOTE_IN_STRING__#" ) ; '); WriteNl (f);
        WriteS (f, "    Text_Io . Put ( LNodeTag ) ; "); WriteNl (f);
        WriteS (f, '    Text_Io . Put ( "__ADA_DQUOTE_IN_STRING__>REF " ) ; '); WriteNl (f);
        WriteS (f, "    Text_Io . Put ( LNodeTag ) ; "); WriteNl (f);
        WriteS (f, '    Text_Io . Put ( "(" ) ; '); WriteNl (f);
        WriteS (f, "    yyWriteAdr ( Value ) ; "); WriteNl (f);
        WriteS (f, '    Text_Io . Put ( ")" ) ; '); WriteNl (f);
        WriteS (f, "    Text_Io . Put ( yyNodeKind ( Value ) ) ; "); WriteNl (f);
        WriteS (f, '    Text_Io . Put ( "</a>" ) ; '); WriteNl (f);
        WriteS (f, "    yyWriteNl ; "); WriteNl (f);
        WriteS (f, "   END IF ; "); 
        WriteS (f, "  END WriteChildOrLink ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  PROCEDURE WriteBOOLEANAttribute "); WriteNl (f);
        WriteS (f, "    ( Name : STRING ; Value : BOOLEAN ) "); WriteNl (f);
        WriteS (f, "  IS BEGIN "); WriteNl (f);
        WriteS (f, "   IF Value OR NOT SuppressNullFields "); 
        WriteS (f, "   THEN "); WriteNl (f);
        WriteS (f, "    Text_Io . Put ( IndentString ) ; "); WriteNl (f);
        WriteS (f, "    Text_Io . Put ( Name ) ; "); WriteNl (f);
        WriteS (f, '    Text_Io . Put ( " : " ) ; '); WriteNl (f);
        WriteS (f, '    Text_Io . Put ( "BOOLEAN = " ) ; '); 
        WriteS (f, "    writeBOOLEAN ( Value ) "); 
        WriteS (f, "    yyWriteNl  ; "); WriteNl (f);
        WriteS (f, "   END IF ; "); 
        WriteS (f, "  END WriteBOOLEANAttribute ; "); WriteNl (f);
        WriteNl (f);
      
        ForallClassesExtensionsFirst ( Classes , WriteHtmlNodes ) ;
        WriteS (f, " PROCEDURE WriteHtmlRecurse ( Tree : "); WI ( itTree ) ; WriteS (f, " ) "); WriteNl (f);
        WriteS (f, " IS "); WriteNl (f);
        WriteS (f, "   yyt : "); WI ( itTree ) ; WriteS (f, " := Tree ; "); WriteNl (f);
        WriteS (f, " BEGIN "); WriteNl (f);
        WriteS (f, "   LOOP "); WriteNl (f);
        WriteS (f, "    IF yyt = "); WI (iNoTree); WriteS (f, " OR ELSE yyt . ALL . yyHead . yyMark = 0"); WriteNl (f);
        WriteS (f, "    THEN "); WriteNl (f);
        WriteS (f, "     EXIT ; "); WriteNl (f);
        WriteS (f, "    ELSE "); WriteNl (f);
        WriteS (f, "     yyt . ALL . yyHead . yyMark := 0 ; "); WriteNl (f);
        WriteS (f, "     CASE yyt . ALL . Kind IS "); WriteNl (f);
        WriteHtmlCases ( Classes );
        WriteS (f, "     WHEN OTHERS => EXIT ; "); WriteNl (f);
        WriteS (f, "     END CASE ; "); WriteNl (f);
        WriteS (f, "    END IF ; "); WriteNl (f);
        WriteS (f, "   END LOOP ; "); WriteNl (f);
        WriteS (f, " END WriteHtmlRecurse ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, " BEGIN -- Write"); WI (iModule); WriteS (f, "Html "); WriteNl (f);
        WriteS (f, "  Text_Io . Set_Output ( f ) ; "); WriteNl (f);
        WriteS (f, "  IF yyRecursionLevel = 0 THEN yyLabelCount := 0 ; END IF ; "); WriteNl (f);
        WriteS (f, "  yyRecursionLevel := yyRecursionLevel + 1 ; "); WriteNl (f);
        WriteS (f, "  yyMark ( Tree ) ; "); WriteNl (f);
        WriteS (f, '  Text_Io . Put ( "<html> " ) ; yyWriteNl  ; '); 
        WriteS (f, '  Text_Io . Put ( "<head>" ) ; yyWriteNl  ; '); 
        WriteS (f, '  Text_Io . Put ( "<title>" ) ; '); 
        WriteS (f, '  Text_Io . Put ( "Tree """ ) ; '); 
        WriteS (f, '  Text_Io . Put ( Title ) ; '); 
        WriteS (f, '  Text_Io . Put ( """</title>" ) ; yyWriteNl  ; '); 
        WriteS (f, '  Text_Io . Put ( "</head>" ) ; yyWriteNl  ; '); 
        WriteS (f, '  Text_Io . Put ( "<body>" ) ; yyWriteNl  ; '); 
        WriteS (f, '  Text_Io . Put ( "<pre>" ) ; yyWriteNl  ; '); 
        WriteS (f, "  yyWriteNl  ; "); WriteNl (f);
        WriteS (f, "  WriteHtmlRecurse ( Tree ) ; "); WriteNl (f);
        WriteS (f, '  Text_Io . Put ( "</pre>" ) ; yyWriteNl  ; '); 
        WriteS (f, '  Text_Io . Put ( "</body>" ) ; yyWriteNl  ; '); 
        WriteS (f, '  Text_Io . Put ( "</html>" ) ; yyWriteNl  ; '); 
        WriteS (f, "  yyRecursionLevel := yyRecursionLevel - 1;"); WriteNl (f);
        WriteS (f, " END Write"); WI (iModule); WriteS (f, "Html ; "); WriteNl (f);
        WriteNl (f);
      END;
 
      IF IsElement (ORD ('p'), Options) 
         OR IsElement (ORD ('g'), Options) THEN
      
      END; 
      IF IsElement (ORD ('p'), Options) THEN
      
      END;
      IF IsElement (ORD ('g'), Options) THEN
      
      END;
;
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  END;
 END TreeIO;

PROCEDURE TreeIOInit (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Ag) THEN
(* line 598 "" *)
     WITH t^.Ag DO
(* line 598 "" *)
      
      IF IsElement (ORD ('p'), Options) 
         OR IsElement (ORD ('g'), Options) THEN
        
      END; 
;
      RETURN;
     END (* WITH *) ;

  END;
 END TreeIOInit;

PROCEDURE WriteNodeName (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 608 "" *)
     WITH t^.Class DO
(* line 608 "" *)
      
        WriteNodeName ( Extensions ) ; 
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "  WHEN "); WI (Name); WriteS (f, " => "); WriteNl (f);
           WriteS (f, '    Text_Io . Put ( "Node of Kind '); WI (Name); WriteS (f, ':" ) ; yyWriteNl ; '); 
           IF ({HasChildren, HasAttributes} * Properties) # {} THEN
             WriteS (f, "    yyyWriteNode"); WI (Name); WriteS (f, " ( Tree ) ;"); WriteNl (f);
           END;
           WriteNl (f);
        END;
        WriteNodeName ( Next ) ; 
;
      RETURN;
     END (* WITH *) ;

  END;
 END WriteNodeName;

PROCEDURE WriteNode (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 624 "" *)
     WITH t^.Class DO
(* line 624 "" *)
      
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           WriteS (f, "PROCEDURE yyyWriteNode"); WI (Name); WriteS (f, " ( yyt : "); WI ( itTree ); WriteS (f, " )"); WriteNl (f);
           WriteS (f, "  IS BEGIN"); WriteNl (f);
           WriteNodeAttributes ( t ) ; 
           WriteS (f, "    NULL ; "); WriteNl (f);
            
           WriteS (f, "  END yyyWriteNode"); WI (Name); WriteS (f, " ; "); WriteNl (f);
           WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END WriteNode;

PROCEDURE WriteNodeAttributes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.NoClass:
(* line 639 "" *)
      RETURN;

  | Tree.Class:
(* line 641 "" *)
     WITH t^.Class DO
(* line 641 "" *)
      
        WriteNodeAttributes ( BaseClass ) ; 
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           iClassName := Name; 
           ForallAttributes (Attributes, WriteNodeAttributes);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 649 "" *)
     WITH t^.Child DO
(* line 649 "" *)
      
        WriteS (f, '    yyWriteSelector ( "'); WI (Name); WriteS (f, '" ) ; '); WriteNl (f);
        WriteS (f, "    yyWriteAdr ( yyt . ALL . "); WI ( iClassName ) ; 
               WriteS (f, " . "); WI (Name); WriteS (f, " ) ; "); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 654 "" *)
     WITH t^.Attribute DO
(* line 654 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN
         IF Link IN Properties 
         THEN
           WriteS (f, '    yyWriteSelector ( "'); WI (Name); WriteS (f, '" ) ; '); WriteNl (f);
           WriteS (f, "    yyWriteAdr ( yyt . ALL . "); WI ( iClassName ) ; 
                  WriteS (f, " . "); WI (Name); WriteS (f, " ) ; "); WriteNl (f);
         ELSE  
           WriteS (f, '    yyWriteSelector ( "'); WI (Name); WriteS (f, '" ) ; write'); WI (Type);
           WriteS (f, "      ( yyt . ALL . "); WI ( iClassName ) ; 
                      WriteS (f, " . "); WI (Name) ; WriteS (f, " ) yyWriteNl  ; "); WriteNl (f);
         END; 
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END WriteNodeAttributes;

PROCEDURE Mark (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 672 "" *)
     WITH t^.Class DO
(* line 672 "" *)
      
        Mark ( Extensions ) ; 
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           WriteS (f, "    WHEN "); WI (Name); WriteS (f, " => "); WriteNl (f);
           GetIterator (t);
           iClassName := Name; 
           ForallAttributes (t, Mark);
           IF Iterator = NoTree THEN
              WriteS (f, "      RETURN ; "); WriteNl (f);
           ELSE
              WriteS (f, "      yyt := yyt . ALL . "); WI (iClassName); 
                       WriteS (f, " . "); WI (Iterator^.Child.Name); WriteS (f, " ; "); WriteNl (f);
           END;
        END;
        Mark ( Next ) ; 
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 689 "" *)
     WITH t^.Child DO
(* line 689 "" *)
      
        IF t # Iterator THEN
           WriteS (f, "      yyMark ( yyt . ALL . "); WI (iClassName); WriteS (f, " . "); WI (Name); WriteS (f, " ) ; "); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 695 "" *)
     WITH t^.Attribute DO
(* line 695 "" *)
      
        IF Link IN Properties THEN
           WriteS (f, "      yyMark ( yyt . ALL . "); WI (iClassName); WriteS (f, " . "); WI (Name); WriteS (f, " ) ; "); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Mark;

PROCEDURE WriteClassName (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 703 "" *)
     WITH t^.Class DO
(* line 703 "" *)
      
        WriteClassName ( Extensions ) ; 
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "   | "); WI (Name); WriteS (f, " ( TNode ) => "); WriteNl (f);
           IF ({HasChildren, HasAttributes} * Properties) # {} THEN
              WriteS (f, "       yWrite"); WI (Name); WriteS (f, " ( TNode ) ; "); WriteNl (f);
              GetIterator (t);
              IF Iterator = NoTree THEN
                WriteS (f, "       EXIT ;"); WriteNl (f);
              ELSE
                 WriteS (f, '       yyIndentSelector ( "'); WI (Iterator^.Child.Name); WriteS (f, '" ) ;'); 
                 WriteS (f, "       yyt := TNode . "); WI (Iterator^.Child.Name); WriteS (f, " ;"); WriteNl (f);
              END ;
           ELSE
              WriteS (f, '       Text_Io . Put ("'); WI (Name); WriteS (f, '" ) ; yyWriteNl  ; EXIT ;'); WriteNl (f);
           END;
        END;
        WriteClassName ( Next ) ; 
;
      RETURN;
     END (* WITH *) ;

  END;
 END WriteClassName;

PROCEDURE WriteAttributes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 725 "" *)
     WITH t^.Class DO
(* line 725 "" *)
      
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           WriteS (f, "PROCEDURE yWrite"); WI (Name); WriteS (f, " ( yyt : "); WI ( Name ); WriteS (f, " )"); WriteNl (f);
           WriteS (f, "=BEGIN"); WriteNl (f);
           WriteS (f, '  Text_Io . Put ("'); WI (Name); WriteS (f, '" ) ; yyWriteNl  ;'); WriteNl (f);
           GetIterator (t);
           iClassName := Name;  
           ForallAttributes (t, WriteAttributes);
           WriteS (f, " END yWrite"); WI (Name); WriteS (f, " ;"); WriteNl (f);
           WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 738 "" *)
     WITH t^.Child DO
(* line 738 "" *)
      
        IF t # Iterator THEN
           WriteS (f, '  yyIndentSelectorTree ( "'); WI (Name); WriteS (f, '" , yyt . '); WI (Name); WriteS (f, ' ) ;'); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 743 "" *)
     WITH t^.Attribute DO
(* line 743 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
         IF Link IN Properties 
         THEN
           WriteS (f, '  yyIndentSelectorTree ( "'); WI (Name); WriteS (f, '" , yyt . '); WI (Name); WriteS (f, ' ) ;'); WriteNl (f);
         ELSE 
           WriteS (f, '  yyIndentSelector ( "'); WI (Name); WriteS (f, '" ) ; '); 
           WriteS (f, "write"); WI (Type); WriteS (f, " ( yyt . "); WI (Name); WriteS (f, " ) yyWriteNl  ;"); WriteNl (f);
         END  ; 
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END WriteAttributes;

PROCEDURE NodeKinds (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 759 "" *)
     WITH t^.Class DO
(* line 760 "" *)
       NodeKinds ( Extensions ) ; 
     IF ( NoCodeClass * Properties = { } ) 
     THEN
       WriteS (f, "    WHEN "); WI ( Name ) ; WriteS (f, ' => RETURN "'); WI ( Name ) ; WriteS (f, '" ; '); WriteNl (f);
     END  ; 
     NodeKinds ( Next ) ; 
   ;
      RETURN;
     END (* WITH *) ;

  END;
 END NodeKinds;

PROCEDURE WriteHtmlNodes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 770 "" *)
     WITH t^.Class DO
(* line 771 "" *)
       
     IF ( NoCodeClass * Properties = { } ) 
     THEN
       WriteS (f, "  PROCEDURE Write"); WI ( Name ) ; WriteS (f, "Html ( TNode : tAst ) "); WriteNl (f);
       WriteS (f, "  IS "); WriteNl (f);
       WriteS (f, "    LNodeTag : STRING := yyNodeTag ( TNode ) ; "); WriteNl (f);
       WriteS (f, "  BEGIN "); WriteNl (f);
       WriteS (f, '    Text_Io . Put ( "<a name=__ADA_DQUOTE_IN_STRING__" ) ; '); WriteNl (f);
       WriteS (f, "    Text_Io . Put ( LNodeTag ) ; "); WriteNl (f);
       WriteS (f, '    Text_Io . Put ( "__ADA_DQUOTE_IN_STRING__>DEF " ) ; '); WriteNl (f);
       WriteS (f, "    Text_Io . Put ( LNodeTag ) ; "); WriteNl (f);
       WriteS (f, '    Text_Io . Put ( "(" ) ; '); WriteNl (f);
       WriteS (f, "    yyWriteAdr ( TNode ) ; "); WriteNl (f);
       WriteS (f, '    Text_Io . Put ( ")'); WI ( Name ) ; WriteS (f, '</a>" ) ; '); WriteNl (f);
       WriteS (f, "    yyWriteNl ; "); WriteNl (f);
       IF ( { HasChildren , HasAttributes } * Properties # { } ) 
       THEN 
         iClassName := Name; 
         ForallAttributes ( t , WriteHtmlNodes ) ; 
       END  ; 
       WriteS (f, "    yyWriteNl ; "); WriteNl (f);
       WriteS (f, "  END Write"); WI ( Name ) ; WriteS (f, "Html ; "); WriteNl (f);
       WriteNl (f);
     END  ; 
   ;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 797 "" *)
     WITH t^.Child DO
(* line 798 "" *)
       WriteS (f, '    WriteChildOrLink ( "'); WI ( Name ) ; WriteS (f, '" , "'); WI ( Type ) ; 
     WriteS (f, '" , TNode . ALL . '); WI ( iClassName ) ; WriteS (f, ' . '); WI ( Name ) ; WriteS (f, ' ) ; '); WriteNl (f);
   ;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 802 "" *)
     WITH t^.Attribute DO
(* line 803 "" *)
       IF (NoCodeAttr * Properties) = {} 
     THEN 
       IF Link IN Properties 
       THEN 
         WriteS (f, '    WriteChildOrLink ( "'); WI ( Name ) ; WriteS (f, '" , "'); WI ( Type ) ; 
         WriteS (f, '" , TNode . ALL . '); WI ( iClassName ) ; WriteS (f, ' . '); WI ( Name ) ; WriteS (f, ' , TRUE ) ; '); WriteNl (f);
       ELSIF Type = iBOOLEAN 
       THEN 
         WriteS (f, '    WriteBOOLEANAttribute ( "'); WI ( Name ) ; WriteS (f, '" , TNode . ALL . '); WI ( Name ) ; WriteS (f, ' ) ; '); WriteNl (f);
       ELSE
         WriteS (f, '    Text_Io . Put ( IndentString & "'); WI ( Name ) ; WriteS (f, ' : '); WI ( Type ) ; WriteS (f, ' = " ) ; '); WriteNl (f);
         WriteS (f, "    write"); WI ( Type ) ; WriteS (f, " ( TNode . ALL . "); WI ( iClassName ) ; WriteS (f, " . "); WI ( Name ) ; WriteS (f, " ) "); WriteNl (f);
          
         WriteS (f, "    yyWriteNl ; "); WriteNl (f);
       END  ; 
     END  ; 
   ;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END WriteHtmlNodes;

PROCEDURE WriteHtmlCases (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 823 "" *)
     WITH t^.Class DO
(* line 824 "" *)
       WriteHtmlCases ( Extensions ) ; 
     IF ( NoCodeClass * Properties = { } ) 
     THEN
       WriteS (f, "     WHEN "); WI ( Name ) ; WriteS (f, " => "); WriteNl (f);
       WriteS (f, "         Write"); WI ( Name ) ; WriteS (f, "Html ( yyt ) ; "); WriteNl (f);
       IF ( { HasChildren , HasAttributes } * Properties # { } ) 
       THEN 
         GetIterator ( t ) ; 
         iClassName := Name; 
         ForallAttributes ( t , WriteHtmlCases ) ;  
         IF Iterator = NoTree THEN
           WriteS (f, "         EXIT ; "); WriteNl (f);
         ELSE
           WriteS (f, "         yyt := yyt . ALL . "); WI (iClassName); WriteS (f, " . "); WI ( Iterator ^ . Child . Name ) ; WriteS (f, " ; "); WriteNl (f);
         END;
       END  
     END  ;  
     WriteHtmlCases ( Next ) ;  
   ;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 844 "" *)
     WITH t^.Child DO
(* line 845 "" *)
       IF t # Iterator 
     THEN
         WriteS (f, "         WriteHtmlRecurse ( yyt . ALL . "); WI (iClassName); WriteS (f, " . "); WI ( Name ) ; WriteS (f, " ) ;"); WriteNl (f);
     END  ; 
   ;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 851 "" *)
     WITH t^.Attribute DO
(* line 852 "" *)
       IF Link IN Properties  
     THEN
         WriteS (f, "         WriteHtmlRecurse ( yyt . ALL . "); WI (iClassName); WriteS (f, " . "); WI ( Name ) ; WriteS (f, " ) ;"); WriteNl (f);
     END  ; 
   ;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END WriteHtmlCases;

PROCEDURE GetIterator (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 901 "" *)
     WITH t^.Class DO
(* line 901 "" *)
      
        Iterator := NoTree;
        RevChild := NoTree;
        ForallAttributes (t, GetIterator);
        IF RevChild # NoTree THEN Iterator := RevChild; END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 907 "" *)
     WITH t^.Child DO
(* line 907 "" *)
      
        Iterator := t;
        IF Reverse IN Properties THEN RevChild := t; END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END GetIterator;

PROCEDURE BeginTreeAda2;
 BEGIN
(* line 77 "" *)
 

  Strings . ArrayToString ( "BOOLEAN" , sBOOLEAN ) ; 
  iBOOLEAN := Idents . MakeIdent ( sBOOLEAN ) ; 



 END BeginTreeAda2;

PROCEDURE CloseTreeAda2;
 BEGIN

 END CloseTreeAda2;

PROCEDURE yyExit;
 BEGIN
  IO.CloseIO; System.Exit (1);
 END yyExit;

BEGIN
 yyf   := IO.StdOutput;
 Exit  := yyExit;
 BeginTreeAda2;
END TreeAda2.

