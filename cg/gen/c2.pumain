/* Ich, Doktor Josef Grosch, Informatiker, 28.6.1990 */
/* Modified Rodney M. Bates: 
   July 1999 changed procedure name yWriteNode to yyyWriteNode, to avoid
            possible conflict with yWrite<Class>, where <Class> = "Node"
   July 1999 Added cases to Mark, WriteTREEm to follow LINK Attributes 

*/ 

TRAFO TreeC2
TREE Tree
PUBLIC TreeIO GetIterator

EXPORT  {
FROM Positions  IMPORT tPosition;

VAR Iterator    : Tree.tTree;

PROCEDURE WriteLine (Line: tPosition);
}

GLOBAL  {

FROM IO         IMPORT WriteS, WriteNl;
FROM Sets       IMPORT IsElement;
FROM Idents     IMPORT tIdent;
FROM Positions  IMPORT tPosition;

FROM Tree       IMPORT
   NoTree       , tTree         , Options       , ClassCount    ,
   f            , WI    , WN    , iInteger      , itTree        ,
   iNoTree      , iModule       , iMain         , HasChildren   ,
   HasAttributes, NoCodeAttr    , NoCodeClass   ,
   ForallClasses, ForallAttributes, Reverse     , Link ;

VAR
   iClassName   : tIdent;
   RevChild     : tTree;

PROCEDURE WriteLine (Line: tPosition);
   BEGIN
      IF Line.Line # 0 THEN
         IF IsElement (ORD ('6'), Options) THEN
            WriteS (f, "# line "); WN (Line.Line); WriteS (f, ' "'); WI (Line.File); WriteS (f, '"'); WriteNl (f);
         ELSE
            WriteS (f, "/* line "); WN (Line.Line); WriteS (f, ' "'); WI (Line.File); WriteS (f, '" */'); WriteNl (f);
         END;
      END;
   END WriteLine;
}

PROCEDURE TreeIO (t: Tree)

Ag (..) :- {
        WriteS (f, "typedef "); WI (itTree); WriteS (f, " * yyPtrtTree;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static FILE * yyf;"); WriteNl (f);
        WriteNl (f);
      IF IsElement (ORD (','), Options) THEN
        WriteS (f, "static void yyMark"); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " (register "); WI (itTree); WriteS (f, " yyt)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyt) register "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " for (;;) {"); WriteNl (f);
        WriteS (f, "  if (yyt == "); WI (iNoTree); WriteS (f, " || ++ yyt->yyHead.yyMark > 1) return;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  switch (yyt->Kind) {"); WriteNl (f);
        ForallClasses (Classes, Mark);
        WriteS (f, "  default: return;"); WriteNl (f);
        WriteS (f, "  }"); WriteNl (f);
        WriteS (f, " }"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD (';'), Options) THEN
        WriteS (f, "# define yyInitTreeStoreSize 32"); WriteNl (f);
        WriteS (f, "# define yyMapToTree(yyLabel) yyTreeStorePtr [yyLabel]"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static unsigned long yyTreeStoreSize = yyInitTreeStoreSize;"); WriteNl (f);
        WriteS (f, "static "); WI (itTree); WriteS (f, " yyTreeStore [yyInitTreeStoreSize];"); WriteNl (f);
        WriteS (f, "static "); WI (itTree); WriteS (f, " * yyTreeStorePtr = yyTreeStore;"); WriteNl (f);
        WriteS (f, "static int yyLabelCount;"); WriteNl (f);
        WriteS (f, "static short yyRecursionLevel = 0;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static "); WI (iMain); WriteS (f, "_tLabel yyMapToLabel"); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " ("); WI (itTree); WriteS (f, " yyt)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyt) "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " register int yyi;"); WriteNl (f);
        WriteS (f, " for (yyi = 1; yyi <= yyLabelCount; yyi ++) if (yyTreeStorePtr [yyi] == yyt) return yyi;"); WriteNl (f);
        WriteS (f, " if (++ yyLabelCount == yyTreeStoreSize)"); WriteNl (f);
        WriteS (f, "  ExtendArray ((char * *) & yyTreeStorePtr, & yyTreeStoreSize, sizeof ("); WI (itTree); WriteS (f, "));"); WriteNl (f);
        WriteS (f, " yyTreeStorePtr [yyLabelCount] = yyt;"); WriteNl (f);
        WriteS (f, " return yyLabelCount;"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('w'), Options) OR
         IsElement (ORD ('o'), Options) THEN
        WriteS (f, "static void yyWrite"); WI (iModule); WriteS (f, " ();"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static void yyWriteNl () { (void) putc ('\n', yyf); }"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static void yyWriteSelector"); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " (char * yys)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yys) char * yys;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " register int yyi = 16 - strlen (yys);"); WriteNl (f);
        WriteS (f, ' (void) fputs (yys, yyf);'); WriteNl (f);
        WriteS (f, " while (yyi -- > 0) (void) putc (' ', yyf);"); WriteNl (f);
        WriteS (f, ' (void) fputs (" = ", yyf);'); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static void yyWriteHex"); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " (unsigned char * yyx, int yysize)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyx, yysize) unsigned char * yyx; int yysize;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, '{ register int yyi; for (yyi = 0; yyi < yysize; yyi ++) (void) fprintf (yyf, "%02x ", yyx [yyi]); }'); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('o'), Options) THEN
        WriteS (f, "static void yyWriteAdr"); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " ("); WI (itTree); WriteS (f, " yyt)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyt) "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " if (yyt == "); WI (iNoTree); WriteS (f, ') (void) fputs ("'); WI (iNoTree); WriteS (f, '", yyf);'); WriteNl (f);
        WriteS (f, " else yyWriteHex ((unsigned char *) & yyt, sizeof (yyt));"); WriteNl (f);
        WriteS (f, " yyWriteNl ();"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        ForallClasses (Classes, WriteNode);
        WriteS (f, "void Write"); WI (iModule); WriteS (f, "Node"); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " (FILE * yyyf, "); WI (itTree); WriteS (f, " yyt)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyyf, yyt) FILE * yyyf; "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " yyf = yyyf;"); WriteNl (f);
        WriteS (f, " if (yyt == "); WI (iNoTree); WriteS (f, ') { (void) fputs ("'); WI (iNoTree); WriteS (f, '\n", yyf); return; }'); WriteNl (f);
        WriteNl (f);
        WriteS (f, " switch (yyt->Kind) {"); WriteNl (f);
        ForallClasses (Classes, WriteNodeName);
        WriteS (f, " default: ;"); WriteNl (f);
        WriteS (f, " }"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('w'), Options) THEN
        WriteS (f, "static short yyIndentLevel;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "void Write"); WI (iModule); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " (FILE * yyyf, "); WI (itTree); WriteS (f, " yyt)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyyf, yyt) FILE * yyyf; "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " short yySaveLevel = yyIndentLevel;"); WriteNl (f);
        WriteS (f, " yyf = yyyf;"); WriteNl (f);
        WriteS (f, " if (yyRecursionLevel ++ == 0) yyLabelCount = 0;"); WriteNl (f);
        WriteS (f, " yyMark (yyt);"); WriteNl (f);
        WriteS (f, " yyIndentLevel = 0;"); WriteNl (f);
        WriteS (f, " yyWrite"); WI (iModule); WriteS (f, " (yyt);"); WriteNl (f);
        WriteS (f, " yyIndentLevel = yySaveLevel;"); WriteNl (f);
        WriteS (f, " yyRecursionLevel --;"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static void yyIndentSelector"); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " (char * yys)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yys) char * yys;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " register int yyi;"); WriteNl (f);
        WriteS (f, " for (yyi = 1; yyi <= yyIndentLevel; yyi ++) (void) putc (' ', yyf);"); WriteNl (f);
        WriteS (f, " yyWriteSelector (yys);"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static void yyIndentSelectorTree"); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " (char * yys, "); WI (itTree); WriteS (f, " yyt)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yys, yyt) char * yys; "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{ yyIndentSelector (yys); write"); WI (itTree); WriteS (f, " (yyt) }"); WriteNl (f);
        WriteNl (f);
        ForallClasses (Classes, WriteAttributes);
        WriteS (f, "static void yyWrite"); WI (iModule); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " ("); WI (itTree); WriteS (f, " yyt)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyt) "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{ unsigned short yyLevel = yyIndentLevel;"); WriteNl (f);
        WriteS (f, " for (;;) {"); WriteNl (f);
        WriteS (f, "  if (yyt == "); WI (iNoTree); WriteS (f, ') { (void) fputs (" '); WI (iNoTree); WriteS (f, '\n", yyf); goto yyExit;'); WriteNl (f);
        WriteS (f, '  } else if (yyt->yyHead.yyMark == 0) { (void) fprintf (yyf, "^%d\n", yyMapToLabel (yyt)); goto yyExit;'); WriteNl (f);
        WriteS (f, "  } else if (yyt->yyHead.yyMark > 1) {"); WriteNl (f);
        WriteS (f, "   register int yyi;"); WriteNl (f);
        WriteS (f, '   (void) fprintf (yyf, "\n%06d:", yyMapToLabel (yyt));'); WriteNl (f);
        WriteS (f, "   for (yyi = 8; yyi <= yyIndentLevel; yyi ++) (void) putc (' ', yyf);"); WriteNl (f);
        WriteS (f, "  } else (void) putc (' ', yyf);"); WriteNl (f);
        WriteS (f, "  yyt->yyHead.yyMark = 0;"); WriteNl (f);
        WriteS (f, "  yyIndentLevel += 2;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  switch (yyt->Kind) {"); WriteNl (f);
        ForallClasses (Classes, WriteClassName);
        WriteS (f, "  default: goto yyExit;"); WriteNl (f);
        WriteS (f, "  }"); WriteNl (f);
        WriteS (f, " }"); WriteNl (f);
        WriteS (f, "yyExit:"); WriteNl (f);
        WriteS (f, " yyIndentLevel = yyLevel;"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('r'), Options) THEN
        WriteS (f, "static tIdent yyKindToIdent ["); WN (ClassCount); WriteS (f, " + 1];"); WriteNl (f);
        WriteS (f, "static bool yyIsInitialized = false;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static short yyMapToKind"); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " (char * yys)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yys) char * yys;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " register int yyk;"); WriteNl (f);
        WriteS (f, " register tIdent yyi = MakeIdent ((tString) yys, strlen (yys));"); WriteNl (f);
        WriteS (f, " for (yyk = 0; yyk <= "); WN (ClassCount); WriteS (f, "; yyk ++) {"); WriteNl (f);
        WriteS (f, "  if (yyKindToIdent [yyk] == yyi) return yyk;"); WriteNl (f);
        WriteS (f, " }"); WriteNl (f);
        WriteS (f, " return 0;"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        WriteS (f, 'static void yyReadNl () { (void) fscanf (yyf, "\n"); }'); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static tIdent yyReadIdent ()"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " char yys [256];"); WriteNl (f);
        WriteS (f, ' (void) fscanf (yyf, "%s", yys);'); WriteNl (f);
        WriteS (f, " return MakeIdent ((tString) yys, strlen (yys));"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static void yyReadHex"); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " (unsigned char * yyx, int yysize)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyx, yysize) unsigned char * yyx; int yysize;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " register int yyi; int yyk;"); WriteNl (f);
        WriteS (f, ' for (yyi = 0; yyi < yysize; yyi ++) { (void) fscanf (yyf, "%x ", & yyk); yyx [yyi] = yyk; }'); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        WriteS (f, 'static void yySkip () { (void) fscanf (yyf, " %*s =%*c"); }'); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static void yyRead"); WI (iModule); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " (yyPtrtTree yyt)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyt) yyPtrtTree yyt;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " static "); WI (iMain); WriteS (f, "_tLabel yyLabel;"); WriteNl (f);
        WriteS (f, " static "); WI (iMain); WriteS (f, "_tKind yyKind;"); WriteNl (f);
        WriteS (f, " static char yys [256];"); WriteNl (f);
        WriteS (f, " for (;;) {"); WriteNl (f);
        WriteS (f, "  switch (getc (yyf)) {"); WriteNl (f);
        WriteS (f, "  case '^':");WriteS (f, ' (void) fscanf (yyf, "%hd\n", & yyLabel); * yyt = yyMapToTree (yyLabel); return;'); WriteNl (f);
        WriteS (f, "  case '\n': case '0':");WriteS (f, ' (void) fscanf (yyf, "%hd%*c %s\n", & yyLabel, yys);'); WriteNl (f);
        WriteS (f, "   yyKind = yyMapToKind (yys); * yyt = Make"); WI (iMain); WriteS (f, " (yyKind);"); WriteNl (f);
        WriteS (f, '   if (yyLabel != yyMapToLabel (* yyt)) { (void) fputs ("'); WI (iModule);
        WriteS (f, ": error in Read"); WI (iModule); WriteS (f, '\n", stderr); '); WI (iMain); WriteS (f, "_Exit (); } break;"); WriteNl (f);
        WriteS (f, "  default: ;"); WriteNl (f);
        WriteS (f, '   (void) fscanf (yyf, "%s", yys);'); WriteNl (f);
        WriteS (f, "   yyKind = yyMapToKind (yys);"); WriteNl (f);
        WriteS (f, "   if (yyKind == 0) { * yyt = "); WI (iNoTree); WriteS (f, "; return; }"); WriteNl (f);
        WriteS (f, "   * yyt = Make"); WI (iMain); WriteS (f, " (yyKind);"); WriteNl (f);
        WriteS (f, "  }"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  switch (yyKind) {"); WriteNl (f);
        ForallClasses (Classes, ReadAttributes);
        WriteS (f, "  default: return;"); WriteNl (f);
        WriteS (f, "  }"); WriteNl (f);
        WriteS (f, " }"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        WI (itTree); WriteS (f, " Read"); WI (iModule); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " (FILE * yyyf)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyyf) FILE * yyyf;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
        WriteS (f, " yyf = yyyf;"); WriteNl (f);
        WriteS (f, " if (yyRecursionLevel ++ == 0) yyLabelCount = 0;"); WriteNl (f);
        WriteS (f, ' if (! yyIsInitialized) {'); WriteNl (f);
        WriteS (f, "  register int yyi;"); WriteNl (f);
        WriteS (f, "  for (yyi = 0; yyi <= "); WN (ClassCount); WriteS (f, "; yyi ++)"); WriteNl (f);
        WriteS (f, "   yyKindToIdent [yyi] = MakeIdent ((tString) "); WI (iMain); WriteS (f, "_NodeName [yyi], strlen ("); WI (iMain); WriteS (f, "_NodeName [yyi]));"); WriteNl (f);
        WriteS (f, "  yyIsInitialized = true;"); WriteNl (f);
        WriteS (f, " }"); WriteNl (f);
        WriteS (f, " yyRead"); WI (iModule); WriteS (f, " (& yyt);"); WriteNl (f);
        WriteS (f, " yyRecursionLevel --;"); WriteNl (f);
        WriteS (f, " return yyt;"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
      END;
        WriteS (f, "# define yyNil 0374"); WriteNl (f);
        WriteS (f, "# define yyNoLabel     0375"); WriteNl (f);
        WriteS (f, "# define yyLabelDef    0376"); WriteNl (f);
        WriteS (f, "# define yyLabelUse    0377"); WriteNl (f);
        WriteNl (f);
      IF IsElement (ORD ('p'), Options) THEN
        WriteS (f, "static void yyPut"); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " (char * yyx, int yysize)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyx, yysize) char * yyx; int yysize;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{ (void) fwrite (yyx, 1, yysize, yyf); }"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static void yyPutIdent"); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " (tIdent yyi)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyi) tIdent yyi;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " char yys [256];"); WriteNl (f);
        WriteS (f, " GetString (yyi, (tString) yys);"); WriteNl (f);
        WriteS (f, ' (void) fprintf (yyf, "%s\n", yys);'); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static void yyPut"); WI (iModule); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " ("); WI (itTree); WriteS (f, " yyt)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyt) "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " static "); WI (iMain); WriteS (f, "_tLabel yyLabel;"); WriteNl (f);
        WriteS (f, " for (;;) {"); WriteNl (f);
        WriteS (f, "  if (yyt == "); WI (iNoTree); WriteS (f, ") {"); WriteNl (f);
        WriteS (f, "   (void) putc (yyNil, yyf); return;"); WriteNl (f);
        WriteS (f, "  } else if (yyt->yyHead.yyMark == 0) {"); WriteNl (f);
        WriteS (f, "   (void) putc (yyLabelUse, yyf); yyLabel = yyMapToLabel (yyt); yyPut ((char *) & yyLabel, sizeof (yyLabel)); return;"); WriteNl (f);
        WriteS (f, "  } else if (yyt->yyHead.yyMark > 1) {"); WriteNl (f);
        WriteS (f, "   (void) putc (yyLabelDef, yyf); yyLabel = yyMapToLabel (yyt); yyPut ((char *) & yyLabel, sizeof (yyLabel));"); WriteNl (f);
        IF ClassCount > 251 THEN
        WriteS (f, "   yyPut ((char *) & yyt->Kind, sizeof ("); WI (iMain); WriteS (f, "_tKind));"); WriteNl (f);
        WriteS (f, "  } else if (yyt->Kind > 251) {"); WriteNl (f);
        WriteS (f, "   (void) putc (yyNoLabel, yyf); yyPut ((char *) & yyt->Kind, sizeof ("); WI (iMain); WriteS (f, "_tKind));"); WriteNl (f);
        ELSE
        WriteS (f, "   (void) putc ((char) yyt->Kind, yyf);"); WriteNl (f);
        END;
        WriteS (f, "  } else {"); WriteNl (f);
        WriteS (f, "   (void) putc ((char) yyt->Kind, yyf);"); WriteNl (f);
        WriteS (f, "  }"); WriteNl (f);
        WriteS (f, "  yyt->yyHead.yyMark = 0;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  switch (yyt->Kind) {"); WriteNl (f);
        ForallClasses (Classes, PutAttributes);
        WriteS (f, "  default: return;"); WriteNl (f);
        WriteS (f, "  }"); WriteNl (f);
        WriteS (f, " }"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "void Put"); WI (iModule); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " (FILE * yyyf, "); WI (itTree); WriteS (f, " yyt)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyyf, yyt) FILE * yyyf; "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " yyf = yyyf;"); WriteNl (f);
        WriteS (f, " if (yyRecursionLevel ++ == 0) yyLabelCount = 0;"); WriteNl (f);
        WriteS (f, " yyMark (yyt);"); WriteNl (f);
        WriteS (f, " yyPut"); WI (iModule); WriteS (f, " (yyt);"); WriteNl (f);
        WriteS (f, " yyRecursionLevel --;"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('g'), Options) THEN
        WriteS (f, "static void yyGet"); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " (char * yyx, int yysize)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyx, yysize) char * yyx; int yysize;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{ (void) fread (yyx, 1, yysize, yyf); }"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static void yyGetIdent"); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " (tIdent * yyi)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyi) tIdent * yyi;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " char yys [256];"); WriteNl (f);
        WriteS (f, ' (void) fscanf (yyf, "%s%*c", yys);'); WriteNl (f);
        WriteS (f, " * yyi = MakeIdent ((tString) yys, strlen (yys));"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static void yyGet"); WI (iModule); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " (yyPtrtTree yyt)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyt) yyPtrtTree yyt;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " static "); WI (iMain); WriteS (f, "_tLabel yyLabel;"); WriteNl (f);
        WriteS (f, " static "); WI (iMain); WriteS (f, "_tKind yyKind;"); WriteNl (f);
        WriteS (f, " for (;;) {"); WriteNl (f);
        WriteS (f, "  switch (yyKind = getc (yyf)) {"); WriteNl (f);
        WriteS (f, "  case yyNil           : * yyt = "); WI (iNoTree); WriteS (f, "; return;"); WriteNl (f);
        WriteS (f, "  case yyLabelUse      : yyGet ((char *) & yyLabel, sizeof (yyLabel));"); WriteNl (f);
        WriteS (f, "   * yyt = yyMapToTree (yyLabel); return;"); WriteNl (f);
        WriteS (f, "  case yyLabelDef      : yyGet ((char *) & yyLabel, sizeof (yyLabel));"); WriteNl (f);
        IF ClassCount > 251 THEN
        WriteS (f, "   yyGet ((char *) & yyKind, sizeof (yyKind));"); WriteNl (f);
        ELSE
        WriteS (f, "   yyKind = getc (yyf);"); 
        END;
        WriteS (f, "   * yyt = Make"); WI (iMain); WriteS (f, " (yyKind);"); WriteNl (f);
        WriteS (f, '   if (yyLabel != yyMapToLabel (* yyt)) { (void) fputs ("'); WI (iModule);
        WriteS (f, ": error in Get"); WI (iModule); WriteS (f, '\n", stderr); '); WI (iMain); WriteS (f, "_Exit (); } break;"); WriteNl (f);
        IF ClassCount > 251 THEN
        WriteS (f, "  case yyNoLabel       : yyGet ((char *) & yyKind, sizeof (yyKind));"); WriteNl (f);
        WriteS (f, "   * yyt = Make"); WI (iMain); WriteS (f, " (yyKind); break;"); WriteNl (f);
        END;
        WriteS (f, "  default      : * yyt = Make"); WI (iMain); WriteS (f, " (yyKind);"); WriteNl (f);
        WriteS (f, "  }"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  switch (yyKind) {"); WriteNl (f);
        ForallClasses (Classes, GetAttributes);
        WriteS (f, "  default: return;"); WriteNl (f);
        WriteS (f, "  }"); WriteNl (f);
        WriteS (f, " }"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        WI (itTree); WriteS (f, " Get"); WI (iModule); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " (FILE * yyyf)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyyf) FILE * yyyf;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
        WriteS (f, " yyf = yyyf;"); WriteNl (f);
        WriteS (f, " if (yyRecursionLevel ++ == 0) yyLabelCount = 0;"); WriteNl (f);
        WriteS (f, " yyGet"); WI (iModule); WriteS (f, " (& yyt);"); WriteNl (f);
        WriteS (f, " yyRecursionLevel --;"); WriteNl (f);
        WriteS (f, " return yyt;"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
      END;
}; .


PROCEDURE WriteNodeName (t: Tree)

Class (..) :- {
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "case k"); WI (Name); WriteS (f, ": (void) fputs ("); WI (iMain); WriteS (f, "_NodeName [k"); WI (Name);
           WriteS (f, "], yyf); (void) fputc ('\n', yyf);"); WriteNl (f);
           IF ({HasChildren, HasAttributes} * Properties) # {} THEN
              WriteS (f, " yyyWriteNode"); WI (Name); WriteS (f, " (yyt);"); 
           END;
           WriteS (f, " break;"); WriteNl (f);
        END;
}; .


PROCEDURE WriteNode (t: Tree)

Class (..) :- {
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           WriteS (f, "static void yyyWriteNode"); WI (Name); WriteNl (f);
           WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
           WriteS (f, " ("); WI (itTree); WriteS (f, " yyt)"); WriteNl (f);
           WriteS (f, "# else"); WriteNl (f);
           WriteS (f, " (yyt) "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
           WriteS (f, "# endif"); WriteNl (f);
           WriteS (f, "{"); WriteNl (f);
           IF (BaseClass^.Kind = Tree.Class) AND                (* NOT Top ? *)
              (({HasChildren, HasAttributes} * BaseClass^.Class.Properties) # {}) THEN
           WriteS (f, " yyyWriteNode"); WI (BaseClass^.Class.Name); WriteS (f, " (yyt); "); WriteNl (f);
           END;
           iClassName := Name;
           ForallAttributes (Attributes, WriteNode);
           WriteS (f, "}"); WriteNl (f);
           WriteNl (f);
        END;
}; .
Child (..) :- {
        WriteS (f, ' yyWriteSelector ("'); WI (Name); WriteS (f, '");'); 
        WriteS (f, " yyWriteAdr (yyt->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ");"); WriteNl (f);
}; .
Attribute (..) :- {
        IF (NoCodeAttr * Properties) = {} 
        THEN 
          IF Link IN Properties
          THEN 
            WriteS (f, ' yyWriteSelector ("'); WI (Name); WriteS (f, '");'); 
            WriteS (f, " yyWriteAdr (yyt->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ");"); WriteNl (f);
          ELSE 
            WriteS (f, ' yyWriteSelector ("'); WI (Name); WriteS (f, '"); write'); WI (Type);
            WriteS (f, " (yyt->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ") yyWriteNl ();"); WriteNl (f);
          END;
        END;
}; .


PROCEDURE Mark (t: Tree)

Class (..) :- {
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           WriteS (f, "case k"); WI (Name); WriteS (f, ":"); WriteNl (f);
           GetIterator (t);
           iClassName := Name;
           ForallAttributes (t, Mark);
           IF Iterator = NoTree THEN
              WriteS (f, "return;"); WriteNl (f);
           ELSE
              WriteS (f, "yyt = yyt->"); WI (iClassName); WriteS (f, "."); WI (Iterator^.Child.Name); WriteS (f, "; break;"); WriteNl (f);
           END;
        END;
}; .
Child (..) :- {
        IF t # Iterator THEN
           WriteS (f, "yyMark (yyt->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ");"); WriteNl (f);
        END;
}; .
Attribute (..) :- {
        IF Link IN Properties THEN
           WriteS (f, "yyMark (yyt->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ");"); WriteNl (f);
        END;
}; .


PROCEDURE WriteClassName (t: Tree)

Class (..) :- {
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "case k"); WI (Name); WriteS (f, ": "); 
           IF ({HasChildren, HasAttributes} * Properties) # {} THEN
              WriteS (f, "yWrite"); WI (Name); WriteS (f, " (yyt); "); 
              GetIterator (t);
              IF Iterator = NoTree THEN
                 WriteS (f, "goto yyExit;"); WriteNl (f);
              ELSE
                 WriteS (f, 'yyIndentSelector ("'); WI (Iterator^.Child.Name); WriteS (f, '"); '); 
                 WriteS (f, "yyt = yyt->"); WI (Name); WriteS (f, "."); WI (Iterator^.Child.Name); WriteS (f, "; break;"); WriteNl (f);
              END;
           ELSE
              WriteS (f, "(void) fputs ("); WI (iMain); WriteS (f, "_NodeName [k"); WI (Name);
              WriteS (f, "], yyf); (void) fputc ('\n', yyf); goto yyExit;"); WriteNl (f);
           END;
        END;
}; .


PROCEDURE WriteAttributes (t: Tree)

Class (..) :- {
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           WriteS (f, "static void yWrite"); WI (Name); WriteNl (f);
           WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
           WriteS (f, " ("); WI (itTree); WriteS (f, " yyt)"); WriteNl (f);
           WriteS (f, "# else"); WriteNl (f);
           WriteS (f, " (yyt) "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
           WriteS (f, "# endif"); WriteNl (f);
           WriteS (f, "{"); WriteNl (f);
           WriteS (f, " (void) fputs ("); WI (iMain); WriteS (f, "_NodeName [k"); WI (Name);
           WriteS (f, "], yyf); (void) fputc ('\n', yyf);"); WriteNl (f);
           GetIterator (t);
           iClassName := Name;
           ForallAttributes (t, WriteAttributes);
           WriteS (f, "}"); WriteNl (f);
           WriteNl (f);
        END;
}; .
Child (..) :- {
        IF t # Iterator THEN
           WriteS (f, ' yyIndentSelectorTree ("'); WI (Name); WriteS (f, '", yyt->'); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ");"); WriteNl (f);
        END;
}; .
Attribute (..) :- {
        IF (NoCodeAttr * Properties) = {} 
        THEN 
          IF Link IN Properties
          THEN
            WriteS (f, ' yyIndentSelectorTree ("'); WI (Name); WriteS (f, '", yyt->'); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ");"); WriteNl (f);
          ELSE 
            WriteS (f, ' yyIndentSelector ("'); WI (Name); WriteS (f, '"); '); 
            WriteS (f, "write"); WI (Type); WriteS (f, " (yyt->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ") yyWriteNl ();"); WriteNl (f);
          END;
        END;
}; .


PROCEDURE ReadAttributes (t: Tree)

Class (..) :- {
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           WriteS (f, "case k"); WI (Name); WriteS (f, ":"); WriteNl (f);
           GetIterator (t);
           iClassName := Name;
           ForallAttributes (t, ReadAttributes);
           IF Iterator = NoTree THEN
              WriteS (f, "return;"); WriteNl (f);
           ELSE
              WriteS (f, "yySkip (); yyt = & ((* yyt)->"); WI (iClassName); WriteS (f, "."); WI (Iterator^.Child.Name); WriteS (f, "); break;"); WriteNl (f);
           END;
        END;
}; .
Child (..) :- {
        IF t # Iterator THEN
           WriteS (f, "yySkip (); read"); WI (itTree); WriteS (f, " (& ((* yyt)->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, "))"); WriteNl (f);
        END;
}; .
Attribute (..) :- {
        IF (NoCodeAttr * Properties) = {} THEN 
           WriteS (f, "yySkip (); read"); WI (Type); WriteS (f, " ((* yyt)->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ") yyReadNl ();"); WriteNl (f);
        END;
}; .


PROCEDURE PutAttributes (t: Tree)

Class (..) :- {
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           WriteS (f, "case k"); WI (Name); WriteS (f, ":"); WriteNl (f);
           GetIterator (t);
           iClassName := Name;
           ForallAttributes (t, PutAttributes);
           IF Iterator = NoTree THEN
              WriteS (f, "return;"); WriteNl (f);
           ELSE
              WriteS (f, "yyt = yyt->"); WI (iClassName); WriteS (f, "."); WI (Iterator^.Child.Name); WriteS (f, "; break;"); WriteNl (f);
           END;
        END;
}; .
Child (..) :- {
        IF t # Iterator THEN
           WriteS (f, "put"); WI (itTree); WriteS (f, " (yyt->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ")"); WriteNl (f);
        END;
}; .
Attribute (..) :- {
        IF (NoCodeAttr * Properties) = {} THEN 
           WriteS (f, "put"); WI (Type); WriteS (f, " (yyt->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ")"); WriteNl (f);
        END;
}; .


PROCEDURE GetAttributes (t: Tree)

Class (..) :- {
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           WriteS (f, "case k"); WI (Name); WriteS (f, ":"); WriteNl (f);
           GetIterator (t);
           iClassName := Name;
           ForallAttributes (t, GetAttributes);
           IF Iterator = NoTree THEN
              WriteS (f, "return;"); WriteNl (f);
           ELSE
              WriteS (f, "yyt = & ((* yyt)->"); WI (iClassName); WriteS (f, "."); WI (Iterator^.Child.Name); WriteS (f, "); break;"); WriteNl (f);
           END;
        END;
}; .
Child (..) :- {
        IF t # Iterator THEN
           WriteS (f, "get"); WI (itTree); WriteS (f, " (& ((* yyt)->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, "))"); WriteNl (f);
        END;
}; .
Attribute (..) :- {
        IF (NoCodeAttr * Properties) = {} THEN 
           WriteS (f, "get"); WI (Type); WriteS (f, " ((* yyt)->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ")"); WriteNl (f);
        END;
}; .


PROCEDURE GetIterator (t: Tree)

Class (..) :- {
        Iterator := NoTree;
        RevChild := NoTree;
        ForallAttributes (t, GetIterator);
        IF RevChild # NoTree THEN Iterator := RevChild; END;
}; .
Child (..) :- {
        Iterator := t;
        IF Reverse IN Properties THEN RevChild := t; END;
}; .

