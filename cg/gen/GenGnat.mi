
(* This file was mechanically generated by puma. *)

IMPLEMENTATION MODULE GenGnat;








IMPORT SYSTEM, System, IO, Tree;
(* line 14 "" *)


(* IMPORT IO; This is already generated by puma *) 
FROM IO		IMPORT WriteS, WriteNl;
IMPORT Idents , Errors ; 
FROM Idents	IMPORT tIdent;
FROM Sets       IMPORT IsElement;
FROM Tree	IMPORT
   NoTree	, tTree		, 
   Class	, Child		, Attribute	, 
   NoCodeAttr	, NoCodeClass	, Link          , Low           ,
   iNoTree	, Options       , 
   itTree	, iMain		, iModule	, f		,
   WI	        , ForallClasses	, ForallAttributes, 
   IdentifyClass ;

IMPORT Positions , Strings;

VAR debug1 : BOOLEAN ; 

VAR Node : tTree;
VAR gNClassNonEmptyClass : tTree ; 
VAR gEntityClass : tTree ; 
VAR gIdentNodeNumber : tIdent ;
VAR gIdentNext : tIdent ;
VAR gIdentPrev : tIdent ;
VAR gIdentIsListMember : tIdent ;
VAR gIdentLink : tIdent ;
VAR gIdentSloc : tIdent ;
VAR gIdentIsRewriteSubstitution : tIdent ;
VAR gIdentIsRewriteInsertion : tIdent ;
VAR gIdentComesFromSource : tIdent ;
VAR gIdentAnalyzed : tIdent ;
VAR gIdentErrorPosted : tIdent ;
VAR gIdentParenCount : tIdent ;
VAR gIdentHasDynamicLengthCheck : tIdent ;
VAR gIdentHasDynamicRangeCheck : tIdent ;
VAR gIdentDiscriminantConstraint : tIdent ;
VAR gIdentPrimitiveOperations : tIdent ;
VAR gIdentPrivalsChain : tIdent ;
VAR gIdentPrivateDependents : tIdent ;
VAR gIdentGirderConstraint : tIdent ;
VAR gIdentDefiningIdentifier : tIdent ;
VAR gIdentMechanism : tIdent ;


VAR gIdentChars : tIdent ;
VAR gIdentNextEntity : tIdent ;
VAR gIdentScope : tIdent ;
VAR gIdentHomonym : tIdent ;
VAR gIdentEtype : tIdent ;
VAR gIdentEinfo : tIdent ;
VAR gIdentSinfo : tIdent ;
VAR gIdentGnatUtils : tIdent ;
VAR gIdentGnatAdaUtils : tIdent ;
VAR gIdentAtree : tIdent ;
VAR gIdentNlists : tIdent ;
VAR gIdentNClassNonEmpty : tIdent ;
VAR gIdentNClassEntity : tIdent ;
VAR gFieldInterface : tIdent ;
VAR gString : Strings . tString ; 

(* Convert an M3-style identifier (mixed case) back to Gnat-style (underscores) *)
PROCEDURE WG ( Ident : tIdent ) 
; VAR I : CARDINAL 
; VAR LString : Strings . tString 
; VAR LPrevChar , LChar , LNextChar : CHAR 
; VAR LLength : CARDINAL 
; BEGIN 
    Idents . GetString ( Ident , LString ) 
  ; LLength := Strings . Length ( LString )  
  ; IF LLength > 0 
    THEN 
    ; I := 1 
    ; LPrevChar := ' ' 
    ; LChar := Strings . Char ( LString , 1 ) 
    ; LOOP 
        IF I < LLength 
        THEN 
          INC ( I )
        ; LNextChar := Strings . Char ( LString , I ) 
        ELSIF I = LLength  
        THEN 
          INC ( I )
        ; LNextChar := ' ' 
        ELSE EXIT 
        END (* IF *) 
      ; IF  ( ( ( 'a' <= LPrevChar ) AND ( LPrevChar <= 'z' ) ) 
              AND ( ( ( '0' <= LChar ) AND ( LChar <= '9' ) ) 
                    OR ( ( 'A' <= LChar ) AND ( LChar <= 'Z' ) ) 
                  ) 
            ) OR ( ( ( 'A' <= LPrevChar ) AND ( LPrevChar <= 'Z' ) ) 
                   AND ( ( 'A' <= LChar ) AND ( LChar <= 'Z' ) ) 
                   AND ( ( 'a' <= LNextChar ) AND ( LNextChar <= 'z' ) ) 
                 ) 
        THEN IO . WriteC ( f , '_' ) 
        END (* IF *) 
      ; IO . WriteC ( f , LChar ) 
      ; LPrevChar := LChar 
      ; LChar := LNextChar 
      END (* LOOP *) 
    END (* IF *) 
  END WG; 

PROCEDURE IsDescendedFrom ( Descendent : tTree ; Ancestor : tTree ) : BOOLEAN 
; VAR LClass : tTree 
; BEGIN
    IF Ancestor = NoTree THEN RETURN FALSE 
    ELSIF Tree . IsType ( Ancestor , Tree . NoClass ) THEN RETURN FALSE 
    ELSIF NOT Tree . IsType ( Ancestor , Tree . Class ) 
    THEN 
      Errors . MessageI
        ( 'IsDescendedFrom, Ancestor not Class' 
        , Errors . Fatal 
        , Positions . NoPosition 
        , Errors . Integer 
        , SYSTEM . ADR ( Ancestor ^ . Kind )  
        ) 
    ELSE 
      LClass := Descendent 
    ; LOOP 
        IF LClass = Ancestor THEN RETURN TRUE 
        ELSIF LClass  = NoTree THEN RETURN FALSE 
        ELSIF Tree . IsType ( LClass , Tree . NoClass ) THEN RETURN FALSE 
        ELSIF NOT Tree . IsType ( LClass , Tree . Class ) 
        THEN 
          Errors . MessageI
            ( 'IsDescendedFrom, LClass not Class' 
            , Errors . Fatal 
            , Positions . NoPosition 
            , Errors . Integer 
            , SYSTEM . ADR ( LClass ^ . Kind )
            ) 
        ELSE 
          LClass := LClass ^ . Class . BaseClass 
        END (* IF *) 
      END (* LOOP *) 
    END (* IF *) 
  END IsDescendedFrom ; 

PROCEDURE PackageName ( FieldName : tIdent ) : tIdent 
; BEGIN 
    IF FieldName = gIdentNext 
    THEN RETURN gIdentNlists
    ELSIF FieldName = gIdentPrev 
    THEN RETURN gIdentNlists
    ELSIF FieldName = gIdentLink 
    THEN RETURN gIdentGnatAdaUtils
    ELSIF FieldName = gIdentNextEntity
    THEN RETURN gIdentSinfo
    ELSIF FieldName = gIdentScope
    THEN RETURN gIdentSinfo
    ELSIF FieldName = gIdentHomonym
    THEN RETURN gIdentSinfo
    ELSIF FieldName = gIdentEtype
    THEN RETURN gIdentSinfo
    ELSIF FieldName = gIdentDiscriminantConstraint
    THEN RETURN gIdentGnatAdaUtils
    ELSIF FieldName = gIdentPrimitiveOperations
    THEN RETURN gIdentGnatAdaUtils
    ELSIF FieldName = gIdentPrivalsChain
    THEN RETURN gIdentGnatAdaUtils
    ELSIF FieldName = gIdentPrivateDependents
    THEN RETURN gIdentGnatAdaUtils
    ELSIF FieldName = gIdentGirderConstraint
    THEN RETURN gIdentGnatAdaUtils
    ELSIF FieldName = gIdentDefiningIdentifier
    THEN RETURN gIdentGnatAdaUtils
    ELSIF FieldName = gIdentMechanism
    THEN RETURN gIdentGnatAdaUtils
    ELSIF FieldName = gIdentIsListMember  
    THEN RETURN gIdentNlists
    ELSIF FieldName = gIdentSloc
    THEN RETURN gIdentAtree
    ELSIF FieldName = gIdentIsRewriteSubstitution
    THEN RETURN gIdentAtree
    ELSIF FieldName = gIdentIsRewriteInsertion
    THEN RETURN gIdentAtree
    ELSIF FieldName = gIdentComesFromSource
    THEN RETURN gIdentAtree
    ELSIF FieldName = gIdentAnalyzed
    THEN RETURN gIdentAtree
    ELSIF FieldName = gIdentErrorPosted
    THEN RETURN gIdentAtree
    ELSIF FieldName = gIdentParenCount
    THEN RETURN gIdentAtree
    ELSIF FieldName = gIdentHasDynamicLengthCheck
    THEN RETURN gIdentSinfo
    ELSIF FieldName = gIdentHasDynamicRangeCheck
    THEN RETURN gIdentSinfo
    ELSIF FieldName = gIdentChars
    THEN RETURN gIdentSinfo
    ELSE RETURN gFieldInterface 
    END (* IF *) 
  END PackageName ;

CONST UseQualifiers = FALSE ; 

PROCEDURE WriteQualifier ( Name : tIdent ) 
; BEGIN  
    IF IsElement ( ORD ( '%' ) , Options )  
    THEN 
      WI ( PackageName ( Name ) ) ; 
      WriteS ( f , " . " )  
    END (* IF *) 
  END WriteQualifier ; 







































































































PROCEDURE yyAbort (yyFunction: ARRAY OF CHAR);
 BEGIN
  IO.WriteS (IO.StdError, 'Error: module GenGnat, routine ');
  IO.WriteS (IO.StdError, yyFunction);
  IO.WriteS (IO.StdError, ' failed');
  IO.WriteNl (IO.StdError);
  Exit;
 END yyAbort;

PROCEDURE yyIsEqual (yya, yyb: ARRAY OF SYSTEM.BYTE): BOOLEAN;
 VAR yyi       : INTEGER;
 BEGIN
  FOR yyi := 0 TO INTEGER (HIGH (yya)) DO
   IF yya [yyi] # yyb [yyi] THEN RETURN FALSE; END;
  END;
  RETURN TRUE;
 END yyIsEqual;

PROCEDURE GnatModule (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Ag) THEN
(* line 230 "" *)
     WITH t^.Ag DO
(* line 230 "" *)
      
      IF IsElement (ORD ('~'), Options) THEN

        debug1 := IsElement ( ORD ( 'Z' ) , Options ) ; 

        Strings . ArrayToString ( 'NodeNumber' , gString ) ; 
        gIdentNodeNumber := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Next' , gString ) ; 
        gIdentNext := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Prev' , gString ) ; 
        gIdentPrev := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'IsListMember' , gString ) ; 
        gIdentIsListMember := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Link' , gString ) ; 
        gIdentLink := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Sloc' , gString ) ; 
        gIdentSloc := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'IsRewriteSubstitution' , gString ) ; 
        gIdentIsRewriteSubstitution := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'IsRewriteInsertion' , gString ) ; 
        gIdentIsRewriteInsertion := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'ComesFromSource' , gString ) ; 
        gIdentComesFromSource := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Analyzed' , gString ) ; 
        gIdentAnalyzed := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'ErrorPosted' , gString ) ; 
        gIdentErrorPosted := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'ParenCount' , gString ) ; 
        gIdentParenCount := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'HasDynamicLengthCheck' , gString ) ; 
        gIdentHasDynamicLengthCheck := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'DiscriminantConstraint' , gString ) ; 
        gIdentDiscriminantConstraint := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'PrimitiveOperations' , gString ) ; 
        gIdentPrimitiveOperations := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'PrivalsChain' , gString ) ; 
        gIdentPrivalsChain := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'PrivateDependents' , gString ) ; 
        gIdentPrivateDependents := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'GirderConstraint' , gString ) ; 
        gIdentGirderConstraint := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'DefiningIdentifier' , gString ) ; 
        gIdentDefiningIdentifier := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Mechanism' , gString ) ; 
        gIdentMechanism := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'HasDynamicRangeCheck' , gString ) ; 
        gIdentHasDynamicRangeCheck := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Chars' , gString ) ; 
        gIdentChars := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'NextEntity' , gString ) ; 
        gIdentNextEntity := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Scope' , gString ) ; 
        gIdentScope := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Homonym' , gString ) ; 
        gIdentHomonym := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Etype' , gString ) ; 
        gIdentEtype := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Einfo' , gString ) ; 
        gIdentEinfo := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Sinfo' , gString ) ; 
        gIdentSinfo := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'GnatUtils' , gString ) ; 
        gIdentGnatUtils := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'GnatAdaUtils' , gString ) ; 
        gIdentGnatAdaUtils := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Atree' , gString ) ; 
        gIdentAtree := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'Nlists' , gString ) ; 
        gIdentNlists := Idents . MakeIdent ( gString ) ;
        Strings . ArrayToString ( 'NClassNonEmpty' , gString ) ; 
        gIdentNClassNonEmpty := Idents . MakeIdent ( gString ) ;
        gNClassNonEmptyClass := IdentifyClass ( NoTree , gIdentNClassNonEmpty ) ; 
        Strings . ArrayToString ( 'NClassEntity' , gString ) ; 
        gIdentNClassEntity := Idents . MakeIdent ( gString ) ;
        gEntityClass := IdentifyClass ( NoTree , gIdentNClassEntity ) ; 


	WriteS (f, "TYPE yyPtrtTree	= UNTRACED REF "); WI (itTree); WriteS (f, ";"); WriteNl (f);
	WriteNl (f);
	WriteS (f, "TYPE yytMapArray = ARRAY OF "); WI (itTree); WriteS (f, " ;"); WriteNl (f);
	WriteS (f, "TYPE yytMapRef = REF yytMapArray ;"); WriteNl (f);
	WriteNl (f);
        WriteS (f, "VAR yyNodeMapRef : yytMapRef ;"); WriteNl (f);
        WriteS (f, "VAR yyListMapRef : yytMapRef ;"); WriteNl (f);
        WriteS (f, "VAR yyElistMapRef : yytMapRef ;"); WriteNl (f);
        WriteS (f, "VAR yyElmtMapRef : yytMapRef ;"); WriteNl (f);
        WriteS (f, "VAR yyNextNodeNumber : INTEGER := 1 ;"); WriteNl (f);
        WriteNl (f);
	WriteS (f, "PROCEDURE yyConvert"); WI (iMain); WriteNl (f);
        WriteS (f, "   ( FId : GnatTypes . Union_Id "); WriteNl (f);
        WriteS (f, "   ; FNew : yyPtrtTree "); WriteNl (f);
        WriteS (f, "   ; FCallerId : GnatTypes . Union_Id "); WriteNl (f);
        WriteS (f, "   ; FCallerField : TEXT "); WriteNl (f);
        WriteS (f, "   )"); WriteNl (f);
        WriteS (f, "=VAR LKind : "); WI ( iMain ) ; WriteS (f, " . SHORTCARD "); WriteNl (f);
        WriteS (f, ";VAR LId := FId"); WriteNl (f);
        WriteS (f, ";VAR LNew := FNew"); WriteNl (f);
        WriteS (f, ";VAR LCallerId := FCallerId"); WriteNl (f);
        WriteS (f, ";VAR LCallerField := FCallerField"); WriteNl (f);
        WriteS (f, ";BEGIN"); WriteNl (f);
	WriteS (f, "  LOOP"); WriteNl (f);
        WriteS (f, "    IF GnatTypes . List_Low_Bound <= LId "); WriteNl (f);
        WriteS (f, "       AND LId < GnatTypes . List_Low_Bound + NUMBER ( yyListMapRef ^ )"); WriteNl (f);
        WriteS (f, "    THEN (* This is a list node. *) "); WriteNl (f);
	WriteS (f, "      IF LId = GnatTypes . No_List"); WriteNl (f);
        WriteS (f, "      THEN"); WriteNl (f);
        WriteS (f, "        VAR LNewList := NEW ( "); WI ( iMain ) ; WriteS (f, " . NoList )"); WriteNl (f);
        WriteS (f, "                   (* Multiple copies of NoList nodes *)"); WriteNl (f);
        WriteS (f, "      ; BEGIN"); WriteNl (f);
        WriteS (f, "          LNew ^ := LNewList"); WriteNl (f);
        WriteS (f, "        ; LNew ^ . Kind := Tree . NkNoList"); WriteNl (f);
        WriteS (f, "        ; LNewList . NodeNumber := yyNextNodeNumber"); WriteNl (f);
        WriteS (f, "        ; INC ( yyNextNodeNumber )"); WriteNl (f);
        WriteS (f, "        ; RETURN"); WriteNl (f);
        WriteS (f, "        END (* BEGIN *)"); WriteNl (f);
        WriteS (f, "      END (* IF *) "); WriteNl (f);
        WriteS (f, "    ; WITH WNewRef = yyListMapRef ^ [ LId - GnatTypes . List_Low_Bound ] "); WriteNl (f);
        WriteS (f, "      DO"); WriteNl (f);
        WriteS (f, "        IF WNewRef # "); WI ( iNoTree ) ; WriteNl (f);
        WriteS (f, "        THEN LNew ^ := WNewRef ; RETURN END (* IF *) "); WriteNl (f);
        WriteS (f, "      ; VAR LNewList : Tree . List := NEW ( "); WI ( iMain ) ; WriteS (f, " . List ) "); WriteNl (f);
        WriteS (f, "        ; BEGIN"); WriteNl (f);
        WriteS (f, "            WNewRef := LNewList"); WriteNl (f);
        WriteS (f, "          ; LNew ^ := LNewList"); WriteNl (f);
        WriteS (f, "          ; LNew ^ . Kind := Tree . NkList"); WriteNl (f);
        WriteS (f, "          ; LNewList . NodeNumber := yyNextNodeNumber"); WriteNl (f);
        WriteS (f, "          ; INC ( yyNextNodeNumber )"); WriteNl (f);
        WriteS (f, "          ; yyConvert"); WI (iMain); WriteNl (f);
        WriteS (f, "               ( Nlists . Parent ( LId ) , ADR ( LNewList . Parent )"); WriteNl (f);
        WriteS (f, '               , LId , " Parent" ) '); WriteNl (f);
        WriteS (f, "          ; yyConvert"); WI (iMain); WriteNl (f);
        WriteS (f, "               ( Nlists . Last ( LId ) , ADR ( LNewList . Last )"); WriteNl (f);
        WriteS (f, '               , LId , "Last" ) '); WriteNl (f);
        WriteS (f, "          ; LCallerId := LId"); WriteNl (f);
        WriteS (f, '          ; LCallerField := "First"'); WriteNl (f);
        WriteS (f, "          ; LId := Nlists . First ( LId ) "); WriteNl (f);
        WriteS (f, "          ; LNew := ADR ( LNewList . First )"); WriteNl (f);
        WriteS (f, "          END (* BEGIN *) "); WriteNl (f);
        WriteS (f, "      END (* WITH WNewRef *) "); WriteNl (f);
        WriteS (f, "    ELSIF GnatTypes . Elist_Low_Bound <= LId"); WriteNl (f);
        WriteS (f, "          AND LId < GnatTypes . Elist_Low_Bound + NUMBER ( yyElistMapRef ^ )"); WriteNl (f);
        WriteS (f, "    THEN (* This is an Elist node. *) "); WriteNl (f);
	WriteS (f, "      IF LId = GnatTypes . No_Elist"); WriteNl (f);
        WriteS (f, "      THEN"); WriteNl (f);
        WriteS (f, "        VAR LNewElist := NEW ( "); WI ( iMain ) ; WriteS (f, " . NoElist ) "); WriteNl (f);
        WriteS (f, "                   (* Multiple copies of NoElist nodes *)"); WriteNl (f);
        WriteS (f, "      ; BEGIN"); WriteNl (f);
        WriteS (f, "          LNew ^ := LNewElist"); WriteNl (f);
        WriteS (f, "        ; LNew ^ . Kind := Tree . NkNoElist"); WriteNl (f);
        WriteS (f, "        ; LNewElist . NodeNumber := yyNextNodeNumber"); WriteNl (f);
        WriteS (f, "        ; INC ( yyNextNodeNumber )"); WriteNl (f);
        WriteS (f, "        ; RETURN  "); WriteNl (f);
        WriteS (f, "        END (* BEGIN *)"); WriteNl (f);
        WriteS (f, "      END (* IF *) "); WriteNl (f);
        WriteS (f, "    ; WITH WNewRef = yyElistMapRef ^ [ LId - GnatTypes . Elist_Low_Bound ] "); WriteNl (f);
        WriteS (f, "      DO"); WriteNl (f);
        WriteS (f, "        IF WNewRef # "); WI ( iNoTree ) ; WriteNl (f);
        WriteS (f, "        THEN LNew ^ := WNewRef ; RETURN END (* IF *) "); WriteNl (f);
        WriteS (f, "      ; VAR LNewElist : Tree . Elist := NEW ( "); WI ( iMain ) ; WriteS (f, " . Elist ) "); WriteNl (f);
        WriteS (f, "        ; BEGIN"); WriteNl (f);
        WriteS (f, "            WNewRef := LNewElist"); WriteNl (f);
        WriteS (f, "          ; LNew ^ := LNewElist"); WriteNl (f);
        WriteS (f, "          ; LNew ^ . Kind := Tree . NkElist"); WriteNl (f);
        WriteS (f, "          ; LNewElist . NodeNumber := yyNextNodeNumber"); WriteNl (f);
        WriteS (f, "          ; INC ( yyNextNodeNumber )"); WriteNl (f);
        WriteS (f, "          ; yyConvert"); WI (iMain);WriteNl (f);
        WriteS (f, "               ( Elists . Last_Elmt ( LId ) , ADR ( LNewElist . LastElmt )"); WriteNl (f);
        WriteS (f, '               , LId , "Last_Elmt" ) '); WriteNl (f);
        WriteS (f, "          ; LCallerId := LId"); WriteNl (f);
        WriteS (f, '          ; LCallerField := "First_Elmt"'); WriteNl (f);
        WriteS (f, "          ; LId := Elists . First_Elmt ( LId ) "); WriteNl (f);
        WriteS (f, "          ; LNew := ADR ( LNewElist . FirstElmt )"); WriteNl (f);
        WriteS (f, "          END (* BEGIN *) "); WriteNl (f);
        WriteS (f, "      END (* WITH WNewRef *) "); WriteNl (f);
        WriteS (f, "    ELSIF GnatTypes . Elmt_Low_Bound <= LId"); WriteNl (f);
        WriteS (f, "          AND LId < GnatTypes . Elmt_Low_Bound + NUMBER ( yyElmtMapRef ^ )"); WriteNl (f);
        WriteS (f, "    THEN (* This is an Elmt node. *) "); WriteNl (f);
	WriteS (f, "      IF LId = GnatTypes . No_Elmt"); WriteNl (f);
        WriteS (f, "      THEN"); WriteNl (f);
        WriteS (f, "        VAR LNewElmt := NEW ( "); WI ( iMain ) ; WriteS (f, " . NoElmt ) "); WriteNl (f);
        WriteS (f, "                   (* Multiple copies of NoElmt nodes *)"); WriteNl (f);
        WriteS (f, "      ; BEGIN"); WriteNl (f);
        WriteS (f, "          LNew ^ := LNewElmt "); WriteNl (f);
        WriteS (f, "        ; LNew ^ . Kind := Tree . NkNoElmt"); WriteNl (f);
        WriteS (f, "        ; LNewElmt . NodeNumber := yyNextNodeNumber"); WriteNl (f);
        WriteS (f, "        ; INC ( yyNextNodeNumber )"); WriteNl (f);
        WriteS (f, "        ; RETURN "); WriteNl (f);
        WriteS (f, "        END (* BEGIN *)"); WriteNl (f);
        WriteS (f, "      END (* IF *) "); WriteNl (f);
        WriteS (f, "    ; WITH WNewRef = yyElmtMapRef ^ [ LId - GnatTypes . Elmt_Low_Bound ] "); WriteNl (f);
        WriteS (f, "      DO"); WriteNl (f);
        WriteS (f, "        IF WNewRef # "); WI ( iNoTree ) ; WriteNl (f);
        WriteS (f, "        THEN LNew ^ := WNewRef"); WriteNl (f);
        WriteS (f, "        ; RETURN"); WriteNl (f);
        WriteS (f, "        END (* IF *) "); WriteNl (f);
        WriteS (f, "      ; VAR LNewElmt : Tree . Elmt := NEW ( "); WI ( iMain ) ; WriteS (f, " . Elmt ) "); WriteNl (f);
        WriteS (f, "        ; BEGIN"); WriteNl (f);
        WriteS (f, "            WNewRef := LNewElmt"); WriteNl (f);
        WriteS (f, "          ; LNew ^ := LNewElmt"); WriteNl (f);
        WriteS (f, "          ; LNew ^ . Kind := Tree . NkElmt"); WriteNl (f);
        WriteS (f, "          ; LNewElmt . NodeNumber := yyNextNodeNumber"); WriteNl (f);
        WriteS (f, "          ; INC ( yyNextNodeNumber )"); WriteNl (f);
        WriteS (f, "          ; yyConvert"); WI (iMain); WriteNl (f);
        WriteS (f, "               ( Elists . Node ( LId ) , ADR ( LNewElmt . Node )"); WriteNl (f);
        WriteS (f, '               , LId , "Node" ) '); WriteNl (f);
        WriteS (f, "          ; LCallerId := LId"); WriteNl (f);
        WriteS (f, '          ; LCallerField := "Next_Elmt"'); WriteNl (f);
        WriteS (f, "          ; LId := Elists . Next_Elmt ( LId ) "); WriteNl (f);
        WriteS (f, "          ; LNew := ADR ( LNewElmt . NextElmt )"); WriteNl (f);
        WriteS (f, "          END (* BEGIN *) "); WriteNl (f);
        WriteS (f, "      END (* WITH WNewRef *) "); WriteNl (f);
        WriteS (f, "    ELSIF GnatTypes . Node_Low_Bound <= LId"); WriteNl (f);
        WriteS (f, "          AND LId < GnatTypes . Node_Low_Bound + NUMBER ( yyNodeMapRef ^ )"); WriteNl (f);
        WriteS (f, "    THEN (* This is an ordinary node. *) "); WriteNl (f);
	WriteS (f, "      IF LId = GnatTypes . Empty"); WriteNl (f);
        WriteS (f, "      THEN"); WriteNl (f);
        WriteS (f, "        VAR LNewNode := NEW ( "); WI ( iMain ) ; WriteS (f, " . NNoNode ) "); WriteNl (f);
        WriteS (f, "                   (* Multiple copies of Empty nodes *)"); WriteNl (f);
        WriteS (f, "      ; BEGIN "); WriteNl (f);
        WriteS (f, "          LNew ^ := LNewNode "); WriteNl (f);
        WriteS (f, "        ; LNew ^ . Kind := Tree . NkNNoNode"); WriteNl (f);
        WriteS (f, "        ; LNewNode . NodeNumber := yyNextNodeNumber"); WriteNl (f);
        WriteS (f, "        ; INC ( yyNextNodeNumber )"); WriteNl (f);
        WriteS (f, "        ; RETURN "); WriteNl (f);
        WriteS (f, "        END (* BEGIN *) "); WriteNl (f);
        WriteS (f, "      END (* IF *) "); WriteNl (f);
        WriteS (f, "    ; WITH WNewRef = yyNodeMapRef [ LId - GnatTypes . Node_Low_Bound ] "); WriteNl (f);
        WriteS (f, "      DO"); WriteNl (f);
        WriteS (f, "        IF WNewRef # "); WI ( iNoTree ) ; WriteNl (f);
        WriteS (f, "        THEN LNew ^ := WNewRef"); WriteNl (f);
        WriteS (f, "        ; RETURN"); WriteNl (f);
        WriteS (f, "        END (* IF *) "); WriteNl (f);
        WriteS (f, "      ; LKind := GnatUtils . Kind ( LId )"); WriteNl (f);
        WriteS (f, "      ; CASE LKind OF"); WriteNl (f);
	ForallClasses ( Classes , Convert);
        WriteS (f, "        END (* CASE *)"); WriteNl (f);
        WriteS (f, "      END (* WITH WNewRef *) "); WriteNl (f);
        WriteS (f, "    ELSE (* Bad UnionId *)  "); WriteNl (f);
        WriteS (f, '      Wr . PutText ( Stdio . stdout , "Bad union id, " )'); WriteNl (f);
        WriteS (f, "    ; Wr . PutText ( Stdio . stdout , Fmt . Int ( LCallerId ) )"); WriteNl (f);
        WriteS (f, "    ; Wr . PutChar ( Stdio . stdout , ':' )"); WriteNl (f);
        WriteS (f, "    ; Wr . PutText ( Stdio . stdout , LCallerField )"); WriteNl (f);
        WriteS (f, "    ; Wr . PutChar ( Stdio . stdout , '=' )"); WriteNl (f);
        WriteS (f, "    ; Wr . PutText ( Stdio . stdout , Fmt . Int ( LId ) )"); WriteNl (f);
        WriteS (f, "    ; Wr . PutText ( Stdio . stdout , Wr . EOL )"); WriteNl (f);
        WriteS (f, "    ; Wr . Flush ( Stdio . stdout )"); WriteNl (f);
        WriteS (f, "    ; LNew ^ := NIL"); WriteNl (f);
        WriteS (f, "    ; RETURN"); WriteNl (f);
        WriteS (f, "    END (* IF *) "); WriteNl (f);
        WriteS (f, "  END (* LOOP *) "); WriteNl (f);
	WriteS (f, " END yyConvert"); WI (iMain); WriteS (f, ";"); WriteNl (f);
	WriteNl (f);
        IF debug1 
        THEN 
        WriteS (f, "PROCEDURE yyWriteHex ( VAR yyx : ARRAY OF CHAR ) "); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteS (f, "  FOR yyi := 0 TO NUMBER ( yyx ) - 1 DO"); WriteNl (f);
        WriteS (f, "   Wr . PutText ( Stdio . stdout , Fmt . Pad ( Fmt . Int ( ORD ( yyx [ yyi ] ) , 16 ) , 2 , '0' ) ) ;"); WriteNl (f);
        WriteS (f, "   Wr . PutChar ( Stdio . stdout , ' ' ) ;"); WriteNl (f);
        WriteS (f, "  END ;"); WriteNl (f);
        WriteS (f, " END yyWriteHex ;"); WriteNl (f);
	WriteNl (f);
        END  ; 
        WriteS (f, "PROCEDURE GnatConvert"); WI (iMain); WriteS (f, " ( GnatTree : GnatTypes . Node_Id ) "); WriteNl (f);
        WriteS (f, " : "); WI (itTree); WriteNl (f);
	WriteS (f, "=VAR LNew	: "); WI (itTree); WriteS (f, ";"); WriteNl (f);
	WriteS (f, " BEGIN"); WriteNl (f);
	WriteS (f, "  "); WriteNl (f);
        WriteS (f, "  yyNodeMapRef := NEW ( yytMapRef , Atree . Last_Node_Id ( )  - GnatTypes . Node_Low_Bound + 1 ) ;"); WriteNl (f);
        IF debug1 
        THEN 
        WriteS (f, '  Wr . PutText ( Stdio . stdout , "Last_Node_Id = " ) ; '); WriteNl (f);
        WriteS (f, "  Wr . PutText ( Stdio . stdout , Fmt . Int ( Atree . Last_Node_Id ( ) ) ) ; "); WriteNl (f);
        WriteS (f, "  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; "); WriteNl (f);
        WriteS (f, '  Wr . PutText ( Stdio . stdout , "yyNodeMapRef = " ) ; '); WriteNl (f);
        WriteS (f, "  yyWriteHex ( LOOPHOLE ( yyNodeMapRef , ARRAY [ 0..BYTESIZE ( yytMapRef ) - 1 ] OF CHAR ) ) ; "); WriteNl (f);
        WriteS (f, "  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; "); WriteNl (f);
        WriteS (f, '  Wr . PutText ( Stdio . stdout , "NUMBER = " ) ; '); WriteNl (f);
        WriteS (f, "  Wr . PutText ( Stdio . stdout , Fmt . Int ( NUMBER ( yyNodeMapRef ^ ) ) ) ; "); WriteNl (f);
        WriteS (f, "  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; "); WriteNl (f);
        WriteS (f, "  Wr . Flush ( Stdio . stdout ) ; "); WriteNl (f);
        END  ; 
        WriteS (f, "  yyListMapRef := NEW ( yytMapRef , Nlists . Last_List_Id ( ) - GnatTypes . List_Low_Bound + 1 ) ;"); WriteNl (f);
        IF debug1 
        THEN 
        WriteS (f, '  Wr . PutText ( Stdio . stdout , "Last_List_Id = " ) ; '); WriteNl (f);
        WriteS (f, "  Wr . PutText ( Stdio . stdout , Fmt . Int ( Nlists . Last_List_Id ( ) ) ) ; "); WriteNl (f);
        WriteS (f, "  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; "); WriteNl (f);
        WriteS (f, '  Wr . PutText ( Stdio . stdout , "yyListMapRef = " ) ; '); WriteNl (f);
        WriteS (f, "  yyWriteHex ( LOOPHOLE ( yyListMapRef , ARRAY [ 0..BYTESIZE ( yytMapRef ) - 1 ] OF CHAR ) ) ; "); WriteNl (f);
        WriteS (f, "  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; "); WriteNl (f);
        WriteS (f, '  Wr . PutText ( Stdio . stdout , "NUMBER = " ) ; '); WriteNl (f);
        WriteS (f, "  Wr . PutText ( Stdio . stdout , Fmt . Int ( NUMBER ( yyListMapRef ^ ) ) ) ; "); WriteNl (f);
        WriteS (f, "  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; "); WriteNl (f);
        WriteS (f, "  Wr . Flush ( Stdio . stdout ) ; "); WriteNl (f);
        END  ; 
        WriteS (f, "  yyElistMapRef := NEW ( yytMapRef , Elists . Last_Elist_Id ( ) - GnatTypes . Elist_Low_Bound + 1 ) ;"); WriteNl (f);
        IF debug1 
        THEN 
        WriteS (f, '  Wr . PutText ( Stdio . stdout , "Last_Elist_Id = " ) ; '); WriteNl (f);
        WriteS (f, "  Wr . PutText ( Stdio . stdout , Fmt . Int ( Elists . Last_Elist_Id ( ) ) ) ; "); WriteNl (f);
        WriteS (f, "  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; "); WriteNl (f);
        WriteS (f, '  Wr . PutText ( Stdio . stdout , "yyElistMapRef = " ) ; '); WriteNl (f);
        WriteS (f, "  yyWriteHex ( LOOPHOLE ( yyElistMapRef , ARRAY [ 0..BYTESIZE ( yytMapRef ) - 1 ] OF CHAR ) ) ; "); WriteNl (f);
        WriteS (f, "  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; "); WriteNl (f);
        WriteS (f, '  Wr . PutText ( Stdio . stdout , "NUMBER = " ) ; '); WriteNl (f);
        WriteS (f, "  Wr . PutText ( Stdio . stdout , Fmt . Int ( NUMBER ( yyElistMapRef ^ ) ) ) ; "); WriteNl (f);
        WriteS (f, "  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; "); WriteNl (f);
        WriteS (f, "  Wr . Flush ( Stdio . stdout ) ; "); WriteNl (f);
        END  ; 
        WriteS (f, "  yyElmtMapRef := NEW ( yytMapRef , Elists . Last_Elmt_Id ( ) - GnatTypes . Elmt_Low_Bound + 1 ) ;"); WriteNl (f);
        IF debug1 
        THEN 
        WriteS (f, '  Wr . PutText ( Stdio . stdout , "Last_Elmt_Id = " ) ; '); WriteNl (f);
        WriteS (f, "  Wr . PutText ( Stdio . stdout , Fmt . Int ( Elists . Last_Elmt_Id ( ) ) ) ; "); WriteNl (f);
        WriteS (f, "  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; "); WriteNl (f);
        WriteS (f, '  Wr . PutText ( Stdio . stdout , "yyElmtMapRef = " ) ; '); WriteNl (f);
        WriteS (f, "  yyWriteHex ( LOOPHOLE ( yyElmtMapRef , ARRAY [ 0..BYTESIZE ( yytMapRef ) - 1 ] OF CHAR ) ) ; "); WriteNl (f);
        WriteS (f, "  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; "); WriteNl (f);
        WriteS (f, '  Wr . PutText ( Stdio . stdout , "NUMBER = " ) ; '); WriteNl (f);
        WriteS (f, "  Wr . PutText ( Stdio . stdout , Fmt . Int ( NUMBER ( yyElmtMapRef ^ ) ) ) ; "); WriteNl (f);
        WriteS (f, "  Wr . PutText ( Stdio . stdout , Wr . EOL ) ; "); WriteNl (f);
        WriteS (f, "  Wr . Flush ( Stdio . stdout ) ; "); WriteNl (f);
        END  ; 
        WriteNl (f);
	WriteS (f, "  yyConvert"); WI (iMain); WriteNl (f);
        WriteS (f, '    ( GnatTree , ADR ( LNew ) , 0 , "<ROOT>" ) ;'); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  yyNodeMapRef := NIL ; "); WriteNl (f);
        WriteS (f, "  yyListMapRef := NIL ; "); WriteNl (f);
        WriteS (f, "  yyElistMapRef := NIL ; "); WriteNl (f);
        WriteS (f, "  yyElmtMapRef := NIL ; "); WriteNl (f);
        WriteNl (f);
	WriteS (f, "  RETURN LNew;"); WriteNl (f);
	WriteS (f, " END GnatConvert"); WI (iMain); WriteS (f, ";"); WriteNl (f);
	WriteNl (f);
      END  
;
      RETURN;
     END (* WITH *) ;

  END;
 END GnatModule;

PROCEDURE Convert (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 572 "" *)
     WITH t^.Class DO
(* line 572 "" *)
      
	IF ( ( NoCodeClass * Properties ) = { } ) 
           AND ( Extensions ^ . Kind = Tree . NoClass )  
           AND IsDescendedFrom ( t , gNClassNonEmptyClass ) 
        THEN
	   WriteS (f, "        | "); WI ( iMain ) ; WriteS (f, " . Nk"); WI (Name); WriteNl (f);
           WriteS (f, "        => VAR LNewNode := NEW ( "); WI ( iMain ) ; WriteS (f, " . "); WI ( Name ) ; WriteS (f, " )"); WriteNl (f);
           WriteS (f, "           ; BEGIN"); WriteNl (f);
           WriteS (f, "               WNewRef := LNewNode"); WriteNl (f);
           WriteS (f, "             ; LNew ^ := WNewRef"); WriteNl (f);
           WriteS (f, "             ; LNew ^ . Kind := LKind"); WriteNl (f);
           WriteS (f, "             ; LNewNode . NodeNumber := yyNextNodeNumber"); WriteNl (f);
           WriteS (f, "             ; INC ( yyNextNodeNumber )"); WriteNl (f);
	   ConvertAttrs (t);
           WriteS (f, "             (* Field Next of Node is the builtin tail-recursion eliminated iterator *) "); WriteNl (f);
           WriteS (f, "             ; LCallerId := LId"); WriteNl (f);
           WriteS (f, '             ; LCallerField := "Next"'); WriteNl (f);
           WriteS (f, "             ; LId := Nlists . Next ( LId ) "); WriteNl (f);
           WriteS (f, "             ; LNew := ADR ( LNewNode . Next )"); WriteNl (f);
           WriteS (f, "             END (* BEGIN *) "); WriteNl (f);
	END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END Convert;

PROCEDURE ConvertAttrs (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 597 "" *)
     WITH t^.Class DO
(* line 597 "" *)
      
	IF ( ( NoCodeClass * Properties ) = { } ) 
        THEN
           ConvertAttrs ( t^.Class.BaseClass); 
           IF IsDescendedFrom ( t , gEntityClass ) 
           THEN gFieldInterface := gIdentEinfo 
           ELSE gFieldInterface := gIdentSinfo 
           END ;   
	   ConvertAttrs (t^.Class.Attributes);
	END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 609 "" *)
     WITH t^.Child DO
(* line 609 "" *)
      
        IF Name = gIdentNext
        THEN 
           WriteS (f, "             (* Next is handled last, as tail recursion elimination *) "); WriteNl (f);
        ELSE 
           WriteS (f, "             ; yyConvert"); WI (iMain); WriteNl (f);
           WriteS (f, "                 ( "); WriteQualifier ( Name ) ; WG ( Name ) ; 
                                 WriteS (f, " ( LId ) , ADR ( LNewNode . "); WI ( Name ) ; WriteS (f, " )"); WriteNl (f);
           WriteS (f, '                 , LId , "'); WG ( Name ) ; WriteS (f, '" ) '); WriteNl (f);
        END  ; 
        ConvertAttrs ( t^.Child.Next); 
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 621 "" *)
     WITH t^.Attribute DO
(* line 621 "" *)
      
	IF ( NoCodeAttr * Properties ) = {} 
        THEN 
          IF Name = gIdentNodeNumber
          THEN   
          ELSIF Link IN Properties 
          THEN 
           WriteS (f, "             ; yyConvert"); WI (iMain); WriteNl (f);
           WriteS (f, "                 ( "); WriteQualifier ( Name ) ; WG ( Name ) ; 
                                 WriteS (f, " ( LId ) , ADR ( LNewNode . "); WI ( Name ) ; WriteS (f, " )"); WriteNl (f);
           WriteS (f, '                 , LId , "'); WG ( Name ) ; WriteS (f, '" ) '); WriteNl (f);
          ELSE 

	   WriteS (f, "             ; copy"); WI (Type); WriteS (f, " ( LNewNode . "); WI ( Name ) ; 
                           WriteS (f, " , "); WriteQualifier ( Name ) ; WG ( Name ) ; WriteS (f, " ( LId ) )"); WriteNl (f);
          END  
	END;
        ConvertAttrs ( t^.Attribute.Next); 
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ConvertAttrs;

PROCEDURE BeginGenGnat;
 BEGIN

 END BeginGenGnat;

PROCEDURE CloseGenGnat;
 BEGIN

 END CloseGenGnat;

PROCEDURE yyExit;
 BEGIN
  IO.CloseIO; System.Exit (1);
 END yyExit;

BEGIN
 yyf   := IO.StdOutput;
 Exit  := yyExit;
 BeginGenGnat;
END GenGnat.

