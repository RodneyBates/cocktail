
(* This file was mechanically generated by puma. *)

IMPLEMENTATION MODULE TreeAda1;








IMPORT SYSTEM, System, IO, Tree;
(* line 37 "" *)


FROM Positions IMPORT tPosition ; 

FROM General    IMPORT Max;
FROM IO         IMPORT WriteS, WriteNl, StdError; 
FROM Idents     IMPORT tIdent;
FROM Texts      IMPORT WriteText;
FROM Sets       IMPORT IsElement, Include;
FROM TreeAda2   IMPORT TreeIO , GetIterator , Iterator ;
FROM IOUtils    IMPORT WriteBackslash ; 

FROM Tree       IMPORT
   NoTree       , tTree         , Input         , Reverse       ,
   Class        , Child         , Attribute     , Abstract      ,
   HasChildren  , HasAttributes , NoCodeAttr    , NoCodeClass   ,
   Options      , TreeRoot      , ClassCount    , iNoTree       ,
   itTree       , iMain         , iModule       , f             ,
   WI   , WN    , ForallClasses , ForallAttributes, Ignore      ,
   Test         , Dummy         , ForallClassesPreAndPost       ,
   Link         ;

IMPORT Strings;

VAR
   ConstCount   ,
   ListCount    : INTEGER;
   iRange       ,
   iClassName   : tIdent;
   Node         : tTree;
   gBitCount    : SHORTCARD;
   i, MaxBit    : SHORTCARD;

(* Move this to Ada2.puma when it is converted: *) 
PROCEDURE WriteLine (Line: tPosition);
   BEGIN
      IF Line.Line # 0 THEN
         WriteS (f, "-- Copied from line "); WN (Line.Line); WriteS (f, ' of file "'); WI (Line.File); WriteS (f, '" '); WriteNl (f);
      END;
   END WriteLine;






































































































PROCEDURE yyAbort (yyFunction: ARRAY OF CHAR);
 BEGIN
  IO.WriteS (IO.StdError, 'Error: module TreeAda1, routine ');
  IO.WriteS (IO.StdError, yyFunction);
  IO.WriteS (IO.StdError, ' failed');
  IO.WriteNl (IO.StdError);
  Exit;
 END yyAbort;

PROCEDURE yyIsEqual (yya, yyb: ARRAY OF SYSTEM.BYTE): BOOLEAN;
 VAR yyi       : INTEGER;
 BEGIN
  FOR yyi := 0 TO INTEGER (HIGH (yya)) DO
   IF yya [yyi] # yyb [yyi] THEN RETURN FALSE; END;
  END;
  RETURN TRUE;
 END yyIsEqual;

PROCEDURE TreePackSpec (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Ag) THEN
(* line 83 "" *)
     WITH t^.Ag DO
(* line 83 "" *)
      
        WriteNl (f);
        WriteS (f, "-- This Ada PACKAGE spec file was mechanically generated by cg. "); WriteNl (f);
        WriteNl (f);
      IF IsElement (ORD ('<'), Options) THEN
        WriteS (f, "WITH "); WI (iMain); WriteS (f, " ; USE "); WI (iMain); WriteS (f, " ; "); WriteNl (f);
      END;
      IF IsElement (ORD ('^'), Options) 
         OR IsElement (ORD ('o'), Options) THEN
        WriteS (f, "WITH Text_IO ; "); 
      END; 
        WriteLine (TreeCodes^.Codes.SpecWithLine);
        WriteText (f, TreeCodes^.Codes.SpecWith);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.SpecWithLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.SpecWith);
           Node := Node^.Module.Next;
        END;
        WriteS (f, "PACKAGE "); WI (iModule); WriteS (f, " IS "); WriteNl (f);
        WriteNl (f);
        WriteLine (TreeCodes^.Codes.ImportLine);
        WriteText (f, TreeCodes^.Codes.Import);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.ImportLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Import);
           Node := Node^.Module.Next;
        END;
        WriteNl (f);
      IF NOT IsElement (ORD ('<'), Options) THEN
        WriteS (f, "KindNull : CONSTANT := "); WN (ConstCount); WriteS (f, " ; "); WriteNl (f);
        ForallClassesPreAndPost (Classes, ConstDeclsPre, ConstDeclsPost);
        WriteNl (f);
        IF FALSE OR IsElement (ORD ('^'), Options) THEN
 
          ForallClasses ( Classes, PointerTypes);
        END;
        WriteS (f, "KindLast : CONSTANT := "); WN (ConstCount+1); WriteS (f, " ; "); WriteNl (f);
      
      END;
        WriteLine (TreeCodes^.Codes.ExportLine);
        WriteText (f, TreeCodes^.Codes.Export);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.ExportLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Export);
           Node := Node^.Module.Next;
        END;
        WriteNl (f);
      IF NOT IsElement (ORD ('<'), Options) THEN
        WriteS (f, "# ifndef yyNodeHead"); WriteNl (f);
        WriteS (f, "# define yyNodeHead"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "SUBTYPE KindTyp IS INTEGER RANGE KindNull .. KindLast ; "); 
        WriteS (f, "TYPE yyNode ( Kind : KindTyp := KindNull ) ; "); WriteNl (f);
        WriteS (f, "TYPE "); WI (itTree); WriteS (f, " IS ACCESS yyNode ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "SUBTYPE SHORTCARD IS INTEGER RANGE 0 .. 32767 ; "); 
        WriteNl (f);
        WriteS (f, "TYPE BITSET IS ARRAY ( 0 .. 31 ) OF BOOLEAN ; "); WriteNl (f);
        WriteS (f, "BitSetEmpty : CONSTANT BITSET := ( OTHERS => FALSE ) ; "); 
        WriteNl (f);
      IF IsElement (ORD ('L'), Options) THEN
        MaxBit := 0;
        ForallClasses (Classes, CompMaxBit);
        WriteS (f, "TYPE yytNodeHead IS RECORD "); WriteNl (f);
        WriteS (f, "  yyMark , yyOffset : SHORTCARD ; "); WriteNl (f);
        WriteS (f, "  yyParent : "); WI (itTree); WriteS (f, " ; "); WriteNl (f);
        WriteS (f, "  yyIsComp0"); 
      IF IsElement (ORD ('5'), Options) THEN
        WriteS (f, " , yyIsDone0"); 
      END;
        FOR i := 1 TO (MaxBit - 1) DIV BSS DO
           WriteS (f, " , yyIsComp"); WN (i);
      IF IsElement (ORD ('5'), Options) THEN
           WriteS (f, " , yyIsDone"); WN (i);
      END;
        END;
        WriteS (f, " : BITSET ; yyNodeHead "); WriteNl (f);
        WriteS (f, "END RECORD ; "); WriteNl (f);
      ELSE
        WriteS (f, "TYPE yytNodeHead IS RECORD "); WriteNl (f);
        WriteS (f, "  yyMark : SHORTCARD ; yyNodeHead "); WriteNl (f);
        WriteS (f, "END RECORD ; "); WriteNl (f);
      END;
        ForallClasses (Classes, TypeDeclNode);
        WriteNl (f);
        WriteS (f, "TYPE yyNode ( Kind : KindTyp := KindNull ) IS RECORD "); WriteNl (f);
        WriteS (f, "  yyHead : yytNodeHead ; "); WriteNl (f);
        WriteS (f, "  CASE Kind IS "); WriteNl (f);
        ForallClasses (Classes, TypeDeclRecord);
        WriteS (f, "  WHEN OTHERS => NULL ; "); 
        WriteS (f, "  END CASE ; "); WriteNl (f);
        WriteS (f, "END RECORD ; "); WriteNl (f);
        WriteNl (f);
        WI (iNoTree); WriteS (f, " : CONSTANT "); WI (itTree); WriteS (f, " := NULL ; "); WriteNl (f);
        WriteNl (f);
        WI (iMain); WriteS (f, "Root : "); WI (itTree); WriteS (f, " ; "); WriteNl (f);
      
        WriteS (f, "FUNCTION Make"); WI (iMain); WriteS (f, " ( Kind : KindTyp ) RETURN "); WI (itTree); WriteS (f, " ; "); WriteNl (f);
        WriteS (f, "FUNCTION IsType ( Tree : "); WI (itTree); WriteS (f, " ; Kind : KindTyp ) RETURN BOOLEAN ; "); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('n'), Options) THEN
        ForallClasses (Classes, ProcedureDecln);
        WriteNl (f);
      END;
      IF IsElement (ORD ('m'), Options) THEN
        ForallClasses (Classes, ProcedureDeclm);
        WriteNl (f);
      END;
      IF IsElement (ORD ('f'), Options) THEN
        WriteS ( StdError , "-f option not implemented for Ada" ) ; 
        WriteNl (StdError ) ;
        
      END;
      IF IsElement (ORD ('F'), Options) AND NOT IsElement (ORD ('<'), Options) THEN
        WriteS ( StdError , "-F option not implemented for Ada" ) ; 
        WriteNl (StdError ) ;
         
      END;
      IF IsElement (ORD ('o'), Options) THEN
        WriteS (f, "PROCEDURE Write"); WI (iModule); WriteS (f, "Node "); WriteNl (f);
        WriteS (f, " ( Tree : "); WI (itTree); WriteS (f, " ) ; "); WriteNl (f);
      END;
      IF IsElement (ORD ('w'), Options) THEN
        WriteS ( StdError , "-w option not implemented for Ada" ) ; 
        WriteNl (StdError ) ;
        
      END;
      IF IsElement (ORD ('^'), Options) THEN
        WriteS (f, "-- Html graph writer:"); WriteNl (f);
        WriteS (f, "PROCEDURE Write"); WI (iModule); WriteS (f, "Html "); WriteNl (f);
        WriteS (f, '  ( f : Text_Io . File_Type ; Tree : '); WI (itTree); WriteS (f, ' ; Title : STRING := "" '); WriteNl (f);
        WriteS (f, "  ; SuppressNullFields : BOOLEAN := FALSE ) ; "); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('r'), Options) THEN
        WriteS ( StdError , "-r option not implemented for Ada" ) ; 
        WriteNl (StdError ) ;
        
      END;
      IF IsElement (ORD ('p'), Options) THEN
        WriteS ( StdError , "-p option not implemented for Ada" ) ; 
        WriteNl (StdError ) ;
        
      END;
      IF IsElement (ORD ('g'), Options) THEN
        WriteS ( StdError , "-g option not implemented for Ada" ) ; 
        WriteNl (StdError ) ;
        
      END;
      IF IsElement (ORD ('t'), Options) THEN
        WriteS ( StdError , "-t option not implemented for Ada" ) ; 
        WriteNl (StdError ) ;
        
      END;
      IF IsElement (ORD ('b'), Options) THEN
        WriteS ( StdError , "-b option not implemented for Ada" ) ; 
        WriteNl (StdError ) ;
        
      END;
      IF IsElement (ORD ('R'), Options) THEN
        WriteS ( StdError , "-R option not implemented for Ada" ) ; 
        WriteNl (StdError ) ;
        
      END;
      IF IsElement (ORD ('y'), Options) THEN
        WriteS ( StdError , "-y option not implemented for Ada" ) ; 
        WriteNl (StdError ) ;
        
      END;
      IF IsElement (ORD ('k'), Options) THEN
        WriteS (f, "FUNCTION Check"); WI (iModule); WriteS (f, " ( Tree : "); WI (itTree); WriteS (f, " ) RETURN BOOLEAN ; "); WriteNl (f);
      END;
      IF IsElement (ORD ('q'), Options) THEN
        WriteS ( StdError , "-q option not implemented for Ada" ) ; 
        WriteNl (StdError ) ;
        
      END;
      IF IsElement (ORD ('='), Options) THEN
        WriteS ( StdError , "-= option not implemented for Ada" ) ; 
        WriteNl (StdError ) ;
      
      END;
      IF IsElement (ORD ('L'), Options) THEN
        WriteS (f, "PROCEDURE Init"); WI (iModule); WriteS (f, " ( Tree : "); WI (itTree); WriteS (f, " ) ; "); WriteNl (f);
      END;
        WriteS (f, "PROCEDURE Begin"); WI (iModule); WriteS (f, " ; "); WriteNl (f);
        WriteS (f, "PROCEDURE Close"); WI (iModule); WriteS (f, " ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "END "); WI (iModule); WriteS (f, " ; "); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  END;
 END TreePackSpec;

PROCEDURE ConstDeclsPre (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 288 "" *)
     WITH t^.Class DO
(* line 288 "" *)
      
        IF NOT (Abstract IN Properties) THEN
           INC (ConstCount);
           IF NOT (Ignore IN Properties) THEN
              WI (Name); WriteS (f, " : CONSTANT := "); WN (ConstCount); WriteS (f, ";"); WriteNl (f);
           END;
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END ConstDeclsPre;

PROCEDURE ConstDeclsPost (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 299 "" *)
     WITH t^.Class DO
(* line 299 "" *)
      
      IF IsElement (ORD ('+'), Options) THEN
        IF NOT (Abstract IN Properties) THEN
           IF NOT (Ignore IN Properties) THEN
              WI (Name); WriteS (f, "Max : CONSTANT := "); WN (ConstCount); WriteS (f, " ; "); WriteNl (f);
           END;
        END;
      END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END ConstDeclsPost;

PROCEDURE PointerTypes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 311 "" *)
     WITH t^.Class DO
(* line 311 "" *)
      
        IF NOT (Abstract IN Properties) THEN
           IF NOT (Ignore IN Properties) THEN
              WriteS (f, "SUBTYPE p");WI (Name); WriteS (f, " IS "); WI ( itTree ); WriteS (f, " ; "); WriteNl (f);
           END;
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END PointerTypes;

PROCEDURE TypeDeclNode (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 321 "" *)
     WITH t^.Class DO
(* line 321 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "TYPE y"); WI (Name); WriteS (f, " IS RECORD "); WriteNl (f);
           ForallAttributes (t, TypeDeclNode); 
           WriteS (f, "  END RECORD ; "); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 328 "" *)
     WITH t^.Child DO
(* line 328 "" *)
      
        WriteS (f, "  "); WI (Name); WriteS (f, " : "); WI (itTree); WriteS (f, " ; "); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 331 "" *)
     WITH t^.Attribute DO
(* line 331 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
           WriteS (f, "  "); WI (Name); WriteS (f, " : "); WI (Type); WriteS (f, " ; "); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END TypeDeclNode;

PROCEDURE TypeDeclRecord (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 340 "" *)
     WITH t^.Class DO
(* line 340 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "  WHEN "); WI (Name); WriteS (f, " => "); WI (Name); WriteS (f, " : y"); WI (Name); WriteS (f, " ; "); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END TypeDeclRecord;

PROCEDURE ProcedureDecln (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 349 "" *)
     WITH t^.Class DO
(* line 349 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "FUNCTION n"); WI (Name); WriteS (f, " RETURN "); WI (itTree); WriteS (f, " ; "); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END ProcedureDecln;

PROCEDURE ProcedureDeclm (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 358 "" *)
     WITH t^.Class DO
(* line 359 "" *)
      ProcedureHeadingm (t);
(* line 360 "" *)
      WriteS (f, " ; ");
(* line 360 "" *)
      WriteNl (f);
      RETURN;
     END (* WITH *) ;

  END;
 END ProcedureDeclm;

PROCEDURE ProcedureHeadingm (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 365 "" *)
     WITH t^.Class DO
(* line 365 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           ListCount := 0;
           WriteS (f, "FUNCTION m"); WI (Name); WriteNl (f);
           WriteS (f, "  ( ");  
           ForallAttributes (t, ProcedureHeadingm); 
           WriteS (f, ") RETURN "); WI (itTree); WriteS (f, "");   
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 374 "" *)
     WITH t^.Child DO
(* line 374 "" *)
      
        IF Input IN Properties THEN
           IF ListCount > 0 THEN WriteS (f, "; "); END;
           WriteS (f, "  p"); WI (Name); WriteS (f, " : "); WI (itTree); WriteS (f, " := NULL "); WriteNl (f);
           WriteS (f, "  "); 
           INC (ListCount);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 382 "" *)
     WITH t^.Attribute DO
(* line 382 "" *)
      
        IF Input IN Properties THEN
           IF ListCount > 0 THEN WriteS (f, "; "); END;
           WriteS (f, "  p"); WI (Name); WriteS (f, ": "); WI (Type); WriteNl (f);
           WriteS (f, "  "); WriteNl (f);
           INC (ListCount);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ProcedureHeadingm;

PROCEDURE TreePackBody (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Ag) THEN
(* line 393 "" *)
     WITH t^.Ag DO
(* line 393 "" *)
      
        WriteNl (f);
        WriteS (f, "-- This Ada PACKAGE BODY file was mechanically generated by cg. "); WriteNl (f);
        WriteNl (f);
      IF IsElement (ORD ('k'), Options) 
         OR IsElement (ORD ('q'), Options) 
         OR IsElement (ORD ('w'), Options) 
         OR IsElement (ORD ('^'), Options) 
         OR IsElement (ORD ('o'), Options) THEN
        WriteS (f, "WITH Text_Io ; "); 
      END; 
      IF IsElement (ORD ('o'), Options) THEN
        WriteS (f, "WITH Unchecked_Conversion ; "); 
      END; 
      IF IsElement (ORD ('<'), Options) THEN
        WriteS (f, "WITH "); WI (iMain); WriteS (f, " ; USE "); WI (iMain); WriteS (f, " ; "); WriteNl (f);
        WriteNl (f);
      END;
        WriteLine (TreeCodes^.Codes.BodyWithLine);
        WriteText (f, TreeCodes^.Codes.BodyWith);
        WriteS (f, "PACKAGE BODY "); WI (iModule); WriteS (f, " IS "); WriteNl (f);
      
      IF IsElement (ORD ('<'), Options) THEN
       
      END;
        WriteLine (TreeCodes^.Codes.GlobalLine);
        WriteText (f, TreeCodes^.Codes.Global);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.GlobalLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Global);
           Node := Node^.Module.Next;
        END;
        WriteLine (TreeCodes^.Codes.LocalLine);
        WriteText (f, TreeCodes^.Codes.Local);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.LocalLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Local);
           Node := Node^.Module.Next;
        END;
        WriteS (f, '# include "yy'); WI (iModule); WriteS (f, '.w"'); WriteNl (f);
        WriteNl (f);
      IF NOT IsElement (ORD ('<'), Options) THEN
        WriteS (f, "yyTypeRange : ARRAY ( 0.."); WN (ClassCount); WriteS (f, ") OF SHORTCARD;"); WriteNl (f);
      
        WriteS (f, "FUNCTION  Make"); WI (iMain); WriteS (f, " ( Kind : KindTyp ) RETURN "); WI (itTree); WriteNl (f);
        WriteS (f, "  IS "); WriteNl (f);
        WriteS (f, "    yyt : "); WI (itTree); WriteS (f, " ; "); WriteNl (f);
        WriteS (f, "  BEGIN "); WriteNl (f);
        WriteS (f, "    yyt := NEW yyNode ( Kind ) ; "); 
        WriteS (f, "    yyt . ALL . yyHead . yyMark := 0 ; "); WriteNl (f);
        WriteS (f, "    RETURN yyt; "); WriteNl (f);
        WriteS (f, " END Make"); WI (iMain); WriteS (f, " ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "FUNCTION IsType ( Tree : "); WI (itTree); WriteS (f, " ; Kind : KindTyp ) RETURN  BOOLEAN "); WriteNl (f);
        WriteS (f, "  IS BEGIN "); WriteNl (f);
        WriteS (f, "    RETURN Tree /= "); WI (iNoTree); WriteNl (f);
        WriteS (f, "      AND Kind <= Tree . ALL . Kind "); WriteNl (f);
        WriteS (f, "      AND Tree . ALL . Kind <= yyTypeRange ( Kind ) ; "); WriteNl (f);
        WriteS (f, "  END IsType ; "); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('n'), Options) THEN
        ForallClasses (Classes, ProcedureBodyn);
      END;
        WriteNl (f);
      IF IsElement (ORD ('m'), Options) THEN
        ForallClasses (Classes, ProcedureBodym);
      END;
      TreeIO (t);  
      IF IsElement (ORD ('f'), Options) THEN
      
      END;
      IF IsElement (ORD ('F'), Options) AND NOT IsElement (ORD ('<'), Options) THEN
      
      END;
      IF IsElement (ORD ('t'), Options) OR
         IsElement (ORD ('b'), Options) THEN
      
      END;
      IF IsElement (ORD ('t'), Options) THEN
      
      END;
      IF IsElement (ORD ('R'), Options) THEN
      
      END;
      IF IsElement (ORD ('y'), Options) THEN
      
      END;
      IF IsElement (ORD ('k'), Options) THEN
        WriteS (f, "FUNCTION yyCheckChild "); WriteNl (f);
        WriteS (f, "  ( yyParent , yyChild : "); WI (itTree); WriteNl (f);
        WriteS (f, "  ; yyType : KindTyp ; yySelector: STRING "); WriteNl (f);
        WriteS (f, "  ) "); WriteNl (f);
        WriteS (f, "RETURN BOOLEAN ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "FUNCTION yyCheck"); WI (iModule); WriteS (f, " ( yyt : "); WI (itTree); WriteS (f, " ) RETURN BOOLEAN "); WriteNl (f);
        WriteS (f, "  IS "); 
        WriteS (f, "    yyResult : BOOLEAN ; "); WriteNl (f);
        WriteS (f, "  BEGIN "); WriteNl (f);
        WriteS (f, "    IF yyt = "); WI (iNoTree); WriteS (f, " THEN RETURN FALSE ; "); WriteNl (f);
        WriteS (f, "    ELSIF yyt . ALL . yyHead . yyMark = 0 THEN RETURN TRUE ; "); WriteNl (f);
        WriteS (f, "    END IF ; "); WriteNl (f);
        WriteS (f, "    yyt . ALL . yyHead . yyMark := 0;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "    yyResult := TRUE;"); WriteNl (f);
        WriteS (f, "    CASE yyt . ALL . Kind IS "); WriteNl (f);
        ForallClasses (Classes, CheckAttributes);
        WriteS (f, "    WHEN OTHERS => NULL ; "); WriteNl (f);
        WriteS (f, "    END CASE ; "); WriteNl (f);
        WriteS (f, "    RETURN yyResult ; "); WriteNl (f);
        WriteS (f, "  END yyCheck"); WI (iModule); WriteS (f, " ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "FUNCTION yyCheckChild "); WriteNl (f);
        WriteS (f, "  ( yyParent , yyChild : "); WI (itTree); WriteNl (f);
        WriteS (f, "  ; yyType : KindTyp ; yySelector: STRING "); WriteNl (f);
        WriteS (f, "  ) "); WriteNl (f);
        WriteS (f, "RETURN BOOLEAN "); WriteNl (f);
        WriteS (f, "  IS "); 
        WriteS (f, "    yySuccess : BOOLEAN ; "); WriteNl (f);
        WriteS (f, "  BEGIN"); WriteNl (f);
        WriteS (f, "    yySuccess := IsType ( yyChild , yyType ) ; "); WriteNl (f);
        WriteS (f, "    IF NOT yySuccess THEN"); WriteNl (f);
        WriteS (f, '      Text_Io . Put ( "CheckTree: parent = " ) ; '); WriteNl (f);
        WriteS (f, "      Write"); WI (iModule); WriteS (f, "Node ( yyParent ) ; "); WriteNl (f);
        WriteS (f, '      Text_Io . Put_Line ( "" ) ; '); WriteNl (f);
        WriteS (f, '      Text_Io . Put ( "selector: " ) ; '); WriteNl (f);
        WriteS (f, "      Text_Io . Put ( yySelector ) ; "); WriteNl (f);
        WriteS (f, '      Text_Io . Put ( ", child = " ) ; '); WriteNl (f);
        WriteS (f, "      Write"); WI (iModule); WriteS (f, "Node ( yyChild ) ; "); WriteNl (f);
        WriteS (f, '      Text_Io . Put_Line ( "" ) ; '); WriteNl (f);
        WriteS (f, "    END IF ; "); WriteNl (f);
        WriteS (f, "  RETURN yyCheck"); WI (iModule); WriteS (f, " ( yyChild ) AND yySuccess ; "); WriteNl (f);
        WriteS (f, " END yyCheckChild ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "FUNCTION Check"); WI (iModule); WriteS (f, " ( Tree : "); WI (itTree); WriteS (f, " ) RETURN BOOLEAN "); WriteNl (f);
        WriteS (f, "  IS BEGIN "); WriteNl (f);
        WriteS (f, "    yyMark ( Tree ) ; "); WriteNl (f);
        WriteS (f, "    RETURN yyCheck"); WI (iModule); WriteS (f, " ( Tree ) ; "); WriteNl (f);
        WriteS (f, "  END Check"); WI (iModule); WriteS (f, " ; "); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('q'), Options) THEN
      
      END;
      IF IsElement (ORD ('='), Options) THEN
      
      END;
      IF IsElement (ORD ('L'), Options) THEN
        MaxBit := 0;
        ForallClasses (Classes, CompMaxBit);
        WriteS (f, "PROCEDURE Init"); WI ( iModule); WriteS (f, " ( yyt : "); WI (itTree); WriteS (f, " ) "); WriteNl (f);
        WriteS (f, "  IS BEGIN"); WriteNl (f);
        WriteS (f, "  LOOP"); WriteNl (f);
        FOR i := 0 TO (MaxBit - 1) DIV BSS DO
           WriteS (f, "     yyt . ALL . yyIsComp"); WN (i); WriteS (f, " := BitsetEmpty ; "); WriteNl (f);
      IF IsElement (ORD ('5'), Options) THEN
           WriteS (f, "     yyt . ALL . yyIsDone"); WN (i); WriteS (f, " := BitsetEmpty ;"); WriteNl (f);
      END;
        END;
        WriteS (f, "    CASE yyt . ALL . Kind OF"); WriteNl (f);
        ForallClasses (Classes, InitAttributes);
        WriteS (f, "    ELSE RETURN;"); WriteNl (f);
        WriteS (f, "    END CASE ; "); WriteNl (f);
        WriteS (f, "  END LOOP ;"); WriteNl (f);
        WriteS (f, " END Init"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
      END;
        WriteS (f, "PROCEDURE Begin"); WI (iModule); WriteNl (f);
        WriteS (f, "  IS BEGIN "); WriteNl (f);
        WriteLine (TreeCodes^.Codes.BeginLine);
        WriteText (f, TreeCodes^.Codes.Begin);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.BeginLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Begin);
           Node := Node^.Module.Next;
        END;
        WriteS (f, "    NULL ; "); WriteNl (f);
           
        WriteS (f, "  END Begin"); WI (iModule); WriteS (f, " ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE Close"); WI (iModule); WriteNl (f);
        WriteS (f, "  IS BEGIN "); WriteNl (f);
        WriteLine (TreeCodes^.Codes.CloseLine);
        WriteText (f, TreeCodes^.Codes.Close);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.CloseLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Close);
           Node := Node^.Module.Next;
        END;
        WriteS (f, "    NULL ; "); WriteNl (f);
           
        WriteS (f, "  END Close"); WI (iModule); WriteS (f, " ; "); WriteNl (f);
        WriteNl (f);
      IF NOT IsElement (ORD ('<'), Options) THEN
      
      END;
        WriteS (f, "BEGIN"); WriteNl (f);
      IF IsElement (ORD ('r'), Options) THEN
        
      END;
      IF NOT IsElement (ORD ('<'), Options) THEN
      
        ForallClasses (Classes, InitTypeRange);
      END;
      IF IsElement (ORD (';'), Options) THEN
       
      END;
      IF IsElement (ORD ('y'), Options) THEN
      
      END;
        WriteS (f, "  Begin"); WI (iModule); WriteS (f, " ; "); WriteNl (f);
        WriteS (f, "END "); WI (iModule); WriteS (f, " ; "); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  END;
 END TreePackBody;

PROCEDURE ProcedureBodyn (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 874 "" *)
     WITH t^.Class DO
(* line 874 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "FUNCTION n"); WI (Name); WriteS (f, " RETURN "); WI (itTree); WriteNl (f);
           WriteS (f, "  IS "); WriteNl (f);
           WriteS (f, "    yyt : "); WI (itTree); WriteS (f, " ; "); WriteNl (f);
           WriteS (f, "  BEGIN "); WriteNl (f);
           WriteS (f, "    yyt := NEW yyNode ( "); WI ( Name ) ; WriteS (f, " ) ; "); WriteNl (f);
           WriteS (f, "    yyt . ALL . yyHead . yyMark := 0 ; "); WriteNl (f);
           iClassName := Name;
           ForallAttributes (t, ProcedureBodyn);
           WriteS (f, "    RETURN yyt ; "); WriteNl (f);
           WriteS (f, " END n"); WI (Name); WriteS (f, " ; "); WriteNl (f);
           WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 889 "" *)
     WITH t^.Child DO
(* line 889 "" *)
      
        WriteS (f, "    begin"); WI (itTree); WriteS (f, " ( yyt . ALL . "); WI ( iClassName ) ; WriteS (f, " . "); WI (Name); WriteS (f, " ) "); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 892 "" *)
     WITH t^.Attribute DO
(* line 892 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
           WriteS (f, "    begin"); WI (Type); WriteS (f, " ( yyt . ALL . "); WI ( iClassName ) ; WriteS (f, " . "); WI (Name); WriteS (f, " ) "); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ProcedureBodyn;

PROCEDURE ProcedureBodym (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 901 "" *)
     WITH t^.Class DO
(* line 901 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           ProcedureHeadingm (t);
           WriteS (f, "  IS "); 
           WriteS (f, "    yyt : "); WI (itTree); WriteS (f, " ; "); WriteNl (f);
           WriteS (f, "  BEGIN "); WriteNl (f);
           WriteS (f, "    yyt := NEW yyNode ( "); WI ( Name ) ; WriteS (f, " ) ; "); WriteNl (f);
           WriteS (f, "    yyt . ALL . yyHead . yyMark := 0 ; "); WriteNl (f);
           IF ({HasChildren, HasAttributes} * Properties) # {} THEN
              iClassName := Name;
              ForallAttributes (t, ProcedureBodym);
           END;
           WriteS (f, "    RETURN yyt ; "); WriteNl (f);
           WriteS (f, "  END m"); WI (Name); WriteS (f, " ; "); WriteNl (f);
           WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 918 "" *)
     WITH t^.Child DO
(* line 918 "" *)
      
        IF Input IN Properties THEN
           WriteS (f, "    yyt . ALL . "); WI ( iClassName ) ; WriteS (f, " . "); WI (Name); WriteS (f, " := p"); WI (Name); WriteS (f, " ; "); WriteNl (f);
        ELSE
           WriteS (f, "    begin"); WI (itTree); WriteS (f, " ( yyt . ALL . "); WI ( iClassName ) ; WriteS (f, " . "); WI (Name); WriteS (f, " ) "); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 925 "" *)
     WITH t^.Attribute DO
(* line 925 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
           IF Input IN Properties THEN
              WriteS (f, "    yyt . ALL . "); WI ( iClassName ) ; WriteS (f, " . "); WI (Name); WriteS (f, " := p"); WI (Name); WriteS (f, " ; "); WriteNl (f);
           ELSE
              WriteS (f, "    begin"); WI (Type); WriteS (f, " ( yyt . ALL . "); WI ( iClassName ) ; WriteS (f, " . "); WI (Name); WriteS (f, " ) "); WriteNl (f);
           END;
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ProcedureBodym;

PROCEDURE ReleaseAttributes1 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 938 "" *)
     WITH t^.Class DO
(* line 938 "" *)
      
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           WriteS (f, "| "); WI (Name); WriteS (f, ":"); WriteNl (f);
           iClassName := Name;
           ForallAttributes (t, ReleaseAttributes1);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 945 "" *)
     WITH t^.Child DO
(* line 945 "" *)
      
        WriteS (f, "close"); WI (itTree); WriteS (f, " (yyt . ALL . "); WI ( iClassName ) ; WriteS (f, " . "); WI (Name); WriteS (f, " ) "); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ReleaseAttributes1;

PROCEDURE ReleaseAttributes2 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 952 "" *)
     WITH t^.Class DO
(* line 952 "" *)
      
        IF ((NoCodeClass * Properties) = {}) AND (HasAttributes IN Properties) THEN
           WriteS (f, "WHEN "); WI (Name); WriteS (f, " => "); WriteNl (f);
           iClassName := Name;
           ForallAttributes (t, ReleaseAttributes2);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 959 "" *)
     WITH t^.Attribute DO
(* line 959 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
           WriteS (f, "close"); WI (Type); WriteS (f, " (yyt . ALL . "); WI ( iClassName ) ; WriteS (f, " . "); WI (Name); WriteS (f, " ) "); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ReleaseAttributes2;

PROCEDURE TraverseTD (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 968 "" *)
     WITH t^.Class DO
(* line 968 "" *)
      
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           WriteS (f, "| "); WI (Name); WriteS (f, ":"); WriteNl (f);
           GetIterator (t);
           iClassName := Name;
           ForallAttributes (t, TraverseTD);
           IF Iterator = NoTree THEN
              WriteS (f, "RETURN;"); WriteNl (f);
           ELSE
              WriteS (f, "yyt := yyt . ALL . "); WI (iClassName); WriteS (f, " . "); WI (Iterator^.Child.Name); WriteS (f, " ; "); WriteNl (f);
           END;
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 981 "" *)
     WITH t^.Child DO
(* line 981 "" *)
      
        IF t # Iterator THEN
           WriteS (f, "yyTraverse"); WI (iModule); WriteS (f, "TD (yyt . ALL . "); WI (iClassName); WriteS (f, " . "); WI (Name); WriteS (f, " ) ; "); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END TraverseTD;

PROCEDURE TraverseBU (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 990 "" *)
     WITH t^.Class DO
(* line 990 "" *)
      
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           WriteS (f, "| "); WI (Name); WriteS (f, ":"); WriteNl (f);
           GetIterator (t);
           iClassName := Name;
           ForallAttributes (t, TraverseBU);
           IF Iterator = NoTree THEN
              WriteS (f, "RETURN;"); WriteNl (f);
           ELSE
              WriteS (f, "yyTraverse"); WI (iModule); WriteS (f, "BU (yyt . ALL . "); WI (iClassName); WriteS (f, " . "); WI (Iterator^.Child.Name); WriteS (f, " ) ; "); WriteNl (f);
           END;
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1003 "" *)
     WITH t^.Child DO
(* line 1003 "" *)
      
        IF t # Iterator THEN
           WriteS (f, "yyTraverse"); WI (iModule); WriteS (f, "BU (yyt . ALL . "); WI (iClassName); WriteS (f, " . "); WI (Name); WriteS (f, " ) ; "); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END TraverseBU;

PROCEDURE Reverse1 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1012 "" *)
     WITH t^.Class DO
(* line 1012 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           iClassName := Name;
           ForallAttributes (t, Reverse1);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1018 "" *)
     WITH t^.Child DO
(* line 1018 "" *)
      
        IF Reverse IN Properties THEN
           WriteS (f, "WHEN "); WI (iClassName); WriteS (f, " => yyNext := yyOld . ALL . "); WI (iClassName); WriteS (f, " . "); WI (Name); WriteS (f, " ; "); 
           WriteS (f, " yyOld . ALL . "); WI (iClassName); WriteS (f, " . "); WI (Name); WriteS (f, " := yyNew ; "); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Reverse1;

PROCEDURE Reverse2 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1028 "" *)
     WITH t^.Class DO
(* line 1028 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           iClassName := Name;
           ForallAttributes (t, Reverse2);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1034 "" *)
     WITH t^.Child DO
(* line 1034 "" *)
      
        IF Reverse IN Properties THEN
           WriteS (f, "WHEN "); WI (iClassName); WriteS (f, " => yyTail . ALL . "); WI (iClassName); WriteS (f, " . "); WI (Name); WriteS (f, " := yyOld ; "); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Reverse2;

PROCEDURE Copy (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1043 "" *)
     WITH t^.Class DO
(* line 1043 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "WHEN "); WI (Name); WriteS (f, " => yyNew^^."); WI (Name); WriteS (f, " := yyt^."); WI (Name); WriteS (f, ";"); WriteNl (f);
           GetIterator (t);
           iClassName := Name;
           ForallAttributes (t, Copy);
           IF Iterator = NoTree THEN
              WriteS (f, "RETURN;"); WriteNl (f);
           ELSE
              WriteS (f, "yyt := yyt^."); WI (Name); WriteS (f, "."); WI (Iterator^.Child.Name); WriteS (f, ";"); WriteNl (f);
              WriteS (f, "yyNew := SYSTEM.ADR (yyNew^^."); WI (Name); WriteS (f, "."); WI (Iterator^.Child.Name); WriteS (f, ");"); WriteNl (f);
           END;
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1057 "" *)
     WITH t^.Child DO
(* line 1057 "" *)
      
        IF t # Iterator THEN
           WriteS (f, "copy"); WI (itTree); WriteS (f, " (yyNew^^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ", "); 
              WriteS (f, "yyt^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ")"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 1063 "" *)
     WITH t^.Attribute DO
(* line 1063 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
           WriteS (f, "copy"); WI (Type); WriteS (f, " (yyNew^^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ", "); 
              WriteS (f, "yyt^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ")"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Copy;

PROCEDURE CheckAttributes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1073 "" *)
     WITH t^.Class DO
(* line 1073 "" *)
      
        IF ((NoCodeClass * Properties) = {}) 
           AND (HasChildren IN Properties) THEN
           WriteS (f, "    WHEN "); WI (Name); WriteS (f, " => "); WriteNl (f);
           iClassName := Name;
           ForallAttributes (t, CheckAttributes);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1081 "" *)
     WITH t^.Child DO
(* line 1082 "" *)
       WriteS (f, "       yyResult := yyResult AND THEN "); WriteNl (f);
       WriteS (f, "         yyCheckChild ( yyt , yyt . ALL . "); WI ( iClassName ) ; WriteS (f, " . "); WI (Name); WriteS (f, " , "); 
                   WI (Type); WriteS (f, ' , "'); WI (Name); WriteS (f, '" ) ; '); WriteNl (f);
     ;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 1086 "" *)
   LOOP
     WITH t^.Attribute DO
(* line 1087 "" *)
      IF NOT (( Link IN Properties )) THEN EXIT; END;
(* line 1088 "" *)
       WriteS (f, "       yyResult := yyResult AND THEN "); WriteNl (f);
       WriteS (f, "         yyCheckChild  ( yyt , yyt . ALL . "); WI ( iClassName ) ; WriteS (f, " . "); WI (Name); WriteS (f, " , "); 
                   WI (Type); WriteS (f, ' , "'); WI (Name); WriteS (f, '" ) ; '); WriteNl (f);
     ;
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  ELSE END;

 END CheckAttributes;

PROCEDURE InitTypeRange (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 1096 "" *)
     WITH t^.Class DO
(* line 1096 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           iRange := Name;
           ForallClasses (Extensions, InitTypeRange2);
           WriteS (f, "  yyTypeRange ("); WI (Name); WriteS (f, ") := "); WI (iRange); WriteS (f, " ; "); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END InitTypeRange;

PROCEDURE InitTypeRange2 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 1107 "" *)
     WITH t^.Class DO
(* line 1107 "" *)
      
        iRange := Name;
;
      RETURN;
     END (* WITH *) ;

  END;
 END InitTypeRange2;

PROCEDURE QueryAttributes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1114 "" *)
     WITH t^.Class DO
(* line 1114 "" *)
      
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           WriteS (f, "WHEN "); WI (Name); WriteS (f, " => IF FALSE THEN"); WriteNl (f);
           iClassName := Name;
           ForallAttributes (t, QueryAttributes);
           WriteS (f, "END;"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1122 "" *)
     WITH t^.Child DO
(* line 1123 "" *)
       WriteS (f, "ELSIF yyyIsEqual ('"); WI (Name); WriteS (f, "') THEN Query"); WI (iModule);
       WriteS (f, " (yyt . ALL . "); WI (iClassName); WriteS (f, " . "); WI (Name); WriteS (f, " ) ; "); WriteNl (f);
     ;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 1126 "" *)
   LOOP
     WITH t^.Attribute DO
(* line 1127 "" *)
      IF NOT (( Link IN Properties )) THEN EXIT; END;
(* line 1128 "" *)
       WriteS (f, "ELSIF yyyIsEqual ('"); WI (Name); WriteS (f, "') THEN Query"); WI (iModule);
       WriteS (f, " (yyt . ALL . "); WI (iClassName); WriteS (f, " . "); WI (Name); WriteS (f, " ) ; "); WriteNl (f);
     ;
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  ELSE END;

 END QueryAttributes;

PROCEDURE IsEqualAttributes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1135 "" *)
     WITH t^.Class DO
(* line 1135 "" *)
      
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           WriteS (f, "WHEN "); WI (Name); WriteS (f, " => RETURN TRUE "); WriteNl (f);
           iClassName := Name;
           ForallAttributes (t, IsEqualAttributes);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1143 "" *)
     WITH t^.Child DO
(* line 1143 "" *)
      
        WriteS (f, "AND equal"); WI (itTree); WriteS (f, " (yyt1 . ALL . "); WI (iClassName); WriteS (f, " . "); WI (Name);
        WriteS (f, ", yyt2 . ALL . "); WI (iClassName); WriteS (f, " . "); WI (Name); WriteS (f, " ) "); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 1147 "" *)
     WITH t^.Attribute DO
(* line 1147 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
           WriteS (f, "AND (equal"); WI (Type); WriteS (f, " (yyt1 . ALL . "); WI (iClassName); WriteS (f, " . "); WI (Name);
           WriteS (f, ", yyt2 . ALL . "); WI (iClassName); WriteS (f, " . "); WI (Name); WriteS (f, " ) ) "); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END IsEqualAttributes;

PROCEDURE InitAttributes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1157 "" *)
   LOOP
     WITH t^.Class DO
(* line 1158 "" *)
      IF NOT (((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties)) THEN EXIT; END;
(* line 1159 "" *)
      WriteS (f, "    WHEN ");
(* line 1159 "" *)
      WI (Name);
(* line 1159 "" *)
      WriteS (f, " => ");
(* line 1159 "" *)
      WriteNl (f);
(* line 1160 "" *)
      GetIterator (t);
(* line 1161 "" *)
      iClassName := Name;
(* line 1162 "" *)
      gBitCount := BitCount;
(* line 1163 "" *)
      ForallAttributes (t, InitAttributes);
(* line 1164 "" *)
             IF (Iterator = NoTree) OR NOT (Input IN Iterator^.Child.Properties) THEN
           WriteS (f, "       RETURN ; "); WriteNl (f);
        ELSE
           WriteS (f, "       yyt := yyt . ALL . "); WI ( iClassName ) ; WriteS (f, " . "); WI (Iterator^.Child.Name); WriteS (f, " ; "); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.Child:
(* line 1170 "" *)
   LOOP
     WITH t^.Child DO
(* line 1171 "" *)
      IF NOT (Input IN Properties) THEN EXIT; END;
(* line 1172 "" *)
      WriteS (f, "       yyt . ALL . yyHead . yyOffset := ");
(* line 1173 "" *)
      WN (gBitCount + BitOffset);
(* line 1173 "" *)
      WriteS (f, " ; ");
(* line 1174 "" *)
      WriteS (f, "       yyt . ALL . yyHead . yyParent := yyt ; ");
(* line 1175 "" *)
      IF NOT (t # Iterator) THEN EXIT; END;
(* line 1176 "" *)
      WriteS (f, "       Init");
(* line 1176 "" *)
      WI (iModule);
(* line 1176 "" *)
      WriteS (f, " (yyt . ALL . ");
(* line 1176 "" *)
      WI (iClassName);
(* line 1176 "" *)
      WriteS (f, " . ");
(* line 1176 "" *)
      WI (Name);
(* line 1176 "" *)
      WriteS (f, " ) ; ");
(* line 1176 "" *)
      WriteNl (f);
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  ELSE END;

 END InitAttributes;

PROCEDURE InitNodeSize (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 1181 "" *)
   LOOP
     WITH t^.Class DO
(* line 1182 "" *)
      IF NOT ((NoCodeClass * Properties) = {}) THEN EXIT; END;
(* line 1183 "" *)
      WriteS (f, " yyNodeSize [");
(* line 1183 "" *)
      WI (Name);
(* line 1183 "" *)
      WriteS (f, "] := SYSTEM.TSIZE (y");
(* line 1183 "" *)
      WI (Name);
(* line 1183 "" *)
      WriteS (f, ");");
(* line 1183 "" *)
      WriteNl (f);
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
 END InitNodeSize;

PROCEDURE CompMaxBit (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1188 "" *)
     WITH t^.Class DO
(* line 1189 "" *)
      i := 1;
(* line 1190 "" *)
      ForallAttributes (t, CompMaxBit);
(* line 1191 "" *)
      MaxBit := Max (i, MaxBit);
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1193 "" *)
   LOOP
     WITH t^.Child DO
(* line 1195 "" *)
      IF NOT (({Input, Test, Dummy} * Properties = {})) THEN EXIT; END;
(* line 1196 "" *)
      INC (i);
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.Attribute:
(* line 1193 "" *)
   LOOP
     WITH t^.Attribute DO
(* line 1195 "" *)
      IF NOT (({Input, Test, Dummy} * Properties = {})) THEN EXIT; END;
(* line 1196 "" *)
      INC (i);
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  ELSE END;

 END CompMaxBit;

PROCEDURE BeginTreeAda1;
 BEGIN
(* line 79 "" *)
 ConstCount := 0; 

 END BeginTreeAda1;

PROCEDURE CloseTreeAda1;
 BEGIN

 END CloseTreeAda1;

PROCEDURE yyExit;
 BEGIN
  IO.CloseIO; System.Exit (1);
 END yyExit;

BEGIN
 yyf   := IO.StdOutput;
 Exit  := yyExit;
 BeginTreeAda1;
END TreeAda1.

