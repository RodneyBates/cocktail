(* $Id: Parser.mi,v 2.8 1992/08/12 06:54:05 grosch rel $ *)
(* Skeleton parser for Cocktail lalr. *)
(* Modified Rodney M. Bates. Various times. *)

IMPLEMENTATION MODULE Parser;

IMPORT SYSTEM, Scanner, Positions, Errors, Strings, DynArray, Sets, System;

(* line 13 "/tmp/lalr1716" *)
(* line 13 ../src/cg.lalr *)


FROM StringMem	IMPORT GetString;
FROM Strings	IMPORT tString, SubString, Length, ArrayToString, IntToString, Concatenate;
FROM Idents	IMPORT tIdent, NoIdent, MakeIdent;
FROM Texts	IMPORT MakeText;
FROM Scanner	IMPORT BeginScanner, tScanAttribute, Attribute;
FROM Positions	IMPORT NoPosition;

IMPORT Idents;

FROM Tree	IMPORT
   iInteger	, Reverse	, Link          , MakeTree	,
   Input	,
   Output	, Synthesized	, Inherited	, String	,
   Nonterminal	, Terminal	, Explicit	, HasSelector	,
   Thread	, Virtual	, Stack		, Demand	,
   Funct	, Ignore	, Abstract	, nNoAction	,
   nNoProp	, nNoAttribute	, nNoClass	, nNoDecl	,
   nNoDesignator, nNoLayout	, nNoModule	, nNoName	,
   nNoPrec	, NoTree	, tTree		, TreeRoot	, ViewName	,
   SubUnit	, mAg		, mClass	, mChild	,
   mAttribute	, mActionPart	, mLeftAssoc	, mRightAssoc	,
   mNonAssoc	, mAssign	, mCopy		, mTargetCode	,
   mOrder	, mCheck	, mDesignator	, mIdent	, mRemote	,
   mAny		, mAnys		, mLayoutAny	, mModule	,
   mDecl	, mName		, mProp		, mSelect	,
   ReverseTree	, BeginTree	, Codes		, CloseTree	;

TYPE
   tParsAttribute = RECORD
      CASE : INTEGER OF
      | 1: Scan		: Scanner.tScanAttribute;
           Properties	: BITSET;
      | 2: Tree		: tTree;
	   Ident	: tIdent;
      END;
   END;

VAR
   Properties, InitProperties	: BITSET;
   String1, String2		: tString;
   ClassCount			: INTEGER;
   i				: CARDINAL;
   ClassIdent, ModuleIdent	: tIdent;
   ParserName, TreeName, EvalName: tIdent;

PROCEDURE mCodes (): tTree;
   VAR t: tTree;
   BEGIN
      t := MakeTree (Codes);
      WITH t^.Codes DO
	 MakeText (Export);
	 MakeText (Import);
	 MakeText (Global);
	 MakeText (SpecWith);
	 MakeText (BodyWith);
	 MakeText (Local);
	 MakeText (Begin);
	 MakeText (Close);
	 ExportLine := NoPosition;
	 ImportLine := NoPosition;
	 GlobalLine := NoPosition;
	 SpecWithLine := NoPosition;
	 BodyWithLine := NoPosition;
	 LocalLine  := NoPosition;
	 BeginLine  := NoPosition;
	 CloseLine  := NoPosition;
      END;
      RETURN t;
   END mCodes;

PROCEDURE UpdateName (VAR Name: tIdent; Ident: tIdent);
   BEGIN
      IF Name = NoIdent THEN Name := Ident; END
   END UpdateName;


CONST
   yyInitStackSize      = 100;
   yyNoState            = 0;

   yyFirstTerminal		= 0;
   yyLastTerminal		= 81;
   yyFirstSymbol		= 0;
   yyLastSymbol		= 122;
   yyTableMax		= 1249;
   yyNTableMax		= 247;
   yyFirstReadState		= 1;
   yyLastReadState		= 186;
   yyFirstReadTermState		= 187;
   yyLastReadTermState		= 240;
   yyLastReadNontermState		= 246;
   yyFirstReduceState		= 247;
   yyLastReduceState		= 372;
   yyStartState		= 1;
   yyStopState		= 247;

   yyFirstFinalState    = yyFirstReadTermState;
   yyLastState          = yyLastReduceState;

TYPE
   yyTableElmt          = SHORTCARD;
   yyTCombRange         = yyTableElmt [0 .. yyTableMax];
   yyNCombRange         = yyTableElmt [yyLastTerminal + 1 .. yyNTableMax];
   yyStateRange         = yyTableElmt [0 .. yyLastState];
   yyReadRange          = yyTableElmt [yyFirstReadState .. yyLastReadState];
   yyReadReduceRange    = yyTableElmt 
                            [yyFirstReadTermState ..yyLastReadNontermState];
   yyReduceRange        = yyTableElmt [yyFirstReduceState .. yyLastReduceState];
   yySymbolRange        = yyTableElmt [yyFirstSymbol .. yyLastSymbol];
   yyTCombType          = RECORD Check, Next: yyStateRange; END;
   yyNCombType          = yyStateRange;
   yyTCombTypePtr       = POINTER TO yyTCombType;
   yyNCombTypePtr       = POINTER TO yyNCombType;
   yyStackPtrType       = yyTableElmt [ MIN(yyTableElmt) .. MAX (yyTableElmt) ];
   yyStackType          = POINTER TO ARRAY yyStackPtrType OF yyStateRange;
   yyAttributeStackType = POINTER TO ARRAY yyStackPtrType OF tParsAttribute;

VAR
   yyTBasePtr           : ARRAY yyTableElmt [0 .. yyLastReadState] 
                          OF yyTCombTypePtr;
   yyNBasePtr           : ARRAY yyTableElmt [0 .. yyLastReadState]      
                          OF yyNCombTypePtr;
   yyDefault            : ARRAY yyTableElmt [0 .. yyLastReadState]      
                          OF yyReadRange  ;
   yyTComb              : ARRAY yyTCombRange            OF yyTCombType  ;
   yyNComb              : ARRAY yyNCombRange            OF yyNCombType  ;
   yyLength             : ARRAY yyReduceRange           OF yyTableElmt  ;
   yyLeftHandSide       : ARRAY yyReduceRange           OF yySymbolRange;
   yyContinuation       : ARRAY yyTableElmt [0 .. yyLastReadState]      
                          OF yySymbolRange;
   yyFinalToProd        : ARRAY yyReadReduceRange       OF yyReduceRange;
   yyIsInitialized      : BOOLEAN;
   yyTableFile          : System.tFile;

PROCEDURE TokenName (Token: SHORTCARD; VAR Name: ARRAY OF CHAR);
   PROCEDURE Copy (Source: ARRAY OF CHAR; VAR Target: ARRAY OF CHAR);
      VAR i, j: CARDINAL;
      BEGIN
         IF HIGH (Source) < HIGH (Target)
         THEN j := HIGH (Source); ELSE j := HIGH (Target); END;
         FOR i := 0 TO j DO Target [i] := Source [i]; END;
         IF HIGH (Target) > j THEN Target [j + 1] := CHR (0); END;
      END Copy;
   BEGIN
      CASE Token OF
      | 0: Copy ("_EndOfFile", Name);
      | 1: Copy ("Ident", Name);
      | 2: Copy ("Integer", Name);
      | 3: Copy ("String", Name);
      | 4: Copy ("TargetCode", Name);
      | 5: Copy ("Code", Name);
      | 6: Copy ("FUNCTION", Name);
      | 7: Copy ("WhiteSpace", Name);
      | 10: Copy ('BEGIN', Name);
      | 11: Copy ('CLOSE', Name);
      | 12: Copy ("DECLARE", Name);
      | 13: Copy ("END", Name);
      | 14: Copy ("EVAL", Name);
      | 15: Copy ('EXPORT', Name);
      | 16: Copy ('GLOBAL', Name);
      | 17: Copy ("VIRTUAL", Name);
      | 18: Copy ('LOCAL', Name);
      | 19: Copy ("MODULE", Name);
      | 20: Copy ("STACK", Name);
      | 21: Copy ("REVERSE", Name);
      | 22: Copy ('RULE', Name);
      | 23: Copy ("TREE", Name);
      | 24: Copy ("AFTER", Name);
      | 25: Copy ("BEFORE", Name);
      | 26: Copy ("CHECK", Name);
      | 27: Copy ("THREAD", Name);
      | 28: Copy ("DEMAND", Name);
      | 30: Copy ("IMPORT", Name);
      | 31: Copy ("INPUT", Name);
      | 32: Copy ("OUTPUT", Name);
      | 33: Copy ("SYNTHESIZED", Name);
      | 34: Copy ("INHERITED", Name);
      | 35: Copy ('PARSER', Name);
      | 36: Copy ('PREC', Name);
      | 37: Copy ('LEFT', Name);
      | 38: Copy ('RIGHT', Name);
      | 39: Copy ('NONE', Name);
      | 40: Copy ('(', Name);
      | 41: Copy (')', Name);
      | 42: Copy ('[', Name);
      | 43: Copy (']', Name);
      | 44: Copy ('{', Name);
      | 45: Copy ('}', Name);
      | 46: Copy (',', Name);
      | 47: Copy (';', Name);
      | 48: Copy ('.', Name);
      | 49: Copy (':', Name);
      | 50: Copy ('=', Name);
      | 52: Copy (':=', Name);
      | 57: Copy ('<', Name);
      | 58: Copy ('>', Name);
      | 59: Copy ('->', Name);
      | 60: Copy (':-', Name);
      | 61: Copy ('=>', Name);
      | 62: Copy ('<-', Name);
      | 70: Copy ("PROPERTY", Name);
      | 71: Copy ("FOR", Name);
      | 72: Copy ("IGNORE", Name);
      | 74: Copy ("SELECT", Name);
      | 75: Copy ("SUBUNIT", Name);
      | 76: Copy ("REMOTE", Name);
      | 77: Copy ('SCANNER', Name);
      | 78: Copy ("VIEW", Name);
      | 79: Copy ("SPECWITH", Name);
      | 80: Copy ("BODYWITH", Name);
      | 81: Copy ('LINK', Name);
      END;
   END TokenName;

PROCEDURE Parser (): CARDINAL;

   VAR
      yyState           : yyStateRange;
      yyTerminal        : yySymbolRange;
      yyNonterminal     : yySymbolRange;        (* left-hand side symbol *)
      yyStackPtr        : yyStackPtrType;
      yyStateStackSize  : LONGINT;
      yyAttrStackSize   : LONGINT;
      yyShortStackSize  : yyStackPtrType;
      yyStateStack      : yyStackType;
      yyAttributeStack  : yyAttributeStackType;
      yySynAttribute    : tParsAttribute;       (* synthesized attribute *)
   yyRepairAttribute : Scanner.tScanAttribute;
      yyRepairToken     : yySymbolRange;
      yyTCombPtr        : yyTCombTypePtr;
      yyNCombPtr        : yyNCombTypePtr;
      yyIsRepairing     : BOOLEAN;
      yyErrorCount      : CARDINAL;
      yyTokenString     : ARRAY [0..127] OF CHAR;
   BEGIN
   BeginParser;
      yyState           := yyStartState;
   yyTerminal        := VAL ( yySymbolRange,Scanner.GetToken ());
      yyStateStackSize  := yyInitStackSize;
      yyAttrStackSize   := yyInitStackSize;
      DynArray.MakeArray 
        (yyStateStack, yyStateStackSize, SYSTEM.TSIZE (yyStateRange));
      DynArray.MakeArray 
        (yyAttributeStack, yyAttrStackSize, SYSTEM.TSIZE (tParsAttribute));
      yyShortStackSize  := VAL ( yyStackPtrType , yyStateStackSize ) - 1;
      yyStackPtr        := 0;
      yyErrorCount      := 0;
      yyIsRepairing     := FALSE;

      LOOP
         IF yyStackPtr >= yyShortStackSize THEN
            DynArray.ExtendArray 
              (yyStateStack, yyStateStackSize, SYSTEM.TSIZE (yyStateRange));
            DynArray.ExtendArray 
              (yyAttributeStack, yyAttrStackSize, 
               SYSTEM.TSIZE (tParsAttribute)
              );
            yyShortStackSize := VAL ( yyStackPtrType , yyStateStackSize ) - 1;
         END (* IF *) ;
         yyStateStack^ [yyStackPtr] := yyState;

         LOOP   (* SPEC State := Next (State, Terminal); terminal transition *)
            yyTCombPtr := yyTCombTypePtr 
                            ( LONGCARD ( yyTBasePtr [yyState] ) 
                              + VAL ( LONGCARD , yyTerminal ) 
                                * SYSTEM.TSIZE (yyTCombType)
                            );
            IF yyTCombPtr^.Check = yyState 
            THEN
               yyState := yyTCombPtr^.Next;
               EXIT;
            END (* IF *) ;
            yyState := yyDefault [yyState];

            IF yyState = yyNoState 
            THEN (* syntax error *)
               yyState := yyStateStack^ [yyStackPtr];
               IF yyIsRepairing 
               THEN (* repair *)
                  yyRepairToken := yyContinuation [yyState];
                  yyState := Next (yyState, yyRepairToken);
                  IF yyState <= yyLastReadTermState 
                  THEN (* read or read terminal reduce ? *)
                  Scanner.ErrorAttribute 
                       (VAL(INTEGER,yyRepairToken), yyRepairAttribute);
                     TokenName (yyRepairToken, yyTokenString);
                     Errors.ErrorMessageI 
                       (Errors.TokenInserted, Errors.Repair,
                     Scanner.Attribute.Position, Errors.Array, 
                        SYSTEM.ADR (yyTokenString)
                       );
                     IF yyState >= yyFirstFinalState 
                     THEN (* avoid second push *)
                        yyState := yyFinalToProd [yyState];
                     END (* IF *) ;
                     INC (yyStackPtr);
                     yyAttributeStack^ [yyStackPtr].Scan := yyRepairAttribute;
                     yyStateStack^     [yyStackPtr] := yyState;
                  END (* IF *) ;
                  IF yyState >= yyFirstFinalState 
                  THEN (* final state ? *)
                    EXIT;
                  END (* IF *) ;
               ELSE (* report and recover *)
                  INC (yyErrorCount);
                  ErrorRecovery 
                    (yyTerminal, yyStateStack, yyStateStackSize, yyStackPtr);
                  yyIsRepairing := TRUE;
               END (* IF *) ;
            END (* IF *) ;
         END (* LOOP *) ;

         IF yyState >= yyFirstFinalState 
         THEN (* final state ? *)
            IF yyState <= yyLastReadTermState 
            THEN (* read terminal reduce ? *)
               INC (yyStackPtr);
            yyAttributeStack^ [yyStackPtr].Scan := Scanner.Attribute;
            yyTerminal := VAL( yySymbolRange , Scanner.GetToken () );
               yyIsRepairing := FALSE;
            END (* IF *) ;

            LOOP (* reduce *)
CASE yyState OF
  | 247: (* _0000_ : Cg _EndOfFile .*)
  DynArray.ReleaseArray (yyStateStack, yyStateStackSize, SYSTEM.TSIZE (yyTableElmt));
  DynArray.ReleaseArray (yyAttributeStack, yyAttrStackSize, SYSTEM.TSIZE (tParsAttribute));
  RETURN yyErrorCount;

  | 248: (* Cg : ScannerName ParserCodes TreeCodes EvalCodes PrecPart PropPart DeclPart RulePart Modules .*)
  DEC (yyStackPtr, 9); yyNonterminal := 91;
(* line 175 "/tmp/lalr1716" *)
  (* line 176 ../src/cg.lalr *)
   TreeRoot := mAg (NoIdent, yyAttributeStack^[yyStackPtr+1].Ident, ParserName, yyAttributeStack^[yyStackPtr+2].Tree, TreeName, yyAttributeStack^[yyStackPtr+3].Tree, EvalName, yyAttributeStack^[yyStackPtr+4].Tree, yyAttributeStack^[yyStackPtr+5].Tree, yyAttributeStack^[yyStackPtr+6].Tree, yyAttributeStack^[yyStackPtr+7].Tree, yyAttributeStack^[yyStackPtr+8].Tree, ReverseTree (yyAttributeStack^[yyStackPtr+9].Tree)); 
  | 249: (* Cg : MODULE Ident Cg_1 ScannerName ParserCodes TreeCodes EvalCodes PrecPart PropPart DeclPart RulePart END Ident Modules .*)
  DEC (yyStackPtr, 14); yyNonterminal := 91;
(* line 177 "/tmp/lalr1716" *)
  (* line 180 ../src/cg.lalr *)
   TreeRoot := mAg (yyAttributeStack^[yyStackPtr+2].Scan.Ident, yyAttributeStack^[yyStackPtr+4].Ident, ParserName, yyAttributeStack^[yyStackPtr+5].Tree, TreeName, yyAttributeStack^[yyStackPtr+6].Tree, EvalName, yyAttributeStack^[yyStackPtr+7].Tree, yyAttributeStack^[yyStackPtr+8].Tree, yyAttributeStack^[yyStackPtr+9].Tree, yyAttributeStack^[yyStackPtr+10].Tree, yyAttributeStack^[yyStackPtr+11].Tree, ReverseTree (yyAttributeStack^[yyStackPtr+14].Tree)); 
  | 250: (* Cg_1 : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 92;
(* line 179 "/tmp/lalr1716" *)
  (* line 178 ../src/cg.lalr *)
   ModuleIdent := yyAttributeStack^[yyStackPtr+0].Scan.Ident; 
  | 251: (* ScannerName : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 82;
(* line 182 "/tmp/lalr1716" *)
  (* line 183 ../src/cg.lalr *)
   yySynAttribute.Ident := NoIdent; 
  | 252: (* ScannerName : 'SCANNER' .*)
  DEC (yyStackPtr, 1); yyNonterminal := 82;
(* line 185 "/tmp/lalr1716" *)
  (* line 185 ../src/cg.lalr *)
   ArrayToString ("Scanner", String1);
  	  yySynAttribute.Ident := MakeIdent (String1); 
  | 253,241: (* ScannerName : 'SCANNER' Name0 .*)
  DEC (yyStackPtr, 2); yyNonterminal := 82;
(* line 189 "/tmp/lalr1716" *)
  (* line 188 ../src/cg.lalr *)
   yySynAttribute.Ident := yyAttributeStack^[yyStackPtr+2].Scan.Ident; 
  | 254: (* ParserCodes : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 83;
(* line 192 "/tmp/lalr1716" *)
  (* line 191 ../src/cg.lalr *)
   yySynAttribute.Tree := mCodes (); 
  | 255: (* ParserCodes : 'PARSER' Codes .*)
  DEC (yyStackPtr, 2); yyNonterminal := 83;
(* line 194 "/tmp/lalr1716" *)
  (* line 193 ../src/cg.lalr *)
   yySynAttribute.Tree := yyAttributeStack^[yyStackPtr+2].Tree; 
  | 256: (* ParserCodes : 'PARSER' Name0 Codes .*)
  DEC (yyStackPtr, 3); yyNonterminal := 83;
(* line 196 "/tmp/lalr1716" *)
  (* line 195 ../src/cg.lalr *)
   yySynAttribute.Tree := yyAttributeStack^[yyStackPtr+3].Tree; UpdateName (ParserName, yyAttributeStack^[yyStackPtr+2].Scan.Ident); 
  | 257: (* TreeCodes : SubUnit .*)
  DEC (yyStackPtr, 1); yyNonterminal := 84;
(* line 199 "/tmp/lalr1716" *)
  (* line 198 ../src/cg.lalr *)
   yySynAttribute.Tree := mCodes (); 
  | 258: (* TreeCodes : TREE SubUnit Codes .*)
  DEC (yyStackPtr, 3); yyNonterminal := 84;
(* line 201 "/tmp/lalr1716" *)
  (* line 200 ../src/cg.lalr *)
   yySynAttribute.Tree := yyAttributeStack^[yyStackPtr+3].Tree; 
  | 259: (* TreeCodes : TREE Name0 SubUnit Codes .*)
  DEC (yyStackPtr, 4); yyNonterminal := 84;
(* line 203 "/tmp/lalr1716" *)
  (* line 202 ../src/cg.lalr *)
   yySynAttribute.Tree := yyAttributeStack^[yyStackPtr+4].Tree; UpdateName (TreeName, yyAttributeStack^[yyStackPtr+2].Scan.Ident); 
  | 260: (* EvalCodes : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 85;
(* line 206 "/tmp/lalr1716" *)
  (* line 205 ../src/cg.lalr *)
   yySynAttribute.Tree := mCodes (); 
  | 261: (* EvalCodes : EVAL Codes .*)
  DEC (yyStackPtr, 2); yyNonterminal := 85;
(* line 208 "/tmp/lalr1716" *)
  (* line 207 ../src/cg.lalr *)
   yySynAttribute.Tree := yyAttributeStack^[yyStackPtr+2].Tree; 
  | 262: (* EvalCodes : EVAL Name0 Codes .*)
  DEC (yyStackPtr, 3); yyNonterminal := 85;
(* line 210 "/tmp/lalr1716" *)
  (* line 209 ../src/cg.lalr *)
   yySynAttribute.Tree := yyAttributeStack^[yyStackPtr+3].Tree; UpdateName (EvalName, yyAttributeStack^[yyStackPtr+2].Scan.Ident); 
  | 263: (* Codes : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 94;
(* line 213 "/tmp/lalr1716" *)
  (* line 212 ../src/cg.lalr *)
   yySynAttribute.Tree := mCodes (); 
  | 264,195: (* Codes : Codes SPECWITH TargetCode .*)
  DEC (yyStackPtr, 3); yyNonterminal := 94;
(* line 216 "/tmp/lalr1716" *)
  (* line 214 ../src/cg.lalr *)
   yySynAttribute.Tree := yyAttributeStack^[yyStackPtr+1].Tree;
  	  yySynAttribute.Tree^.Codes.SpecWith	    := yyAttributeStack^[yyStackPtr+3].Scan.Text;
  	  yySynAttribute.Tree^.Codes.SpecWithLine := yyAttributeStack^[yyStackPtr+3].Scan.Position; 
  | 265,196: (* Codes : Codes BODYWITH TargetCode .*)
  DEC (yyStackPtr, 3); yyNonterminal := 94;
(* line 222 "/tmp/lalr1716" *)
  (* line 218 ../src/cg.lalr *)
   yySynAttribute.Tree := yyAttributeStack^[yyStackPtr+1].Tree;
  	  yySynAttribute.Tree^.Codes.BodyWith	    := yyAttributeStack^[yyStackPtr+3].Scan.Text;
  	  yySynAttribute.Tree^.Codes.BodyWithLine := yyAttributeStack^[yyStackPtr+3].Scan.Position; 
  | 266,191: (* Codes : Codes 'EXPORT' TargetCode .*)
  DEC (yyStackPtr, 3); yyNonterminal := 94;
(* line 228 "/tmp/lalr1716" *)
  (* line 222 ../src/cg.lalr *)
   yySynAttribute.Tree := yyAttributeStack^[yyStackPtr+1].Tree;
  	  yySynAttribute.Tree^.Codes.Export	    := yyAttributeStack^[yyStackPtr+3].Scan.Text;
  	  yySynAttribute.Tree^.Codes.ExportLine := yyAttributeStack^[yyStackPtr+3].Scan.Position; 
  | 267,194: (* Codes : Codes IMPORT TargetCode .*)
  DEC (yyStackPtr, 3); yyNonterminal := 94;
(* line 234 "/tmp/lalr1716" *)
  (* line 226 ../src/cg.lalr *)
   yySynAttribute.Tree := yyAttributeStack^[yyStackPtr+1].Tree;
  	  yySynAttribute.Tree^.Codes.Import     := yyAttributeStack^[yyStackPtr+3].Scan.Text;
  	  yySynAttribute.Tree^.Codes.ImportLine := yyAttributeStack^[yyStackPtr+3].Scan.Position; 
  | 268,192: (* Codes : Codes 'GLOBAL' TargetCode .*)
  DEC (yyStackPtr, 3); yyNonterminal := 94;
(* line 240 "/tmp/lalr1716" *)
  (* line 230 ../src/cg.lalr *)
   yySynAttribute.Tree := yyAttributeStack^[yyStackPtr+1].Tree;
  	  yySynAttribute.Tree^.Codes.Global     := yyAttributeStack^[yyStackPtr+3].Scan.Text;
  	  yySynAttribute.Tree^.Codes.GlobalLine := yyAttributeStack^[yyStackPtr+3].Scan.Position; 
  | 269,193: (* Codes : Codes 'LOCAL' TargetCode .*)
  DEC (yyStackPtr, 3); yyNonterminal := 94;
(* line 246 "/tmp/lalr1716" *)
  (* line 234 ../src/cg.lalr *)
   yySynAttribute.Tree := yyAttributeStack^[yyStackPtr+1].Tree;
  	  yySynAttribute.Tree^.Codes.Local      := yyAttributeStack^[yyStackPtr+3].Scan.Text;
  	  yySynAttribute.Tree^.Codes.LocalLine  := yyAttributeStack^[yyStackPtr+3].Scan.Position; 
  | 270,189: (* Codes : Codes 'BEGIN' TargetCode .*)
  DEC (yyStackPtr, 3); yyNonterminal := 94;
(* line 252 "/tmp/lalr1716" *)
  (* line 238 ../src/cg.lalr *)
   yySynAttribute.Tree := yyAttributeStack^[yyStackPtr+1].Tree;
  	  yySynAttribute.Tree^.Codes.Begin      := yyAttributeStack^[yyStackPtr+3].Scan.Text;
  	  yySynAttribute.Tree^.Codes.BeginLine  := yyAttributeStack^[yyStackPtr+3].Scan.Position; 
  | 271,190: (* Codes : Codes 'CLOSE' TargetCode .*)
  DEC (yyStackPtr, 3); yyNonterminal := 94;
(* line 258 "/tmp/lalr1716" *)
  (* line 242 ../src/cg.lalr *)
   yySynAttribute.Tree := yyAttributeStack^[yyStackPtr+1].Tree;
  	  yySynAttribute.Tree^.Codes.Close      := yyAttributeStack^[yyStackPtr+3].Scan.Text;
  	  yySynAttribute.Tree^.Codes.CloseLine  := yyAttributeStack^[yyStackPtr+3].Scan.Position; 
  | 272: (* SubUnit : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 95;

  | 273,242: (* SubUnit : SubUnit SUBUNIT Name0 .*)
  DEC (yyStackPtr, 3); yyNonterminal := 95;
(* line 265 "/tmp/lalr1716" *)
  (* line 248 ../src/cg.lalr *)
   UpdateName (SubUnit, yyAttributeStack^[yyStackPtr+3].Scan.Ident); 
  | 274,243: (* SubUnit : SubUnit VIEW Name0 .*)
  DEC (yyStackPtr, 3); yyNonterminal := 95;
(* line 267 "/tmp/lalr1716" *)
  (* line 250 ../src/cg.lalr *)
   UpdateName (ViewName, yyAttributeStack^[yyStackPtr+3].Scan.Ident); 
  | 275: (* PrecPart : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 86;
(* line 270 "/tmp/lalr1716" *)
  (* line 253 ../src/cg.lalr *)
   yySynAttribute.Tree := nNoPrec; 
  | 276: (* PrecPart : 'PREC' Precs .*)
  DEC (yyStackPtr, 2); yyNonterminal := 86;
(* line 272 "/tmp/lalr1716" *)
  (* line 255 ../src/cg.lalr *)
   yySynAttribute.Tree := ReverseTree (yyAttributeStack^[yyStackPtr+2].Tree); 
  | 277: (* Precs : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 96;
(* line 275 "/tmp/lalr1716" *)
  (* line 258 ../src/cg.lalr *)
   yySynAttribute.Tree := nNoPrec; 
  | 278: (* Precs : Precs 'LEFT' Names .*)
  DEC (yyStackPtr, 3); yyNonterminal := 96;
(* line 277 "/tmp/lalr1716" *)
  (* line 260 ../src/cg.lalr *)
   yySynAttribute.Tree := mLeftAssoc  (ReverseTree (yyAttributeStack^[yyStackPtr+3].Tree), yyAttributeStack^[yyStackPtr+1].Tree); 
  | 279: (* Precs : Precs 'RIGHT' Names .*)
  DEC (yyStackPtr, 3); yyNonterminal := 96;
(* line 279 "/tmp/lalr1716" *)
  (* line 262 ../src/cg.lalr *)
   yySynAttribute.Tree := mRightAssoc (ReverseTree (yyAttributeStack^[yyStackPtr+3].Tree), yyAttributeStack^[yyStackPtr+1].Tree); 
  | 280: (* Precs : Precs 'NONE' Names .*)
  DEC (yyStackPtr, 3); yyNonterminal := 96;
(* line 281 "/tmp/lalr1716" *)
  (* line 264 ../src/cg.lalr *)
   yySynAttribute.Tree := mNonAssoc   (ReverseTree (yyAttributeStack^[yyStackPtr+3].Tree), yyAttributeStack^[yyStackPtr+1].Tree); 
  | 281: (* PropPart : Props .*)
  DEC (yyStackPtr, 1); yyNonterminal := 87;
(* line 284 "/tmp/lalr1716" *)
  (* line 268 ../src/cg.lalr *)
   yySynAttribute.Tree := ReverseTree (yyAttributeStack^[yyStackPtr+1].Tree); 
  | 282: (* Props : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 98;
(* line 287 "/tmp/lalr1716" *)
  (* line 271 ../src/cg.lalr *)
   yySynAttribute.Tree := nNoProp; 
  | 283: (* Props : Props PROPERTY Properties .*)
  DEC (yyStackPtr, 3); yyNonterminal := 98;
(* line 290 "/tmp/lalr1716" *)
  (* line 273 ../src/cg.lalr *)
   yySynAttribute.Tree := mProp (yyAttributeStack^[yyStackPtr+3].Properties, mName (ModuleIdent, NoPosition, nNoName), yyAttributeStack^[yyStackPtr+1].Tree);
  	  InitProperties := {}; 
  | 284: (* Props : Props PROPERTY Properties FOR Names .*)
  DEC (yyStackPtr, 5); yyNonterminal := 98;
(* line 295 "/tmp/lalr1716" *)
  (* line 276 ../src/cg.lalr *)
   yySynAttribute.Tree := mProp (yyAttributeStack^[yyStackPtr+3].Properties, ReverseTree (yyAttributeStack^[yyStackPtr+5].Tree), yyAttributeStack^[yyStackPtr+1].Tree);
  	  InitProperties := {}; 
  | 285: (* Props : Props SELECT Names .*)
  DEC (yyStackPtr, 3); yyNonterminal := 98;
(* line 300 "/tmp/lalr1716" *)
  (* line 279 ../src/cg.lalr *)
   yySynAttribute.Tree := mSelect (ReverseTree (yyAttributeStack^[yyStackPtr+3].Tree), yyAttributeStack^[yyStackPtr+1].Tree);
  	  InitProperties := {}; 
  | 286: (* DeclPart : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 88;
(* line 305 "/tmp/lalr1716" *)
  (* line 283 ../src/cg.lalr *)
   yySynAttribute.Tree := nNoDecl; 
  | 287: (* DeclPart : DECLARE Decls .*)
  DEC (yyStackPtr, 2); yyNonterminal := 88;
(* line 307 "/tmp/lalr1716" *)
  (* line 285 ../src/cg.lalr *)
   yySynAttribute.Tree := ReverseTree (yyAttributeStack^[yyStackPtr+2].Tree); 
  | 288: (* Decls : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 100;
(* line 310 "/tmp/lalr1716" *)
  (* line 288 ../src/cg.lalr *)
   yySynAttribute.Tree := nNoDecl; 
  | 289,232: (* Decls : Decls Names '=' Decls_1 AttrDecls '.' .*)
  DEC (yyStackPtr, 6); yyNonterminal := 100;
(* line 312 "/tmp/lalr1716" *)
  (* line 292 ../src/cg.lalr *)
   yySynAttribute.Tree := mDecl (ReverseTree (yyAttributeStack^[yyStackPtr+2].Tree), ReverseTree (yyAttributeStack^[yyStackPtr+5].Tree), {Nonterminal, Explicit}, yyAttributeStack^[yyStackPtr+1].Tree); 
  | 290,230: (* Decls : Decls Names ':' Decls_2 AttrDecls '.' .*)
  DEC (yyStackPtr, 6); yyNonterminal := 100;
(* line 314 "/tmp/lalr1716" *)
  (* line 296 ../src/cg.lalr *)
   yySynAttribute.Tree := mDecl (ReverseTree (yyAttributeStack^[yyStackPtr+2].Tree), ReverseTree (yyAttributeStack^[yyStackPtr+5].Tree), {Terminal, Explicit}, yyAttributeStack^[yyStackPtr+1].Tree); 
  | 291: (* Decls_2 : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 103;
(* line 316 "/tmp/lalr1716" *)
  (* line 294 ../src/cg.lalr *)
   Properties := InitProperties; 
  | 292: (* Decls_1 : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 101;
(* line 318 "/tmp/lalr1716" *)
  (* line 290 ../src/cg.lalr *)
   Properties := InitProperties; 
  | 293: (* Names : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 97;
(* line 321 "/tmp/lalr1716" *)
  (* line 299 ../src/cg.lalr *)
   yySynAttribute.Tree := nNoName; 
  | 294,244: (* Names : Names Name1 .*)
  DEC (yyStackPtr, 2); yyNonterminal := 97;
(* line 323 "/tmp/lalr1716" *)
  (* line 301 ../src/cg.lalr *)
   yySynAttribute.Tree := mName (yyAttributeStack^[yyStackPtr+2].Scan.Ident, yyAttributeStack^[yyStackPtr+2].Scan.Position, yyAttributeStack^[yyStackPtr+1].Tree); 
  | 295,199: (* Names : Names ',' .*)
  DEC (yyStackPtr, 2); yyNonterminal := 97;
(* line 325 "/tmp/lalr1716" *)
  (* line 303 ../src/cg.lalr *)
   yySynAttribute.Tree := yyAttributeStack^[yyStackPtr+1].Tree; 
  | 296: (* RulePart : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 89;
(* line 328 "/tmp/lalr1716" *)
  (* line 306 ../src/cg.lalr *)
   yySynAttribute.Tree := nNoClass; 
  | 297: (* RulePart : 'RULE' Types .*)
  DEC (yyStackPtr, 2); yyNonterminal := 89;
(* line 330 "/tmp/lalr1716" *)
  (* line 308 ../src/cg.lalr *)
   yySynAttribute.Tree := ReverseTree (yyAttributeStack^[yyStackPtr+2].Tree); 
  | 298: (* Types : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 105;
(* line 333 "/tmp/lalr1716" *)
  (* line 311 ../src/cg.lalr *)
   yySynAttribute.Tree := nNoClass; 
  | 299,235: (* Types : Types BaseTypes '=' Types_1 AttrDecls Prec Extensions '.' .*)
  DEC (yyStackPtr, 8); yyNonterminal := 105;
(* line 336 "/tmp/lalr1716" *)
  (* line 316 ../src/cg.lalr *)
   INC (ClassCount); IntToString (ClassCount, String2); ArrayToString ("yy", String1);
  	  Concatenate (String1, String2); ClassIdent := MakeIdent (String1);
  	  yySynAttribute.Tree := mClass (ClassIdent, {Nonterminal, Explicit}, ReverseTree (yyAttributeStack^[yyStackPtr+5].Tree),
  	  yyAttributeStack^[yyStackPtr+7].Tree, yyAttributeStack^[yyStackPtr+1].Tree, ClassIdent, yyAttributeStack^[yyStackPtr+3].Scan.Position, 0, yyAttributeStack^[yyStackPtr+6].Scan.Ident, yyAttributeStack^[yyStackPtr+2].Tree); 
  | 300,238: (* Types : Types Name1 BaseTypes '=' Types_2 AttrDecls Prec Extensions '.' .*)
  DEC (yyStackPtr, 9); yyNonterminal := 105;
(* line 343 "/tmp/lalr1716" *)
  (* line 324 ../src/cg.lalr *)
   yySynAttribute.Tree := mClass (yyAttributeStack^[yyStackPtr+2].Scan.Ident, {Nonterminal, Explicit} + yyAttributeStack^[yyStackPtr+2].Properties,
  	     ReverseTree (yyAttributeStack^[yyStackPtr+6].Tree), yyAttributeStack^[yyStackPtr+8].Tree, yyAttributeStack^[yyStackPtr+1].Tree, yyAttributeStack^[yyStackPtr+2].Scan.Ident, yyAttributeStack^[yyStackPtr+2].Scan.Position, 0,
  	     yyAttributeStack^[yyStackPtr+7].Scan.Ident, yyAttributeStack^[yyStackPtr+3].Tree); 
  | 301,237: (* Types : Types Name1 BaseTypes ':' Types_3 TokenCode TypeProperties AttrDecls Prec Extensions '.' .*)
  DEC (yyStackPtr, 11); yyNonterminal := 105;
(* line 349 "/tmp/lalr1716" *)
  (* line 331 ../src/cg.lalr *)
   yySynAttribute.Tree := mClass (yyAttributeStack^[yyStackPtr+2].Scan.Ident, {Terminal, Explicit} + yyAttributeStack^[yyStackPtr+2].Properties + yyAttributeStack^[yyStackPtr+7].Properties,
  	     ReverseTree (yyAttributeStack^[yyStackPtr+8].Tree), yyAttributeStack^[yyStackPtr+10].Tree, yyAttributeStack^[yyStackPtr+1].Tree, yyAttributeStack^[yyStackPtr+2].Scan.Ident, yyAttributeStack^[yyStackPtr+2].Scan.Position,
  	     yyAttributeStack^[yyStackPtr+6].Scan.Integer, yyAttributeStack^[yyStackPtr+9].Scan.Ident, yyAttributeStack^[yyStackPtr+3].Tree); 
  | 302,236: (* Types : Types Name1 Ident BaseTypes ':' Types_4 TokenCode TypeProperties AttrDecls Prec Extensions '.' .*)
  DEC (yyStackPtr, 12); yyNonterminal := 105;
(* line 355 "/tmp/lalr1716" *)
  (* line 338 ../src/cg.lalr *)
   yySynAttribute.Tree := mClass (yyAttributeStack^[yyStackPtr+2].Scan.Ident, {Terminal, Explicit, HasSelector} + yyAttributeStack^[yyStackPtr+2].Properties + yyAttributeStack^[yyStackPtr+8].Properties,
  	     ReverseTree (yyAttributeStack^[yyStackPtr+9].Tree), yyAttributeStack^[yyStackPtr+11].Tree, yyAttributeStack^[yyStackPtr+1].Tree, yyAttributeStack^[yyStackPtr+3].Scan.Ident, yyAttributeStack^[yyStackPtr+2].Scan.Position,
  	     yyAttributeStack^[yyStackPtr+7].Scan.Integer, yyAttributeStack^[yyStackPtr+10].Scan.Ident, yyAttributeStack^[yyStackPtr+4].Tree); 
  | 303,239: (* Types : Types Name1 BaseTypes ':=' Types_5 AttrDecls Prec Extensions '.' .*)
  DEC (yyStackPtr, 9); yyNonterminal := 105;
(* line 361 "/tmp/lalr1716" *)
  (* line 345 ../src/cg.lalr *)
   yySynAttribute.Tree := mClass (yyAttributeStack^[yyStackPtr+2].Scan.Ident, {Abstract, Explicit} + yyAttributeStack^[yyStackPtr+2].Properties,
  	     ReverseTree (yyAttributeStack^[yyStackPtr+6].Tree), yyAttributeStack^[yyStackPtr+8].Tree, yyAttributeStack^[yyStackPtr+1].Tree, yyAttributeStack^[yyStackPtr+2].Scan.Ident, yyAttributeStack^[yyStackPtr+2].Scan.Position, 0,
  	     yyAttributeStack^[yyStackPtr+7].Scan.Ident, yyAttributeStack^[yyStackPtr+3].Tree); 
  | 304: (* Types_5 : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 115;
(* line 366 "/tmp/lalr1716" *)
  (* line 343 ../src/cg.lalr *)
   Properties := InitProperties; 
  | 305: (* Types_4 : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 114;
(* line 368 "/tmp/lalr1716" *)
  (* line 336 ../src/cg.lalr *)
   Properties := InitProperties; 
  | 306: (* Types_3 : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 111;
(* line 370 "/tmp/lalr1716" *)
  (* line 329 ../src/cg.lalr *)
   Properties := InitProperties; 
  | 307: (* Types_2 : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 110;
(* line 372 "/tmp/lalr1716" *)
  (* line 322 ../src/cg.lalr *)
   Properties := InitProperties; 
  | 308: (* Types_1 : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 107;
(* line 374 "/tmp/lalr1716" *)
  (* line 314 ../src/cg.lalr *)
   Properties := InitProperties; 
  | 309: (* BaseTypes : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 106;
(* line 377 "/tmp/lalr1716" *)
  (* line 350 ../src/cg.lalr *)
   yySynAttribute.Tree := nNoName; 
  | 310: (* BaseTypes : '<-' Names .*)
  DEC (yyStackPtr, 2); yyNonterminal := 106;
(* line 379 "/tmp/lalr1716" *)
  (* line 352 ../src/cg.lalr *)
   yySynAttribute.Tree := ReverseTree (yyAttributeStack^[yyStackPtr+2].Tree); 
  | 311: (* TokenCode : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 112;
(* line 382 "/tmp/lalr1716" *)
  (* line 355 ../src/cg.lalr *)
   yySynAttribute.Scan.Integer := 0; 
  | 312,233: (* TokenCode : Integer .*)
  DEC (yyStackPtr, 1); yyNonterminal := 112;
(* line 384 "/tmp/lalr1716" *)
  (* line 357 ../src/cg.lalr *)
   yySynAttribute.Scan.Integer := yyAttributeStack^[yyStackPtr+1].Scan.Integer; 
  | 313: (* Prec : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 108;
(* line 387 "/tmp/lalr1716" *)
  (* line 360 ../src/cg.lalr *)
   yySynAttribute.Scan.Ident := NoIdent; 
  | 314,246: (* Prec : 'PREC' Name1 .*)
  DEC (yyStackPtr, 2); yyNonterminal := 108;
(* line 389 "/tmp/lalr1716" *)
  (* line 362 ../src/cg.lalr *)
   yySynAttribute.Scan.Ident := yyAttributeStack^[yyStackPtr+2].Scan.Ident; 
  | 315: (* Extensions : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 109;
(* line 392 "/tmp/lalr1716" *)
  (* line 365 ../src/cg.lalr *)
   yySynAttribute.Tree := nNoClass; 
  | 316,234: (* Extensions : '<' Types '>' .*)
  DEC (yyStackPtr, 3); yyNonterminal := 109;
(* line 394 "/tmp/lalr1716" *)
  (* line 367 ../src/cg.lalr *)
   yySynAttribute.Tree := ReverseTree (yyAttributeStack^[yyStackPtr+2].Tree); 
  | 317: (* AttrDecls : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 102;
(* line 397 "/tmp/lalr1716" *)
  (* line 370 ../src/cg.lalr *)
   yySynAttribute.Tree := nNoAttribute; 
  | 318,231: (* AttrDecls : AttrDecls '->' .*)
  DEC (yyStackPtr, 2); yyNonterminal := 102;
(* line 399 "/tmp/lalr1716" *)
  (* line 372 ../src/cg.lalr *)
   yySynAttribute.Tree := yyAttributeStack^[yyStackPtr+1].Tree; Properties := {}; 
  | 319,215: (* AttrDecls : AttrDecls '[' Name1 Properties ']' .*)
  DEC (yyStackPtr, 5); yyNonterminal := 102;
(* line 402 "/tmp/lalr1716" *)
  (* line 374 ../src/cg.lalr *)
   IF Thread IN yyAttributeStack^[yyStackPtr+4].Properties THEN
  	     Idents.GetString (yyAttributeStack^[yyStackPtr+3].Scan.Ident, String1);
  	     ArrayToString ("In", String2);
  	     Concatenate (String1, String2);
  	     yySynAttribute.Tree := mAttribute (yyAttributeStack^[yyStackPtr+1].Tree, MakeIdent (String1), iInteger, Properties + yyAttributeStack^[yyStackPtr+4].Properties + {Inherited}, yyAttributeStack^[yyStackPtr+3].Scan.Position);
  	     Idents.GetString (yyAttributeStack^[yyStackPtr+3].Scan.Ident, String1);
  	     ArrayToString ("Out", String2);
  	     Concatenate (String1, String2);
  	     yySynAttribute.Tree := mAttribute (yySynAttribute.Tree, MakeIdent (String1), iInteger, Properties + yyAttributeStack^[yyStackPtr+4].Properties + {Synthesized}, yyAttributeStack^[yyStackPtr+3].Scan.Position);
  	  ELSE
  	     yySynAttribute.Tree := mAttribute (yyAttributeStack^[yyStackPtr+1].Tree, yyAttributeStack^[yyStackPtr+3].Scan.Ident, iInteger, Properties + yyAttributeStack^[yyStackPtr+4].Properties, yyAttributeStack^[yyStackPtr+3].Scan.Position);
  	  END;
  	
  | 320,214: (* AttrDecls : AttrDecls '[' Name1 ':' Name1 Properties ']' .*)
  DEC (yyStackPtr, 7); yyNonterminal := 102;
(* line 418 "/tmp/lalr1716" *)
  (* line 388 ../src/cg.lalr *)
   IF Thread IN yyAttributeStack^[yyStackPtr+6].Properties THEN
  	     Idents.GetString (yyAttributeStack^[yyStackPtr+3].Scan.Ident, String1);
  	     ArrayToString ("In", String2);
  	     Concatenate (String1, String2);
  	     yySynAttribute.Tree := mAttribute (yyAttributeStack^[yyStackPtr+1].Tree, MakeIdent (String1), yyAttributeStack^[yyStackPtr+5].Scan.Ident, Properties + yyAttributeStack^[yyStackPtr+6].Properties + {Inherited}, yyAttributeStack^[yyStackPtr+3].Scan.Position);
  	     Idents.GetString (yyAttributeStack^[yyStackPtr+3].Scan.Ident, String1);
  	     ArrayToString ("Out", String2);
  	     Concatenate (String1, String2);
  	     yySynAttribute.Tree := mAttribute (yySynAttribute.Tree, MakeIdent (String1), yyAttributeStack^[yyStackPtr+5].Scan.Ident, Properties + yyAttributeStack^[yyStackPtr+6].Properties + {Synthesized}, yyAttributeStack^[yyStackPtr+3].Scan.Position);
  	  ELSE
  	     yySynAttribute.Tree := mAttribute (yyAttributeStack^[yyStackPtr+1].Tree, yyAttributeStack^[yyStackPtr+3].Scan.Ident, yyAttributeStack^[yyStackPtr+5].Scan.Ident, Properties + yyAttributeStack^[yyStackPtr+6].Properties, yyAttributeStack^[yyStackPtr+3].Scan.Position);
  	  END;
  	
  | 321,213: (* AttrDecls : AttrDecls '(' Name1 Properties ')' .*)
  DEC (yyStackPtr, 5); yyNonterminal := 102;
(* line 433 "/tmp/lalr1716" *)
  (* line 402 ../src/cg.lalr *)
   yySynAttribute.Tree := mChild (yyAttributeStack^[yyStackPtr+1].Tree, yyAttributeStack^[yyStackPtr+3].Scan.Ident, yyAttributeStack^[yyStackPtr+3].Scan.Ident, Properties + yyAttributeStack^[yyStackPtr+4].Properties, yyAttributeStack^[yyStackPtr+3].Scan.Position); 
  | 322,210: (* AttrDecls : AttrDecls '(' Name1 ':' Name1 Properties ')' .*)
  DEC (yyStackPtr, 7); yyNonterminal := 102;
(* line 435 "/tmp/lalr1716" *)
  (* line 404 ../src/cg.lalr *)
   yySynAttribute.Tree := mChild (yyAttributeStack^[yyStackPtr+1].Tree, yyAttributeStack^[yyStackPtr+3].Scan.Ident, yyAttributeStack^[yyStackPtr+5].Scan.Ident, Properties + yyAttributeStack^[yyStackPtr+6].Properties, yyAttributeStack^[yyStackPtr+3].Scan.Position); 
  | 323: (* AttrDecls : AttrDecls Name1 Properties .*)
  DEC (yyStackPtr, 3); yyNonterminal := 102;
(* line 437 "/tmp/lalr1716" *)
  (* line 406 ../src/cg.lalr *)
   yySynAttribute.Tree := mChild (yyAttributeStack^[yyStackPtr+1].Tree, yyAttributeStack^[yyStackPtr+2].Scan.Ident, yyAttributeStack^[yyStackPtr+2].Scan.Ident, Properties + yyAttributeStack^[yyStackPtr+3].Properties, yyAttributeStack^[yyStackPtr+2].Scan.Position); 
  | 324: (* AttrDecls : AttrDecls Name1 ':' Name1 Properties .*)
  DEC (yyStackPtr, 5); yyNonterminal := 102;
(* line 439 "/tmp/lalr1716" *)
  (* line 408 ../src/cg.lalr *)
   yySynAttribute.Tree := mChild (yyAttributeStack^[yyStackPtr+1].Tree, yyAttributeStack^[yyStackPtr+2].Scan.Ident, yyAttributeStack^[yyStackPtr+4].Scan.Ident, Properties + yyAttributeStack^[yyStackPtr+5].Properties, yyAttributeStack^[yyStackPtr+2].Scan.Position); 
  | 325,222: (* AttrDecls : AttrDecls '{' Actions '}' .*)
  DEC (yyStackPtr, 4); yyNonterminal := 102;
(* line 441 "/tmp/lalr1716" *)
  (* line 410 ../src/cg.lalr *)
   yySynAttribute.Tree := mActionPart (yyAttributeStack^[yyStackPtr+1].Tree, ReverseTree (yyAttributeStack^[yyStackPtr+3].Tree)); 
  | 326: (* TypeProperties : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 113;
(* line 444 "/tmp/lalr1716" *)
  (* line 413 ../src/cg.lalr *)
   yySynAttribute.Properties := {}; 
  | 327: (* Properties : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 99;
(* line 447 "/tmp/lalr1716" *)
  (* line 416 ../src/cg.lalr *)
   yySynAttribute.Properties := {}; 
  | 328,203: (* Properties : Properties REVERSE .*)
  DEC (yyStackPtr, 2); yyNonterminal := 99;
(* line 449 "/tmp/lalr1716" *)
  (* line 418 ../src/cg.lalr *)
   yySynAttribute.Properties := yyAttributeStack^[yyStackPtr+1].Properties + {Reverse	}; 
  | 329,212: (* Properties : Properties 'LINK' .*)
  DEC (yyStackPtr, 2); yyNonterminal := 99;
(* line 451 "/tmp/lalr1716" *)
  (* line 420 ../src/cg.lalr *)
   yySynAttribute.Properties := yyAttributeStack^[yyStackPtr+1].Properties + {Link	}; 
  | 330,206: (* Properties : Properties INPUT .*)
  DEC (yyStackPtr, 2); yyNonterminal := 99;
(* line 453 "/tmp/lalr1716" *)
  (* line 422 ../src/cg.lalr *)
   yySynAttribute.Properties := yyAttributeStack^[yyStackPtr+1].Properties + {Input	}; 
  | 331,207: (* Properties : Properties OUTPUT .*)
  DEC (yyStackPtr, 2); yyNonterminal := 99;
(* line 455 "/tmp/lalr1716" *)
  (* line 424 ../src/cg.lalr *)
   yySynAttribute.Properties := yyAttributeStack^[yyStackPtr+1].Properties + {Output	}; 
  | 332,208: (* Properties : Properties SYNTHESIZED .*)
  DEC (yyStackPtr, 2); yyNonterminal := 99;
(* line 457 "/tmp/lalr1716" *)
  (* line 426 ../src/cg.lalr *)
   yySynAttribute.Properties := yyAttributeStack^[yyStackPtr+1].Properties + {Synthesized	}; 
  | 333,209: (* Properties : Properties INHERITED .*)
  DEC (yyStackPtr, 2); yyNonterminal := 99;
(* line 459 "/tmp/lalr1716" *)
  (* line 428 ../src/cg.lalr *)
   yySynAttribute.Properties := yyAttributeStack^[yyStackPtr+1].Properties + {Inherited	}; 
  | 334,204: (* Properties : Properties THREAD .*)
  DEC (yyStackPtr, 2); yyNonterminal := 99;
(* line 461 "/tmp/lalr1716" *)
  (* line 430 ../src/cg.lalr *)
   yySynAttribute.Properties := yyAttributeStack^[yyStackPtr+1].Properties + {Thread	}; 
  | 335,201: (* Properties : Properties VIRTUAL .*)
  DEC (yyStackPtr, 2); yyNonterminal := 99;
(* line 463 "/tmp/lalr1716" *)
  (* line 432 ../src/cg.lalr *)
   yySynAttribute.Properties := yyAttributeStack^[yyStackPtr+1].Properties + {Virtual	}; 
  | 336,202: (* Properties : Properties STACK .*)
  DEC (yyStackPtr, 2); yyNonterminal := 99;
(* line 465 "/tmp/lalr1716" *)
  (* line 434 ../src/cg.lalr *)
   yySynAttribute.Properties := yyAttributeStack^[yyStackPtr+1].Properties + {Stack	}; 
  | 337,205: (* Properties : Properties DEMAND .*)
  DEC (yyStackPtr, 2); yyNonterminal := 99;
(* line 467 "/tmp/lalr1716" *)
  (* line 436 ../src/cg.lalr *)
   yySynAttribute.Properties := yyAttributeStack^[yyStackPtr+1].Properties + {Demand	}; 
  | 338,200: (* Properties : Properties FUNCTION .*)
  DEC (yyStackPtr, 2); yyNonterminal := 99;
(* line 469 "/tmp/lalr1716" *)
  (* line 438 ../src/cg.lalr *)
   yySynAttribute.Properties := yyAttributeStack^[yyStackPtr+1].Properties + {Funct	}; 
  | 339,211: (* Properties : Properties IGNORE .*)
  DEC (yyStackPtr, 2); yyNonterminal := 99;
(* line 471 "/tmp/lalr1716" *)
  (* line 440 ../src/cg.lalr *)
   yySynAttribute.Properties := yyAttributeStack^[yyStackPtr+1].Properties + {Ignore	}; 
  | 340: (* Actions : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 116;
(* line 474 "/tmp/lalr1716" *)
  (* line 443 ../src/cg.lalr *)
   yySynAttribute.Tree := nNoAction; 
  | 341,227: (* Actions : Actions Exprs ':=' Exprs ';' .*)
  DEC (yyStackPtr, 5); yyNonterminal := 116;
(* line 476 "/tmp/lalr1716" *)
  (* line 445 ../src/cg.lalr *)
   yySynAttribute.Tree := mAssign (yyAttributeStack^[yyStackPtr+1].Tree, yyAttributeStack^[yyStackPtr+3].Scan.Position, ReverseTree (yyAttributeStack^[yyStackPtr+2].Tree), ReverseTree (yyAttributeStack^[yyStackPtr+4].Tree)); 
  | 342,228: (* Actions : Actions Exprs ':-' Exprs ';' .*)
  DEC (yyStackPtr, 5); yyNonterminal := 116;
(* line 478 "/tmp/lalr1716" *)
  (* line 447 ../src/cg.lalr *)
   yySynAttribute.Tree := mCopy (yyAttributeStack^[yyStackPtr+1].Tree, yyAttributeStack^[yyStackPtr+3].Scan.Position, ReverseTree (yyAttributeStack^[yyStackPtr+2].Tree), ReverseTree (yyAttributeStack^[yyStackPtr+4].Tree)); 
  | 343,226: (* Actions : Actions Exprs ':=' Exprs '{' Exprs '}' Exprs ';' .*)
  DEC (yyStackPtr, 9); yyNonterminal := 116;
(* line 480 "/tmp/lalr1716" *)
  (* line 449 ../src/cg.lalr *)
   yySynAttribute.Tree := mTargetCode (yyAttributeStack^[yyStackPtr+1].Tree, yyAttributeStack^[yyStackPtr+3].Scan.Position, ReverseTree (yyAttributeStack^[yyStackPtr+2].Tree), ReverseTree (yyAttributeStack^[yyStackPtr+6].Tree)); 
  | 344,223: (* Actions : Actions Exprs AFTER Exprs ';' .*)
  DEC (yyStackPtr, 5); yyNonterminal := 116;
(* line 482 "/tmp/lalr1716" *)
  (* line 451 ../src/cg.lalr *)
   yySynAttribute.Tree := mOrder (yyAttributeStack^[yyStackPtr+1].Tree, NoPosition, ReverseTree (yyAttributeStack^[yyStackPtr+2].Tree), ReverseTree (yyAttributeStack^[yyStackPtr+4].Tree)); 
  | 345,224: (* Actions : Actions Exprs BEFORE Exprs ';' .*)
  DEC (yyStackPtr, 5); yyNonterminal := 116;
(* line 484 "/tmp/lalr1716" *)
  (* line 453 ../src/cg.lalr *)
   yySynAttribute.Tree := mOrder (yyAttributeStack^[yyStackPtr+1].Tree, NoPosition, ReverseTree (yyAttributeStack^[yyStackPtr+4].Tree), ReverseTree (yyAttributeStack^[yyStackPtr+2].Tree)); 
  | 346,229: (* Actions : Actions Checks ';' .*)
  DEC (yyStackPtr, 3); yyNonterminal := 116;
(* line 486 "/tmp/lalr1716" *)
  (* line 455 ../src/cg.lalr *)
   yySynAttribute.Tree := yyAttributeStack^[yyStackPtr+2].Tree; yySynAttribute.Tree^.Check.Next := yyAttributeStack^[yyStackPtr+1].Tree; 
  | 347,225: (* Actions : Actions Exprs ';' .*)
  DEC (yyStackPtr, 3); yyNonterminal := 116;
(* line 488 "/tmp/lalr1716" *)
  (* line 457 ../src/cg.lalr *)
   yySynAttribute.Tree := mTargetCode (yyAttributeStack^[yyStackPtr+1].Tree, Attribute.Position, nNoDesignator, ReverseTree (yyAttributeStack^[yyStackPtr+2].Tree)); 
  | 348: (* Actions : Actions Exprs .*)
  DEC (yyStackPtr, 2); yyNonterminal := 116;
(* line 490 "/tmp/lalr1716" *)
  (* line 459 ../src/cg.lalr *)
   yySynAttribute.Tree := mTargetCode (yyAttributeStack^[yyStackPtr+1].Tree, Attribute.Position, nNoDesignator, ReverseTree (yyAttributeStack^[yyStackPtr+2].Tree)); 
  | 349: (* Checks : Check .*)
  DEC (yyStackPtr, 1); yyNonterminal := 118;
(* line 493 "/tmp/lalr1716" *)
  (* line 462 ../src/cg.lalr *)
   yySynAttribute.Tree := yyAttributeStack^[yyStackPtr+1].Tree; 
  | 350,245: (* Checks : Check Checks .*)
  DEC (yyStackPtr, 2); yyNonterminal := 118;
(* line 495 "/tmp/lalr1716" *)
  (* line 464 ../src/cg.lalr *)
   yySynAttribute.Tree := yyAttributeStack^[yyStackPtr+1].Tree; yySynAttribute.Tree^.Check.Actions := yyAttributeStack^[yyStackPtr+2].Tree; 
  | 351: (* Check : '=>' Exprs .*)
  DEC (yyStackPtr, 2); yyNonterminal := 119;
(* line 498 "/tmp/lalr1716" *)
  (* line 468 ../src/cg.lalr *)
   yySynAttribute.Tree := mCheck (nNoAction, NoPosition, NoTree, ReverseTree (yyAttributeStack^[yyStackPtr+2].Tree), nNoAction); 
  | 352: (* Check : '=>' Exprs '{' Exprs '}' Space .*)
  DEC (yyStackPtr, 6); yyNonterminal := 119;
(* line 500 "/tmp/lalr1716" *)
  (* line 470 ../src/cg.lalr *)
   yySynAttribute.Tree := mCheck (nNoAction, NoPosition, NoTree, ReverseTree (yyAttributeStack^[yyStackPtr+4].Tree), nNoAction); 
  | 353: (* Check : CHECK Exprs .*)
  DEC (yyStackPtr, 2); yyNonterminal := 119;
(* line 502 "/tmp/lalr1716" *)
  (* line 472 ../src/cg.lalr *)
   yySynAttribute.Tree := mCheck (nNoAction, yyAttributeStack^[yyStackPtr+1].Scan.Position, ReverseTree (yyAttributeStack^[yyStackPtr+2].Tree), NoTree, nNoAction); 
  | 354: (* Check : CHECK Exprs '=>' Exprs .*)
  DEC (yyStackPtr, 4); yyNonterminal := 119;
(* line 504 "/tmp/lalr1716" *)
  (* line 474 ../src/cg.lalr *)
   yySynAttribute.Tree := mCheck (nNoAction, yyAttributeStack^[yyStackPtr+1].Scan.Position, ReverseTree (yyAttributeStack^[yyStackPtr+2].Tree), ReverseTree (yyAttributeStack^[yyStackPtr+4].Tree), nNoAction); 
  | 355: (* Check : CHECK Exprs '=>' Exprs '{' Exprs '}' Space .*)
  DEC (yyStackPtr, 8); yyNonterminal := 119;
(* line 506 "/tmp/lalr1716" *)
  (* line 476 ../src/cg.lalr *)
   yySynAttribute.Tree := mCheck (nNoAction, yyAttributeStack^[yyStackPtr+1].Scan.Position, ReverseTree (yyAttributeStack^[yyStackPtr+2].Tree), ReverseTree (yyAttributeStack^[yyStackPtr+6].Tree), nNoAction); 
  | 356: (* Exprs : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 117;
(* line 509 "/tmp/lalr1716" *)
  (* line 479 ../src/cg.lalr *)
   yySynAttribute.Tree := nNoDesignator; 
  | 357,221: (* Exprs : Exprs Name1 Space ':' Space Ident .*)
  DEC (yyStackPtr, 6); yyNonterminal := 117;
(* line 511 "/tmp/lalr1716" *)
  (* line 481 ../src/cg.lalr *)
   yySynAttribute.Tree := mDesignator (yyAttributeStack^[yyStackPtr+2].Scan.Ident, yyAttributeStack^[yyStackPtr+6].Scan.Ident, yyAttributeStack^[yyStackPtr+2].Scan.Position, yyAttributeStack^[yyStackPtr+6].Scan.Position, yyAttributeStack^[yyStackPtr+1].Tree); 
  | 358: (* Exprs : Exprs Name1 Space ':' Space .*)
  DEC (yyStackPtr, 5); yyNonterminal := 117;
(* line 514 "/tmp/lalr1716" *)
  (* line 483 ../src/cg.lalr *)
   yySynAttribute.Tree := mIdent (yyAttributeStack^[yyStackPtr+2].Scan.Ident, yyAttributeStack^[yyStackPtr+2].Scan.Position, yyAttributeStack^[yyStackPtr+1].Tree);
  	  yySynAttribute.Tree := mAnys (ReverseTree (yyAttributeStack^[yyStackPtr+3].Tree), yySynAttribute.Tree);
  	  yySynAttribute.Tree := mAny (yyAttributeStack^[yyStackPtr+4].Scan.StringRef, yySynAttribute.Tree);
  	  yySynAttribute.Tree := mAnys (ReverseTree (yyAttributeStack^[yyStackPtr+5].Tree), yySynAttribute.Tree); 
  | 359: (* Exprs : Exprs Name1 Space .*)
  DEC (yyStackPtr, 3); yyNonterminal := 117;
(* line 521 "/tmp/lalr1716" *)
  (* line 488 ../src/cg.lalr *)
   yySynAttribute.Tree := mIdent (yyAttributeStack^[yyStackPtr+2].Scan.Ident, yyAttributeStack^[yyStackPtr+2].Scan.Position, yyAttributeStack^[yyStackPtr+1].Tree);
  	  yySynAttribute.Tree := mAnys (ReverseTree (yyAttributeStack^[yyStackPtr+3].Tree), yySynAttribute.Tree); 
  | 360,218: (* Exprs : Exprs ':' .*)
  DEC (yyStackPtr, 2); yyNonterminal := 117;
(* line 525 "/tmp/lalr1716" *)
  (* line 491 ../src/cg.lalr *)
   yySynAttribute.Tree := mAny (yyAttributeStack^[yyStackPtr+2].Scan.StringRef, yyAttributeStack^[yyStackPtr+1].Tree); 
  | 361,220: (* Exprs : Exprs REMOTE Exprs '=>' Space Ident Space ':' Space Ident .*)
  DEC (yyStackPtr, 10); yyNonterminal := 117;
(* line 527 "/tmp/lalr1716" *)
  (* line 493 ../src/cg.lalr *)
   yySynAttribute.Tree := mRemote (ReverseTree (yyAttributeStack^[yyStackPtr+3].Tree), yyAttributeStack^[yyStackPtr+6].Scan.Ident, yyAttributeStack^[yyStackPtr+10].Scan.Ident, yyAttributeStack^[yyStackPtr+10].Scan.Position, yyAttributeStack^[yyStackPtr+1].Tree); 
  | 362,216: (* Exprs : Exprs Code .*)
  DEC (yyStackPtr, 2); yyNonterminal := 117;
(* line 529 "/tmp/lalr1716" *)
  (* line 495 ../src/cg.lalr *)
   yySynAttribute.Tree := mAny (yyAttributeStack^[yyStackPtr+2].Scan.StringRef, yyAttributeStack^[yyStackPtr+1].Tree); 
  | 363,217: (* Exprs : Exprs WhiteSpace .*)
  DEC (yyStackPtr, 2); yyNonterminal := 117;
(* line 531 "/tmp/lalr1716" *)
  (* line 497 ../src/cg.lalr *)
   yySynAttribute.Tree := mAny (yyAttributeStack^[yyStackPtr+2].Scan.StringRef, yyAttributeStack^[yyStackPtr+1].Tree); 
  | 364: (* Modules : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 90;
(* line 534 "/tmp/lalr1716" *)
  (* line 500 ../src/cg.lalr *)
   yySynAttribute.Tree := nNoModule; 
  | 365,240: (* Modules : Modules MODULE Ident Modules_1 ParserCodes TreeCodes EvalCodes PropPart DeclPart RulePart END Ident .*)
  DEC (yyStackPtr, 12); yyNonterminal := 90;
(* line 536 "/tmp/lalr1716" *)
  (* line 504 ../src/cg.lalr *)
   yySynAttribute.Tree := mModule (yyAttributeStack^[yyStackPtr+3].Scan.Ident, yyAttributeStack^[yyStackPtr+5].Tree, yyAttributeStack^[yyStackPtr+6].Tree, yyAttributeStack^[yyStackPtr+7].Tree, yyAttributeStack^[yyStackPtr+8].Tree, yyAttributeStack^[yyStackPtr+9].Tree, yyAttributeStack^[yyStackPtr+10].Tree, yyAttributeStack^[yyStackPtr+1].Tree); 
  | 366: (* Modules_1 : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 121;
(* line 538 "/tmp/lalr1716" *)
  (* line 502 ../src/cg.lalr *)
   ModuleIdent := yyAttributeStack^[yyStackPtr+0].Scan.Ident; 
  | 367,187: (* Name0 : Ident .*)
  DEC (yyStackPtr, 1); yyNonterminal := 93;
(* line 541 "/tmp/lalr1716" *)
  (* line 508 ../src/cg.lalr *)
   yySynAttribute.Scan := yyAttributeStack^[yyStackPtr+1].Scan; 
  | 368,188: (* Name0 : String .*)
  DEC (yyStackPtr, 1); yyNonterminal := 93;
(* line 544 "/tmp/lalr1716" *)
  (* line 510 ../src/cg.lalr *)
   yySynAttribute.Scan := yyAttributeStack^[yyStackPtr+1].Scan; GetString (yyAttributeStack^[yyStackPtr+1].Scan.StringRef, String1);
  	  SubString (String1, 2, Length (String1) - 1, String2);
  	  yySynAttribute.Scan.Ident := MakeIdent (String2); 
  | 369,197: (* Name1 : Ident .*)
  DEC (yyStackPtr, 1); yyNonterminal := 104;
(* line 551 "/tmp/lalr1716" *)
  (* line 516 ../src/cg.lalr *)
   yySynAttribute.Scan := yyAttributeStack^[yyStackPtr+1].Scan;
  	  yySynAttribute.Properties := {}; 
  | 370,198: (* Name1 : String .*)
  DEC (yyStackPtr, 1); yyNonterminal := 104;
(* line 556 "/tmp/lalr1716" *)
  (* line 519 ../src/cg.lalr *)
   yySynAttribute.Scan := yyAttributeStack^[yyStackPtr+1].Scan; GetString (yyAttributeStack^[yyStackPtr+1].Scan.StringRef, String1);
  	  yySynAttribute.Scan.Ident := MakeIdent (String1);
  	  yySynAttribute.Properties := {String}; 
  | 371: (* Space : .*)
  DEC (yyStackPtr, 0); yyNonterminal := 120;
(* line 562 "/tmp/lalr1716" *)
  (* line 524 ../src/cg.lalr *)
   yySynAttribute.Tree := nNoLayout; 
  | 372,219: (* Space : Space WhiteSpace .*)
  DEC (yyStackPtr, 2); yyNonterminal := 120;
(* line 564 "/tmp/lalr1716" *)
  (* line 526 ../src/cg.lalr *)
   yySynAttribute.Tree := mLayoutAny (yyAttributeStack^[yyStackPtr+2].Scan.StringRef, yyAttributeStack^[yyStackPtr+1].Tree); 
END;
              (* SPEC State 
                   := Next (Top (), Nonterminal); nonterminal transition *)
               yyNCombPtr 
                 := yyNCombTypePtr 
                      ( LONGCARD (yyNBasePtr [yyStateStack^ [yyStackPtr]])
                        + VAL ( LONGCARD, yyNonterminal )
                          * SYSTEM.TSIZE (yyNCombType)
                      );
               yyState := yyNCombPtr^;
               INC (yyStackPtr);
               yyAttributeStack^ [yyStackPtr] := yySynAttribute;
               IF yyState < yyFirstFinalState 
               THEN (* read nonterminal ? *)
                 EXIT 
               END (* IF *) ; 
            END (* LOOP *) ;

         ELSE (* read *)
            INC (yyStackPtr);
         yyAttributeStack^ [yyStackPtr].Scan := Scanner.Attribute;
         yyTerminal := VAL(yySymbolRange,Scanner.GetToken ());
            yyIsRepairing := FALSE;
         END (* IF *);
      END (* LOOP *) ;
   END Parser;

PROCEDURE ErrorRecovery (
      VAR Terminal      : yySymbolRange ;
          StateStack    : yyStackType   ;
          StackSize     : LONGINT       ;
          StackPtr      : yyStackPtrType);
   VAR
      TokensSkipped     : BOOLEAN;
      ContinueSet       : Sets.tSet;
      RestartSet        : Sets.tSet;
      Token             : yySymbolRange;
      TokenArray        : ARRAY [0..127] OF CHAR;
      TokenString       : Strings.tString;
      ContinueString    : Strings.tString;
   BEGIN
   (* 1. report the error *)
         TokenName ( Terminal , TokenArray );
         Strings.ArrayToString (TokenArray, TokenString);
         Errors.ErrorMessageI (Errors.SyntaxError, Errors.Error, 
         Scanner.Attribute.Position, Errors.String, SYSTEM.ADR(TokenString) );

   (* 2. report the set of expected terminal symbols *)
      Sets.MakeSet (ContinueSet, yyLastTerminal);
      ComputeContinuation (StateStack, StackSize, StackPtr, ContinueSet);
      Strings.AssignEmpty (ContinueString);
      FOR Token := VAL(yySymbolRange,Sets.Minimum (ContinueSet)) TO VAL(yySymbolRange,Sets.Maximum (ContinueSet)) DO
         IF Sets.IsElement (VAL(Sets.tElement,Token), ContinueSet) THEN
            TokenName (Token, TokenArray);
            Strings.ArrayToString (TokenArray, TokenString);
            IF (Strings.Length (ContinueString) + Strings.Length (TokenString) + 1 <= Strings.cMaxStrLength) THEN
               Strings.Concatenate (ContinueString, TokenString);
               Strings.Append (ContinueString, ' ');
            END;
         END;
      END;
      Errors.ErrorMessageI (Errors.ExpectedTokens, Errors.Information,
      Scanner.Attribute.Position, Errors.String, SYSTEM.ADR (ContinueString));
      Sets.ReleaseSet (ContinueSet);

   (* 3. compute the set of terminal symbols for restart of the parse *)
      Sets.MakeSet (RestartSet, yyLastTerminal);
      ComputeRestartPoints (StateStack, StackSize, StackPtr, RestartSet);

   (* 4. skip terminal symbols until a restart point is reached *)
      TokensSkipped := FALSE;
      WHILE NOT Sets.IsElement (VAL(Sets.tElement,Terminal), RestartSet) DO
      Terminal := VAL(yySymbolRange,Scanner.GetToken ());
         TokensSkipped := TRUE;
      END;
      Sets.ReleaseSet (RestartSet);

   (* 5. report the restart point *)
      IF TokensSkipped THEN
      Errors.ErrorMessage (Errors.RestartPoint, Errors.Information, Scanner.Attribute.Position);
      END;
   END ErrorRecovery;

(*
   compute the set of terminal symbols that can be accepted (read)
   in a given stack configuration (eventually after reduce actions)
*)

PROCEDURE ComputeContinuation (
          Stack         : yyStackType   ;
          StackSize     : LONGINT       ;
          StackPtr      : yyStackPtrType;
      VAR ContinueSet   : Sets.tSet     );
   VAR Terminal         : yySymbolRange;
   BEGIN
      Sets.AssignEmpty (ContinueSet);
      FOR Terminal := yyFirstTerminal TO yyLastTerminal DO
         IF IsContinuation (Terminal, Stack, StackSize, StackPtr) THEN
            Sets.Include (ContinueSet, VAL(Sets.tElement,Terminal));
         END;
      END;
   END ComputeContinuation;

(*
   check whether a given terminal symbol can be accepted (read)
   in a certain stack configuration (eventually after reduce actions)
*)

PROCEDURE IsContinuation (
      Terminal          : yySymbolRange ;
      ParseStack        : yyStackType   ;
      StackSize         : LONGINT       ;
      StackPtr          : yyStackPtrType): BOOLEAN;
   VAR
      State             : yyStackPtrType;
      Nonterminal       : yySymbolRange;
      Stack             : yyStackType;
   BEGIN
      DynArray.MakeArray (Stack, StackSize, SYSTEM.TSIZE (yyStateRange));
      FOR State := 0 TO StackPtr DO
         Stack^ [State] := ParseStack^ [State];
      END;
      State := Stack^ [StackPtr];
      LOOP
         Stack^ [StackPtr] := State;
         State := Next (State, Terminal);
         IF State = yyNoState THEN
            DynArray.ReleaseArray (Stack, StackSize, SYSTEM.TSIZE (yyStateRange));
            RETURN FALSE;
         END;
         IF State <= yyLastReadTermState THEN           (* read or read terminal reduce ? *)
            DynArray.ReleaseArray (Stack, StackSize, SYSTEM.TSIZE (yyStateRange));
            RETURN TRUE;
         END;

         LOOP                                           (* reduce *)
            IF State =  yyStopState THEN
               DynArray.ReleaseArray (Stack, StackSize, SYSTEM.TSIZE (yyStateRange));
               RETURN TRUE;
            ELSE 
               DEC (StackPtr, yyLength [State]);
               Nonterminal := yyLeftHandSide [State];
            END;

            State := Next (Stack^ [StackPtr], Nonterminal);
            IF StackPtr >= VAL ( yyStackPtrType , StackSize ) THEN
               DynArray.ExtendArray (Stack, StackSize, SYSTEM.TSIZE (yyStateRange));
            END;
            INC (StackPtr);
            IF State < yyFirstFinalState THEN EXIT; END; (* read nonterminal ? *)
            State := yyFinalToProd [State];             (* read nonterminal reduce *)
         END;
      END;
   END IsContinuation;

(*
   compute a set of terminal symbols that can be used to restart
   parsing in a given stack configuration. we simulate parsing until
   end of file using a suffix program synthesized by the function
   Continuation. All symbols acceptable in the states reached during
   the simulation can be used to restart parsing.
*)

PROCEDURE ComputeRestartPoints (
          ParseStack    : yyStackType   ;
          StackSize     : LONGINT       ;
          StackPtr      : yyStackPtrType;
      VAR RestartSet    : Sets.tSet     );
   VAR
      Stack             : yyStackType;
      State             : yyStackPtrType;
      Nonterminal       : yySymbolRange;
      ContinueSet       : Sets.tSet;
   BEGIN
      DynArray.MakeArray (Stack, StackSize, SYSTEM.TSIZE (yyStateRange));
      FOR State := 0 TO StackPtr DO
         Stack^ [State] := ParseStack^ [State];
      END;
      Sets.MakeSet (ContinueSet, yyLastTerminal);
      Sets.AssignEmpty (RestartSet);
      State := Stack^ [StackPtr];

      LOOP
         IF StackPtr >= VAL ( yyStackPtrType , StackSize ) THEN
            DynArray.ExtendArray (Stack, StackSize, SYSTEM.TSIZE (yyStateRange));
         END;
         Stack^ [StackPtr] := State;
         ComputeContinuation (Stack, StackSize, StackPtr, ContinueSet);
         Sets.Union (RestartSet, ContinueSet);
         State := Next (State, yyContinuation [State]);

         IF State >= yyFirstFinalState THEN             (* final state ? *)
            IF State <= yyLastReadTermState THEN        (* read terminal reduce ? *)
               INC (StackPtr);
               State := yyFinalToProd [State];
            END;

            LOOP                                        (* reduce *)
               IF State = yyStopState THEN
                  DynArray.ReleaseArray (Stack, StackSize, SYSTEM.TSIZE (yyStateRange));
                  Sets.ReleaseSet (ContinueSet);
                  RETURN;
               ELSE 
                  DEC (StackPtr, yyLength [State]);
                  Nonterminal := yyLeftHandSide [State];
               END;

               State := Next (Stack^ [StackPtr], Nonterminal);
               INC (StackPtr);
               IF State < yyFirstFinalState THEN EXIT; END; (* read nonterminal ? *)
               State := yyFinalToProd [State];          (* read nonterminal reduce *)
            END;
         ELSE                                           (* read *)
            INC (StackPtr);
         END;
      END;
   END ComputeRestartPoints;

(* access the parse table:   Next : State x Symbol -> State *)

PROCEDURE Next (State: yyStateRange; Symbol: yySymbolRange): yyStateRange;
   VAR
      TCombPtr          : yyTCombTypePtr;
      NCombPtr          : yyNCombTypePtr;
   BEGIN
      IF Symbol <= yyLastTerminal THEN
         LOOP
            TCombPtr 
              := yyTCombTypePtr 
                   ( LONGCARD (yyTBasePtr [State]) 
                     + VAL ( LONGCARD , Symbol )
                       * SYSTEM.TSIZE (yyTCombType)
                   );
            IF TCombPtr^.Check # State THEN
               State := yyDefault [State];
               IF State = yyNoState THEN RETURN yyNoState; END;
            ELSE
               RETURN TCombPtr^.Next;
            END;
         END;
      ELSE
        NCombPtr 
          := yyNCombTypePtr 
               ( LONGCARD (yyNBasePtr [State]) 
                 + VAL ( LONGCARD , Symbol )
                   * SYSTEM.TSIZE (yyNCombType)
               );
        RETURN NCombPtr^;
      END;
   END Next;

PROCEDURE yyGetTables;
   VAR
      BlockSize, j, n   : CARDINAL;
      State     : yyStateRange;
      TBase     : ARRAY yyTableElmt[0 .. yyLastReadState] OF yyTCombRange;
      NBase     : ARRAY yyTableElmt[0 .. yyLastReadState] OF yyNCombRange;
   BEGIN
      BlockSize := 64000 DIV SYSTEM.TSIZE (yyTCombType);
      yyTableFile := System.OpenInput (ParsTabName);
      yyErrorCheck (Errors.OpenParseTable, yyTableFile);
      IF 
         (yyGetTable (SYSTEM.ADR (TBase         )) DIV SYSTEM.TSIZE (yyTCombRange ) - 1
            # yyLastReadState) OR
         (yyGetTable (SYSTEM.ADR (NBase         )) DIV SYSTEM.TSIZE (yyNCombRange ) - 1
            # yyLastReadState) OR
         (yyGetTable (SYSTEM.ADR (yyDefault     )) DIV SYSTEM.TSIZE (yyReadRange  ) - 1
            # yyLastReadState) OR
         (yyGetTable (SYSTEM.ADR (yyNComb       )) DIV SYSTEM.TSIZE (yyNCombType  )
            # yyNTableMax - yyLastTerminal) OR
         (yyGetTable (SYSTEM.ADR (yyLength      )) DIV SYSTEM.TSIZE (yyTableElmt  ) - 1
            # yyLastReduceState - yyFirstReduceState) OR
         (yyGetTable (SYSTEM.ADR (yyLeftHandSide)) DIV SYSTEM.TSIZE (yySymbolRange) - 1
            # yyLastReduceState - yyFirstReduceState) OR
         (yyGetTable (SYSTEM.ADR (yyContinuation)) DIV SYSTEM.TSIZE (yySymbolRange) - 1
            # yyLastReadState) OR
         (yyGetTable (SYSTEM.ADR (yyFinalToProd )) DIV SYSTEM.TSIZE (yyReduceRange) - 1
            # yyLastReadNontermState - yyFirstReadTermState)
      THEN
         Errors.ErrorMessage (Errors.WrongParseTable, Errors.Fatal, Positions.NoPosition);
      END;
      n := 0;
      j := 0;
      WHILE j <= yyTableMax DO
         INC (n, yyGetTable (SYSTEM.ADR (yyTComb [VAL(yyStateRange,j)])) DIV SYSTEM.TSIZE (yyTCombType));
         INC (j, BlockSize);
      END;
      IF n # yyTableMax + 1 THEN 
         Errors.ErrorMessage (Errors.WrongParseTable, Errors.Fatal, Positions.NoPosition);
      END;
      System.Close (yyTableFile);

      FOR State := 1 TO yyLastReadState DO
         yyTBasePtr [State] := SYSTEM.ADR (yyTComb [TBase [State]]);
      END;
      FOR State := 1 TO yyLastReadState DO
         yyNBasePtr [State] := SYSTEM.ADR (yyNComb [NBase [State]]);
      END;
   END yyGetTables;

PROCEDURE yyGetTable (Address: SYSTEM.ADDRESS): CARDINAL;
   VAR
      N         : INTEGER;
      Length    : yyTableElmt;
      LongLength : CARDINAL;
   BEGIN
      N := System.Read (yyTableFile, SYSTEM.ADR (Length), SYSTEM.TSIZE (yyTableElmt));
      yyErrorCheck (Errors.ReadParseTable, N);
      LongLength := VAL ( CARDINAL , Length );
      N := System.Read (yyTableFile, Address, LongLength);
      yyErrorCheck (Errors.ReadParseTable, N);
      RETURN LongLength;
   END yyGetTable;

PROCEDURE yyErrorCheck (ErrorCode: INTEGER; Info: INTEGER);
   VAR ErrNo: INTEGER;
   BEGIN
     IF Info < 0 THEN
        ErrNo := System.ErrNum ();
        Errors.ErrorMessageI (ErrorCode, Errors.Fatal, Positions.NoPosition,
           Errors.Integer, SYSTEM.ADR (ErrNo));
     END;
   END yyErrorCheck;

PROCEDURE BeginParser;
   BEGIN
(* line 93 "/tmp/lalr1716" *)
(* line 91 ../src/cg.lalr *)

   BeginScanner;
   ClassCount	  := 0;
   InitProperties := {Input};
   ModuleIdent	  := NoIdent;
   SubUnit	  := NoIdent;
   ViewName	  := NoIdent;
   ParserName	  := NoIdent;
   TreeName	  := NoIdent;
   EvalName	  := NoIdent;

      IF NOT yyIsInitialized THEN
         yyIsInitialized := TRUE;
         yyGetTables;
      END;
   END BeginParser;

PROCEDURE CloseParser;
   BEGIN

   END CloseParser;

BEGIN
    yyIsInitialized := FALSE;
    ParsTabName := 'Parser.Tab';
END Parser.
