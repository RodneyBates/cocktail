
(* This file was mechanically generated by puma. *)

IMPLEMENTATION MODULE Semantics;








IMPORT SYSTEM, System, IO, Tree;
(* line 32 "" *)


FROM SYSTEM     IMPORT TSIZE, ADR;
FROM General    IMPORT Max;
FROM IO         IMPORT StdOutput, WriteN, WriteS, WriteI, WriteNl;
FROM DynArray   IMPORT MakeArray;
FROM StringMem  IMPORT tStringRef;
FROM Strings    IMPORT tString, IntToString, Append, Concatenate, ArrayToString,
                        Length, Char;
FROM Idents     IMPORT WriteIdent, tIdent, NoIdent, MakeIdent, MaxIdent, GetString;
FROM Texts      IMPORT MakeText;

IMPORT Sets ; 
FROM Sets       IMPORT
   tSet         , MakeSet       , ReleaseSet    , AssignEmpty   ,
   IsElement    , Include       , IsEmpty       , Extract       ,
   Select       , Difference    , Complement    , ForallDo      ;

FROM Relations  IMPORT tRelation, MakeRelation, IsCyclic, GetCyclics, Assign, IsRelated;
FROM Positions  IMPORT NoPosition;

FROM Tree       IMPORT
   NoTree       , tTree         , tInstance     , tInstancePtr  ,
   Computed     , Reverse       , Link          , 
   Write         , Read          ,
   Inherited    , Synthesized   , Input         , Output        ,
   Stack        , Variable      , Ignore        , CopyDef       ,
   CopyUse      , Thread        , NoAttribute   , MultInhComp   ,
   Test         , Left          , Right         , NoCodeAttr    ,
   NonBaseComp  , Dummy         , Terminal      ,
   Nonterminal  , HasChildren   , HasAttributes , HasActions    ,
   Reachable    , Referenced    , Implicit      , mActionPart   ,
   mClass       , mAttribute    , mChild        , mIdent        ,
   mCopy        , mDesignator   , MaxSet        , WriteName     ,
   Options      , TreeRoot      , ForallClasses , ForallAttributes,
   GrammarClass , cLNC          , WriteDependencies, WriteClass ,
   IdentifyClass, IdentifyAttribute, IdentifyModule, TypeNames  ,
   ClassCount   , nNoClass      , nNoAttribute  , nNoDesignator ,
   nNoAction    , nNoName       , iPosition     , itPosition    ,
   WriteCyclics , HasItem       , Mark          , Abstract      ,
   InitIdentifyClass, InitIdentifyClass2;
   
IMPORT Relations, StringMem, Errors;

CONST
AssignmentLhsNamesNoAttributes	= 10	;
CopyRuleLhsNamesNoAttributes	= 11	;
BlockLhsNamesNoAttributes	= 12	;
CheckWithoutStatement	= 13	;
InheritedUseOfSynthesizedAttribute	= 14	;
AttributeMultipleComputed	= 15	;
ChildsClassHasNoSuchAttribute	= 16	;
NoSuchChild	= 17	;
SynthesizedUseOfInheritedAttribute	= 18	;
NoSuchAttribute	= 19	;
CopyRuleInsertionsInherited	= 20	;
CopyRuleInsertionsSynthesized	= 21	;
CopyRuleInsertionsThreaded	= 22	;
ModuleNotDeclared	= 23	;
TerminalCodeMultipleUsed	= 24	;
NodeTypeNotDeclared	= 25	;
OnlyOneReverseAllowedInNodeType	= 26	;
NodeTypeMultipleDeclared	= 27	;
VariantSelectorMultipleDeclared	= 28	;
PrecedenceNotDeclared	= 29	;
SelectorMultipleDeclared	= 30	;
PrecedenceMultipleDeclared	= 31	;
AbstractTypeRequired	= 32	;
ChildRequired	= 33	;
AttributeNotDeclared	= 34	;
SelectorNotDeclared	= 35	;
AttributeNeverSet	= 36	;
AttributeNeverUsed	= 37	;
AssignmentToInputAttribute	= 38	;
AttributeSynthesizedAsWellAsInherited	= 39	;
NodeTypeNotUsed	= 40	;
InheritedAttributesAllowedOnlyInBaseClasses	= 41	;
AttributeComputationMissing	= 42	;
CycleInLocalDependenciesDP	= 43	;


VAR
   CopyInherited, CopySynthesized, CopyThreaded,
   ChildCount, AttributeCount, ActionCount, ActionName : INTEGER;
   ItemCount    ,
   ChecksCount  ,
   ReverseCount : INTEGER;
   iNull        ,
   Ident        : tIdent;
   ClassNames   ,
   SelectorNames,
   VariantNames ,
   PrecNames    ,
   CodesUsed    ,
   Results      ,
   Arguments    ,
   Cyclics      : tSet;
   MaxInstCount ,
   TokenCode    ,
   DummyIndex   ,
   i, j, k      : SHORTCARD;
   InstanceSize : LONGINT;
   IsAbstract   ,
   Success      : BOOLEAN;
   Module       ,
   Node         ,
   Attribute    ,
   Child        ,
   TheAction    ,
   TheClass     ,
   Class        : tTree;
   String       ,
   String2      : tString;
   ActProperties: BITSET;

PROCEDURE LookUp (i: tIdent; t: tTree): BOOLEAN;
   BEGIN
      WHILE t^.Kind = Tree.Name DO
         IF t^.Name.Name = i THEN RETURN TRUE; END;
         t := t^.Name.Next;
      END;
      RETURN FALSE;
   END LookUp;

PROCEDURE ProcessIgnore2 (t: tTree): tTree;
   VAR r: tTree;
   BEGIN
      IF t^.Kind # Tree.NoAttribute THEN
         t^.AttrOrAction.Next := ProcessIgnore2 (t^.AttrOrAction.Next);
      END;
      IF (t^.Kind = Tree.Child) AND (Ignore IN t^.Child.Properties) OR
         (t^.Kind = Tree.Attribute) AND (Ignore IN t^.Attribute.Properties) OR
         (t^.Kind = Tree.ActionPart) AND (Ignore IN t^.ActionPart.Properties) THEN
         RETURN t^.AttrOrAction.Next;
      END;
      RETURN t;
   END ProcessIgnore2;

PROCEDURE CompBaseClass (t, b: tTree);
   BEGIN
      IF t^.Kind = Tree.Class THEN
         t^.Class.BaseClass := b;
         CompBaseClass (t^.Class.Next, b);
         CompBaseClass (t^.Class.Extensions, t);
      END;
   END CompBaseClass;

PROCEDURE CompParsIndex (t: tTree; VAR Index: SHORTCARD);
   VAR OldIndex : SHORTCARD;
   BEGIN
      OldIndex := Index;
      CASE t^.Kind OF
      | Tree.Class:
         CompParsIndex (t^.Class.Attributes, Index);
         CompParsIndex (t^.Class.Extensions, Index);
         CompParsIndex (t^.Class.Next, OldIndex);
      | Tree.Child:
         INC (Index);
         t^.Child.ParsIndex := Index;
         CompParsIndex (t^.Child.Next, Index);
      | Tree.Attribute:
         CompParsIndex (t^.Attribute.Next, Index);
      | Tree.ActionPart:
         INC (Index);
         t^.ActionPart.ParsIndex := Index;
         INC (ActionName);
         t^.ActionPart.Name := ActionName;
         CompParsIndex (t^.ActionPart.Next, Index);
      ELSE
      END;
   END CompParsIndex;

(* Number children only, from 1. *)
PROCEDURE CompChildIndex (t: tTree; VAR Index: SHORTCARD);
   VAR OldIndex : SHORTCARD;
   BEGIN
      OldIndex := Index;
      CASE t^.Kind OF
      | Tree.Class:
         CompChildIndex (t^.Class.Attributes, Index);
         t^.Class.ClassChildCount := Index; 
         CompChildIndex (t^.Class.Extensions, Index);
         CompChildIndex (t^.Class.Next, OldIndex);
      | Tree.Child:
         INC (Index);
         t^.Child.ChildIndex := Index;
         CompChildIndex (t^.Child.Next, Index);
      | Tree.Attribute:
         CompChildIndex (t^.Attribute.Next, Index);
      | Tree.ActionPart:
         CompChildIndex (t^.ActionPart.Next, Index);
      ELSE
      END;
   END CompChildIndex;

PROCEDURE CompIndex (t: tTree; In: SHORTCARD; VAR Out: SHORTCARD);
   BEGIN
      CASE t^.Kind OF
      | Tree.Class:
         CompIndex (t^.Class.Attributes, In, Out);
         t^.Class.AttrCount := Out;
         CompIndex (t^.Class.Extensions, Out, Out);
         CompIndex (t^.Class.Next, In, Out);
      | Tree.NoClass:
      | Tree.Child:
         INC (In);
         t^.Child.AttrIndex := In;
         CompIndex (t^.Child.Next, In, Out);
      | Tree.Attribute:
         INC (In);
         t^.Attribute.AttrIndex := In;
         CompIndex (t^.Attribute.Next, In, Out);
      | Tree.ActionPart:
         CompIndex (t^.ActionPart.Next, In, Out);
      | Tree.NoAttribute:
         Out := In;
      END;
   END CompIndex;

PROCEDURE CompInstance (t: tTree; In: SHORTCARD; VAR Out: SHORTCARD);
   BEGIN
      CASE t^.Kind OF
      | Tree.Class:
         CompInstance (t^.Class.Attributes, In , Out);
         t^.Class.InstCount := t^.Class.AttrCount + Out;
         MaxInstCount := Max (MaxInstCount, t^.Class.InstCount);
         CompInstance (t^.Class.Extensions, Out, Out);
         CompInstance (t^.Class.Next, In, Out);
      | Tree.NoClass:
      | Tree.Child:
         t^.Child.InstOffset := In;
         IF t^.Child.Class # NoTree THEN
            CompInstance (t^.Child.Next, In + t^.Child.Class^.Class.AttrCount, Out);
         ELSE
            CompInstance (t^.Child.Next, In, Out);
         END;
      | Tree.Attribute:
         CompInstance (t^.Attribute.Next, In, Out);
      | Tree.ActionPart:
         CompInstance (t^.ActionPart.Next, In, Out);
      | Tree.NoAttribute:
         Out := In;
      END;
   END CompInstance;

PROCEDURE CompBitCount (t: tTree; In: SHORTCARD; VAR Out: SHORTCARD);
   BEGIN
      CASE t^.Kind OF
      | Tree.Class:
         CompBitCount (t^.Class.Attributes, In, Out);
         t^.Class.BitCount := Out;
         CompBitCount (t^.Class.Extensions, Out, Out);
         CompBitCount (t^.Class.Next, In, Out);
      | Tree.NoClass:
      | Tree.Child:
         IF {Input, Test, Dummy} * t^.Child.Properties = {} THEN INC (In); END;
         CompBitCount (t^.Child.Next, In, Out);
      | Tree.Attribute:
         IF {Input, Test, Dummy} * t^.Attribute.Properties = {} THEN INC (In); END;
         CompBitCount (t^.Attribute.Next, In, Out);
      | Tree.ActionPart:
         CompBitCount (t^.ActionPart.Next, In, Out);
      | Tree.NoAttribute:
         Out := In;
      END;
   END CompBitCount;

PROCEDURE CompBitOffset (t: tTree; In: SHORTCARD; VAR Out: SHORTCARD);
   BEGIN
      CASE t^.Kind OF
      | Tree.Class:
         CompBitOffset (t^.Class.Attributes, In , Out);
         CompBitOffset (t^.Class.Extensions, Out, Out);
         CompBitOffset (t^.Class.Next, In, Out);
      | Tree.NoClass:
      | Tree.Child:
         t^.Child.BitOffset := In;
         IF t^.Child.Class # NoTree THEN
            CompBitOffset (t^.Child.Next, In + t^.Child.Class^.Class.BitCount, Out);
         ELSE
            CompBitOffset (t^.Child.Next, In, Out);
         END;
      | Tree.Attribute:
         CompBitOffset (t^.Attribute.Next, In, Out);
      | Tree.ActionPart:
         CompBitOffset (t^.ActionPart.Next, In, Out);
      | Tree.NoAttribute:
         Out := In;
      END;
   END CompBitOffset;

PROCEDURE InitInstance (t: tTree; Offset: SHORTCARD; InstancePtr: tInstancePtr);
   BEGIN
      CASE t^.Kind OF
      | Tree.Class:
         InitInstance (t^.Class.BaseClass , Offset, InstancePtr);
         InitInstance (t^.Class.Attributes, Offset, InstancePtr);
      | Tree.NoClass:
      | Tree.Child:
         WITH InstancePtr^ [t^.Child.AttrIndex] DO
            Attribute  := t;
            Properties := t^.Child.Properties + {Left};
            Action     := ADR (Action);
         END;
         IF t^.Child.Class # NoTree THEN
            InitInstance1 (t^.Child.Class, t, Offset + t^.Child.InstOffset, InstancePtr);
         END;
         InitInstance (t^.Child.Next, Offset, InstancePtr);
      | Tree.Attribute:
         WITH InstancePtr^ [t^.Attribute.AttrIndex] DO
            Attribute  := t;
            Properties := t^.Attribute.Properties + {Left};
            Action     := ADR (Action);
         END;
         InitInstance (t^.Attribute.Next, Offset, InstancePtr);
      | Tree.ActionPart:
         InitInstance (t^.ActionPart.Next, Offset, InstancePtr);
      | Tree.NoAttribute:
      END;
   END InitInstance;

PROCEDURE InitInstance1 (t, selector: tTree; Offset: SHORTCARD; InstancePtr: tInstancePtr);
   BEGIN
      CASE t^.Kind OF
      | Tree.Class:
         InitInstance1 (t^.Class.BaseClass , selector, Offset, InstancePtr);
         InitInstance1 (t^.Class.Attributes, selector, Offset, InstancePtr);
      | Tree.NoClass:
      | Tree.Child:
         WITH InstancePtr^ [Offset + t^.Child.AttrIndex] DO
            Selector   := selector;
            Attribute  := t;
            Properties := t^.Child.Properties + {Right};
            Action     := ADR (Action);
         END;
         InitInstance1 (t^.Child.Next, selector, Offset, InstancePtr);
      | Tree.Attribute:
         WITH InstancePtr^ [Offset + t^.Attribute.AttrIndex] DO
            Selector   := selector;
            Attribute  := t;
            Properties := t^.Attribute.Properties + {Right};
            Action     := ADR (Action);
         END;
         InitInstance1 (t^.Attribute.Next, selector, Offset, InstancePtr);
      | Tree.ActionPart:
         InitInstance1 (t^.ActionPart.Next, selector, Offset, InstancePtr);
      | Tree.NoAttribute:
      END;
   END InitInstance1;

VAR relation    : tRelation;
VAR result      : INTEGER;

PROCEDURE EnterDependency (argument: Sets.tElement);
   BEGIN
      Relations.Include (relation, result, argument);
   END EnterDependency;

VAR MultipleInheritedActions    : BOOLEAN;

PROCEDURE CompDP1 (t: tTree; VAR Set: tSet; Usage: INTEGER; NonBase, Check: BOOLEAN);
   VAR Attribute, ChildsClass   : tTree;
   VAR Offset   : SHORTCARD;
   BEGIN
      CASE t^.Kind OF
      | Tree.Class:
            CompDP1 (t^.Class.BaseClass , Set, Usage, FALSE  , Check);
            MultipleInheritedActions := FALSE;
            CompDP1 (t^.Class.Attributes, Set, Usage, NonBase, Check);
      | Tree.NoClass:
      | Tree.Attribute:
            IF t^.Attribute.AttrIndex # DummyIndex THEN         (* HAGs *)
               Relations.Include (relation, DummyIndex, t^.Attribute.AttrIndex);
            END;
            CompDP1 (t^.Attribute.Next, Set, Usage, NonBase, Check);
      | Tree.Child:
            ChildsClass := t^.Child.Class;
            IF ChildsClass # NoTree THEN
               IF NOT (Input IN t^.Child.Properties) THEN       (* HAGs *)
                  Relations.Include (relation, DummyIndex, t^.Child.AttrIndex);
                  FOR i := 1 TO ChildsClass^.Class.AttrCount DO
                     Relations.Include (relation, Class^.Class.AttrCount + t^.Child.InstOffset + i, t^.Child.AttrIndex);
                  END;
               END;

               Attribute := IdentifyAttribute (ChildsClass, iNull);
               Offset := Class^.Class.AttrCount + t^.Child.InstOffset + Attribute^.Child.AttrIndex;
               Relations.Include (relation, DummyIndex, Offset);
               INCL (Class^.Class.Instance^[Offset].Properties, Right);
            END;
            CompDP1 (t^.Child.Next, Set, Usage, NonBase, Check);
      | Tree.ActionPart:
            IF MultInhComp IN t^.ActionPart.Properties THEN MultipleInheritedActions := TRUE; END;
            CompDP1 (t^.ActionPart.Actions, Set, Usage, NonBase, Check);
            CompDP1 (t^.ActionPart.Next   , Set, Usage, NonBase, Check);
      | Tree.NoAttribute:
      | Tree. Assign :
            IF IsCopy (t^.Assign.Arguments) THEN t^.Kind := Tree.Copy; END;
            AssignEmpty (Results  );
            AssignEmpty (Arguments);
            CompDP1 (t^.Assign.Results  , Results  , Write, NonBase, TRUE );
            CompDP1 (t^.Assign.Arguments, Arguments, Read , NonBase, FALSE);
            IF IsEmpty (Results) THEN
Tree.Error (AssignmentLhsNamesNoAttributes, t^.Assign.Pos);
            END;
            WHILE NOT IsEmpty (Results) DO
               result := Extract (Results);
               WITH Class^.Class.Instance^[result] DO
                  IF (Action = ADR (Action)) OR (MultInhComp IN Properties) OR NOT MultipleInheritedActions THEN
                     Action := t;
                     IF t^.Kind = Tree.Copy THEN CopyArg := Select (Arguments); END;
                  END;
               END;
               ForallDo (Arguments, EnterDependency);
            END;
            CompDP1 (t^.Assign.Next, Set, Usage, NonBase, Check);
      | Tree. Copy :
            AssignEmpty (Results  );
            AssignEmpty (Arguments);
            CompDP1 (t^.Copy.Results  , Results  , Write, NonBase, TRUE );
            CompDP1 (t^.Copy.Arguments, Arguments, Read , NonBase, TRUE );
            IF IsEmpty (Results) THEN
Tree.Error (CopyRuleLhsNamesNoAttributes, t^.Copy.Pos);
            END;
            WHILE NOT IsEmpty (Results) DO
               result := Extract (Results);
               WITH Class^.Class.Instance^[result] DO
                  IF (Action = ADR (Action)) OR (MultInhComp IN Properties) OR NOT MultipleInheritedActions THEN
                     Action  := t;
                     CopyArg := Select (Arguments);
                  END;
               END;
               ForallDo (Arguments, EnterDependency);
            END;
            CompDP1 (t^.Copy.Next, Set, Usage, NonBase, Check);
      | Tree. TargetCode :
            AssignEmpty (Results  );
            AssignEmpty (Arguments);
            CompDP1 (t^.TargetCode.Results, Results  , Write, NonBase, TRUE );
            CompDP1 (t^.TargetCode.Code   , Arguments, Read , NonBase, FALSE);
            Difference (Arguments, Results);
            IF IsEmpty (Results) AND IsCode (t^.TargetCode.Code) THEN
Tree.Error (BlockLhsNamesNoAttributes, t^.TargetCode.Pos);
            END;
            WHILE NOT IsEmpty (Results) DO
               result := Extract (Results);
               WITH Class^.Class.Instance^[result] DO
                  IF (Action = ADR (Action)) OR (MultInhComp IN Properties) OR NOT MultipleInheritedActions THEN
                     Action  := t;
                  END;
               END;
               ForallDo (Arguments, EnterDependency);
            END;
            CompDP1 (t^.TargetCode.Next, Set, Usage, NonBase, Check);
      | Tree. Order:
            AssignEmpty (Results  );
            AssignEmpty (Arguments);
            CompDP1 (t^.Order.Results  , Results  , Read, NonBase, TRUE );
            CompDP1 (t^.Order.Arguments, Arguments, Read, NonBase, TRUE );
            WHILE NOT IsEmpty (Results) DO
               result := Extract (Results);
               ForallDo (Arguments, EnterDependency);
            END;
            CompDP1 (t^.Order.Next, Set, Usage, NonBase, Check);
      | Tree. Check :
            IF t^.Check.Results # NoTree THEN
               AssignEmpty (Results  );
               AssignEmpty (Arguments);
               CompDP1 (t^.Check.Results, Results, Write, NonBase, FALSE);
            END;
            IF t^.Check.Condition # NoTree THEN
               CompDP1 (t^.Check.Condition, Arguments, Read, NonBase, FALSE);
            END;
            IF t^.Check.Statement # NoTree THEN
               CompDP1 (t^.Check.Statement, Arguments, Read, NonBase, FALSE);
            ELSE
Tree.Warning (CheckWithoutStatement, t^.Check.Pos);
            END;
            CompDP1 (t^.Check.Actions, Arguments, Read, NonBase, FALSE);
            IF t^.Check.Results # NoTree THEN
               result := Extract (Results);
               Class^.Class.Instance^[result].Action := t;
               ForallDo (Arguments, EnterDependency);
               CompDP1 (t^.Check.Next, Set, Usage, NonBase, Check);
            END;
      | Tree.NoAction:
      | Tree. Designator :
            Attribute := IdentifyAttribute (Class, t^.Designator.Selector);
            IF (Attribute # NoTree) AND (Attribute^.Kind = Tree.Child) THEN
               ChildsClass := Attribute^.Child.Class;
               Offset := Class^.Class.AttrCount + Attribute^.Child.InstOffset;
               INCL (Attribute^.Child.Properties, Read);
               IF ChildsClass # NoTree THEN
                  Attribute := IdentifyAttribute (ChildsClass, t^.Designator.Attribute);
                  IF Attribute # NoTree THEN
                     Include (Set, Offset + Attribute^.Child.AttrIndex);
                     INCL (Attribute^.Child.Properties, Usage);
                     IF Usage = Write THEN
                        INCL (Attribute^.Child.Properties, Inherited);
                        INCL (Class^.Class.Instance^ [Offset + Attribute^.Child.AttrIndex].Properties, Computed);
                        IF Synthesized IN Attribute^.Child.Properties THEN
Tree.ErrorI (InheritedUseOfSynthesizedAttribute, t^.Designator.Pos, Errors.Ident, ADR (t^.Designator.Attribute));
                        END;
                        WITH Class^.Class.Instance^ [Offset + Attribute^.Child.AttrIndex] DO
                           IF NonBase AND NOT MultipleInheritedActions AND (NonBaseComp IN Properties) AND
                              NOT (MultInhComp IN Properties) THEN
Tree.ErrorI (AttributeMultipleComputed, t^.Designator.Pos, Errors.Ident, ADR (t^.Designator.Attribute));
                           END;
                           IF NOT MultipleInheritedActions OR (MultInhComp IN Properties) THEN
                              EXCL (Properties, MultInhComp);
                              IF NonBase THEN INCL (Properties, NonBaseComp); END;
                              IF MultipleInheritedActions THEN INCL (Properties, MultInhComp); END;
                           END;
                        END;
                     END;
                  ELSIF Check THEN
Tree.ErrorI (ChildsClassHasNoSuchAttribute, t^.Designator.Pos, Errors.Ident, ADR (t^.Designator.Attribute));
                  END;
               END;
            ELSIF Check THEN
Tree.ErrorI (NoSuchChild, t^.Designator.Pos, Errors.Ident, ADR (t^.Designator.Selector));
            END;
            CompDP1 (t^.Designator.Next, Set, Usage, NonBase, Check);
      | Tree. Ident :
            Attribute := IdentifyAttribute (Class, t^.Ident.Attribute);
            IF Attribute # NoTree THEN
               Include (Set, Attribute^.Child.AttrIndex);
               INCL (Attribute^.Child.Properties, Usage);
               IF Usage = Write THEN
                  INCL (Attribute^.Child.Properties, Synthesized);
                  INCL (Class^.Class.Instance^ [Attribute^.Child.AttrIndex].Properties, Computed);
                  IF Inherited IN Attribute^.Child.Properties THEN
Tree.ErrorI (SynthesizedUseOfInheritedAttribute, t^.Ident.Pos, Errors.Ident, ADR (t^.Ident.Attribute));
                  END;
                  WITH Class^.Class.Instance^ [Attribute^.Child.AttrIndex] DO
                     IF NonBase AND NOT MultipleInheritedActions AND (NonBaseComp IN Properties) AND
                        NOT (MultInhComp IN Properties) THEN
Tree.ErrorI (AttributeMultipleComputed, t^.Ident.Pos, Errors.Ident, ADR (t^.Ident.Attribute));
                     END;
                     IF NOT MultipleInheritedActions OR (MultInhComp IN Properties) THEN
                        EXCL (Properties, MultInhComp);
                        IF NonBase THEN INCL (Properties, NonBaseComp); END;
                        IF MultipleInheritedActions THEN INCL (Properties, MultInhComp); END;
                     END;
                  END;
               END;
            ELSIF Check THEN
Tree.ErrorI (NoSuchAttribute, t^.Ident.Pos, Errors.Ident, ADR (t^.Ident.Attribute));
            END;
            CompDP1 (t^.Ident.Next, Set, Usage, NonBase, Check);
      | Tree.Remote:
            CompDP1 (t^.Remote.Designators, Set, Usage, NonBase, Check);
            CompDP1 (t^.Remote.Next, Set, Usage, NonBase, Check);
      | Tree.Any:
            CompDP1 (t^.Any.Next, Set, Usage, NonBase, Check);
      | Tree.Anys:
            CompDP1 (t^.Anys.Next, Set, Usage, NonBase, Check);
      | Tree.NoDesignator:
      END;
   END CompDP1;

PROCEDURE IsCode (t: tTree): BOOLEAN;
   BEGIN
      CASE t^.Kind OF
      | Tree.Designator
      , Tree.Ident
      , Tree.Remote      : RETURN TRUE;
      | Tree.Any         : RETURN IsCode (t^.Any.Next);
      | Tree.Anys        : RETURN IsCode (t^.Anys.Next);
      | Tree.NoDesignator: RETURN FALSE;
      END;
   END IsCode;

PROCEDURE CopyTree (t: tTree): tTree;
   BEGIN
      CASE t^.Kind OF
      | Tree.Attribute: WITH t^.Attribute DO
            RETURN mAttribute (CopyTree (Next), Name, Type, Properties, Pos);
         END;
      | Tree.Child: WITH t^.Child DO
            RETURN mChild (CopyTree (Next), Name, Type, Properties, Pos);
         END;
      | Tree.ActionPart: WITH t^.ActionPart DO
            RETURN mActionPart (CopyTree (Next), Actions);
         END;
      | Tree.NoAttribute:
         RETURN nNoAttribute;
      END;
   END CopyTree;

PROCEDURE ExpandMultiple (Class: tTree);
   VAR Node, class: tTree;
   BEGIN
      WITH Class^.Class DO
         IF NOT (Mark IN Properties) THEN
            INCL (Properties, Mark);
            IF BaseClass^.Kind = Tree.Class THEN ExpandMultiple (BaseClass); END;
            Node := Names;
            WHILE Node^.Kind = Tree.Name DO
               WITH Node^.Name DO
                  class := IdentifyClass (TreeRoot^.Ag.Classes, Name);
                  IF class # NoTree THEN
                     ExpandMultiple (class);
                     TheClass := Class;
                     ForallAttributes (class, ExpandMultiple2);
                  END;
                  Node := Next;
               END;
            END;
            EXCL (Properties, Mark);
         END;
      END;
END ExpandMultiple;

PROCEDURE AppendAttr (VAR Attributes: tTree; Attribute: tTree);
   BEGIN
      IF Attributes^.Kind = NoAttribute THEN
         Attribute^.AttrOrAction.Next := Attributes;
         Attributes := Attribute;
      ELSE
         AppendAttr (Attributes^.AttrOrAction.Next, Attribute);
      END;
   END AppendAttr;


















































































































PROCEDURE yyAbort (yyFunction: ARRAY OF CHAR);
 BEGIN
  IO.WriteS (IO.StdError, 'Error: module Semantics, routine ');
  IO.WriteS (IO.StdError, yyFunction);
  IO.WriteS (IO.StdError, ' failed');
  IO.WriteNl (IO.StdError);
  Exit;
 END yyAbort;

PROCEDURE yyIsEqual (yya, yyb: ARRAY OF SYSTEM.BYTE): BOOLEAN;
 VAR yyi       : INTEGER;
 BEGIN
  FOR yyi := 0 TO INTEGER (HIGH (yya)) DO
   IF yya [yyi] # yyb [yyi] THEN RETURN FALSE; END;
  END;
  RETURN TRUE;
 END yyIsEqual;

PROCEDURE Semantics (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Ag:
(* line 669 "" *)
     WITH t^.Ag DO
(* line 669 "" *)
      
        InitIdentifyClass (Classes);
        ForallClasses (Classes, StampItems);
        StampItems (Modules);
        ExpandProps (Props);
        ExpandProps (Modules);
        IF Ignore IN Properties THEN
           ProcessIgnore (ParserCodes);
           ProcessIgnore (TreeCodes);
           ProcessIgnore (EvalCodes);
        END;
        ProcessIgnore (Decls);
        ForallClasses (Classes, ProcessIgnore);
        ProcessIgnore (Modules);
        ExpandModules (Decls);
        ExpandModules (Modules);
      IF IsElement (ORD ('c'), Options) THEN
        ArrayToString ("bool", String);
      ELSE
        ArrayToString ("BOOLEAN", String);
      END;
        Ident := MakeIdent (String);
        TypeCount := MaxIdent ();
        MakeSet (TypeNames, TypeCount);
        Include (TypeNames, Ident);
        Semantics (Classes);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Class:
(* line 696 "" *)
     WITH t^.Class DO
(* line 696 "" *)
      
        CompBaseClass (t, nNoClass);                    
        ForallClasses (t, ExpandMultiple);
        ClassCount := 0;
        MakeSet (CodesUsed, MaxIdent ());
        ForallClasses (t, CountClasses);
        ForallClasses (t, CheckReverse);
        INCL (t^.Class.Properties, Referenced);
        CompReachable (t);

      IF IsElement (ORD ('x'), Options) OR
         IsElement (ORD ('z'), Options) OR
         IsElement (ORD ('u'), Options) THEN
        TokenCode := 0;
        ForallClasses (t, CodeTerminals);
        ActionName := 0;
        i := 0;
        CompChildIndex (t, i);
        i := 0;
        CompParsIndex (t, i);
        ForallClasses (t, CheckUsage2);
      END;

        ForallClasses (t, ExpandChecks);
        ForallClasses (t, Identify);
        MakeSet (ClassNames, MaxIdent ());
        MakeSet (SelectorNames, MaxIdent ());
        MakeSet (VariantNames, MaxIdent ());
        MakeSet (PrecNames, MaxIdent ());
        CheckNames (TreeRoot^.Ag.Precs);
        ForallClasses (t, CheckNames);
        ReleaseSet (ClassNames);
        ReleaseSet (SelectorNames);
        ReleaseSet (VariantNames);
        ReleaseSet (PrecNames);
        ReleaseSet (CodesUsed);
        ForallClasses (t, CheckDesignator);
        CompBitCount (t, 1, i);
        CompBitOffset (t, 0, i);

      IF IsElement (ORD ('.'), Options) THEN            
        CompIndex (t, 0, i);
        CompInstance (t, 0, i);
        MakeSet (MaxSet, MaxInstCount);
        Complement (MaxSet);
        ForallClasses (t, InitInstance0);
        ForallClasses (t, CompDP);
      IF IsElement (ORD ('2'), Options) THEN
        WriteNl (StdOutput);
        WriteS (StdOutput, "Inherited Attribute Computation Rules"); WriteNl (StdOutput);
        WriteS (StdOutput, "-------------------------------------"); WriteNl (StdOutput);
        WriteNl (StdOutput);
      END;
        ForallClasses (t, CopyProperties);
        ForallClasses (t, CheckInherited);
      IF IsElement (ORD ('1'), Options) THEN
        WriteNl (StdOutput);
        WriteS (StdOutput, "Inserted Copy Rules"); WriteNl (StdOutput);
        WriteS (StdOutput, "-------------------"); WriteNl (StdOutput);
        WriteNl (StdOutput);
      END;
        Success := TRUE;
        ForallClasses (t, CheckComplete);
        IF Success THEN INCL (GrammarClass, cLNC); END;
        IF CopyInherited > 0 THEN
Tree.InformationI (CopyRuleInsertionsInherited, t^.Class.Pos, Errors.Integer, ADR (CopyInherited));
        END;
        IF CopySynthesized > 0 THEN
Tree.InformationI (CopyRuleInsertionsSynthesized, t^.Class.Pos, Errors.Integer, ADR (CopySynthesized));
        END;
        IF CopyThreaded > 0 THEN
Tree.InformationI (CopyRuleInsertionsThreaded, t^.Class.Pos, Errors.Integer, ADR (CopyThreaded));
        END;
        ForallClasses (t, CheckUsage);
      END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Semantics;

PROCEDURE StampItems (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Module:
(* line 778 "" *)
     WITH t^.Module DO
(* line 778 "" *)
      
        ForallClasses (Classes, StampItems);
        StampItems (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Class:
(* line 782 "" *)
     WITH t^.Class DO
(* line 782 "" *)
      
        IF Abstract IN Properties THEN
           ForallAttributes (Attributes, StampItems);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 787 "" *)
     WITH t^.Child DO
(* line 787 "" *)
      
        INC (ItemCount); Item := ItemCount;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 790 "" *)
     WITH t^.Attribute DO
(* line 790 "" *)
      
        INC (ItemCount); Item := ItemCount;
;
      RETURN;
     END (* WITH *) ;

  | Tree.ActionPart:
(* line 793 "" *)
     WITH t^.ActionPart DO
(* line 793 "" *)
      
        INC (ItemCount); Item := ItemCount;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END StampItems;

PROCEDURE ExpandProps (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Module:
(* line 800 "" *)
     WITH t^.Module DO
(* line 800 "" *)
      
        ExpandProps (Props);
        ExpandProps (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Prop:
(* line 804 "" *)
     WITH t^.Prop DO
(* line 804 "" *)
      
        ActProperties := Properties;
        ExpandProps (Names);
        ExpandProps (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Select:
(* line 809 "" *)
     WITH t^.Select DO
(* line 809 "" *)
      
        CheckSelect (Names);
        ActProperties := {Ignore};
        IF NOT LookUp (TreeRoot^.Ag.Name, Names) THEN
           TreeRoot^.Ag.Properties := TreeRoot^.Ag.Properties + ActProperties;
           ExpandProps (TreeRoot^.Ag.Decls);
           ForallClasses (TreeRoot^.Ag.Classes, ExpandProps);
        END;
        Module := TreeRoot^.Ag.Modules;
        WHILE Module^.Kind = Tree.Module DO
           IF NOT LookUp (Module^.Module.Name, Names) THEN
              Module^.Module.Properties := Module^.Module.Properties + ActProperties;
              ExpandProps (Module^.Module.Decls);
              ForallClasses (Module^.Module.Classes, ExpandProps);
           END;
           Module := Module^.Module.Next;
        END;
        ExpandProps (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Name:
(* line 828 "" *)
     WITH t^.Name DO
(* line 828 "" *)
      
        IF Name = TreeRoot^.Ag.Name THEN
           TreeRoot^.Ag.Properties := TreeRoot^.Ag.Properties + ActProperties;
           ExpandProps (TreeRoot^.Ag.Decls);
           ForallClasses (TreeRoot^.Ag.Classes, ExpandProps);
        ELSE
           Module := IdentifyModule (TreeRoot^.Ag.Modules, Name);
           IF Module = NoTree THEN
Tree.WarningI (ModuleNotDeclared, t^.Name.Pos, Errors.Ident, ADR (Name));
           ELSE
              Module^.Module.Properties := Module^.Module.Properties + ActProperties;
              ExpandProps (Module^.Module.Decls);
              ForallClasses (Module^.Module.Classes, ExpandProps);
           END;
        END;
        ExpandProps (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Decl:
(* line 845 "" *)
     WITH t^.Decl DO
(* line 845 "" *)
      
        ForallAttributes (Attributes, ExpandProps);
        ExpandProps (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Class:
(* line 849 "" *)
     WITH t^.Class DO
(* line 849 "" *)
      
        Properties := Properties + ActProperties;
        ForallAttributes (Attributes, ExpandProps);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 853 "" *)
     WITH t^.Child DO
(* line 853 "" *)
      
        Properties := Properties + ActProperties;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 856 "" *)
     WITH t^.Attribute DO
(* line 856 "" *)
      
        Properties := Properties + ActProperties;
;
      RETURN;
     END (* WITH *) ;

  | Tree.ActionPart:
(* line 859 "" *)
     WITH t^.ActionPart DO
(* line 859 "" *)
      
        Properties := Properties + ActProperties;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ExpandProps;

PROCEDURE CheckSelect (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Name) THEN
(* line 866 "" *)
     WITH t^.Name DO
(* line 866 "" *)
      
        IF NOT ((Name = TreeRoot^.Ag.Name) OR (IdentifyModule (TreeRoot^.Ag.Modules, Name) # NoTree)) THEN
Tree.WarningI (ModuleNotDeclared, t^.Name.Pos, Errors.Ident, ADR (Name));
        END;
        CheckSelect (Next);
;
      RETURN;
     END (* WITH *) ;

  END;
 END CheckSelect;

PROCEDURE ProcessIgnore (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Module:
(* line 876 "" *)
     WITH t^.Module DO
(* line 876 "" *)
      
        IF Ignore IN Properties THEN
           ProcessIgnore (ParserCodes);
           ProcessIgnore (TreeCodes);
           ProcessIgnore (EvalCodes);
        END;
        ProcessIgnore (Decls);
        ForallClasses (Classes, ProcessIgnore);
        ProcessIgnore (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Codes:
(* line 886 "" *)
     WITH t^.Codes DO
(* line 886 "" *)
      
        MakeText (Export);
        MakeText (Import);
        MakeText (Global);
        MakeText (Local);
        MakeText (Begin);
        MakeText (Close);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Decl:
(* line 894 "" *)
     WITH t^.Decl DO
(* line 894 "" *)
      
        Attributes := ProcessIgnore2 (Attributes);
        ProcessIgnore (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Class:
(* line 898 "" *)
     WITH t^.Class DO
(* line 898 "" *)
      
        Attributes := ProcessIgnore2 (Attributes);
        IF Ignore IN Properties THEN Names := nNoName; END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ProcessIgnore;

PROCEDURE ExpandModules (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Module:
(* line 906 "" *)
     WITH t^.Module DO
(* line 906 "" *)
      
        ExpandModules (Decls);
        ExpandModules (Classes);
        ExpandModules (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Decl:
(* line 911 "" *)
     WITH t^.Decl DO
(* line 911 "" *)
      
        Attribute       := Attributes;
        ActProperties   := Properties;
        ExpandModules (Names);
        ExpandModules (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Name:
(* line 917 "" *)
     WITH t^.Name DO
(* line 917 "" *)
      
        Class := IdentifyClass (TreeRoot^.Ag.Classes, Name);
        IF Class = NoTree THEN
           IF TreeRoot^.Ag.Classes^.Kind = Tree.NoClass THEN
              TreeRoot^.Ag.Classes := mClass (Name, ActProperties, CopyTree (Attribute),
                 nNoClass, TreeRoot^.Ag.Classes, Name, Pos, 0, NoIdent, nNoName);
              InitIdentifyClass2 (TreeRoot^.Ag.Classes);
           ELSE
              Node := TreeRoot^.Ag.Classes;
              WHILE Node^.Class.Next^.Kind # Tree.NoClass DO
                 Node := Node^.Class.Next;
              END;
              Node^.Class.Next := mClass (Name, ActProperties, CopyTree (Attribute),
                 nNoClass, Node^.Class.Next, Name, Pos, 0, NoIdent, nNoName);
              InitIdentifyClass2 (Node^.Class.Next);
           END;
        ELSE
           IF Class^.Class.Attributes^.Kind = Tree.NoAttribute THEN
              Class^.Class.Attributes := CopyTree (Attribute);
           ELSE
              Node := Class^.Class.Attributes;
              WHILE Node^.Attribute.Next^.Kind # Tree.NoAttribute DO
                 Node := Node^.Attribute.Next;
              END;
              Node^.Attribute.Next := CopyTree (Attribute);
           END;
        END;
        ExpandModules (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Class:
(* line 946 "" *)
     WITH t^.Class DO
(* line 946 "" *)
      
        Class := IdentifyClass (TreeRoot^.Ag.Classes, Name);
        ForallClasses (Extensions, InitIdentifyClass2);
        IF Class = NoTree THEN
           IF TreeRoot^.Ag.Classes^.Kind = Tree.NoClass THEN
              TreeRoot^.Ag.Classes := mClass (Name, Properties, Attributes, Extensions,
                 TreeRoot^.Ag.Classes, Selector, Pos, Code, Prec, Names);
              InitIdentifyClass2 (TreeRoot^.Ag.Classes);
           ELSE
              Node := TreeRoot^.Ag.Classes;
              WHILE Node^.Class.Next^.Kind # Tree.NoClass DO
                 Node := Node^.Class.Next;
              END;
              Node^.Class.Next := mClass (Name, Properties, Attributes, Extensions,
                 Node^.Class.Next, Selector, Pos, Code, Prec, Names);
              InitIdentifyClass2 (Node^.Class.Next);
           END;
        ELSE
           IF Class^.Class.Attributes^.Kind = Tree.NoAttribute THEN
              Class^.Class.Attributes := Attributes;
           ELSE
              Node := Class^.Class.Attributes;
              WHILE Node^.Attribute.Next^.Kind # Tree.NoAttribute DO
                 Node := Node^.Attribute.Next;
              END;
              Node^.Attribute.Next := Attributes;
           END;

           IF Class^.Class.Extensions^.Kind = Tree.NoClass THEN
              Class^.Class.Extensions := Extensions;
           ELSE
              Node := Class^.Class.Extensions;
              WHILE Node^.Class.Next^.Kind # Tree.NoClass DO
                 Node := Node^.Class.Next;
              END;
              Node^.Class.Next := Extensions;
           END;

           IF Class^.Class.Names^.Kind = Tree.NoName THEN
              Class^.Class.Names := Names;
           ELSE
              Node := Class^.Class.Names;
              WHILE Node^.Name.Next^.Kind # Tree.NoName DO
                 Node := Node^.Name.Next;
              END;
              Node^.Name.Next := Names;
           END;
        END;
        ExpandModules (Next);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ExpandModules;

PROCEDURE ExpandChecks (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1000 "" *)
     WITH t^.Class DO
(* line 1000 "" *)
      
        Class := t;
        ExpandChecks (Attributes);
        IF (BaseClass^.Kind = Tree.NoClass) THEN        
           Attributes := mAttribute (Attributes, iNull, iNull, {Synthesized, Computed, Dummy}, NoPosition);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1007 "" *)
     WITH t^.Child DO
(* line 1007 "" *)
      
        ExpandChecks (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 1010 "" *)
     WITH t^.Attribute DO
(* line 1010 "" *)
      
        ExpandChecks (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.ActionPart:
(* line 1013 "" *)
     WITH t^.ActionPart DO
(* line 1013 "" *)
      
        ExpandChecks (Actions);
        ExpandChecks (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Assign:
(* line 1017 "" *)
     WITH t^.Assign DO
(* line 1017 "" *)
      
        ExpandChecks (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Copy:
(* line 1020 "" *)
     WITH t^.Copy DO
(* line 1020 "" *)
      
        ExpandChecks (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TargetCode:
(* line 1023 "" *)
     WITH t^.TargetCode DO
(* line 1023 "" *)
      
        ExpandChecks (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Order:
(* line 1026 "" *)
     WITH t^.Order DO
(* line 1026 "" *)
      
        ExpandChecks (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Check:
(* line 1029 "" *)
     WITH t^.Check DO
(* line 1029 "" *)
      
        IF Results = NoTree THEN
           INC (ChecksCount);
           IntToString (ChecksCount, String);
           Ident := MakeIdent (String);
           Class^.Class.Attributes := mAttribute (Class^.Class.Attributes, Ident, Ident,
              {Test}, NoPosition);
           Results := mIdent (Ident, NoPosition, nNoDesignator);
        ELSE
           Class^.Class.Attributes := mAttribute (Class^.Class.Attributes,
              Results^.Ident.Attribute, Results^.Ident.Attribute, {Test}, NoPosition);
        END;
        ExpandChecks (Next);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ExpandChecks;

PROCEDURE ExpandMultiple2 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Child:
(* line 1047 "" *)
     WITH t^.Child DO
(* line 1047 "" *)
      
        IF NOT HasItem (TheClass, Item) THEN
           Node := mChild (NoTree, Name, Type, Properties, Pos);
           Node^.AttrOrAction.Item := Item;
           AppendAttr (TheClass^.Class.Attributes, Node);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 1054 "" *)
     WITH t^.Attribute DO
(* line 1054 "" *)
      
        IF NOT HasItem (TheClass, Item) THEN
           Node := mAttribute (NoTree, Name, Type, Properties, Pos);
           Node^.AttrOrAction.Item := Item;
           AppendAttr (TheClass^.Class.Attributes, Node);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.ActionPart:
(* line 1061 "" *)
     WITH t^.ActionPart DO
(* line 1061 "" *)
      
        IF NOT HasItem (TheClass, Item) THEN
           Node := mActionPart (NoTree, Actions);
           Node^.AttrOrAction.Item := Item;
           INCL (Node^.ActionPart.Properties, MultInhComp);
           AppendAttr (TheClass^.Class.Attributes, Node);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ExpandMultiple2;

PROCEDURE CountClasses (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1073 "" *)
     WITH t^.Class DO
(* line 1073 "" *)
      
        IF NOT (Abstract IN Properties) THEN INC (ClassCount); END;
        ChildCount      := 0;
        AttributeCount  := 0;
        ActionCount     := 0;
        Class := t;
        ForallAttributes (t, CountClasses);
        IF ChildCount     > 0 THEN INCL (t^.Class.Properties, HasChildren       ); END;
        IF AttributeCount > 0 THEN INCL (t^.Class.Properties, HasAttributes     ); END;
        IF ActionCount    > 0 THEN INCL (t^.Class.Properties, HasActions        ); END;
        IF (Terminal IN Properties) AND (Code # 0) THEN
           IF IsElement (Code, CodesUsed) THEN
Tree.ErrorI (TerminalCodeMultipleUsed, t^.Class.Pos, Errors.Integer, ADR (Code));
           END;
           Include (CodesUsed, Code);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1090 "" *)
     WITH t^.Child DO
(* line 1090 "" *)
      
        INC (ChildCount);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 1093 "" *)
     WITH t^.Attribute DO
(* line 1093 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
           Include (TypeNames, Type);
           IF (Nonterminal IN Class^.Class.Properties) OR (Name # iPosition) THEN
              INC (AttributeCount);
           END;
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.ActionPart:
(* line 1101 "" *)
     WITH t^.ActionPart DO
(* line 1101 "" *)
      
        INC (ActionCount);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END CountClasses;

PROCEDURE CompReachable (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1108 "" *)
   LOOP
     WITH t^.Class DO
(* line 1109 "" *)
      IF NOT (NOT (Reachable IN Properties)) THEN EXIT; END;
(* line 1110 "" *)
      INCL (Properties, Reachable);
(* line 1111 "" *)
      ForallAttributes (Attributes, CompReachable);
(* line 1112 "" *)
      ForallClasses (Extensions, CompReachable);
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.Child:
(* line 1114 "" *)
     WITH t^.Child DO
(* line 1114 "" *)
      
        Class := IdentifyClass (TreeRoot^.Ag.Classes, Type);
        IF Class # NoTree THEN
           INCL (Class^.Class.Properties, Referenced);
           CompReachable (Class);
        ELSE
      IF NOT IsElement (ORD ('j'), Options) THEN
Tree.WarningI (NodeTypeNotDeclared, t^.Child.Pos, Errors.Ident, ADR (Type));
      END;
           IF TreeRoot^.Ag.Classes^.Kind = Tree.NoClass THEN
              TreeRoot^.Ag.Classes := mClass (Type, {Terminal, Implicit, Reachable, Referenced},
                 nNoAttribute, nNoClass, TreeRoot^.Ag.Classes, Type, Pos, 0, NoIdent, nNoName);
              InitIdentifyClass2 (TreeRoot^.Ag.Classes);
              TreeRoot^.Ag.Classes^.Class.BaseClass := nNoClass;
              Class := TreeRoot^.Ag.Classes;
           ELSE
              Node := TreeRoot^.Ag.Classes;
              WHILE Node^.Class.Next^.Kind # Tree.NoClass DO
                 Node := Node^.Class.Next;
              END;
              Node^.Class.Next := mClass (Type, {Terminal, Implicit, Reachable, Referenced},
                 nNoAttribute, nNoClass, Node^.Class.Next, Type, Pos, 0, NoIdent, nNoName);
              InitIdentifyClass2 (Node^.Class.Next);
              Node^.Class.Next^.Class.BaseClass := nNoClass;
              Class := Node^.Class.Next;
           END;
           INC (ClassCount);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END CompReachable;

PROCEDURE CodeTerminals (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 1147 "" *)
     WITH t^.Class DO
(* line 1147 "" *)
      
        IF ({Terminal, Referenced} <= Properties) AND (Code = 0) THEN
           REPEAT INC (TokenCode); UNTIL NOT IsElement (TokenCode, CodesUsed);
           Code := TokenCode;
        END;
        IF (Terminal IN Properties) AND (BaseClass^.Kind = Tree.NoClass) THEN   
           Attributes := mAttribute (Attributes, iPosition, itPosition, {Synthesized, Computed, Input, Read}, NoPosition);
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END CodeTerminals;

PROCEDURE CheckReverse (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1160 "" *)
     WITH t^.Class DO
(* line 1160 "" *)
      
        IF Extensions^.Kind = Tree.NoClass THEN         
           ReverseCount := 0;
           ForallAttributes (t, CheckReverse);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1166 "" *)
     WITH t^.Child DO
(* line 1166 "" *)
      
         IF Reverse IN Properties THEN
            INC (ReverseCount);
            IF ReverseCount > 1 THEN
Tree.Error (OnlyOneReverseAllowedInNodeType, t^.Child.Pos);
            END;
         END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END CheckReverse;

PROCEDURE CheckNames (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1178 "" *)
     WITH t^.Class DO
(* line 1178 "" *)
      
        IF IsElement (Name, ClassNames) THEN
Tree.ErrorI (NodeTypeMultipleDeclared, t^.Class.Pos, Errors.Ident, ADR (Name));
        END;
        Include (ClassNames, Name);
        IF Terminal IN Properties THEN
           IF IsElement (Selector, VariantNames) THEN
Tree.ErrorI (VariantSelectorMultipleDeclared, t^.Class.Pos, Errors.Ident, ADR (Selector));
           END;
           Include (VariantNames, Selector);
        END;
        IF (Prec # NoIdent) AND NOT IsElement (Prec, PrecNames) THEN
Tree.ErrorI (PrecedenceNotDeclared, t^.Class.Pos, Errors.Ident, ADR (Prec));
        END;
        IF Extensions^.Kind = Tree.NoClass THEN         
           AssignEmpty (SelectorNames);
           ForallAttributes (t, CheckNames);
        END;
        CheckNames2 (Names);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1198 "" *)
     WITH t^.Child DO
(* line 1198 "" *)
      
        IF IsElement (Name, SelectorNames) THEN
           IF NOT (IsElement (ORD ('x'), Options) OR
                   IsElement (ORD ('z'), Options) OR
                   IsElement (ORD ('u'), Options)) THEN
Tree.ErrorI (SelectorMultipleDeclared, t^.Child.Pos, Errors.Ident, ADR (Name));
           END;
        END;
        Include (SelectorNames, Name);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 1208 "" *)
     WITH t^.Attribute DO
(* line 1208 "" *)
      
        IF IsElement (Name, SelectorNames) THEN
Tree.ErrorI (SelectorMultipleDeclared, t^.Attribute.Pos, Errors.Ident, ADR (Name));
        END;
        Include (SelectorNames, Name);
;
      RETURN;
     END (* WITH *) ;

  | Tree.LeftAssoc:
(* line 1214 "" *)
     WITH t^.LeftAssoc DO
(* line 1214 "" *)
      
        CheckNames (Names);
        CheckNames (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.RightAssoc:
(* line 1218 "" *)
     WITH t^.RightAssoc DO
(* line 1218 "" *)
      
        CheckNames (Names);
        CheckNames (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.NonAssoc:
(* line 1222 "" *)
     WITH t^.NonAssoc DO
(* line 1222 "" *)
      
        CheckNames (Names);
        CheckNames (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Name:
(* line 1226 "" *)
     WITH t^.Name DO
(* line 1226 "" *)
      
        IF IsElement (Name, PrecNames) THEN
Tree.ErrorI (PrecedenceMultipleDeclared, t^.Name.Pos, Errors.Ident, ADR (Name));
        END;
        Include (PrecNames, Name);
        CheckNames (Next);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END CheckNames;

PROCEDURE CheckNames2 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Name) THEN
(* line 1237 "" *)
     WITH t^.Name DO
(* line 1237 "" *)
      
        Class := IdentifyClass (TreeRoot^.Ag.Classes, Name);
        IF Class = NoTree THEN
Tree.ErrorI (NodeTypeNotDeclared, t^.Name.Pos, Errors.Ident, ADR (Name));
        ELSE
           IF NOT (Abstract IN Class^.Class.Properties) THEN
Tree.Error (AbstractTypeRequired, t^.Name.Pos);
           END;
        END;
        CheckNames2 (Next);
;
      RETURN;
     END (* WITH *) ;

  END;
 END CheckNames2;

PROCEDURE CheckDesignator (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1252 "" *)
     WITH t^.Class DO
(* line 1252 "" *)
      
        Class := t;
        ForallAttributes (Attributes, CheckDesignator);
;
      RETURN;
     END (* WITH *) ;

  | Tree.ActionPart:
(* line 1256 "" *)
     WITH t^.ActionPart DO
(* line 1256 "" *)
      
        CheckDesignator (Actions);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Assign:
(* line 1259 "" *)
     WITH t^.Assign DO
(* line 1259 "" *)
      
        CheckDesignator (Results);
        CheckDesignator (Arguments);
        CheckDesignator (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Copy:
(* line 1264 "" *)
     WITH t^.Copy DO
(* line 1264 "" *)
      
        CheckDesignator (Results);
        CheckDesignator (Arguments);
        CheckDesignator (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.TargetCode:
(* line 1269 "" *)
     WITH t^.TargetCode DO
(* line 1269 "" *)
      
        CheckDesignator (Code);
        CheckDesignator (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Check:
(* line 1273 "" *)
     WITH t^.Check DO
(* line 1273 "" *)
      
        CheckDesignator (Statement);
        CheckDesignator (Condition);
        CheckDesignator (Actions);
        CheckDesignator (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Designator:
(* line 1279 "" *)
     WITH t^.Designator DO
(* line 1279 "" *)
      
        Node := IdentifyAttribute (Class, Selector);
        IF Node # NoTree THEN
           IF Node^.Kind # Tree.Child THEN
Tree.Error (ChildRequired, t^.Designator.Pos);
           ELSE
              IF Node^.Child.Class # NoTree THEN
                 Node := IdentifyAttribute (Node^.Child.Class, Attribute);
                 IF Node = NoTree THEN
Tree.ErrorI (AttributeNotDeclared, t^.Designator.Pos, Errors.Ident, ADR (Attribute));
                 END;
              END;
           END;
        ELSE
Tree.ErrorI (SelectorNotDeclared, t^.Designator.Pos, Errors.Ident, ADR (Selector));
        END;
        CheckDesignator (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Remote:
(* line 1297 "" *)
     WITH t^.Remote DO
(* line 1297 "" *)
      
   Node := IdentifyClass (TreeRoot^.Ag.Classes, Type);
   IF Node = NoTree THEN
Tree.ErrorI (NodeTypeNotDeclared, t^.Remote.Pos, Errors.Ident, ADR (Type));
   ELSE
      Node := IdentifyAttribute (Node, Attribute);
      IF Node = NoTree THEN
Tree.ErrorI (AttributeNotDeclared, t^.Remote.Pos, Errors.Ident, ADR (Attribute));
      END;
   END;
;
(* line 1308 "" *)
      CheckDesignator (Designators);
(* line 1309 "" *)
      CheckDesignator (Next);
      RETURN;
     END (* WITH *) ;

  | Tree.Order:
(* line 1311 "" *)
     WITH t^.Order DO
(* line 1315 "" *)
      CheckDesignator (Next);
      RETURN;
     END (* WITH *) ;

  | Tree.Ident:
(* line 1311 "" *)
     WITH t^.Ident DO
(* line 1315 "" *)
      CheckDesignator (Next);
      RETURN;
     END (* WITH *) ;

  | Tree.Any:
(* line 1311 "" *)
     WITH t^.Any DO
(* line 1315 "" *)
      CheckDesignator (Next);
      RETURN;
     END (* WITH *) ;

  | Tree.Anys:
(* line 1311 "" *)
     WITH t^.Anys DO
(* line 1315 "" *)
      CheckDesignator (Next);
      RETURN;
     END (* WITH *) ;

  | Tree.LayoutAny:
(* line 1311 "" *)
     WITH t^.LayoutAny DO
(* line 1315 "" *)
      CheckDesignator (Next);
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END CheckDesignator;

PROCEDURE Identify (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1322 "" *)
     WITH t^.Class DO
(* line 1322 "" *)
      
        ForallAttributes (t, Identify);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1325 "" *)
     WITH t^.Child DO
(* line 1325 "" *)
      
        Class := IdentifyClass (TreeRoot^.Ag.Classes, Type);
        IF (Class = NoTree) AND NOT IsElement (ORD ('x'), Options) AND
                                NOT IsElement (ORD ('z'), Options) AND
                                NOT IsElement (ORD ('u'), Options) THEN
Tree.ErrorI (NodeTypeNotDeclared, t^.Child.Pos, Errors.Ident, ADR (Type));
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Identify;

PROCEDURE InitInstance0 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 1337 "" *)
     WITH t^.Class DO
(* line 1337 "" *)
      
        InstanceSize := InstCount;
        MakeArray (Instance, InstanceSize, TSIZE (tInstance));
        InitInstance (t, AttrCount, Instance);
;
      RETURN;
     END (* WITH *) ;

  END;
 END InitInstance0;

PROCEDURE CompDP (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 1346 "" *)
     WITH t^.Class DO
(* line 1346 "" *)
      
        MakeRelation (DP, InstCount, InstCount);
        relation := DP;
        MakeSet (Results  , InstCount);
        MakeSet (Arguments, InstCount);
        Class := t;
        Attribute := IdentifyAttribute (t, iNull);
        DummyIndex := Attribute^.Attribute.AttrIndex;
        INCL (Instance^[DummyIndex].Properties, Left);
        CompDP1 (t, Results, Write, TRUE, TRUE);
        ReleaseSet (Results  );
        ReleaseSet (Arguments);
;
      RETURN;
     END (* WITH *) ;

  END;
 END CompDP;

PROCEDURE CopyProperties (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 1363 "" *)
     WITH t^.Class DO
(* line 1363 "" *)
      
        FOR i := 1 TO InstCount DO
           WITH Instance^[i] DO
              Properties := Properties + Attribute^.Child.Properties;
              IF (Action # ADR (Action)) AND (Action^.Kind = Tree.Copy) THEN
                 INCL (Properties, CopyDef);
                 INCL (Instance^[CopyArg].Properties, CopyUse);
              END;
      IF IsElement (ORD ('2'), Options) THEN
              IF NOT (NonBaseComp IN Properties) AND (Action # ADR (Action)) AND
                 (({Synthesized, Left} <= Properties) OR
                 ({Inherited, Right} <= Properties)) THEN
                 WriteIdent     (StdOutput, Name);
                 WriteS         (StdOutput, "   = { ");
                 WriteClass     (Action);
                 WriteS         (StdOutput, " } .");
                 WriteNl        (StdOutput);
              END;
      END;
           END;
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END CopyProperties;

PROCEDURE CheckUsage (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1389 "" *)
     WITH t^.Class DO
(* line 1389 "" *)
      
        IF Extensions^.Kind = Tree.NoClass THEN         
           Class := t;
           IsAbstract := Abstract IN Properties;
           ForallAttributes (t, CheckUsage);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1396 "" *)
     WITH t^.Child DO
(* line 1396 "" *)
      
      IF NOT IsElement (ORD ('W'), Options) AND NOT IsAbstract THEN
        IF NOT (Input IN Properties) AND NOT (Write IN Properties) THEN
Tree.WarningI (AttributeNeverSet, t^.Child.Pos, Errors.Ident, ADR (Name));
        END;
        IF NOT (Output IN Properties) AND NOT (Read IN Properties) AND
           NOT IsElement (ORD ('x'), Options) AND
           NOT IsElement (ORD ('z'), Options) AND
           NOT IsElement (ORD ('u'), Options) THEN
Tree.WarningI (AttributeNeverUsed, t^.Child.Pos, Errors.Ident, ADR (Name));
        END;
      END;
        IF ({Input, Write} <= Properties) AND ((Class = NoTree) OR
           (Class # NoTree) AND NOT (Terminal IN Class^.Class.Properties)) THEN
Tree.ErrorI (AssignmentToInputAttribute, t^.Child.Pos, Errors.Ident, ADR (Name));
        END;
        IF {Synthesized, Inherited} <= Properties THEN
Tree.ErrorI (AttributeSynthesizedAsWellAsInherited, t^.Child.Pos, Errors.Ident, ADR (Name));
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 1416 "" *)
   LOOP
     WITH t^.Attribute DO
(* line 1417 "" *)
      IF NOT (({Test, Dummy} * Properties) = {}) THEN EXIT; END;
(* line 1418 "" *)
           IF NOT IsElement (ORD ('W'), Options) AND NOT IsAbstract THEN
        IF NOT (Input IN Properties) AND NOT (Write IN Properties) THEN
Tree.WarningI (AttributeNeverSet, t^.Attribute.Pos, Errors.Ident, ADR (Name));
        END;
        IF NOT (Output IN Properties) AND NOT (Read IN Properties) THEN
Tree.WarningI (AttributeNeverUsed, t^.Attribute.Pos, Errors.Ident, ADR (Name));
        END;
      END;
        IF ({Input, Write} <= Properties) AND ((Class = NoTree) OR
           (Class # NoTree) AND NOT (Terminal IN Class^.Class.Properties)) THEN
Tree.ErrorI (AssignmentToInputAttribute, t^.Attribute.Pos, Errors.Ident, ADR (Name));
        END;
        IF {Synthesized, Inherited} <= Properties THEN
Tree.ErrorI (AttributeSynthesizedAsWellAsInherited, t^.Attribute.Pos, Errors.Ident, ADR (Name));
        END;
;
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  ELSE END;

 END CheckUsage;

PROCEDURE CheckUsage2 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 1: yyR1: RECORD
  String: tString;
  END;
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 1438 "" *)
    WITH yyTempo.yyR1 DO  
   LOOP
     WITH t^.Class DO
(* line 1439 "" *)
      IF NOT (NOT IsElement (ORD ('W'), Options)) THEN EXIT; END;
(* line 1440 "" *)
      IF NOT (NOT (Reachable IN Properties)) THEN EXIT; END;
(* line 1441 "" *)
      ;
(* line 1442 "" *)
      GetString (Name, String);
(* line 1443 "" *)
      IF NOT ((Char (String, 1) # 'y') AND (Char (String, 2) # 'y')) THEN EXIT; END;
(* line 1444 "" *)
      Tree . WarningI (NodeTypeNotUsed, t ^ . Class . Pos, Errors . Ident, ADR (Name));
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  END;
 END CheckUsage2;

PROCEDURE CheckInherited (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1450 "" *)
     WITH t^.Class DO
(* line 1450 "" *)
      
        IF BaseClass^.Kind = Tree.Class THEN            
           CheckInherited (Attributes);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1455 "" *)
     WITH t^.Child DO
(* line 1455 "" *)
      
        IF Inherited IN Properties THEN
Tree.ErrorI (InheritedAttributesAllowedOnlyInBaseClasses, t^.Child.Pos, Errors.Ident, ADR (Name));
        END;
        CheckInherited (Next);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 1461 "" *)
     WITH t^.Attribute DO
(* line 1461 "" *)
      
        IF Inherited IN Properties THEN
Tree.ErrorI (InheritedAttributesAllowedOnlyInBaseClasses, t^.Attribute.Pos, Errors.Ident, ADR (Name));
        END;
        CheckInherited (Next);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END CheckInherited;

PROCEDURE CheckComplete (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 1471 "" *)
     WITH t^.Class DO
(* line 1471 "" *)
      
        IF (Extensions^.Kind = Tree.NoClass) OR         
           NOT IsElement (ORD ('B'), Options) THEN
           FOR i := 1 TO InstCount DO
              WITH Instance^ [i] DO
                 IF ( { Input , Computed } * Properties = { } )  AND
                    ((Terminal IN t^.Class.Properties) AND 
                     (Attribute^.Kind = Tree.Attribute) OR
                    ({Synthesized, Left} <= Properties) OR
                    ({Inherited,  Right} <= Properties)) THEN
                    CopyRule (t);
                    IF j = 0 THEN
                       GetString (Name, String);
                       ArrayToString (" = ", String2);
                       Concatenate (String, String2);
                       IF Right IN Properties THEN
                          GetString (Selector^.Child.Name, String2);
                          Concatenate (String, String2);
                          Append    (String, ':');
                          GetString (Attribute^.Child.Name, String2);
                          Concatenate (String, String2);
                       ELSE
                          GetString (Attribute^.Child.Name, String2);
                          Concatenate (String, String2);
                       END;
Tree.ErrorI (AttributeComputationMissing, t^.Class.Pos, Errors.String, ADR (String));
                    END;
                 END;
              END;
           END;
        END;

      IF IsElement (ORD ('L'), Options) THEN
        FOR i := 1 TO AttrCount DO
           WITH Instance^ [i] DO
              IF NOT (Input IN Properties) AND (Attribute^.Kind = Tree.Child) THEN
                 FOR j := 1 TO InstCount DO
                    IF IsRelated (j, i, DP) THEN
                       FOR k := 1 TO AttrCount DO
                          IF IsRelated (k, j, DP) THEN
                             Relations.Include (DP, k, i);
                          END;
                       END;
                    END;
                 END;
              END;
           END;
        END;
      END;

        IF IsCyclic (DP) THEN
Tree.ErrorI (CycleInLocalDependenciesDP, t^.Class.Pos, Errors.Ident, ADR (Name));
           WriteS (StdOutput, "Attribute Dependencies DP");
           WriteNl (StdOutput); WriteNl (StdOutput);
           WriteDependencies (t, DP, MaxSet);
           WriteS (StdOutput, "Cyclic Attributes");
           WriteNl (StdOutput); WriteNl (StdOutput);
           MakeSet (Cyclics, InstCount);
           GetCyclics (DP, Cyclics);
           WriteCyclics (t, Cyclics); WriteNl (StdOutput);
           ReleaseSet (Cyclics);
           Success := FALSE;
        END;
      IF IsElement (ORD ('M'), Options) THEN
        WriteClass (t); WriteNl (StdOutput);
      END;
      IF IsElement (ORD ('P'), Options) THEN
        WriteDependencies (t, DP, MaxSet);
      END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END CheckComplete;

PROCEDURE CopyRule (t: Tree.tTree);
(* line 1552 "" *)
 VAR LLastParsIndex : SHORTCARD ; 
          VAR LNewNode : tTree ; 
        

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1556 "" *)
     WITH t^.Class DO
(* line 1556 "" *)
      
        WITH Instance^ [i] DO
           j := 0;
           IF i <= AttrCount THEN  
              Ident := Attribute^.Attribute.Name;
              ForallAttributes (t, CopyRule2);
               
              IF j # 0 THEN  
                 INC (j, AttrCount + Child^.Child.InstOffset);
                 Action := mCopy (nNoAction, NoPosition,
                    mIdent (Ident, NoPosition, nNoDesignator),
                    mDesignator 
                      ( Instance ^[j].Selector^.Child.Name, Ident
                      , NoPosition, NoPosition, nNoDesignator)
                      ) ;
                 INC (CopySynthesized);
              END;
              IF (j = 0) AND (Thread IN Properties) THEN
                  
                 j := i - 1;  
                 Action := mCopy (nNoAction, NoPosition,
                    mIdent (Ident, NoPosition, nNoDesignator),
                    mIdent (Instance^ [j].Attribute^.Attribute.Name, NoPosition, nNoDesignator));
                 INC (CopyThreaded);
              END;
           ELSE  
              IF (Thread IN Properties) AND (Selector^.Child.InstOffset > 0) THEN
                 Ident := Instance^ [i+1].Attribute^.Attribute.Name;    
                          
                 j := i - 1;  
                 LOOP
                    IF j <= AttrCount 
                    THEN  
                      j := 0; EXIT; 
                    END;
                    IF NOT ( Link IN Instance^ [j].Selector^.Child.Properties ) 
                    AND ( Instance^ [j].Attribute^.Attribute.Name = Ident ) 
                    THEN
                       Action := mCopy (nNoAction, NoPosition,
                          mDesignator 
                            ( Selector^.Child.Name
                            , Attribute^.Attribute.Name
                            , NoPosition, NoPosition, nNoDesignator
                            ) ,
                          mDesignator 
                            ( Instance^ [j].Selector^.Child.Name
                            , Ident, NoPosition, NoPosition, nNoDesignator)
                            ) ;
                       INC (CopyThreaded);
                       EXIT;
                    END;
                    DEC (j);
                 END  ;
              END  ;
              IF j = 0 THEN
                 Ident := Attribute^.Attribute.Name;
                 ForallAttributes (t, CopyRule);
                 IF j # 0 THEN  
                    Action := mCopy (nNoAction, NoPosition,
                       mDesignator 
                         ( Selector^.Child.Name, Ident
                         , NoPosition, NoPosition, nNoDesignator
                         ) ,
                       mIdent (Ident, NoPosition, nNoDesignator));
                    INC (CopyInherited);
                 END;
              END;
           END;
           IF j # 0 THEN
              IF IsElement (ORD ('1'), Options) THEN
                      WriteIdent (StdOutput, Name);
                      WriteS     (StdOutput, "  = { ");
                      WriteClass (Action);
                      WriteS     (StdOutput, " } .");
                      WriteNl    (StdOutput);
              END;
              CopyArg := j;
              TheAction := Action;
              Relations.Include (DP, i, j);
              INCL (Properties, CopyDef);
              INCL (Instance^[CopyArg].Properties, CopyUse);
              INCL (Properties, Write);
              INCL (Properties, Computed);
              INCL (Instance^[CopyArg].Properties, Read);
              INCL (Attribute^.Attribute.Properties, Write);
              INCL (Attribute^.Attribute.Properties, Computed);
              INCL (Instance^[CopyArg].Attribute^.Attribute.Properties, Read);
              IF Right IN Properties THEN
                 INCL (Selector^.Child.Properties, Read);
              END;
              IF Right IN Instance^[CopyArg].Properties THEN
                 INCL (Instance^[CopyArg].Selector^.Child.Properties, Read);
              END;
           END;
        END;
        IF j # 0 THEN                           
           INCL (Properties, HasActions);
           IF Attributes^.Kind = Tree.NoAttribute THEN
              Attributes := mActionPart (Attributes, TheAction);
              Attributes^.ActionPart.ParsIndex := 1 ; 
              INC ( ActionName ) ; 
              Attributes^.ActionPart.Name := ActionName ; 
           ELSE
              Node := Attributes;
              LLastParsIndex := 0 ; 
              LOOP 
                CASE Node^.Kind 
                OF Tree.Child 
                  : LLastParsIndex := Node^.Child.ParsIndex 
                | Tree.ActionPart 
                  : LLastParsIndex := Node^.ActionPart.ParsIndex 
                ELSE 
                END  
              ; IF Node^.AttrOrAction.Next^.Kind = Tree.NoAttribute 
                THEN EXIT ; 
                ELSE 
                  Node := Node^.AttrOrAction.Next;
                END  
              END  ;
              LNewNode := mActionPart (nNoAttribute, TheAction);
              Node^.AttrOrAction.Next := LNewNode ; 
              LNewNode^.ActionPart.ParsIndex := LLastParsIndex + 1 ;
              INC ( ActionName ) ; 
              LNewNode^.ActionPart.Name := ActionName ;  
           END;
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1685 "" *)
     WITH t^.Child DO
(* line 1685 "" *)
      
        IF Name = Ident THEN Child := Attribute; j := AttrIndex; END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 1688 "" *)
     WITH t^.Attribute DO
(* line 1688 "" *)
      
        IF Name = Ident THEN Child := Attribute; j := AttrIndex; END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END CopyRule;

PROCEDURE CopyRule2 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Child) THEN
(* line 1695 "" *)
   LOOP
     WITH t^.Child DO
(* line 1696 "" *)
      IF NOT (Class # NoTree) THEN EXIT; END;
(* line 1697 "" *)
      IF NOT (NOT (Link IN Properties)) THEN EXIT; END;
(* line 1698 "" *)
      Attribute := t;
(* line 1699 "" *)
      ForallAttributes (Class, CopyRule);
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
 END CopyRule2;

PROCEDURE IsCopy (yyP1: Tree.tTree): BOOLEAN;

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 1: yyR1: RECORD
  Attr: tTree;
  ChildsClass: tTree;
  END;
 END; END;
 BEGIN
  IF yyP1 = Tree.NoTree THEN RETURN FALSE; END;

  CASE yyP1^.Kind OF
  | Tree.Designator:
(* line 1704 "" *)
    WITH yyTempo.yyR1 DO  
   LOOP
     WITH yyP1^.Designator DO
(* line 1705 "" *)
      ;
(* line 1706 "" *)
      ;
(* line 1707 "" *)
      Attr := IdentifyAttribute (Class, Selector);
(* line 1708 "" *)
      IF NOT (Attr # NoTree) THEN EXIT; END;
(* line 1709 "" *)
      IF NOT (Attr ^ . Kind = Tree . Child) THEN EXIT; END;
(* line 1710 "" *)
      ChildsClass := Attr ^ . Child . Class;
(* line 1711 "" *)
      IF NOT (ChildsClass # NoTree) THEN EXIT; END;
(* line 1712 "" *)
      IF NOT (IdentifyAttribute (ChildsClass, Attribute) # NoTree) THEN EXIT; END;
(* line 1713 "" *)
      IF NOT (IsWhiteSpace (Next)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  | Tree.Ident:
(* line 1715 "" *)
   LOOP
     WITH yyP1^.Ident DO
(* line 1716 "" *)
      IF NOT (IdentifyAttribute (Class, Attribute) # NoTree) THEN EXIT; END;
(* line 1717 "" *)
      IF NOT (IsWhiteSpace (Next)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.Any:
(* line 1719 "" *)
   LOOP
     WITH yyP1^.Any DO
(* line 1720 "" *)
      IF NOT (IsWhiteSpace2 (Code)) THEN EXIT; END;
(* line 1721 "" *)
      IF NOT (IsCopy (Next)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.Anys:
(* line 1723 "" *)
   LOOP
     WITH yyP1^.Anys DO
(* line 1724 "" *)
      IF NOT (IsCopy (Next)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  ELSE END;

  RETURN FALSE;
 END IsCopy;

PROCEDURE IsWhiteSpace (yyP2: Tree.tTree): BOOLEAN;

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF yyP2 = Tree.NoTree THEN RETURN FALSE; END;

  CASE yyP2^.Kind OF
  | Tree.Any:
(* line 1729 "" *)
   LOOP
     WITH yyP2^.Any DO
(* line 1730 "" *)
      IF NOT (IsWhiteSpace2 (Code)) THEN EXIT; END;
(* line 1731 "" *)
      IF NOT (IsWhiteSpace (Next)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.Anys:
(* line 1733 "" *)
   LOOP
     WITH yyP2^.Anys DO
(* line 1734 "" *)
      IF NOT (IsWhiteSpace (Next)) THEN EXIT; END;
      RETURN TRUE;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.NoDesignator:
(* line 1736 "" *)
      RETURN TRUE;

  ELSE END;

  RETURN FALSE;
 END IsWhiteSpace;

PROCEDURE IsWhiteSpace2 (yyP3: tStringRef): BOOLEAN;
(* line 1739 "" *)
 VAR i: CARDINAL; 

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 1: yyR1: RECORD
  String: tString;
  ch: CHAR;
  END;
 END; END;
 BEGIN
(* line 1741 "" *)
    WITH yyTempo.yyR1 DO  
(* line 1742 "" *)
      ;
(* line 1743 "" *)
      ;
(* line 1744 "" *)
      StringMem . GetString (yyP3, String);
(* line 1745 "" *)
        FOR i := 1 TO Length (String) DO
      ch := Char (String, i);
      IF (ch # ' ') AND (ch # 012C) AND (ch # 011C) THEN RETURN FALSE; END;
   END;
;
      RETURN TRUE;
    END (* WITH yyTempos.yyR ... *) ;  

 END IsWhiteSpace2;

PROCEDURE BeginSemantics;
 BEGIN
(* line 657 "" *)

   ItemCount            := 0;
   ChecksCount          := 0;
   MaxInstCount         := 0;
   CopyInherited        := 0;
   CopySynthesized      := 0;
   CopyThreaded         := 0;
   IntToString (0, String); iNull := MakeIdent (String);


 END BeginSemantics;

PROCEDURE CloseSemantics;
 BEGIN

 END CloseSemantics;

PROCEDURE yyExit;
 BEGIN
  IO.CloseIO; System.Exit (1);
 END yyExit;

BEGIN
 yyf   := IO.StdOutput;
 Exit  := yyExit;
 BeginSemantics;
END Semantics.

