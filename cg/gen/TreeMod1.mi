
(* This file was mechanically generated by puma. *)

IMPLEMENTATION MODULE TreeMod1;








IMPORT SYSTEM, System, IO, Tree;
(* line 24 "" *)


FROM General    IMPORT Max;
FROM IO         IMPORT WriteS, WriteNl;
FROM Idents     IMPORT tIdent;
FROM Texts      IMPORT WriteText;
FROM Sets       IMPORT IsElement, Include;
FROM TreeMod2   IMPORT TreeIO, GetIterator, Iterator, WriteLine;
FROM IOUtils    IMPORT WriteBackslash ; 

FROM Tree       IMPORT
   NoTree       , tTree         , Input         , Reverse       ,
   Class        , Child         , Attribute     , Abstract      ,
   HasChildren  , HasAttributes , NoCodeAttr    , NoCodeClass   ,
   Options      , TreeRoot      , ClassCount    , iNoTree       ,
   itTree       , iMain         , iModule       , f             ,
   WI   , WN    , ForallClasses , ForallAttributes, Ignore      ,
   Test         , Dummy         , ForallClassesPreAndPost       , 
   Link         ;

IMPORT Strings;

VAR
   ConstCount   ,
   ListCount    : INTEGER;
   iRange       ,
   iClassName   : tIdent;
   Node         : tTree;
   gBitCount    : SHORTCARD;
   i, MaxBit    : SHORTCARD;






































































































PROCEDURE yyAbort (yyFunction: ARRAY OF CHAR);
 BEGIN
  IO.WriteS (IO.StdError, 'Error: module TreeMod1, routine ');
  IO.WriteS (IO.StdError, yyFunction);
  IO.WriteS (IO.StdError, ' failed');
  IO.WriteNl (IO.StdError);
  Exit;
 END yyAbort;

PROCEDURE yyIsEqual (yya, yyb: ARRAY OF SYSTEM.BYTE): BOOLEAN;
 VAR yyi       : INTEGER;
 BEGIN
  FOR yyi := 0 TO INTEGER (HIGH (yya)) DO
   IF yya [yyi] # yyb [yyi] THEN RETURN FALSE; END;
  END;
  RETURN TRUE;
 END yyIsEqual;

PROCEDURE TreeDefMod (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Ag) THEN
(* line 60 "" *)
     WITH t^.Ag DO
(* line 60 "" *)
      
        WriteS (f, "DEFINITION MODULE "); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
      IF IsElement (ORD ('<'), Options) THEN
        WriteS (f, "FROM "); WI (iMain); WriteS (f, " IMPORT "); WI (itTree); WriteS (f, ", tProcTree;"); WriteNl (f);
      END;
        WriteS (f, "IMPORT SYSTEM, IO;"); WriteNl (f);
        WriteLine (TreeCodes^.Codes.ImportLine);
        WriteText (f, TreeCodes^.Codes.Import);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.ImportLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Import);
           Node := Node^.Module.Next;
        END;
        WriteNl (f);
      IF NOT IsElement (ORD ('<'), Options) THEN
        WriteS (f, "CONST"); WriteNl (f);
        WI (iNoTree); WriteS (f, " = NIL;"); WriteNl (f);
        WriteNl (f);
        
        ForallClassesPreAndPost (Classes, ConstDeclsPre, ConstDeclsPost);
        
        WriteNl (f);
        WriteS (f, "TYPE "); WI (itTree); WriteS (f, " = POINTER TO yyNode;"); WriteNl (f);
        
        IF IsElement (ORD ('^'), Options) THEN
 
          ForallClasses ( Classes, PointerTypes);
        END;
        
        WriteS (f, "tProcTree = PROCEDURE ("); WI (itTree); WriteS (f, ");"); WriteNl (f);
      END;
        WriteLine (TreeCodes^.Codes.ExportLine);
        WriteText (f, TreeCodes^.Codes.Export);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.ExportLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Export);
           Node := Node^.Module.Next;
        END;
        WriteNl (f);
      IF NOT IsElement (ORD ('<'), Options) THEN
        WriteS (f, "# ifndef yyNodeHead"); WriteNl (f);
        WriteS (f, "# define yyNodeHead"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "TYPE"); WriteNl (f);
      IF IsElement (ORD ('L'), Options) THEN
        MaxBit := 0;
        ForallClasses (Classes, CompMaxBit);
        WriteS (f, "yytNodeHead = RECORD yyKind, yyMark, yyOffset: SHORTCARD; yyParent: "); WI (itTree); WriteS (f, "; yyIsComp0"); 
      IF IsElement (ORD ('5'), Options) THEN
        WriteS (f, ", yyIsDone0"); 
      END;
        FOR i := 1 TO (MaxBit - 1) DIV BSS DO
           WriteS (f, ", yyIsComp"); WN (i);
      IF IsElement (ORD ('5'), Options) THEN
           WriteS (f, ", yyIsDone"); WN (i);
      END;
        END;
        WriteS (f, ": BITSET; yyNodeHead END;"); WriteNl (f);
      ELSE
        WriteS (f, "yytNodeHead = RECORD yyKind, yyMark: SHORTCARD; yyNodeHead END;"); WriteNl (f);
      END;
        ForallClasses (Classes, TypeDeclNode);
        WriteNl (f);
        WriteS (f, "yyNode = RECORD"); WriteNl (f);
        WriteS (f, "CASE : SHORTCARD OF"); WriteNl (f);
        WriteS (f, "| 0: Kind: SHORTCARD;"); WriteNl (f);
        WriteS (f, "| "); WN (ClassCount + 1); WriteS (f, ": yyHead: yytNodeHead;"); WriteNl (f);
        ForallClasses (Classes, TypeDeclRecord);
        WriteS (f, "END;"); WriteNl (f);
        WriteS (f, "END;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "VAR "); WI (iMain); WriteS (f, "Root        : "); WI (itTree); WriteS (f, ";"); WriteNl (f);
        WriteS (f, "VAR HeapUsed   : LONGCARD;"); WriteNl (f);
        WriteS (f, "VAR yyPoolFreePtr, yyPoolMaxPtr        : SYSTEM.ADDRESS;"); WriteNl (f);
        WriteS (f, "VAR yyNodeSize : ARRAY [0.."); WN (ClassCount); WriteS (f, "] OF SHORTCARD;"); WriteNl (f);
        WriteS (f, "VAR yyExit     : PROC;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyAlloc      (): "); WI (itTree); WriteS (f, ";"); WriteNl (f);
        WriteS (f, "PROCEDURE Make"); WI (iMain); WriteS (f, "  (Kind: SHORTCARD): "); WI (itTree); WriteS (f, ";"); WriteNl (f);
        WriteS (f, "PROCEDURE IsType       (Tree: "); WI (itTree); WriteS (f, "; Kind: SHORTCARD): BOOLEAN;"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('n'), Options) THEN
        ForallClasses (Classes, ProcedureDeclsn);
        WriteNl (f);
      END;
      IF IsElement (ORD ('m'), Options) THEN
        ForallClasses (Classes, ProcedureHeadingm);
        WriteNl (f);
      END;
      IF IsElement (ORD ('f'), Options) THEN
        WriteS (f, "PROCEDURE Release"); WI (iModule); WriteS (f, "     (Tree: "); WI (itTree); WriteS (f, ");"); WriteNl (f);
      END;
      IF IsElement (ORD ('F'), Options) AND NOT IsElement (ORD ('<'), Options) THEN
        WriteS (f, "PROCEDURE Release"); WI (iModule); WriteS (f, "Module;"); WriteNl (f);
      END;
      IF IsElement (ORD ('o'), Options) THEN
        WriteS (f, "PROCEDURE Write"); WI (iModule); WriteS (f, "Node   (f: IO.tFile; Tree: "); WI (itTree); WriteS (f, ");"); WriteNl (f);
      END;
      IF IsElement (ORD ('w'), Options) THEN
        WriteS (f, "PROCEDURE Write"); WI (iModule); WriteS (f, "       (f: IO.tFile; Tree: "); WI (itTree); WriteS (f, ");"); WriteNl (f);
      END;
      IF IsElement (ORD ('r'), Options) THEN
        WriteS (f, "PROCEDURE Read"); WI (iModule); WriteS (f, "        (f: IO.tFile): "); WI (itTree); WriteS (f, ";"); WriteNl (f);
      END;
      IF IsElement (ORD ('p'), Options) THEN
        WriteS (f, "PROCEDURE Put"); WI (iModule); WriteS (f, " (f: IO.tFile; Tree: "); WI (itTree); WriteS (f, ");"); WriteNl (f);
      END;
      IF IsElement (ORD ('g'), Options) THEN
        WriteS (f, "PROCEDURE Get"); WI (iModule); WriteS (f, " (f: IO.tFile): "); WI (itTree); WriteS (f, ";"); WriteNl (f);
      END;
      IF IsElement (ORD ('t'), Options) THEN
        WriteS (f, "PROCEDURE Traverse"); WI (iModule); WriteS (f, "TD  (Tree: "); WI (itTree); WriteS (f, "; Proc: tProcTree);"); WriteNl (f);
      END;
      IF IsElement (ORD ('b'), Options) THEN
        WriteS (f, "PROCEDURE Traverse"); WI (iModule); WriteS (f, "BU  (Tree: "); WI (itTree); WriteS (f, "; Proc: tProcTree);"); WriteNl (f);
      END;
      IF IsElement (ORD ('R'), Options) THEN
        WriteS (f, "PROCEDURE Reverse"); WI (iModule); WriteS (f, "     (Tree: "); WI (itTree); WriteS (f, "): "); WI (itTree); WriteS (f, ";"); WriteNl (f);
      END;
      IF IsElement (ORD ('y'), Options) THEN
        WriteS (f, "PROCEDURE Copy"); WI (iModule); WriteS (f, "        (Tree: "); WI (itTree); WriteS (f, "): "); WI (itTree); WriteS (f, ";"); WriteNl (f);
      END;
      IF IsElement (ORD ('k'), Options) THEN
        WriteS (f, "PROCEDURE Check"); WI (iModule); WriteS (f, "       (Tree: "); WI (itTree); WriteS (f, "): BOOLEAN;"); WriteNl (f);
      END;
      IF IsElement (ORD ('q'), Options) THEN
        WriteS (f, "PROCEDURE Query"); WI (iModule); WriteS (f, "       (Tree: "); WI (itTree); WriteS (f, ");"); WriteNl (f);
      END;
      IF IsElement (ORD ('='), Options) THEN
        WriteS (f, "PROCEDURE IsEqual"); WI (iModule); WriteS (f, "     (Tree1, Tree2: "); WI (itTree); WriteS (f, "): BOOLEAN;"); WriteNl (f);
      END;
      IF IsElement (ORD ('L'), Options) THEN
        WriteS (f, "PROCEDURE Init"); WI (iModule); WriteS (f, "        (Tree: "); WI (itTree); WriteS (f, ");"); WriteNl (f);
      END;
        WriteS (f, "PROCEDURE Begin"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteS (f, "PROCEDURE Close"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "END "); WI (iModule); WriteS (f, "."); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  END;
 END TreeDefMod;

PROCEDURE ConstDeclsPre (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 208 "" *)
     WITH t^.Class DO
(* line 208 "" *)
      
        IF NOT (Abstract IN Properties) THEN
           INC (ConstCount);
           IF NOT (Ignore IN Properties) THEN
              WI (Name); WriteS (f, " = "); WN (ConstCount); WriteS (f, ";"); WriteNl (f);
           END;
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END ConstDeclsPre;

PROCEDURE ConstDeclsPost (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 220 "" *)
     WITH t^.Class DO
(* line 220 "" *)
      
      IF IsElement (ORD ('+'), Options) THEN
        IF NOT (Abstract IN Properties) THEN
           IF NOT (Ignore IN Properties) THEN
              WI (Name); WriteS (f, "Max = "); WN (ConstCount); WriteS (f, ";"); WriteNl (f);
           END;
        END;
      END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END ConstDeclsPost;

PROCEDURE PointerTypes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 232 "" *)
     WITH t^.Class DO
(* line 232 "" *)
      
        IF NOT (Abstract IN Properties) THEN
           IF NOT (Ignore IN Properties) THEN
              WriteS (f, "p");WI (Name); WriteS (f, " = "); WI ( itTree ); WriteS (f, ";"); WriteNl (f);
           END;
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END PointerTypes;

PROCEDURE TypeDeclNode (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 245 "" *)
     WITH t^.Class DO
(* line 245 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "y"); WI (Name); WriteS (f, " = RECORD yyHead: yytNodeHead; "); 
           ForallAttributes (t, TypeDeclNode); WriteS (f, "END;"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 251 "" *)
     WITH t^.Child DO
(* line 251 "" *)
      
        WI (Name); WriteS (f, ": "); WI (itTree); WriteS (f, "; "); 
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 254 "" *)
     WITH t^.Attribute DO
(* line 254 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
           WI (Name); WriteS (f, ": "); WI (Type); WriteS (f, "; "); 
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END TypeDeclNode;

PROCEDURE TypeDeclRecord (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 263 "" *)
     WITH t^.Class DO
(* line 263 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "| "); WI (Name); WriteS (f, ": "); WI (Name); WriteS (f, ": y"); WI (Name); WriteS (f, ";"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END TypeDeclRecord;

PROCEDURE ProcedureDeclsn (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 272 "" *)
     WITH t^.Class DO
(* line 272 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "PROCEDURE n"); WI (Name); WriteS (f, " (): "); WI (itTree); WriteS (f, ";"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END ProcedureDeclsn;

PROCEDURE ProcedureHeadingm (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 281 "" *)
     WITH t^.Class DO
(* line 281 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           ListCount := 0;
           WriteS (f, "PROCEDURE m"); WI (Name); WriteS (f, " ("); 
           ForallAttributes (t, ProcedureHeadingm); WriteS (f, "): "); WI (itTree); WriteS (f, ";"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 288 "" *)
     WITH t^.Child DO
(* line 288 "" *)
      
        IF Input IN Properties THEN
           IF ListCount > 0 THEN WriteS (f, "; "); END;
           WriteS (f, "p"); WI (Name); WriteS (f, ": "); WI (itTree);
           INC (ListCount);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 295 "" *)
     WITH t^.Attribute DO
(* line 295 "" *)
      
        IF Input IN Properties THEN
           IF ListCount > 0 THEN WriteS (f, "; "); END;
           WriteS (f, "p"); WI (Name); WriteS (f, ": "); WI (Type);
           INC (ListCount);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ProcedureHeadingm;

PROCEDURE TreeImplMod (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Ag) THEN
(* line 306 "" *)
     WITH t^.Ag DO
(* line 306 "" *)
      
        WriteS (f, "IMPLEMENTATION MODULE "); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteS (f, "# define yyALLOC(ptr, size)    ptr := yyPoolFreePtr; "); WriteBackslash ( f ) ; WriteNl (f);
        WriteS (f, "  IF SYSTEM.ADDRESS (ptr) >= yyPoolMaxPtr THEN ptr := yyAlloc (); END; "); WriteBackslash ( f ) ; WriteNl (f);
        WriteS (f, "  INC (yyPoolFreePtr, size);"); WriteNl (f);
        WriteS (f, "# define yyFREE(ptr, size)     "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "IMPORT SYSTEM, System, General, Memory, DynArray, IO, Layout, StringMem, Strings, Idents, Texts, Sets, Positions;"); WriteNl (f);
      IF IsElement (ORD ('<'), Options) THEN
        WriteS (f, "FROM "); WI (iMain); WriteS (f, " IMPORT "); WI (itTree); WriteS (f, ", "); WI (iNoTree); WriteS (f, ", tProcTree, Make"); WI (iMain); WriteS (f, ", IsType, yyExit,"); WriteNl (f);
        ForallClasses (Classes, ImportConst);
        WriteS (f, "yyAlloc, yyPoolFreePtr, yyPoolMaxPtr, yyNodeSize;"); WriteNl (f);
        WriteNl (f);
      END;
        WriteLine (TreeCodes^.Codes.GlobalLine);
        WriteText (f, TreeCodes^.Codes.Global);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.GlobalLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Global);
           Node := Node^.Module.Next;
        END;
        WriteLine (TreeCodes^.Codes.LocalLine);
        WriteText (f, TreeCodes^.Codes.Local);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.LocalLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Local);
           Node := Node^.Module.Next;
        END;
        WriteS (f, '# include "yy'); WI (iModule); WriteS (f, '.w"'); WriteNl (f);
        WriteNl (f);
      IF NOT IsElement (ORD ('<'), Options) THEN
        WriteS (f, "CONST yyBlockSize = 20480;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "TYPE"); WriteNl (f);
        WriteS (f, " yytBlockPtr   = POINTER TO yytBlock;"); WriteNl (f);
        WriteS (f, " yytBlock      = RECORD"); WriteNl (f);
        WriteS (f, "                    yyBlock    : ARRAY [1..yyBlockSize] OF CHAR;"); WriteNl (f);
        WriteS (f, "                    yySuccessor: yytBlockPtr;"); WriteNl (f);
        WriteS (f, "                 END;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "VAR yyBlockList        : yytBlockPtr;"); WriteNl (f);
        WriteS (f, "VAR yyMaxSize, yyi     : SHORTCARD;"); WriteNl (f);
        WriteS (f, "VAR yyTypeRange        : ARRAY [0.."); WN (ClassCount); WriteS (f, "] OF SHORTCARD;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyAlloc (): "); WI (itTree); WriteS (f, ";"); WriteNl (f);
        WriteS (f, " VAR yyBlockPtr        : yytBlockPtr;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  yyBlockPtr   := yyBlockList;"); WriteNl (f);
        WriteS (f, "  yyBlockList  := Memory.Alloc (SYSTEM.TSIZE (yytBlock));"); WriteNl (f);
        WriteS (f, "  yyBlockList^.yySuccessor := yyBlockPtr;"); WriteNl (f);
        WriteS (f, "  yyPoolFreePtr        := SYSTEM.ADR (yyBlockList^.yyBlock);"); WriteNl (f);
        WriteS (f, "  yyPoolMaxPtr := yyPoolFreePtr + yyBlockSize - yyMaxSize + 1;"); WriteNl (f);
        WriteS (f, "  INC (HeapUsed, yyBlockSize);"); WriteNl (f);
        WriteS (f, "  RETURN yyPoolFreePtr;"); WriteNl (f);
        WriteS (f, " END yyAlloc;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE Make"); WI (iMain); WriteS (f, " (yyKind: SHORTCARD): "); WI (itTree); WriteS (f, ";"); WriteNl (f);
        WriteS (f, " VAR yyByteCount       : LONGINT;"); WriteNl (f);
        WriteS (f, " VAR yyt       : "); WI (itTree); WriteS (f, ";"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  yyALLOC (yyt, yyNodeSize [yyKind])"); WriteNl (f);
        WriteS (f, "  yyt^.yyHead.yyMark := 0;"); WriteNl (f);
        WriteS (f, "  yyt^.Kind := yyKind;"); WriteNl (f);
        WriteS (f, "  RETURN yyt;"); WriteNl (f);
        WriteS (f, " END Make"); WI (iMain); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE IsType (yyTree: "); WI (itTree); WriteS (f, "; yyKind: SHORTCARD): BOOLEAN;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  RETURN (yyTree # "); WI (iNoTree); WriteS (f, ") AND (yyKind <= yyTree^.Kind) AND (yyTree^.Kind <= yyTypeRange [yyKind]);"); WriteNl (f);
        WriteS (f, " END IsType;"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('n'), Options) THEN
        ForallClasses (Classes, ProcedureBodyn);
      END;
        WriteNl (f);
      IF IsElement (ORD ('m'), Options) THEN
        ForallClasses (Classes, ProcedureBodym);
      END;
        TreeIO (t);
      IF IsElement (ORD ('f'), Options) THEN
        WriteS (f, "PROCEDURE Release"); WI (iModule); WriteS (f, " (yyt: "); WI (itTree); WriteS (f, ");"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  yyMark (yyt);"); WriteNl (f);
        WriteS (f, "  yyRelease"); WI (iModule); WriteS (f, " (yyt);"); WriteNl (f);
        WriteS (f, " END Release"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "VAR yyChild    : "); WI (itTree); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyRelease"); WI (iModule); WriteS (f, " (yyt: "); WI (itTree); WriteS (f, ");"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  IF yyt = "); WI (iNoTree); WriteS (f, " THEN RETURN; END;"); WriteNl (f);
        WriteS (f, "  CASE yyt^.Kind OF"); WriteNl (f);
        ForallClasses (Classes, ReleaseAttributes1);
        WriteS (f, "  ELSE"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  DEC (yyt^.yyHead.yyMark);"); WriteNl (f);
        WriteS (f, "  IF yyt^.yyHead.yyMark = 0 THEN"); WriteNl (f);
        WriteS (f, "   CASE yyt^.Kind OF"); WriteNl (f);
        ForallClasses (Classes, ReleaseAttributes2);
        WriteS (f, "   ELSE"); WriteNl (f);
        WriteS (f, "   END;"); WriteNl (f);
        WriteS (f, "   yyFREE (yyt, yyNodeSize [yyt^.Kind])"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, " END yyRelease"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('F'), Options) AND NOT IsElement (ORD ('<'), Options) THEN
        WriteS (f, "PROCEDURE Release"); WI (iModule); WriteS (f, "Module;"); WriteNl (f);
        WriteS (f, " VAR yyBlockPtr        : yytBlockPtr;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  WHILE yyBlockList # NIL DO"); WriteNl (f);
        WriteS (f, "   yyBlockPtr  := yyBlockList;"); WriteNl (f);
        WriteS (f, "   yyBlockList := yyBlockList^.yySuccessor;"); WriteNl (f);
        WriteS (f, "   Memory.Free (SYSTEM.TSIZE (yytBlock), yyBlockPtr);"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, "  yyPoolFreePtr        := NIL;"); WriteNl (f);
        WriteS (f, "  yyPoolMaxPtr := NIL;"); WriteNl (f);
        WriteS (f, "  HeapUsed     := 0;"); WriteNl (f);
        WriteS (f, " END Release"); WI (iModule); WriteS (f, "Module;"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('t'), Options) OR
         IsElement (ORD ('b'), Options) THEN
        WriteS (f, "VAR yyProc     : tProcTree;"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('t'), Options) THEN
        WriteS (f, "PROCEDURE Traverse"); WI (iModule); WriteS (f, "TD (yyt: "); WI (itTree); WriteS (f, "; yyyProc: tProcTree);"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  yyMark (yyt);"); WriteNl (f);
        WriteS (f, "  yyProc := yyyProc;"); WriteNl (f);
        WriteS (f, "  yyTraverse"); WI (iModule); WriteS (f, "TD (yyt);"); WriteNl (f);
        WriteS (f, " END Traverse"); WI (iModule); WriteS (f, "TD;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyTraverse"); WI (iModule); WriteS (f, "TD (yyt: "); WI (itTree); WriteS (f, ");"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  LOOP"); WriteNl (f);
        WriteS (f, "   IF (yyt = "); WI (iNoTree); WriteS (f, ") OR (yyt^.yyHead.yyMark = 0) THEN RETURN; END;"); WriteNl (f);
        WriteS (f, "   yyt^.yyHead.yyMark := 0;"); WriteNl (f);
        WriteS (f, "   yyProc (yyt);"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "   CASE yyt^.Kind OF"); WriteNl (f);
        ForallClasses (Classes, TraverseTD);
        WriteS (f, "   ELSE RETURN;"); WriteNl (f);
        WriteS (f, "   END;"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, " END yyTraverse"); WI (iModule); WriteS (f, "TD;"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('b'), Options) THEN
        WriteS (f, "PROCEDURE Traverse"); WI (iModule); WriteS (f, "BU (yyt: "); WI (itTree); WriteS (f, "; yyyProc: tProcTree);"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  yyMark (yyt);"); WriteNl (f);
        WriteS (f, "  yyProc := yyyProc;"); WriteNl (f);
        WriteS (f, "  yyTraverse"); WI (iModule); WriteS (f, "BU (yyt);"); WriteNl (f);
        WriteS (f, " END Traverse"); WI (iModule); WriteS (f, "BU;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyTraverse"); WI (iModule); WriteS (f, "BU (yyt: "); WI (itTree); WriteS (f, ");"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  IF (yyt = "); WI (iNoTree); WriteS (f, ") OR (yyt^.yyHead.yyMark = 0) THEN RETURN; END;"); WriteNl (f);
        WriteS (f, "  yyt^.yyHead.yyMark := 0;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  CASE yyt^.Kind OF"); WriteNl (f);
        ForallClasses (Classes, TraverseBU);
        WriteS (f, "  ELSE"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, "  yyProc (yyt);"); WriteNl (f);
        WriteS (f, " END yyTraverse"); WI (iModule); WriteS (f, "BU;"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('R'), Options) THEN
        WriteS (f, "PROCEDURE Reverse"); WI (iModule); WriteS (f, " (yyOld: "); WI (itTree); WriteS (f, "): "); WI (itTree); WriteS (f, ";"); WriteNl (f);
        WriteS (f, " VAR yyNew, yyNext, yyTail     : "); WI (itTree); WriteS (f, ";"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  yyNew        := yyOld;"); WriteNl (f);
        WriteS (f, "  yyTail       := yyOld;"); WriteNl (f);
        WriteS (f, "  LOOP"); WriteNl (f);
        WriteS (f, "   CASE yyOld^.Kind OF"); WriteNl (f);
        ForallClasses (Classes, Reverse1);
        WriteS (f, "   ELSE EXIT;"); WriteNl (f);
        WriteS (f, "   END;"); WriteNl (f);
        WriteS (f, "   yyNew       := yyOld;"); WriteNl (f);
        WriteS (f, "   yyOld       := yyNext;"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, "  CASE yyTail^.Kind OF"); WriteNl (f);
        ForallClasses (Classes, Reverse2);
        WriteS (f, "  ELSE"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, "  RETURN yyNew;"); WriteNl (f);
        WriteS (f, " END Reverse"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('y'), Options) THEN
        WriteS (f, "CONST yyInitOldToNewStoreSize  = 32;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "TYPE yytOldToNew = RECORD yyOld, yyNew: "); WI (itTree); WriteS (f, "; END;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "VAR yyOldToNewStoreSize        : LONGINT;"); WriteNl (f);
        WriteS (f, "VAR yyOldToNewStorePtr : POINTER TO ARRAY [0..50000] OF yytOldToNew;"); WriteNl (f);
        WriteS (f, "VAR yyOldToNewCount    : INTEGER;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyStoreOldToNew (yyOld, yyNew: "); WI (itTree); WriteS (f, ");"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  IF (yyOldToNewCount = yyOldToNewStoreSize) THEN"); WriteNl (f);
        WriteS (f, "   DynArray.ExtendArray (yyOldToNewStorePtr, yyOldToNewStoreSize, SYSTEM.TSIZE (yytOldToNew));"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, "  yyOldToNewStorePtr^[yyOldToNewCount].yyOld := yyOld;"); WriteNl (f);
        WriteS (f, "  yyOldToNewStorePtr^[yyOldToNewCount].yyNew := yyNew;"); WriteNl (f);
        WriteS (f, "  INC (yyOldToNewCount);"); WriteNl (f);
        WriteS (f, " END yyStoreOldToNew;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyMapOldToNew (yyOld: "); WI (itTree); WriteS (f, "): "); WI (itTree); WriteS (f, ";"); WriteNl (f);
        WriteS (f, " VAR yyi: INTEGER;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  FOR yyi := 0 TO yyOldToNewCount - 1 DO"); WriteNl (f);
        WriteS (f, "   IF yyOldToNewStorePtr^[yyi].yyOld = yyOld THEN"); WriteNl (f);
        WriteS (f, "    RETURN yyOldToNewStorePtr^[yyi].yyNew;"); WriteNl (f);
        WriteS (f, "   END;"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, " END yyMapOldToNew;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyCopy"); WI (iModule); WriteS (f, " (yyt: "); WI (itTree); WriteS (f, "; yyNew: yyPtrtTree);"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  LOOP"); WriteNl (f);
        WriteS (f, "   IF yyt = "); WI (iNoTree); WriteS (f, " THEN yyNew^ := "); WI (iNoTree); WriteS (f, "; RETURN; END;"); WriteNl (f);
        WriteS (f, "   IF yyt^.yyHead.yyMark = 0 THEN yyNew^ := yyMapOldToNew (yyt); RETURN; END;"); WriteNl (f);
        WriteS (f, "   yyNew^ := Make"); WI (iMain); WriteS (f, " (yyt^.Kind);"); WriteNl (f);
        WriteS (f, "   IF yyt^.yyHead.yyMark > 1 THEN yyStoreOldToNew (yyt, yyNew^); END;"); WriteNl (f);
        WriteS (f, "   yyt^.yyHead.yyMark := 0;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "   CASE yyt^.Kind OF"); WriteNl (f);
        ForallClasses (Classes, Copy);
        WriteS (f, "   ELSE"); WriteNl (f);
        WriteS (f, "   END;"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, " END yyCopy"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE Copy"); WI (iModule); WriteS (f, " (yyt: "); WI (itTree); WriteS (f, "): "); WI (itTree); WriteS (f, ";"); WriteNl (f);
        WriteS (f, " VAR yyNew     : "); WI (itTree); WriteS (f, ";"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  yyMark (yyt);"); WriteNl (f);
        WriteS (f, "  yyOldToNewCount := 0;"); WriteNl (f);
        WriteS (f, "  yyCopy"); WI (iModule); WriteS (f, " (yyt, SYSTEM.ADR (yyNew));"); WriteNl (f);
        WriteS (f, "  RETURN yyNew;"); WriteNl (f);
        WriteS (f, " END Copy"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('k'), Options) THEN
        WriteS (f, "PROCEDURE Check"); WI (iModule); WriteS (f, " (yyt: "); WI (itTree); WriteS (f, "): BOOLEAN;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  yyMark (yyt);"); WriteNl (f);
        WriteS (f, "  RETURN yyCheck"); WI (iModule); WriteS (f, " (yyt);"); WriteNl (f);
        WriteS (f, " END Check"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyCheckChild (yyParent, yyChild: "); WI (itTree); WriteS (f, "; yyType: SHORTCARD; yySelector: ARRAY OF CHAR): BOOLEAN;"); WriteNl (f);
        WriteS (f, " CONST yyf     = IO.StdError;"); WriteNl (f);
        WriteS (f, " VAR yySuccess : BOOLEAN;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  yySuccess := IsType (yyChild, yyType);"); WriteNl (f);
        WriteS (f, "  IF NOT yySuccess THEN"); WriteNl (f);
        WriteS (f, "   IO.WriteS (yyf, 'CheckTree: parent = ');"); WriteNl (f);
        WriteS (f, "   Write"); WI (iModule); WriteS (f, "Node (yyf, yyParent);"); WriteNl (f);
        WriteS (f, "   IO.WriteNl (yyf);"); WriteNl (f);
        WriteS (f, "   IO.WriteS (yyf, 'selector: ');"); WriteNl (f);
        WriteS (f, "   IO.WriteS (yyf, yySelector);"); WriteNl (f);
        WriteS (f, "   IO.WriteS (yyf, ', child = ');"); WriteNl (f);
        WriteS (f, "   Write"); WI (iModule); WriteS (f, "Node (yyf, yyChild);"); WriteNl (f);
        WriteS (f, "   IO.WriteNl (yyf);"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, "  RETURN yyCheck"); WI (iModule); WriteS (f, " (yyChild) AND yySuccess;"); WriteNl (f);
        WriteS (f, " END yyCheckChild;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyCheck"); WI (iModule); WriteS (f, " (yyt: "); WI (itTree); WriteS (f, "): BOOLEAN;"); WriteNl (f);
        WriteS (f, " VAR yyResult  : BOOLEAN;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  IF yyt = "); WI (iNoTree); WriteS (f, " THEN RETURN FALSE;"); WriteNl (f);
        WriteS (f, "  ELSIF yyt^.yyHead.yyMark = 0 THEN RETURN TRUE;"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, "  yyt^.yyHead.yyMark := 0;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  yyResult := TRUE;"); WriteNl (f);
        WriteS (f, "  CASE yyt^.Kind OF"); WriteNl (f);
        ForallClasses (Classes, CheckAttributes);
        WriteS (f, "  ELSE"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, "  RETURN yyResult;"); WriteNl (f);
        WriteS (f, " END yyCheck"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('q'), Options) THEN
        WriteS (f, "CONST yyyWrite = 1; yyyRead = 2; yyyQuit = 3;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "VAR yyString   : ARRAY [0..31] OF CHAR;"); WriteNl (f);
        WriteS (f, "VAR yyLength   : INTEGER;"); WriteNl (f);
        WriteS (f, "VAR yyCh       : CHAR;"); WriteNl (f);
        WriteS (f, "VAR yyState    : INTEGER;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyyIsEqual (yya: ARRAY OF CHAR): BOOLEAN;"); WriteNl (f);
        WriteS (f, " VAR yyi       : INTEGER;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  IF (yyLength >= 0) AND (yyString [yyLength] = ' ') THEN"); WriteNl (f);
        WriteS (f, "   IF yyLength - 1 # INTEGER (HIGH (yya)) THEN RETURN FALSE; END;"); WriteNl (f);
        WriteS (f, "   FOR yyi := 0 TO yyLength - 1 DO"); WriteNl (f);
        WriteS (f, "    IF yyString [yyi] # yya [yyi] THEN RETURN FALSE; END;"); WriteNl (f);
        WriteS (f, "   END;"); WriteNl (f);
        WriteS (f, "  ELSE"); WriteNl (f);
        WriteS (f, "   IF yyLength > INTEGER (HIGH (yya)) THEN RETURN FALSE; END;"); WriteNl (f);
        WriteS (f, "   FOR yyi := 0 TO yyLength DO"); WriteNl (f);
        WriteS (f, "    IF yyString [yyi] # yya [yyi] THEN RETURN FALSE; END;"); WriteNl (f);
        WriteS (f, "   END;"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, "  RETURN TRUE;"); WriteNl (f);
        WriteS (f, " END yyyIsEqual;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE Query"); WI (iModule); WriteS (f, " (yyt: "); WI (itTree); WriteS (f, ");"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  yyState := yyyWrite;"); WriteNl (f);
        WriteS (f, "  LOOP"); WriteNl (f);
        WriteS (f, "   CASE yyState OF"); WriteNl (f);
        WriteS (f, "   | yyyQuit   : RETURN;"); WriteNl (f);
        WriteS (f, "   | yyyWrite  : Write"); WI (iModule); WriteS (f, "Node (IO.StdOutput, yyt); yyState := yyyRead;"); WriteNl (f);
        WriteS (f, "   | yyyRead   : IO.WriteS (IO.StdOutput, '? '); yyLength := -1; yyCh := IO.ReadC (IO.StdInput);"); WriteNl (f);
        WriteS (f, "    WHILE yyCh # 12C DO INC (yyLength); yyString [yyLength] := yyCh; yyCh := IO.ReadC (IO.StdInput); END;"); WriteNl (f);
        WriteS (f, "    IF    yyyIsEqual ('parent') THEN yyState := yyyWrite; RETURN;"); WriteNl (f);
        WriteS (f, "    ELSIF yyyIsEqual ('quit'  ) THEN yyState := yyyQuit ; RETURN;"); WriteNl (f);
        WriteS (f, "    ELSIF yyt # "); WI (iNoTree); WriteS (f, " THEN"); WriteNl (f);
        WriteS (f, "     CASE yyt^.Kind OF"); WriteNl (f);
        ForallClasses (Classes, QueryAttributes);
        WriteS (f, "     ELSE"); WriteNl (f);
        WriteS (f, "     END;"); WriteNl (f);
        WriteS (f, "    END;"); WriteNl (f);
        WriteS (f, "   END;"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, " END Query"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('='), Options) THEN
        WriteS (f, "PROCEDURE yyIsEqual (yya, yyb: ARRAY OF SYSTEM.BYTE): BOOLEAN;"); WriteNl (f);
        WriteS (f, " VAR yyi       : INTEGER;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  FOR yyi := 0 TO INTEGER (HIGH (yya)) DO"); WriteNl (f);
        WriteS (f, "   IF yya [yyi] # yyb [yyi] THEN RETURN FALSE; END;"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, "  RETURN TRUE;"); WriteNl (f);
        WriteS (f, " END yyIsEqual;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE IsEqual"); WI (iModule); WriteS (f, " (yyt1, yyt2: "); WI (itTree); WriteS (f, "): BOOLEAN;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  IF yyt1 = yyt2 THEN RETURN TRUE; END;"); WriteNl (f);
        WriteS (f, "  IF (yyt1 = "); WI (iNoTree); WriteS (f, ") OR (yyt2 = "); WI (iNoTree); WriteS (f, ") OR (yyt1^.Kind # yyt2^.Kind) THEN RETURN FALSE; END;"); WriteNl (f);
        WriteS (f, "  CASE yyt1^.Kind OF"); WriteNl (f);
        ForallClasses (Classes, IsEqualAttributes);
        WriteS (f, "  ELSE RETURN TRUE;"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, " END IsEqual"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('L'), Options) THEN
        MaxBit := 0;
        ForallClasses (Classes, CompMaxBit);
        WriteS (f, "PROCEDURE Init"); WI (iModule); WriteS (f, " (yyt: "); WI (itTree); WriteS (f, ");"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  LOOP"); WriteNl (f);
        FOR i := 0 TO (MaxBit - 1) DIV BSS DO
           WriteS (f, "   yyt^.yyHead.yyIsComp"); WN (i); WriteS (f, " := {};"); WriteNl (f);
      IF IsElement (ORD ('5'), Options) THEN
           WriteS (f, "   yyt^.yyHead.yyIsDone"); WN (i); WriteS (f, " := {};"); WriteNl (f);
      END;
        END;
        WriteS (f, "   CASE yyt^.Kind OF"); WriteNl (f);
        ForallClasses (Classes, InitAttributes);
        WriteS (f, "   ELSE RETURN;"); WriteNl (f);
        WriteS (f, "   END;"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, " END Init"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
      END;
        WriteS (f, "PROCEDURE Begin"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteLine (TreeCodes^.Codes.BeginLine);
        WriteText (f, TreeCodes^.Codes.Begin);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.BeginLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Begin);
           Node := Node^.Module.Next;
        END;
        WriteS (f, " END Begin"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE Close"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteLine (TreeCodes^.Codes.CloseLine);
        WriteText (f, TreeCodes^.Codes.Close);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.CloseLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Close);
           Node := Node^.Module.Next;
        END;
        WriteS (f, " END Close"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
      IF NOT IsElement (ORD ('<'), Options) THEN
        WriteS (f, "PROCEDURE xxExit;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  IO.CloseIO; System.Exit (1);"); WriteNl (f);
        WriteS (f, " END xxExit;"); WriteNl (f);
        WriteNl (f);
      END;
        WriteS (f, "BEGIN"); WriteNl (f);
      IF IsElement (ORD ('r'), Options) THEN
        WriteS (f, " yyIsInitialized := FALSE;"); WriteNl (f);
      END;
      IF NOT IsElement (ORD ('<'), Options) THEN
        WriteS (f, " yyBlockList   := NIL;"); WriteNl (f);
        WriteS (f, " yyPoolFreePtr := NIL;"); WriteNl (f);
        WriteS (f, " yyPoolMaxPtr  := NIL;"); WriteNl (f);
        WriteS (f, " HeapUsed      := 0;"); WriteNl (f);
        WriteS (f, " yyExit        := xxExit;"); WriteNl (f);
        ForallClasses (Classes, InitNodeSize);
        WriteS (f, " yyMaxSize     := 0;"); WriteNl (f);
        WriteS (f, " FOR yyi := 1 TO "); WN (ClassCount); WriteS (f, " DO"); WriteNl (f);
        WriteS (f, "  yyNodeSize [yyi] := LONGINT (BITSET (yyNodeSize [yyi] + CARDINAL (General.MaxAlign) - 1) * General.AlignMasks [General.MaxAlign]);"); WriteNl (f);
        WriteS (f, "  yyMaxSize := General.Max (yyNodeSize [yyi], yyMaxSize);"); WriteNl (f);
        WriteS (f, " END;"); WriteNl (f);
        ForallClasses (Classes, InitTypeRange);
      END;
      IF IsElement (ORD (';'), Options) THEN
        WriteS (f, " yyRecursionLevel := 0;"); WriteNl (f);
        WriteS (f, " yyTreeStoreSize := yyInitTreeStoreSize;"); WriteNl (f);
        WriteS (f, " DynArray.MakeArray (yyTreeStorePtr, yyTreeStoreSize, SYSTEM.TSIZE ("); WI (itTree); WriteS (f, "));"); WriteNl (f);
      END;
      IF IsElement (ORD ('y'), Options) THEN
        WriteS (f, " yyOldToNewStoreSize := yyInitOldToNewStoreSize;"); WriteNl (f);
        WriteS (f, " DynArray.MakeArray (yyOldToNewStorePtr, yyOldToNewStoreSize, SYSTEM.TSIZE (yytOldToNew));"); WriteNl (f);
      END;
        WriteS (f, " Begin"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteS (f, "END "); WI (iModule); WriteS (f, "."); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  END;
 END TreeImplMod;

PROCEDURE ProcedureBodyn (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 752 "" *)
     WITH t^.Class DO
(* line 752 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "PROCEDURE n"); WI (Name); WriteS (f, " (): "); WI (itTree); WriteS (f, ";"); WriteNl (f);
           WriteS (f, " VAR yyByteCount    : LONGINT;"); WriteNl (f);
           WriteS (f, " VAR yyt    : "); WI (itTree); WriteS (f, ";"); WriteNl (f);
           WriteS (f, " BEGIN"); WriteNl (f);
           WriteS (f, "  yyALLOC (yyt, yyNodeSize ["); WI (Name); WriteS (f, "])"); WriteNl (f);
           WriteS (f, "  yyt^.yyHead.yyMark := 0;"); WriteNl (f);
           WriteS (f, "  yyt^.Kind := "); WI (Name); WriteS (f, ";"); WriteNl (f);
           iClassName := Name;
           ForallAttributes (t, ProcedureBodyn);
           WriteS (f, "  RETURN yyt;"); WriteNl (f);
           WriteS (f, " END n"); WI (Name); WriteS (f, ";"); WriteNl (f);
           WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 768 "" *)
     WITH t^.Child DO
(* line 768 "" *)
      
        WriteS (f, "  begin"); WI (itTree); WriteS (f, "(yyt^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ")"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 771 "" *)
     WITH t^.Attribute DO
(* line 771 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
           WriteS (f, "  begin"); WI (Type); WriteS (f, "(yyt^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ")"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ProcedureBodyn;

PROCEDURE ProcedureBodym (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 780 "" *)
     WITH t^.Class DO
(* line 780 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           ProcedureHeadingm (t);
           WriteS (f, " VAR yyByteCount    : LONGINT;"); WriteNl (f);
           WriteS (f, " VAR yyt    : "); WI (itTree); WriteS (f, ";"); WriteNl (f);
           WriteS (f, " BEGIN"); WriteNl (f);
           WriteS (f, "  yyALLOC (yyt, yyNodeSize ["); WI (Name); WriteS (f, "])"); WriteNl (f);
           WriteS (f, "  yyt^.yyHead.yyMark := 0;"); WriteNl (f);
           WriteS (f, "  yyt^.Kind := "); WI (Name); WriteS (f, ";"); WriteNl (f);
           IF ({HasChildren, HasAttributes} * Properties) # {} THEN
              WriteS (f, "  WITH yyt^."); WI (Name); WriteS (f, " DO"); WriteNl (f);
              ForallAttributes (t, ProcedureBodym);
              WriteS (f, "  END;"); WriteNl (f);
           END;
           WriteS (f, "  RETURN yyt;"); WriteNl (f);
           WriteS (f, " END m"); WI (Name); WriteS (f, ";"); WriteNl (f);
           WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 799 "" *)
     WITH t^.Child DO
(* line 799 "" *)
      
        IF Input IN Properties THEN
           WriteS (f, "   "); WI (Name); WriteS (f, " := p"); WI (Name); WriteS (f, ";"); WriteNl (f);
        ELSE
           WriteS (f, "   begin"); WI (itTree); WriteS (f, "("); WI (Name); WriteS (f, ")"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 806 "" *)
     WITH t^.Attribute DO
(* line 806 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
           IF Input IN Properties THEN
              WriteS (f, "   "); WI (Name); WriteS (f, " := p"); WI (Name); WriteS (f, ";"); WriteNl (f);
           ELSE
              WriteS (f, "   begin"); WI (Type); WriteS (f, "("); WI (Name); WriteS (f, ")"); WriteNl (f);
           END;
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ProcedureBodym;

PROCEDURE ReleaseAttributes1 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 819 "" *)
     WITH t^.Class DO
(* line 819 "" *)
      
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           WriteS (f, "| "); WI (Name); WriteS (f, ":"); WriteNl (f);
           iClassName := Name;
           ForallAttributes (t, ReleaseAttributes1);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 826 "" *)
     WITH t^.Child DO
(* line 826 "" *)
      
        WriteS (f, "close"); WI (itTree); WriteS (f, " (yyt^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ")"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ReleaseAttributes1;

PROCEDURE ReleaseAttributes2 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 833 "" *)
     WITH t^.Class DO
(* line 833 "" *)
      
        IF ((NoCodeClass * Properties) = {}) AND (HasAttributes IN Properties) THEN
           WriteS (f, "| "); WI (Name); WriteS (f, ":"); WriteNl (f);
           iClassName := Name;
           ForallAttributes (t, ReleaseAttributes2);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 840 "" *)
     WITH t^.Attribute DO
(* line 840 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
           WriteS (f, "close"); WI (Type); WriteS (f, " (yyt^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ")"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ReleaseAttributes2;

PROCEDURE TraverseTD (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 849 "" *)
     WITH t^.Class DO
(* line 849 "" *)
      
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           WriteS (f, "| "); WI (Name); WriteS (f, ":"); WriteNl (f);
           GetIterator (t);
           iClassName := Name;
           ForallAttributes (t, TraverseTD);
           IF Iterator = NoTree THEN
              WriteS (f, "RETURN;"); WriteNl (f);
           ELSE
              WriteS (f, "yyt := yyt^."); WI (iClassName); WriteS (f, "."); WI (Iterator^.Child.Name); WriteS (f, ";"); WriteNl (f);
           END;
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 862 "" *)
     WITH t^.Child DO
(* line 862 "" *)
      
        IF t # Iterator THEN
           WriteS (f, "yyTraverse"); WI (iModule); WriteS (f, "TD (yyt^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ");"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END TraverseTD;

PROCEDURE TraverseBU (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 871 "" *)
     WITH t^.Class DO
(* line 871 "" *)
      
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           WriteS (f, "| "); WI (Name); WriteS (f, ":"); WriteNl (f);
           GetIterator (t);
           iClassName := Name;
           ForallAttributes (t, TraverseBU);
           IF Iterator = NoTree THEN
              WriteS (f, "RETURN;"); WriteNl (f);
           ELSE
              WriteS (f, "yyTraverse"); WI (iModule); WriteS (f, "BU (yyt^."); WI (iClassName); WriteS (f, "."); WI (Iterator^.Child.Name); WriteS (f, ");"); WriteNl (f);
           END;
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 884 "" *)
     WITH t^.Child DO
(* line 884 "" *)
      
        IF t # Iterator THEN
           WriteS (f, "yyTraverse"); WI (iModule); WriteS (f, "BU (yyt^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ");"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END TraverseBU;

PROCEDURE Reverse1 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 893 "" *)
     WITH t^.Class DO
(* line 893 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           iClassName := Name;
           ForallAttributes (t, Reverse1);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 899 "" *)
     WITH t^.Child DO
(* line 899 "" *)
      
        IF Reverse IN Properties THEN
           WriteS (f, "| "); WI (iClassName); WriteS (f, ": yyNext := yyOld^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ";"); 
           WriteS (f, " yyOld^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, " := yyNew;"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Reverse1;

PROCEDURE Reverse2 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 909 "" *)
     WITH t^.Class DO
(* line 909 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           iClassName := Name;
           ForallAttributes (t, Reverse2);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 915 "" *)
     WITH t^.Child DO
(* line 915 "" *)
      
        IF Reverse IN Properties THEN
           WriteS (f, "| "); WI (iClassName); WriteS (f, ": yyTail^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, " := yyOld;"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Reverse2;

PROCEDURE Copy (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 924 "" *)
     WITH t^.Class DO
(* line 924 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "| "); WI (Name); WriteS (f, ": yyNew^^."); WI (Name); WriteS (f, " := yyt^."); WI (Name); WriteS (f, ";"); WriteNl (f);
           GetIterator (t);
           iClassName := Name;
           ForallAttributes (t, Copy);
           IF Iterator = NoTree THEN
              WriteS (f, "RETURN;"); WriteNl (f);
           ELSE
              WriteS (f, "yyt := yyt^."); WI (Name); WriteS (f, "."); WI (Iterator^.Child.Name); WriteS (f, ";"); WriteNl (f);
              WriteS (f, "yyNew := SYSTEM.ADR (yyNew^^."); WI (Name); WriteS (f, "."); WI (Iterator^.Child.Name); WriteS (f, ");"); WriteNl (f);
           END;
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 938 "" *)
     WITH t^.Child DO
(* line 938 "" *)
      
        IF t # Iterator THEN
           WriteS (f, "copy"); WI (itTree); WriteS (f, " (yyNew^^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ", "); 
              WriteS (f, "yyt^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ")"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 944 "" *)
     WITH t^.Attribute DO
(* line 944 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
           WriteS (f, "copy"); WI (Type); WriteS (f, " (yyNew^^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ", "); 
              WriteS (f, "yyt^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ")"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Copy;

PROCEDURE CheckAttributes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 954 "" *)
     WITH t^.Class DO
(* line 954 "" *)
      
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           WriteS (f, "| "); WI (Name); WriteS (f, ":"); WriteNl (f);
           iClassName := Name;
           ForallAttributes (t, CheckAttributes);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 961 "" *)
     WITH t^.Child DO
(* line 961 "" *)
      
        WriteS (f, "yyResult := yyCheckChild (yyt, yyt^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ", "); 
        WI (Type); WriteS (f, ", '"); WI (Name); WriteS (f, "') AND yyResult;"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 966 "" *)
   LOOP
     WITH t^.Attribute DO
(* line 967 "" *)
      IF NOT (( Link IN Properties )) THEN EXIT; END;
(* line 968 "" *)
      
        WriteS (f, "yyResult := yyCheckChild (yyt, yyt^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ", "); 
        WI (Type); WriteS (f, ", '"); WI (Name); WriteS (f, "') AND yyResult;"); WriteNl (f);
  ;
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  ELSE END;

 END CheckAttributes;

PROCEDURE InitTypeRange (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 976 "" *)
     WITH t^.Class DO
(* line 976 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           iRange := Name;
           ForallClasses (Extensions, InitTypeRange2);
           WriteS (f, " yyTypeRange ["); WI (Name); WriteS (f, "] := "); WI (iRange); WriteS (f, ";"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END InitTypeRange;

PROCEDURE InitTypeRange2 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 987 "" *)
     WITH t^.Class DO
(* line 987 "" *)
      
        iRange := Name;
;
      RETURN;
     END (* WITH *) ;

  END;
 END InitTypeRange2;

PROCEDURE QueryAttributes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 994 "" *)
     WITH t^.Class DO
(* line 994 "" *)
      
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           WriteS (f, "| "); WI (Name); WriteS (f, ": IF FALSE THEN"); WriteNl (f);
           iClassName := Name;
           ForallAttributes (t, QueryAttributes);
           WriteS (f, "END;"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1002 "" *)
     WITH t^.Child DO
(* line 1002 "" *)
      
        WriteS (f, "ELSIF yyyIsEqual ('"); WI (Name); WriteS (f, "') THEN Query"); WI (iModule);
        WriteS (f, " (yyt^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ");"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 1006 "" *)
   LOOP
     WITH t^.Attribute DO
(* line 1007 "" *)
      IF NOT (( Link IN Properties )) THEN EXIT; END;
(* line 1008 "" *)
       WriteS (f, "ELSIF yyyIsEqual ('"); WI (Name); WriteS (f, "') THEN Query"); WI (iModule);
       WriteS (f, " (yyt^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ");"); WriteNl (f);
     ;
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  ELSE END;

 END QueryAttributes;

PROCEDURE IsEqualAttributes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1015 "" *)
     WITH t^.Class DO
(* line 1015 "" *)
      
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           WriteS (f, "| "); WI (Name); WriteS (f, ": RETURN TRUE"); WriteNl (f);
           iClassName := Name;
           ForallAttributes (t, IsEqualAttributes);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1023 "" *)
     WITH t^.Child DO
(* line 1023 "" *)
      
        WriteS (f, "AND equal"); WI (itTree); WriteS (f, " (yyt1^."); WI (iClassName); WriteS (f, "."); WI (Name);
        WriteS (f, ", yyt2^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ")"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 1027 "" *)
     WITH t^.Attribute DO
(* line 1027 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
           WriteS (f, "AND (equal"); WI (Type); WriteS (f, " (yyt1^."); WI (iClassName); WriteS (f, "."); WI (Name);
           WriteS (f, ", yyt2^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, "))"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END IsEqualAttributes;

PROCEDURE InitAttributes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1037 "" *)
   LOOP
     WITH t^.Class DO
(* line 1038 "" *)
      IF NOT (((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties)) THEN EXIT; END;
(* line 1039 "" *)
      WriteS (f, "| ");
(* line 1039 "" *)
      WI (Name);
(* line 1039 "" *)
      WriteS (f, ":");
(* line 1039 "" *)
      WriteNl (f);
(* line 1040 "" *)
      GetIterator (t);
(* line 1041 "" *)
      iClassName := Name;
(* line 1042 "" *)
      gBitCount := BitCount;
(* line 1043 "" *)
      ForallAttributes (t, InitAttributes);
(* line 1044 "" *)
             IF (Iterator = NoTree) OR NOT (Input IN Iterator^.Child.Properties) THEN
           WriteS (f, "RETURN;"); WriteNl (f);
        ELSE
           WriteS (f, "yyt := yyt^."); WI (iClassName); WriteS (f, "."); WI (Iterator^.Child.Name); WriteS (f, ";"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.Child:
(* line 1050 "" *)
   LOOP
     WITH t^.Child DO
(* line 1051 "" *)
      IF NOT (Input IN Properties) THEN EXIT; END;
(* line 1052 "" *)
      WriteS (f, "WITH yyt^.");
(* line 1052 "" *)
      WI (iClassName);
(* line 1052 "" *)
      WriteS (f, ".");
(* line 1052 "" *)
      WI (Name);
(* line 1052 "" *)
      WriteS (f, "^.yyHead DO yyOffset := ");
(* line 1053 "" *)
      WN (gBitCount + BitOffset);
(* line 1053 "" *)
      WriteS (f, "; yyParent := yyt; END;");
(* line 1053 "" *)
      WriteNl (f);
(* line 1054 "" *)
      IF NOT (t # Iterator) THEN EXIT; END;
(* line 1055 "" *)
      WriteS (f, "Init");
(* line 1055 "" *)
      WI (iModule);
(* line 1055 "" *)
      WriteS (f, " (yyt^.");
(* line 1055 "" *)
      WI (iClassName);
(* line 1055 "" *)
      WriteS (f, ".");
(* line 1055 "" *)
      WI (Name);
(* line 1055 "" *)
      WriteS (f, ");");
(* line 1055 "" *)
      WriteNl (f);
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  ELSE END;

 END InitAttributes;

PROCEDURE InitNodeSize (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 1060 "" *)
   LOOP
     WITH t^.Class DO
(* line 1061 "" *)
      IF NOT ((NoCodeClass * Properties) = {}) THEN EXIT; END;
(* line 1062 "" *)
      WriteS (f, " yyNodeSize [");
(* line 1062 "" *)
      WI (Name);
(* line 1062 "" *)
      WriteS (f, "] := SYSTEM.TSIZE (y");
(* line 1062 "" *)
      WI (Name);
(* line 1062 "" *)
      WriteS (f, ");");
(* line 1062 "" *)
      WriteNl (f);
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
 END InitNodeSize;

PROCEDURE ImportList (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Ag:
(* line 1067 "" *)
     WITH t^.Ag DO
(* line 1067 "" *)
      
        WriteS (f, "FROM "); WI (iMain); WriteS (f, " IMPORT"); WriteNl (f);
      IF NOT IsElement (ORD ('<'), Options) THEN
        WI (iNoTree); WriteS (f, ", "); WI (itTree); WriteS (f, ", "); WI (iMain); WriteS (f, "Root, Make"); WI (iMain); WriteS (f, ", IsType,"); WriteNl (f);
      END;
        ForallClasses (Classes, ImportList);
      IF IsElement (ORD ('f'), Options) THEN
        WriteS (f, "Release"); WI (iModule); WriteS (f, ","); WriteNl (f);
      END;
      IF IsElement (ORD ('F'), Options) AND NOT IsElement (ORD ('<'), Options) THEN
        WriteS (f, "Release"); WI (iModule); WriteS (f, "Module,"); WriteNl (f);
      END;
      IF IsElement (ORD ('o'), Options) THEN
        WriteS (f, "Write"); WI (iModule); WriteS (f, "Node,"); WriteNl (f);
      END;
      IF IsElement (ORD ('w'), Options) THEN
        WriteS (f, "Write"); WI (iModule); WriteS (f, ","); WriteNl (f);
      END;
      IF IsElement (ORD ('r'), Options) THEN
        WriteS (f, "Read"); WI (iModule); WriteS (f, ","); WriteNl (f);
      END;
      IF IsElement (ORD ('p'), Options) THEN
        WriteS (f, "Put"); WI (iModule); WriteS (f, ","); WriteNl (f);
      END;
      IF IsElement (ORD ('g'), Options) THEN
        WriteS (f, "Get"); WI (iModule); WriteS (f, ","); WriteNl (f);
      END;
      IF IsElement (ORD ('t'), Options) THEN
        WriteS (f, "Traverse"); WI (iModule); WriteS (f, "TD,"); WriteNl (f);
      END;
      IF IsElement (ORD ('b'), Options) THEN
        WriteS (f, "Traverse"); WI (iModule); WriteS (f, "BU,"); WriteNl (f);
      END;
      IF IsElement (ORD ('R'), Options) THEN
        WriteS (f, "Reverse"); WI (iModule); WriteS (f, ","); WriteNl (f);
      END;
      IF IsElement (ORD ('y'), Options) THEN
        WriteS (f, "Copy"); WI (iModule); WriteS (f, ","); WriteNl (f);
      END;
      IF IsElement (ORD ('k'), Options) THEN
        WriteS (f, "Check"); WI (iModule); WriteS (f, ","); WriteNl (f);
      END;
      IF IsElement (ORD ('q'), Options) THEN
        WriteS (f, "Query"); WI (iModule); WriteS (f, ","); WriteNl (f);
      END;
      IF IsElement (ORD ('='), Options) THEN
        WriteS (f, "IsEqual"); WI (iModule); WriteS (f, ","); WriteNl (f);
      END;
      IF IsElement (ORD ('L'), Options) THEN
        WriteS (f, "Init"); WI (iModule); WriteS (f, ","); WriteNl (f);
      END;
        WriteS (f, "Begin"); WI (iModule); WriteS (f, ","); WriteNl (f);
        WriteS (f, "Close"); WI (iModule); WriteS (f, ";"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Class:
(* line 1121 "" *)
     WITH t^.Class DO
(* line 1121 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WI (Name); WriteS (f, ", "); 
      IF IsElement (ORD ('n'), Options) THEN
           WriteS (f, "n"); WI (Name); WriteS (f, ", "); 
      END;
      IF IsElement (ORD ('m'), Options) THEN
           WriteS (f, "m"); WI (Name); WriteS (f, ","); WriteNl (f);
      END;
      
      IF IsElement (ORD ('+'), Options) THEN
           WI (Name); WriteS (f, "Max,"); WriteNl (f);
      END;
      IF IsElement (ORD ('^'), Options) THEN
 
           WriteS (f, "p"); WI (Name); WriteS (f, ","); WriteNl (f);
      END;
      
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ImportList;

PROCEDURE ImportConst (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 1146 "" *)
     WITH t^.Class DO
(* line 1146 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WI (Name); WriteS (f, ", "); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END ImportConst;

PROCEDURE CompMaxBit (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1154 "" *)
     WITH t^.Class DO
(* line 1155 "" *)
      i := 1;
(* line 1156 "" *)
      ForallAttributes (t, CompMaxBit);
(* line 1157 "" *)
      MaxBit := Max (i, MaxBit);
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1159 "" *)
   LOOP
     WITH t^.Child DO
(* line 1161 "" *)
      IF NOT (({Input, Test, Dummy} * Properties = {})) THEN EXIT; END;
(* line 1162 "" *)
      INC (i);
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.Attribute:
(* line 1159 "" *)
   LOOP
     WITH t^.Attribute DO
(* line 1161 "" *)
      IF NOT (({Input, Test, Dummy} * Properties = {})) THEN EXIT; END;
(* line 1162 "" *)
      INC (i);
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  ELSE END;

 END CompMaxBit;

PROCEDURE BeginTreeMod1;
 BEGIN
(* line 56 "" *)
 ConstCount := 0; 

 END BeginTreeMod1;

PROCEDURE CloseTreeMod1;
 BEGIN

 END CloseTreeMod1;

PROCEDURE yyExit;
 BEGIN
  IO.CloseIO; System.Exit (1);
 END yyExit;

BEGIN
 yyf   := IO.StdOutput;
 Exit  := yyExit;
 BeginTreeMod1;
END TreeMod1.

