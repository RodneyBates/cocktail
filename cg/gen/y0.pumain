/* Modified Rodney M. Bates
  10-97 Removed unused import of TreeIO
*/


TRAFO GramYacc
TREE Tree
PUBLIC ParsSpec

GLOBAL {

FROM IO		IMPORT WriteS, WriteNl;
FROM StringMem	IMPORT WriteString;
FROM Idents	IMPORT NoIdent, tIdent;
FROM Texts	IMPORT WriteText;
FROM Sets	IMPORT IsElement, Include;

FROM Tree	IMPORT
   NoTree	, tTree		, Input		, Reverse	,
   Class	, NoClass	, Child		, Attribute	,
   ActionPart	, HasSelector	, HasAttributes	, NoCodeAttr	,
   Referenced	, Options	, TreeRoot	, QueryTree	,
   ClassCount	, iNoTree	, itTree	, iModule	,
   f		, WI, WN	, ForallClasses	, ForallAttributes,
   Nonterminal	, Terminal	, IdentifyAttribute,
   Generated	, String	;

IMPORT Strings;

VAR	Node		,
	ActClass	,
	TheClass	,
	TheAttr		: tTree;
	ActActionIndex	,
	PrevActionIndex	: SHORTCARD;
	IsImplicit	: BOOLEAN;

PROCEDURE GetBaseClass (Class: tTree): tTree;
   BEGIN
      WHILE Class^.Class.BaseClass^.Kind # NoClass DO
	 Class := Class^.Class.BaseClass;
      END;
      RETURN Class;
   END GetBaseClass;

PROCEDURE IsLast (Class, Action: tTree): BOOLEAN;
   VAR Found, Last: BOOLEAN;
   BEGIN
      IsLast2 (Class, Action, Found, Last);
      RETURN Last;
   END IsLast;

PROCEDURE IsLast2 (t, Action: tTree; VAR pFound, pLast: BOOLEAN);
   VAR Found, Last: BOOLEAN;
   BEGIN
      CASE t^.Kind OF
      | Class:
	    IsLast2 (t^.Class.Attributes, Action, pFound, pLast);
	    IF pFound OR NOT pLast THEN RETURN; END;
	    IsLast2 (t^.Class.BaseClass, Action, pFound, pLast);
      | Child:
	    IsLast2 (t^.Child.Next, Action, Found, Last);
	    pFound := Found;
	    IF Found THEN
	       pLast := Last;
	    ELSE
	       pLast := FALSE;
	    END;
      | Attribute:
	    IsLast2 (t^.Attribute.Next, Action, pFound, pLast);
      | ActionPart:
	    IsLast2 (t^.ActionPart.Next, Action, Found, Last);
	    pFound := Found OR (Action = t);
	    IF Found THEN
	       pLast := Last;
	    ELSE
	       pLast := Last AND (Action = t);
	    END;
      ELSE
	    pFound := FALSE;
	    pLast  := TRUE;
      END;
   END IsLast2;
}

PROCEDURE ParsSpec (t: Tree)

Ag (..) :- {
	WriteS (f, "%{"); WriteNl (f);
	WriteS (f, '# include "Scanner.h"'); WriteNl (f);
	WriteS (f, "/* EXPORT */"); WriteNl (f);
	WriteText (f, ParserCodes^.Codes.Export);
	Node := Modules;
	WHILE Node^.Kind = Tree.Module DO
	  WriteText (f, Node^.Module.ParserCodes^.Codes.Export);
	  Node := Node^.Module.Next;
	END;
	WriteS (f, "/* GLOBAL */"); WriteNl (f);
	WriteText (f, ParserCodes^.Codes.Global);
	Node := Modules;
	WHILE Node^.Kind = Tree.Module DO
	   WriteText (f, Node^.Module.ParserCodes^.Codes.Global);
	   Node := Node^.Module.Next;
	END;
	WriteS (f, "/* LOCAL */"); WriteNl (f);
	WriteText (f, ParserCodes^.Codes.Local);
	Node := Modules;
	WHILE Node^.Kind = Tree.Module DO
	  WriteText (f, Node^.Module.ParserCodes^.Codes.Local);
	  Node := Node^.Module.Next;
	END;
	WriteNl (f);
	WriteS (f, "void BeginParser ()"); WriteNl (f);
	WriteS (f, "{"); WriteNl (f);
	WriteText (f, ParserCodes^.Codes.Begin);
	Node := Modules;
	WHILE Node^.Kind = Tree.Module DO
	  WriteText (f, Node^.Module.ParserCodes^.Codes.Begin);
	  Node := Node^.Module.Next;
	END;
	WriteS (f, "}"); WriteNl (f);
	WriteNl (f);
	WriteS (f, "void CloseParser ()"); WriteNl (f);
	WriteS (f, "{"); WriteNl (f);
	WriteText (f, ParserCodes^.Codes.Close);
	Node := Modules;
	WHILE Node^.Kind = Tree.Module DO
	  WriteText (f, Node^.Module.ParserCodes^.Codes.Close);
	  Node := Node^.Module.Next;
	END;
	WriteS (f, "}"); WriteNl (f);
	WriteNl (f);
        ParsVariant (Classes);
	WriteS (f, "%}"); WriteNl (f);
	WriteNl (f);
	WriteS (f, "%union {"); WriteNl (f);
	WriteS (f, " tScanAttribute Scan;"); WriteNl (f);
	Node := Classes;
	WHILE Node^.Kind = Class DO
	  WITH Node^.Class DO
	     IF {Nonterminal, Referenced, HasAttributes} <= Properties THEN
	       IF (String IN Properties) AND NOT (HasSelector IN Properties) THEN
		 WriteS (f, " yy"); WN (Name); WriteS (f, " /* "); WI (Name); WriteS (f, " */ yy"); WN (Name); WriteS (f, ";"); WriteNl (f);
	       ELSE
		 WriteS (f, " yy"); WI (Selector); WriteS (f, " "); WI (Selector); WriteS (f, ";"); WriteNl (f);
	       END;
	     END;
	     Node := Next;
	  END;
	END;
	WriteS (f, "}"); WriteNl (f);
	WriteNl (f);
	WriteS (f, "%token"); WriteNl (f);
	ForallClasses (Classes, Token);
	WriteNl (f);
	PrecDefs (Precs);
	WriteNl (f);
	WriteS (f, "%%"); WriteNl (f);
	WriteNl (f);
	ForallClasses (Classes, ParsSpec);
}; .
Class (..) :- {
	IF {Nonterminal, Referenced} <= Properties THEN
	   TheClass := t;
	   Grammar (t);
	END;
}; .


PROCEDURE ParsVariant (t: Tree)

Class (..) :- {
	IF {Nonterminal, Referenced, HasAttributes} <= Properties THEN
	  WriteS (f, "typedef struct { "); 
	  ForallAttributes (Attributes, RecordField);
	  GenExt (Extensions);
          IF (String IN Properties) AND NOT (HasSelector IN Properties) THEN
	    WriteS (f, "} /* "); WI (Name); WriteS (f, " */ yy"); WN (Name); WriteS (f, ";"); WriteNl (f);
	  ELSE
	    WriteS (f, "} yy"); WI (Selector); WriteS (f, ";"); WriteNl (f);
	  END;
	END;
	ParsVariant (Next);
}; .


PROCEDURE GenExt (t: Tree)

Class (..) :- {
	ForallAttributes (Attributes, RecordField);
	GenExt (Extensions);
	GenExt (Next);
}; .


PROCEDURE Token (t: Tree)

Class (..) :- {
	IF {Terminal, Referenced} <= Properties THEN
	   WriteS (f, " "); WI (Name); WriteS (f, " "); WN (Code); WriteNl (f);
	END;
}; .


PROCEDURE RecordField (t: Tree)

Attribute (..) :- {
	IF (NoCodeAttr * Properties) = {} THEN 
	   WI (Type); WriteS (f, " "); WI (Name); WriteS (f, "; "); 
	END;
}; .


PROCEDURE PrecDefs (t: Tree)

LeftAssoc (..) :- {
	WriteS (f, "%left "); PrecDefs (Names); WriteNl (f);
	PrecDefs (Next);
}; .
RightAssoc (..) :- {
	WriteS (f, "%right"); PrecDefs (Names); WriteNl (f);
	PrecDefs (Next);
}; .
NonAssoc (..) :- {
	WriteS (f, "%none "); PrecDefs (Names); WriteNl (f);
	PrecDefs (Next);
}; .
Name (..) :- {
	WriteS (f, " "); WI (Name);
	PrecDefs (Next);
}; .


PROCEDURE Grammar (t: Tree)

Class (..) :- {
	IF Extensions^.Kind = Tree.NoClass THEN		(* Low ? *)
	   WITH TheClass^.Class DO
	      IF String IN Properties THEN WriteS (f, "yy"); WN (Name); ELSE WI (Name); END;
	   END;
	   WriteS (f, "	: "); 
	   ActClass := t;
	   PrevActionIndex := 0;
	   IsImplicit := FALSE;
	   ForallAttributes (t, Rule);
	   IF Prec # NoIdent THEN WriteS (f, "%prec "); WI (Prec); WriteS (f, " "); END;
	   WriteS (f, ";"); WriteNl (f);
	   PrevActionIndex := 0;
	   IsImplicit := TRUE;
	   ForallAttributes (t, Implicit);
	ELSE
	   Rule (Extensions);
	END;
}; .


PROCEDURE Rule (t: Tree)

Class (..) :- {
	Grammar (t);
	Rule (Next);
}; .
Child (..) :- {
	IF {String, Nonterminal} <= Class^.Class.Properties THEN WriteS (f, "yy"); WN (Type); ELSE WI (Type); END; WriteS (f, " "); 
}; .
ActionPart (..) :- {
      IF NOT IsElement (ORD ('v'), Options) THEN
	IF IsLast (ActClass, t) THEN
	   WriteS (f, "{"); 
	   IF PrevActionIndex # 0 THEN
	      Node := GetBaseClass (TheClass);
	      WITH Node^.Class DO
		 WriteS (f, " $$."); 
		 IF String IN Properties THEN WriteS (f, "yy"); WN (Name); ELSE WI (Name); END;
		 WriteS (f, " = $"); WN (PrevActionIndex); WriteS (f, "."); 
		 IF String IN Properties THEN WriteS (f, "yy"); WN (Name); ELSE WI (Name); END;
		 WriteS (f, ";"); WriteNl (f);
	      END;
	   END;
	   Rule (Actions);
	   WriteS (f, "} "); 
	ELSE
	   WriteS (f, "xx"); WN (Name); WriteS (f, " "); 
	END;
	PrevActionIndex := ParsIndex;
      END;
}; .
Assign (..) :- {
	Rule (Results); WriteS (f, "="); Rule (Arguments); WriteS (f, ";"); WriteNl (f);
	Rule (Next);
}; .
Copy (..) :- {
	Rule (Results); WriteS (f, " = "); Rule (Arguments); WriteS (f, ";"); WriteNl (f);
	Rule (Next);
}; .
TargetCode (..) :- {
	Rule (Code); WriteS (f, ";"); WriteNl (f);
	Rule (Next);
}; .
Order (..) :- {
	Rule (Next);
}; .
Check (..) :- {
	IF Statement # NoTree THEN
	   IF Condition # NoTree THEN
	      WriteS (f, "if ("); Rule (Condition); WriteS (f, ") ; else { "); Rule (Statement); WriteS (f, " }"); WriteNl (f);
	   ELSE
	      Rule (Statement);
	   END;
	END;
	Rule (Next);
}; .
Designator (..) :- {
	TheAttr := IdentifyAttribute (ActClass, Selector);
	IF TheAttr # NoTree THEN
	  Node := TheAttr^.Child.Class;
	  IF Node # NoTree THEN
	    WriteS (f, "$"); 
	    IF NOT IsImplicit THEN
	       WN (TheAttr^.Child.ParsIndex);
	    ELSE
	       WN (SHORTINT (TheAttr^.Child.ParsIndex + 1 - ActActionIndex));
	    END;
	    IF Nonterminal IN Node^.Class.Properties THEN	(* nonterminal *)
	      Node := GetBaseClass (Node);
	      IF (String IN Node^.Class.Properties) AND NOT (HasSelector IN Node^.Class.Properties) THEN
	        WriteS (f, ".yy"); WN (Node^.Class.Name);
	      ELSE
	        WriteS (f, "."); WI (Node^.Class.Name);
	      END;
	    ELSE						(* terminal *)
	      IF (String IN Node^.Class.Properties) AND NOT (HasSelector IN Node^.Class.Properties) THEN
	        WriteS (f, ".Scan.yy"); WN (Node^.Class.Code);
	      ELSE
	        WriteS (f, ".Scan."); WI (Node^.Class.Selector);
	      END;
	    END;
	    WriteS (f, "."); WI (Attribute);
	  ELSE
	    WI (Selector); WriteS (f, ":"); WI (Attribute);
	  END;
	ELSE
	  WI (Selector); WriteS (f, ":"); WI (Attribute);
	END;
	Rule (Next);
}; .
Ident (..) :- {
	TheAttr := IdentifyAttribute (ActClass, Attribute);
	Node := GetBaseClass (TheClass);
	IF TheAttr # NoTree THEN
	  IF (String IN Node^.Class.Properties) AND NOT (HasSelector IN Node^.Class.Properties) THEN
	    WriteS (f, "$$.yy"); WN (Node^.Class.Name); WriteS (f, "."); WI (Attribute);
	  ELSE
	    WriteS (f, "$$."); WI (Node^.Class.Name); WriteS (f, "."); WI (Attribute);
	  END;
	ELSE
	  WI (Attribute);
	END;
	Rule (Next);
}; .
Any (..) :- {
	WriteString (f, Code);
	Rule (Next);
}; .
Anys (..) :- {
	Rule (Layouts);
	Rule (Next);
}; .
LayoutAny (..) :- {
	WriteString (f, Code);
	Rule (Next);
}; .


PROCEDURE Implicit (t: Tree)

ActionPart (..) :- {
	IF NOT (Generated IN Properties) AND NOT IsLast (ActClass, t) THEN
	   INCL (Properties, Generated);
	   ActActionIndex := ParsIndex;
	   WriteS (f, "xx"); WN (Name); WriteS (f, "	: {"); 
	   IF PrevActionIndex # 0 THEN
	      Node := GetBaseClass (TheClass);
	      WITH Node^.Class DO
		 WriteS (f, " $$."); 
		 IF String IN Properties THEN WriteS (f, "yy"); WN (Name); ELSE WI (Name); END;
		 WriteS (f, " = $"); WN (SHORTINT (PrevActionIndex + 1 - ActActionIndex)); WriteS (f, "."); 
		 IF String IN Properties THEN WriteS (f, "yy"); WN (Name); ELSE WI (Name); END;
		 WriteS (f, ";"); WriteNl (f);
	      END;
	   END;
	   Rule (Actions);
	   WriteS (f, "} ."); WriteNl (f);
	END;
	PrevActionIndex := ParsIndex;
}; .

