
(* file ada2.puma *) 

(* Ada generation of Tree io, etc. 
   Rodney M. Bates Jul 2000  
   Extensively modified from file MThree2.puma, which had these header comments:  
     Extensively modified from file mod2.puma, which had these header comments:  
       (* Ich, Doktor Josef Grosch, Informatiker, 26.1.1989 *)
       (* Modified Rodney M. Bates: 
          RMB Dec 1995: Made tree writer reduce the amount of space on the
                        left of deeply indented lines by replacing whole
                        multiples of yyIndentFactor (initially = 20) blanks
                        by a modula-2 style comment containing a count of 
                        the blanks replaced. 

       END of mod2.puma changelog. *)
     Dec 1997 Added <*LINE...*> pragma output with -# option  
     Jan 1999 Added html tree dumper generation 
     Jan 1999 Added cases to Mark, WriteTREEm and WriteTREEHtml to follow 
              LINK Attributes 
     Jan 1999 changed procedure name yWriteNode to yyyWriteNode, to avoid
              possible conflict with yWrite<Class>, where <Class> = "Node"
  END of MThree2.puma changelog. *)

(* ada2.puma changelog: 

  Rodney M. Bates Jul 2000.  Initial creation from MThree2.puma

*) 

TRAFO TreeAda2
TREE Tree
PUBLIC TreeIO TreeIOInit GetIterator 

EXPORT  {
FROM Positions  IMPORT tPosition;

VAR Iterator    : Tree.tTree;

PROCEDURE WriteLine (Line: tPosition);
}

GLOBAL  {

IMPORT Idents , Strings ; 
FROM IO         IMPORT WriteS, WriteNl;
FROM Sets       IMPORT IsElement , IsEmpty , Extract , Exclude ;
FROM Idents     IMPORT tIdent;
FROM Positions  IMPORT tPosition;
FROM Semantics IMPORT TypeCount ; 

FROM Tree       IMPORT
   NoTree       , tTree         , Options       , ClassCount    ,
   f            , WI    , WN    , iInteger      , itTree        ,
   iNoTree      , iModule       , iMain         , HasChildren   ,
   HasAttributes, NoCodeAttr    , NoCodeClass   , Link          , 
   ForallClassesExtensionsFirst, ForallAttributes, Reverse      ,
   TypeNames ;

VAR
   iClassName   : Idents . tIdent;
   sBOOLEAN     : Strings . tString;
   iBOOLEAN     : Idents . tIdent;
   RevChild     : tTree;

PROCEDURE WriteLine (Line: tPosition);
   BEGIN
      IF Line.Line # 0 THEN
         WriteS (f, "-- From line "); WN (Line.Line); WriteS (f, ' of file "'); WI (Line.File); WriteS (f, '"'); WriteNl (f);
         IF IsElement (ORD ('#'), Options) THEN 
           WriteS (f, "PRAGMA LINE ( "); WN (Line.Line); WriteS (f, ' , "'); WI (Line.File); WriteS (f, '" ) ; '); WriteNl (f);
         END; 
      END;
   END WriteLine;
} (* End of GLOBAL *) 

BEGIN { 

  Strings . ArrayToString ( "BOOLEAN" , sBOOLEAN ) ; 
  iBOOLEAN := Idents . MakeIdent ( sBOOLEAN ) ; 

} (* End of BEGIN *)  

PROCEDURE TreeIO (t: Tree)

Ag (..) 
  :- VAR LTypeId : tIdent ; 
      {
        WriteNl (f);
      IF IsElement (ORD ('w'), Options) 
         OR IsElement (ORD ('w'), Options) THEN 
        WriteS (f, "yyf : Text_Io . File_Type ; "); WriteNl (f);
(* ^This won't work, as Text_Io . File_Type is LIMITED PRIVATE. *) 
      END; 
      IF IsElement (ORD ('r'), Options) THEN 
(* These are used only by the Ascii reader, which is  not generated for Ada.
        WriteS (f, "yyLabel : NATURAL ; "); WriteNl (f);
        WriteS (f, "yyKind : NATURAL ; "); WriteNl (f);
        WriteS (f, "yyc : CHARACTER ; "); WriteNl (f);
*)
      END;  
        WriteNl (f);
      IF IsElement (ORD (','), Options) THEN
        WriteS (f, "PROCEDURE yyMark  ( Tree : "); WI (itTree); WriteS (f, " ) "); WriteNl (f);
        WriteS (f, "IS "); WriteNl (f);
        WriteS (f, "  yyt : "); WI ( itTree ) ; WriteS (f, " := Tree ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "BEGIN "); WriteNl (f);
        WriteS (f, "  LOOP"); WriteNl (f);
        WriteS (f, "    IF yyt = "); WI (iNoTree); WriteS (f, " THEN RETURN ; END IF ;"); WriteNl (f);
        WriteS (f, "    yyt . ALL . yyHead . yyMark := yyt . ALL . yyHead . yyMark + 1 ; "); WriteNl (f);
        WriteS (f, "    IF yyt . ALL . yyHead . yyMark > 1 THEN RETURN ; END IF ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "    CASE yyt . ALL . Kind IS"); WriteNl (f);
        Mark ( Classes ) ; 
        WriteS (f, "    WHEN OTHERS => RETURN ; "); WriteNl (f);
        WriteS (f, "    END CASE ; "); WriteNl (f);
        WriteS (f, "  END LOOP ;"); WriteNl (f);
        WriteS (f, "END yyMark ;"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD (';'), Options) THEN
        WriteS (f, "yyInitTreeStoreSize : CONSTANT := 32 ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "TYPE yytTreeStore IS ARRAY ( INTEGER RANGE <> ) OF "); WI (itTree); WriteS (f, " ; "); WriteNl (f);
        WriteS (f, "TYPE yytTreeStorePtr IS ACCESS yytTreeStore ; "); 
        WriteNl (f);
        WriteS (f, "yyTreeStorePtr : yytTreeStorePtr := NULL ; "); WriteNl (f);
        WriteS (f, "yyLabelCount : NATURAL := 0 ; "); WriteNl (f);
        WriteS (f, "yyInitialTreeStoreCount : CONSTANT NATURAL := 2000 ; "); WriteNl (f);
        WriteS (f, "yyRecursionLevel : NATURAL ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "FUNCTION yyMapToLabel ( yyTree : "); WI (itTree); WriteS (f, " ) RETURN NATURAL "); WriteNl (f);
        WriteS (f, "IS "); WriteNl (f);
        WriteS (f, "  yyi : NATURAL ; "); WriteNl (f);
        WriteS (f, "  LNewTreeStorePtr : yytTreeStorePtr ; "); WriteNl (f);
        WriteS (f, "BEGIN"); WriteNl (f);
        WriteS (f, "  FOR yyi IN 0 .. yyLabelCount - 1 "); WriteNl (f);
        WriteS (f, "  LOOP "); WriteNl (f);
        WriteS (f, "    IF yyTreeStorePtr . ALL ( yyi ) = yyTree THEN RETURN yyi ; END IF ; "); WriteNl (f);
        WriteS (f, "  END LOOP ; "); WriteNl (f);
        WriteS (f, "  IF yyTreeStorePtr = NULL "); WriteNl (f);
        WriteS (f, "  THEN "); WriteNl (f);
        WriteS (f, "    yyTreeStorePtr := NEW yytTreeStore ( 0 .. yyInitialTreeStoreCount - 1 ) ; "); WriteNl (f);
        WriteS (f, "  END IF ; "); WriteNl (f);
        WriteS (f, "  IF yyLabelCount = yyTreeStorePtr . ALL __ADA_TICK__ LENGTH "); WriteNl (f);
        WriteS (f, "  THEN "); WriteNl (f);
        WriteS (f, "     LNewTreeStorePtr "); WriteNl (f);
        WriteS (f, "       := NEW yytTreeStore ( 0 .. yyTreeStorePtr . ALL __ADA_TICK__ LENGTH * 2 - 1 ) ;"); WriteNl (f);
        WriteS (f, "     LNewTreeStorePtr . ALL ( yyTreeStorePtr . ALL __ADA_TICK__ RANGE ) "); WriteNl (f);
        WriteS (f, "       := yyTreeStorePtr . ALL ; "); WriteNl (f);
        WriteS (f, "     yyTreeStorePtr := LNewTreeStorePtr ; "); WriteNl (f);
        WriteS (f, "  END IF ; "); WriteNl (f);
        WriteS (f, "  yyi := yyLabelCount ; "); WriteNl (f);
        WriteS (f, "  yyTreeStorePtr . ALL ( yyi ) := yyTree ; "); WriteNl (f);
        WriteS (f, "  yyLabelCount := yyLabelCount + 1 ; "); WriteNl (f);
        WriteS (f, "  RETURN yyi ;"); WriteNl (f);
        WriteS (f, " END yyMapToLabel ; "); WriteNl (f);
        WriteNl (f);
       IF IsElement (ORD ('r'), Options) THEN 
(* This is used only by the Ascii reader, which is  not generated for Ada.
        WriteS (f, "PROCEDURE yyMapToTree ( yyLabel : NATURAL ) : "); WI (itTree); WriteNl (f);
        WriteS (f, "=BEGIN RETURN yyTreeStorePtr ^ [ yyLabel ] ; END yyMapToTree ;"); WriteNl (f);
        WriteNl (f);
*) 
       END;
      END;
      IF IsElement (ORD ('w'), Options) OR
         IsElement (ORD ('^'), Options) OR
         IsElement (ORD ('o'), Options) THEN
        WriteS (f, 'PROCEDURE yyWriteNl IS BEGIN Text_Io . Put_Line ( "" ) ; END yyWriteNl ; '); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyWriteSelector ( yys : STRING ) "); WriteNl (f);
        WriteS (f, "IS "); WriteNl (f);
        WriteS (f, "  SUBTYPE LPadSt IS STRING ( 1 .. 16 - yys __ADA_TICK__ LENGTH ) ; "); WriteNl (f);
        WriteS (f, "BEGIN "); WriteNl (f);
        WriteS (f, "  Text_Io . Put ( yys ) ; "); WriteNl (f);
        WriteS (f, "  Text_Io . Put ( LPadSt __ADA_TICK__ ( OTHERS => ' ' ) ) ; "); WriteNl (f);
        WriteS (f, '  Text_Io . Put ( " = " ) ; '); WriteNl (f);
        WriteS (f, "END yyWriteSelector ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "LittleEndian : BOOLEAN := TRUE ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "TYPE Byte IS RANGE 0 .. 255 ; "); WriteNl (f);
        WriteS (f, "TYPE Bytes IS ARRAY ( INTEGER RANGE <> ) OF BYTE ; "); WriteNl (f);
        WriteS (f, "PACKAGE BYTE_Text_Io IS NEW Text_Io . Integer_Io ( BYTE ) ; "); WriteNl (f);
        WriteS (f, ""); 
        WriteS (f, "PROCEDURE yyWriteHex ( yyx : Bytes ) "); WriteNl (f);
        WriteS (f, "IS BEGIN"); WriteNl (f);
        WriteS (f, "  IF LittleEndian"); WriteNl (f);
        WriteS (f, "  THEN"); WriteNl (f);
        WriteS (f, "    FOR yyi IN REVERSE yyx __ADA_TICK__ RANGE LOOP "); WriteNl (f);
        WriteS (f, "      Byte_Text_Io . Put ( yyx ( yyi ) , 2 , 16 ) ; "); WriteNl (f);
     (* WriteS (f, "      Text_Io . Put (' ' ) ;"); *) 
        WriteS (f, "    END LOOP ; "); WriteNl (f);
        WriteS (f, "  ELSE"); WriteNl (f);
        WriteS (f, "    FOR yyi IN yyx __ADA_TICK__ RANGE LOOP "); WriteNl (f);
        WriteS (f, "      Byte_Text_Io . Put ( yyx ( yyi ) , 2 , 16 ) ; "); WriteNl (f);
     (* WriteS (f, "      Text_Io . Put (' ' ) ;"); *) 
        WriteS (f, "    END LOOP ; "); WriteNl (f);
        WriteS (f, "  END IF ; "); WriteNl (f);
        WriteS (f, "END yyWriteHex ;"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('o'), Options) 
         OR IsElement (ORD ('^'), Options) THEN
        WriteS (f, "SUBTYPE "); WI ( itTree ) ; WriteS (f, "Bytes IS Bytes ( 1 .. "); WI ( itTree ) ; WriteS (f, " __ADA_TICK__ Size / 8 ) ; "); WriteNl (f);
        WriteS (f, "FUNCTION "); WI(itTree); WriteS (f, "ToBytes IS NEW Unchecked_Conversion "); WriteNl (f);
        WriteS (f, "  ( "); WI (itTree); WriteS (f, " , "); WI ( itTree ) ; WriteS (f, "Bytes ) ; "); 
        WriteNl (f);
        WriteS (f, "PROCEDURE yyWriteAdr ( yyt : "); WI (itTree); WriteS (f, " ) "); WriteNl (f);
        WriteS (f, "IS BEGIN "); WriteNl (f);
        WriteS (f, "  IF yyt = "); WI (iNoTree); WriteS (f, " THEN "); WriteNl (f);
        WriteS (f, '   Text_Io . Put ("'); WI (iNoTree); WriteS (f, '" ) ; '); WriteNl (f);
        WriteS (f, "  ELSE "); WriteNl (f);
        WriteS (f, "   yyWriteHex ( "); WI(itTree); WriteS (f, "ToBytes ( yyt ) ) ;"); WriteNl (f);
        WriteS (f, "  END IF ; "); WriteNl (f);
        WriteS (f, "  yyWriteNl ;"); WriteNl (f);
        WriteS (f, "END yyWriteAdr ; "); WriteNl (f);
        WriteNl (f);
	IF itTree <= TypeCount THEN Exclude (TypeNames, itTree); END;
	WHILE NOT IsEmpty (TypeNames) DO
	  LTypeId := Extract (TypeNames);
        WriteS (f, "SUBTYPE "); WI ( LTypeId ) ; WriteS (f, "Bytes IS Bytes ( 1 .. "); WI ( LTypeId ) ; WriteS (f, " __ADA_TICK__ Size / 8 ) ; "); WriteNl (f);
          WriteS (f, "FUNCTION "); WI ( LTypeId ) ; WriteS (f, "ToBytes IS NEW Unchecked_Conversion "); WriteNl (f);
          WriteS (f, "  ( "); WI ( LTypeId ) ; WriteS (f, " , "); WI ( LTypeId ) ; WriteS (f, "Bytes ) ; "); WriteNl (f);
          WriteNl (f);
        END (* WHILE *) ; 
      END;
      IF IsElement (ORD ('o'), Options) THEN 
        ForallClassesExtensionsFirst (Classes, WriteNode);
        WriteS (f, "PROCEDURE Write"); WI (iModule); WriteS (f, "Node "); WriteNl (f);
        WriteS (f, " ( Tree : "); WI (itTree); WriteS (f, " ) "); WriteNl (f);
        WriteS (f, "IS BEGIN"); WriteNl (f);
        WriteS (f, "  IF Tree = "); WI (iNoTree); WriteS (f, " THEN "); WriteNl (f);
        WriteS (f, '    Text_Io . Put ( "'); WI (iNoTree); WriteS (f, '" ) ; yyWriteNl ; RETURN ; '); WriteNl (f);
        WriteS (f, "  END IF ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  CASE Tree . ALL . Kind IS "); WriteNl (f);
        WriteNodeName ( Classes ) ;
        WriteS (f, "  WHEN OTHERS => NULL ; "); WriteNl (f);
        WriteS (f, "  END CASE ;"); WriteNl (f);
        WriteS (f, "END Write"); WI (iModule); WriteS (f, "Node ;"); WriteNl (f);
        WriteNl (f);
      END;
      (* Generate ascii writer, original Cocktail format *) 
      IF IsElement (ORD ('w'), Options) THEN
      (*WriteS (f, "VAR yyIndentLevel      : INTEGER ;"); WriteNl (f);
        WriteS (f, "VAR yyActualIndent , yyIndentQuotient , yyIndentRemainder : INTEGER ;"); WriteNl (f);
        WriteS (f, "CONST yyIndentFactor = 20 ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yySetIndentInfo ( ) "); WriteNl (f);
        WriteS (f, " =BEGIN "); WriteNl (f);
        WriteS (f, "   yyIndentQuotient := yyIndentLevel DIV yyIndentFactor ; "); WriteNl (f);
        WriteS (f, "   yyIndentRemainder := yyIndentLevel MOD yyIndentFactor ; "); WriteNl (f);
        WriteS (f, "   yyActualIndent "); WriteNl (f);
        WriteS (f, "     := 10 * ORD ( yyIndentQuotient > 0 ) "); WriteNl (f);
        WriteS (f, "        + yyIndentRemainder "); WriteNl (f);
        WriteS (f, "  END yySetIndentInfo ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE Write"); WI (iModule); WriteS (f, " ( f : Wr . T ; Tree : "); WI (itTree); WriteS (f, " ) "); WriteNl (f);
        WriteS (f, "=VAR yySaveLevel : INTEGER ;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  yyf := f ;"); WriteNl (f);
        WriteS (f, "  IF yyRecursionLevel = 0 THEN yyLabelCount := 0 END ;"); WriteNl (f);
        WriteS (f, "  INC ( yyRecursionLevel ) ;"); WriteNl (f);
        WriteS (f, "  yyMark ( Tree ) ;"); WriteNl (f);
        WriteS (f, "  yySaveLevel := yyIndentLevel ;"); WriteNl (f);
        WriteS (f, "  yyIndentLevel := 0 ;"); WriteNl (f);
        WriteS (f, "  yySetIndentInfo ( ) ; "); WriteNl (f);
        WriteS (f, "  yyWrite"); WI (iModule); WriteS (f, " ( Tree );"); WriteNl (f);
        WriteS (f, "  yyIndentLevel := yySaveLevel ;"); WriteNl (f);
        WriteS (f, "  yySetIndentInfo ( ) ; "); WriteNl (f);
        WriteS (f, "  DEC ( yyRecursionLevel ) ;"); WriteNl (f);
        WriteS (f, " END Write"); WI (iModule); WriteS (f, " ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyIndentSelector ( yys : TEXT )"); WriteNl (f);
        WriteS (f, "=BEGIN "); WriteNl (f);
        WriteS (f, "   IF yyIndentQuotient > 0 "); WriteNl (f);
        WriteS (f, "   THEN Text_Io . Put ('(' ) ; Text_Io . Put ('*' ) ;"); WriteNl (f);
        WriteS (f, "     Text_Io . Put (Fmt . Pad ( Fmt . Int ( yyIndentQuotient * yyIndentFactor ) , 6 ) ) ; "); WriteNl (f);
        WriteS (f, "     Text_Io . Put ('*' ) ; Text_Io . Put (')' ) ;"); WriteNl (f);
        WriteS (f, "   END ; "); WriteNl (f);
        WriteS (f, '   Text_Io . Put (Fmt . Pad ( "" , yyIndentRemainder ) ) ;'); WriteNl (f);
        WriteS (f, "   yyWriteSelector ( yys ) ; "); WriteNl (f);
        WriteS (f, " END yyIndentSelector ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyIndentSelectorTree ( yys : TEXT ; yyt : "); WI (itTree); WriteS (f, " )"); WriteNl (f);
        WriteS (f, "=BEGIN yyIndentSelector  ( yys ) ; write"); WI (itTree); WriteS (f, " (yyt) END yyIndentSelectorTree ;"); WriteNl (f);
        WriteNl (f);
        ForallClassesExtensionsFirst (Classes, WriteAttributes);
        WriteS (f, "PROCEDURE yyWrite"); WI (iModule); WriteS (f, " ( yyt : "); WI (itTree); WriteS (f, " )"); WriteNl (f);
        WriteS (f, "=VAR yyLevel : NATURAL ;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  yyLevel := yyIndentLevel ;"); WriteNl (f);
        WriteS (f, "  LOOP"); WriteNl (f);
        WriteS (f, "   IF yyt = "); WI (iNoTree); WriteS (f, " THEN"); WriteNl (f);
        WriteS (f, '    Text_Io . Put (" '); WI (iNoTree); WriteS (f, '" ) ; yyWriteNl  ; EXIT ; '); WriteNl (f);
        WriteS (f, "   ELSIF yyt . ALL . yyHead . yyMark = 0 THEN"); WriteNl (f);
        WriteS (f, "    Wr . PutChar ( yyf, '^') ;"); WriteNl (f);
        WriteS (f, "    Text_Io . Put (Fmt . Int ( yyMapToLabel ( yyt ) ) ) ; yyWriteNl  ; EXIT ;"); WriteNl (f);
        WriteS (f, "   ELSIF yyt . ALL . yyHead . yyMark > 1 THEN"); WriteNl (f);
        WriteS (f, "    yyWriteNl  ;"); WriteNl (f);
        WriteS (f, "    Text_Io . Put (Fmt . Pad ( Fmt . Int ( yyMapToLabel ( yyt ) ) , 6 ) ) ;"); WriteNl (f);
        WriteS (f, "    Text_Io . Put (':') ;"); WriteNl (f);
        WriteS (f, '    Text_Io . Put (Fmt . Pad ( "" , MAX ( 0 , yyActualIndent - 7 ) ) ) ;'); WriteNl (f);
        WriteS (f, "   ELSE"); WriteNl (f);
        WriteS (f, "    Text_Io . Put (' ' ) ;"); WriteNl (f);
        WriteS (f, "   END ;"); WriteNl (f);
        WriteS (f, "   yyt . ALL . yyHead . yyMark := 0 ;"); WriteNl (f);
        WriteS (f, "   INC ( yyIndentLevel , 2 ) ;"); WriteNl (f);
        WriteS (f, "   yySetIndentInfo ( ) ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "   CASE yyt . ALL . Kind IS"); WriteNl (f);
        WriteClassName ( Classes );
        WriteS (f, "   WHEN OTHERS => EXIT ;"); WriteNl (f);
        WriteS (f, "   END ;"); WriteNl (f);
        WriteS (f, "  END ;"); WriteNl (f);
        WriteS (f, "  yyIndentLevel := yyLevel ;"); WriteNl (f);
        WriteS (f, "  yySetIndentInfo ( ) ; "); WriteNl (f);
        WriteS (f, " END yyWrite"); WI (iModule); WriteS (f, " ;"); WriteNl (f);
        WriteS (f, "");*)
      END;
      (* Generate html dumper *) 
      IF IsElement (ORD ('^'), Options) THEN
        WriteS (f, "FUNCTION yyNodeTag ( yyt : "); WI ( itTree ) ; WriteS (f, " ) RETURN STRING "); WriteNl (f);
        WriteS (f, "IS BEGIN "); WriteNl (f);
        WriteS (f, "  IF yyt = NULL "); WriteNl (f);
        WriteS (f, '  THEN RETURN "NIL" ; '); WriteNl (f);
        WriteS (f, "  ELSE "); 
        WriteS (f, '    RETURN "Node" '); WriteS (f, "& INTEGER __ADA_TICK__ IMAGE ( yyMapToLabel ( yyt ) ) ; "); WriteNl (f);
        WriteS (f, "  END IF ; "); 
        WriteS (f, " END yyNodeTag ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "FUNCTION yyNodeKind ( yyt : "); WI ( itTree ) ; WriteS (f, " ) RETURN STRING "); WriteNl (f);
        WriteS (f, "IS BEGIN"); WriteNl (f);
        WriteS (f, "  IF yyt = "); WI (iNoTree); WriteNl (f);
        WriteS (f, "  THEN "); WriteNl (f);
        WriteS (f, '    RETURN "NIL"  ; '); WriteNl (f);
        WriteS (f, "  ELSE"); WriteNl (f);
        WriteS (f, "    CASE yyt . ALL . Kind IS "); WriteNl (f);
        NodeKinds ( Classes ) ; 
        WriteS (f, "    WHEN OTHERS => "); 
        WriteS (f, '      RETURN "<Unknown>" ; '); WriteNl (f);
        WriteS (f, "    END CASE ; "); WriteNl (f);
        WriteS (f, "   END IF ; "); WriteNl (f);
        WriteS (f, "  END yyNodeKind ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE Write"); WI (iModule); WriteS (f, "Html "); WriteNl (f);
        WriteS (f, '  ( f : Text_Io . File_Type ; Tree : '); WI (itTree); WriteS (f, ' ; Title : STRING := "" '); WriteNl (f);
        WriteS (f, "  ; SuppressNullFields : BOOLEAN := FALSE ) "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "IS "); WriteNl (f);
        WriteS (f, '  IndentString : CONSTANT STRING := "  " ; '); 
        WriteNl (f);
        WriteS (f, "  PROCEDURE WriteChildOrLink "); WriteNl (f);
        WriteS (f, "    ( Name , TypeName : STRING ; Value : "); WI ( itTree ) ; WriteS (f, " ; IsLink : BOOLEAN := FALSE ) "); WriteNl (f);
        WriteS (f, "  IS "); WriteNl (f);
        WriteS (f, "   LNodeTag : STRING := yyNodeTag ( Value ) ; "); WriteNl (f);
        WriteS (f, "  BEGIN "); WriteNl (f);
        WriteS (f, "   IF Value /= NULL OR NOT SuppressNullFields "); 
        WriteS (f, "   THEN "); WriteNl (f);
        WriteS (f, "    Text_Io . Put ( IndentString ) ; "); WriteNl (f);
        WriteS (f, "    Text_Io . Put ( Name ) ; "); WriteNl (f);
        WriteS (f, '    Text_Io . Put ( " : " ) ; '); WriteNl (f);
        WriteS (f, "    Text_Io . Put ( TypeName ) ; "); WriteNl (f);
        WriteS (f, "    IF IsLink "); WriteNl (f);
        WriteS (f, "    THEN "); WriteNl (f);
        WriteS (f, '      Text_Io . Put ( " LINK" ) ; '); WriteNl (f);
        WriteS (f, "    END IF ; "); WriteNl (f);
        WriteS (f, '    Text_Io . Put ( " = " ) ; '); WriteNl (f);
        WriteS (f, '    Text_Io . Put ( "<a href=__ADA_DQUOTE_IN_STRING__#" ) ; '); WriteNl (f);
        WriteS (f, "    Text_Io . Put ( LNodeTag ) ; "); WriteNl (f);
        WriteS (f, '    Text_Io . Put ( "__ADA_DQUOTE_IN_STRING__>REF " ) ; '); WriteNl (f);
        WriteS (f, "    Text_Io . Put ( LNodeTag ) ; "); WriteNl (f);
        WriteS (f, '    Text_Io . Put ( "(" ) ; '); WriteNl (f);
        WriteS (f, "    yyWriteAdr ( Value ) ; "); WriteNl (f);
        WriteS (f, '    Text_Io . Put ( ")" ) ; '); WriteNl (f);
        WriteS (f, "    Text_Io . Put ( yyNodeKind ( Value ) ) ; "); WriteNl (f);
        WriteS (f, '    Text_Io . Put ( "</a>" ) ; '); WriteNl (f);
        WriteS (f, "    yyWriteNl ; "); WriteNl (f);
        WriteS (f, "   END IF ; "); 
        WriteS (f, "  END WriteChildOrLink ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  PROCEDURE WriteBOOLEANAttribute "); WriteNl (f);
        WriteS (f, "    ( Name : STRING ; Value : BOOLEAN ) "); WriteNl (f);
        WriteS (f, "  IS BEGIN "); WriteNl (f);
        WriteS (f, "   IF Value OR NOT SuppressNullFields "); 
        WriteS (f, "   THEN "); WriteNl (f);
        WriteS (f, "    Text_Io . Put ( IndentString ) ; "); WriteNl (f);
        WriteS (f, "    Text_Io . Put ( Name ) ; "); WriteNl (f);
        WriteS (f, '    Text_Io . Put ( " : " ) ; '); WriteNl (f);
        WriteS (f, '    Text_Io . Put ( "BOOLEAN = " ) ; '); 
        WriteS (f, "    writeBOOLEAN ( Value ) "); 
        WriteS (f, "    yyWriteNl  ; "); WriteNl (f);
        WriteS (f, "   END IF ; "); 
        WriteS (f, "  END WriteBOOLEANAttribute ; "); WriteNl (f);
        WriteNl (f);
     (* WriteS (f, " PROCEDURE WriteAttributeHeader "); WriteNl (f);
        WriteS (f, "   ( Name , Type : TEXT ) "); WriteNl (f);
        WriteS (f, " =BEGIN "); WriteNl (f);
        WriteS (f, "   Text_Io . Put (IndentString ) ; "); WriteNl (f);
        WriteS (f, "   Text_Io . Put (Name ) ; "); WriteNl (f);
        WriteS (f, '   Text_Io . Put (" : " ) ; '); WriteNl (f);
        WriteS (f, "   Text_Io . Put (Type ) ; "); WriteNl (f);
        WriteS (f, '   Text_Io . Put (" = " ) ; '); WriteNl (f);
        WriteS (f, "  END WriteAttributeHeader ; "); WriteNl (f);
        WriteS (f, ""); *) 
        ForallClassesExtensionsFirst ( Classes , WriteHtmlNodes ) ;
        WriteS (f, " PROCEDURE WriteHtmlRecurse ( Tree : "); WI ( itTree ) ; WriteS (f, " ) "); WriteNl (f);
        WriteS (f, " IS "); WriteNl (f);
        WriteS (f, "   yyt : "); WI ( itTree ) ; WriteS (f, " := Tree ; "); WriteNl (f);
        WriteS (f, " BEGIN "); WriteNl (f);
        WriteS (f, "   LOOP "); WriteNl (f);
        WriteS (f, "    IF yyt = "); WI (iNoTree); WriteS (f, " OR ELSE yyt . ALL . yyHead . yyMark = 0"); WriteNl (f);
        WriteS (f, "    THEN "); WriteNl (f);
        WriteS (f, "     EXIT ; "); WriteNl (f);
        WriteS (f, "    ELSE "); WriteNl (f);
        WriteS (f, "     yyt . ALL . yyHead . yyMark := 0 ; "); WriteNl (f);
        WriteS (f, "     CASE yyt . ALL . Kind IS "); WriteNl (f);
        WriteHtmlCases ( Classes );
        WriteS (f, "     WHEN OTHERS => EXIT ; "); WriteNl (f);
        WriteS (f, "     END CASE ; "); WriteNl (f);
        WriteS (f, "    END IF ; "); WriteNl (f);
        WriteS (f, "   END LOOP ; "); WriteNl (f);
        WriteS (f, " END WriteHtmlRecurse ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, " BEGIN -- Write"); WI (iModule); WriteS (f, "Html "); WriteNl (f);
        WriteS (f, "  Text_Io . Set_Output ( f ) ; "); WriteNl (f);
        WriteS (f, "  IF yyRecursionLevel = 0 THEN yyLabelCount := 0 ; END IF ; "); WriteNl (f);
        WriteS (f, "  yyRecursionLevel := yyRecursionLevel + 1 ; "); WriteNl (f);
        WriteS (f, "  yyMark ( Tree ) ; "); WriteNl (f);
        WriteS (f, '  Text_Io . Put ( "<html> " ) ; yyWriteNl  ; '); 
        WriteS (f, '  Text_Io . Put ( "<head>" ) ; yyWriteNl  ; '); 
        WriteS (f, '  Text_Io . Put ( "<title>" ) ; '); 
        WriteS (f, '  Text_Io . Put ( "Tree """ ) ; '); 
        WriteS (f, '  Text_Io . Put ( Title ) ; '); 
        WriteS (f, '  Text_Io . Put ( """</title>" ) ; yyWriteNl  ; '); 
        WriteS (f, '  Text_Io . Put ( "</head>" ) ; yyWriteNl  ; '); 
        WriteS (f, '  Text_Io . Put ( "<body>" ) ; yyWriteNl  ; '); 
        WriteS (f, '  Text_Io . Put ( "<pre>" ) ; yyWriteNl  ; '); 
        WriteS (f, "  yyWriteNl  ; "); WriteNl (f);
        WriteS (f, "  WriteHtmlRecurse ( Tree ) ; "); WriteNl (f);
        WriteS (f, '  Text_Io . Put ( "</pre>" ) ; yyWriteNl  ; '); 
        WriteS (f, '  Text_Io . Put ( "</body>" ) ; yyWriteNl  ; '); 
        WriteS (f, '  Text_Io . Put ( "</html>" ) ; yyWriteNl  ; '); 
        WriteS (f, "  yyRecursionLevel := yyRecursionLevel - 1;"); WriteNl (f);
        WriteS (f, " END Write"); WI (iModule); WriteS (f, "Html ; "); WriteNl (f);
        WriteNl (f);
      END;
(* Ascii reader not generated for Ada.  
      IF IsElement (ORD ('r'), Options) THEN 
        WriteS (f, "PROCEDURE Read"); WI (iModule); WriteS (f, "        (f: Rd.T): "); WI (itTree); WriteS (f, ";"); WriteNl (f);
        WriteS (f, " VAR yyt       : "); WI (itTree); WriteS (f, ";"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  yyf := f;"); WriteNl (f);
        WriteS (f, "  IF yyRecursionLevel = 0 THEN yyLabelCount := 0; END;"); WriteNl (f);
        WriteS (f, "  INC (yyRecursionLevel);"); WriteNl (f);
        WriteS (f, "  IF NOT yyIsInitialized THEN"); WriteNl (f);
        WriteS (f, "   yyInitKindToIdent; yyIsInitialized := TRUE;"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, "  yyRead"); WI (iModule); WriteS (f, " (SYSTEM.ADR (yyt));"); WriteNl (f);
        WriteS (f, "  DEC (yyRecursionLevel);"); WriteNl (f);
        WriteS (f, "  RETURN yyt;"); WriteNl (f);
        WriteS (f, " END Read"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyRead"); WI (iModule); WriteS (f, " (yyt: yyPtrtTree);"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  LOOP"); WriteNl (f);
        WriteS (f, "   CASE IO.ReadC (yyf) OF"); WriteNl (f);
        WriteS (f, "   | '^': yyLabel := IO.ReadI (yyf); yyReadNl; yyt^ := yyMapToTree (yyLabel); RETURN;"); WriteNl (f);
        WriteS (f, "   | 12C, '0': yyLabel := IO.ReadI (yyf); yyc := IO.ReadC (yyf);"); WriteNl (f);
        WriteS (f, "    Layout.SkipSpaces (yyf); Strings.ReadL (yyf, yys);"); WriteNl (f);
        WriteS (f, "    yyKind := yyMapToKind (yys); yyt^ := Make"); WI (iMain); WriteS (f, " (yyKind);"); WriteNl (f);
        WriteS (f, '    IF yyLabel # yyMapToLabel (yyt^) THEN Wr . PutText ( Text_Io . Standard_Output , "'); WI (iModule); WriteS (f, ': error in Read'); 
        WI (iModule); WriteS (f, '" ) ; Wr . PutText ( Text_Io . Standard_Output , Wr . EOL ) ; yyExit ; END ;'); WriteNl (f);
        WriteS (f, "   WHEN OTHERS =>"); WriteNl (f);
        WriteS (f, "    Layout.SkipSpaces (yyf); Strings.ReadL (yyf, yys);"); WriteNl (f);
        WriteS (f, "    yyKind := yyMapToKind (yys);"); WriteNl (f);
        WriteS (f, "    IF yyKind = 0 THEN yyt^ := "); WI (iNoTree); WriteS (f, "; RETURN; END;"); WriteNl (f);
        WriteS (f, "    yyt^ := Make"); WI (iMain); WriteS (f, " (yyKind);"); WriteNl (f);
        WriteS (f, "   END;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "   CASE yyKind OF"); WriteNl (f);
        ForallClassesExtensionsFirst (Classes, ReadAttributes);
        WriteS (f, "   WHEN OTHERS => RETURN;"); WriteNl (f);
        WriteS (f, "   END;"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, " END yyRead"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "VAR yyKindToIdent      : ARRAY [0 .. "); WN (ClassCount); WriteS (f, "] OF Idents.tIdent;"); WriteNl (f);
        WriteS (f, "VAR yyIsInitialized    : BOOLEAN;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyMapToKind (VAR yys: Strings.tString): NATURAL;"); WriteNl (f);
        WriteS (f, " VAR yyi       : Idents.tIdent;"); WriteNl (f);
        WriteS (f, " VAR yyk       : NATURAL;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  yyi := Idents.MakeIdent (yys);"); WriteNl (f);
        WriteS (f, "  FOR yyk := 0 TO "); WN (ClassCount); WriteS (f, " DO"); WriteNl (f);
        WriteS (f, "   IF yyKindToIdent [yyk] = yyi THEN RETURN yyk; END;"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, "  RETURN 0;"); WriteNl (f);
        WriteS (f, " END yyMapToKind;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyInitKindToIdent2 (yya: ARRAY OF CHAR; yyKind: NATURAL);"); WriteNl (f);
        WriteS (f, " VAR yys       : Strings.tString;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  Strings.ArrayToString (yya, yys);"); WriteNl (f);
        WriteS (f, "  yyKindToIdent [yyKind] := Idents.MakeIdent (yys);"); WriteNl (f);
        WriteS (f, " END yyInitKindToIdent2;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyInitKindToIdent;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  yyInitKindToIdent2 ('"); WI (iNoTree); WriteS (f, "', 0);"); WriteNl (f);
        ForallClassesExtensionsFirst (Classes, InitKindToIdent);
        WriteS (f, " END yyInitKindToIdent;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyReadNl; BEGIN IO.ReadNl (yyf); END yyReadNl;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyReadIdent (): Idents.tIdent;"); WriteNl (f);
        WriteS (f, " VAR yys       : Strings.tString;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  Strings.ReadL (yyf, yys);"); WriteNl (f);
        WriteS (f, "  IO.UnRead (yyf);"); WriteNl (f);
        WriteS (f, "  RETURN Idents.MakeIdent (yys);"); WriteNl (f);
        WriteS (f, " END yyReadIdent;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyReadHex (VAR yyx: ARRAY OF SYSTEM.BYTE);"); WriteNl (f);
        WriteS (f, " VAR yyi       : INTEGER;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  FOR yyi := 0 TO INTEGER (HIGH (yyx)) DO"); WriteNl (f);
        WriteS (f, "   yyx [yyi] := SYSTEM.BYTE (CHR (NATURAL (IO.ReadN (yyf, 16))));"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, " END yyReadHex;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yySkip;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  REPEAT UNTIL IO.ReadC (yyf) = '='; yyc := IO.ReadC (yyf);"); WriteNl (f);
        WriteS (f, " END yySkip;"); WriteNl (f);
        WriteNl (f);
      END;
*) 
      IF IsElement (ORD ('p'), Options) 
         OR IsElement (ORD ('g'), Options) THEN
      (*WriteS (f, "TYPE AtomSpecialTyp = Pickle . Special OBJECT"); WriteNl (f);
        WriteS (f, "  OVERRIDES"); WriteNl (f);
        WriteS (f, "    write := WriteAtom"); WriteNl (f);
        WriteS (f, "  ; read := ReadAtom"); WriteNl (f);
        WriteS (f, "  END ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE WriteAtom ( Self : AtomSpecialTyp ; r : REFANY ; wr : Pickle . Writer )"); WriteNl (f);
        WriteS (f, "  RAISES { Pickle . Error , Wr . Failure , Thread . Alerted }"); WriteNl (f);
        WriteS (f, "= VAR LText : TEXT := Atom . ToText ( NARROW ( r , Atom . T ) )"); WriteNl (f);
        WriteS (f, "      (* Why does M3 accept this without the NARROW? *) "); WriteNl (f);
        WriteS (f, "; VAR LLength : INTEGER := Text . Length ( LText )"); WriteNl (f);
        WriteS (f, "; BEGIN"); WriteNl (f);
        WriteS (f, "    wr . writeInt ( LLength ) "); WriteNl (f);
        WriteS (f, "  ; FOR i := 0 TO LLength "); WriteNl (f);
        WriteS (f, "    DO"); WriteNl (f);
        WriteS (f, "      Wr . PutChar ( wr . wr , Text . GetChar ( LText , i ) )"); WriteNl (f);
        WriteS (f, "    END (* FOR *) "); WriteNl (f);
        WriteS (f, "  END WriteAtom ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE ReadAtom "); WriteNl (f);
        WriteS (f, "  ( Self : AtomSpecialTyp ; rd : Pickle . Reader ; id : Pickle . RefID ) "); WriteNl (f);
        WriteS (f, "  : REFANY"); WriteNl (f);
        WriteS (f, "  RAISES { Pickle . Error , Rd . EndOfFile , Rd . Failure , Thread . Alerted }"); WriteNl (f);
        WriteS (f, "= VAR LLength : INTEGER := rd . readInt ( ) "); WriteNl (f);
        WriteS (f, "; VAR LChars : REF ARRAY OF CHAR := NEW ( REF ARRAY OF CHAR , LLength ) "); WriteNl (f);
        WriteS (f, "; BEGIN"); WriteNl (f);
        WriteS (f, "    FOR i := 0 TO LLength "); WriteNl (f);
        WriteS (f, "    DO "); WriteNl (f);
        WriteS (f, "      LChars ^ [ i ] := Rd . GetChar ( rd . rd )"); WriteNl (f);
        WriteS (f, "    END (* FOR *) "); WriteNl (f);
        WriteS (f, "  ; RETURN Atom . FromText ( Text . FromChars ( LChars ^ ) )"); WriteNl (f);
        WriteS (f, "  END ReadAtom ;"); WriteNl (f);
        WriteS (f, "");*)
      END; 
      IF IsElement (ORD ('p'), Options) THEN
      (*WriteS (f, "PROCEDURE Put"); WI (iModule); WriteS (f, " ( f : Wr . T ; Tree : "); WI (itTree); WriteS (f, " )"); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteS (f, "   Pickle . Write ( f , Tree )"); WriteNl (f);
        WriteS (f, " END Put"); WI (iModule); WriteS (f, " ;"); WriteNl (f);
        WriteS (f, "");*)
      END;
      IF IsElement (ORD ('g'), Options) THEN
      (*WriteS (f, "PROCEDURE Get"); WI (iModule); WriteS (f, " ( f : Rd . T ) : "); WI (itTree); 
        WriteS (f, "= BEGIN"); WriteNl (f);
        WriteS (f, "    RETURN NARROW ( Pickle . Read ( f ) , "); WI ( itTree ) ; WriteS (f, " )"); WriteNl (f);
        WriteS (f, "  END Get"); WI (iModule); WriteS (f, " ;"); WriteNl (f);
        WriteS (f, "");*)
      END;
}; .


PROCEDURE TreeIOInit (t: Tree)

Ag (..) :- {
      IF IsElement (ORD ('p'), Options) 
         OR IsElement (ORD ('g'), Options) THEN
        (*WriteS (f, "Pickle . RegisterSpecial ( NEW ( AtomSpecialTyp , sc := TYPECODE ( Atom . T ) ) ) ;");*)
      END; 
}; .


PROCEDURE WriteNodeName (t: Tree)

Class (..) :- {
        WriteNodeName ( Extensions ) ; 
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "  WHEN "); WI (Name); WriteS (f, " => "); WriteNl (f);
           WriteS (f, '    Text_Io . Put ( "Node of Kind '); WI (Name); WriteS (f, ':" ) ; yyWriteNl ; '); 
           IF ({HasChildren, HasAttributes} * Properties) # {} THEN
             WriteS (f, "    yyyWriteNode"); WI (Name); WriteS (f, " ( Tree ) ;"); WriteNl (f);
           END;
           WriteNl (f);
        END;
        WriteNodeName ( Next ) ; 
}; .


PROCEDURE WriteNode (t: Tree)

Class (..) :- {
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           WriteS (f, "PROCEDURE yyyWriteNode"); WI (Name); WriteS (f, " ( yyt : "); WI ( itTree ); WriteS (f, " )"); WriteNl (f);
           WriteS (f, "  IS BEGIN"); WriteNl (f);
           WriteNodeAttributes ( t ) ; 
           WriteS (f, "    NULL ; "); WriteNl (f);
           (* ^Just in case no statements generated. *) 
           WriteS (f, "  END yyyWriteNode"); WI (Name); WriteS (f, " ; "); WriteNl (f);
           WriteNl (f);
        END;
}; .

PROCEDURE WriteNodeAttributes (t: Tree)

NoClass ( ) :- . 

Class (..) :- {
        WriteNodeAttributes ( BaseClass ) ; 
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           iClassName := Name; 
           ForallAttributes (Attributes, WriteNodeAttributes);
        END;
}; .
Child (..) :- {
        WriteS (f, '    yyWriteSelector ( "'); WI (Name); WriteS (f, '" ) ; '); WriteNl (f);
        WriteS (f, "    yyWriteAdr ( yyt . ALL . "); WI ( iClassName ) ; 
               WriteS (f, " . "); WI (Name); WriteS (f, " ) ; "); WriteNl (f);
}; .
Attribute (..) :- {
        IF (NoCodeAttr * Properties) = {} THEN
         IF Link IN Properties 
         THEN
           WriteS (f, '    yyWriteSelector ( "'); WI (Name); WriteS (f, '" ) ; '); WriteNl (f);
           WriteS (f, "    yyWriteAdr ( yyt . ALL . "); WI ( iClassName ) ; 
                  WriteS (f, " . "); WI (Name); WriteS (f, " ) ; "); WriteNl (f);
         ELSE  
           WriteS (f, '    yyWriteSelector ( "'); WI (Name); WriteS (f, '" ) ; write'); WI (Type);
           WriteS (f, "      ( yyt . ALL . "); WI ( iClassName ) ; 
                      WriteS (f, " . "); WI (Name) ; WriteS (f, " ) yyWriteNl  ; "); WriteNl (f);
         END; 
        END;
}; .


PROCEDURE Mark (t: Tree)

Class (..) :- {
        Mark ( Extensions ) ; 
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           WriteS (f, "    WHEN "); WI (Name); WriteS (f, " => "); WriteNl (f);
           GetIterator (t);
           iClassName := Name; 
           ForallAttributes (t, Mark);
           IF Iterator = NoTree THEN
              WriteS (f, "      RETURN ; "); WriteNl (f);
           ELSE
              WriteS (f, "      yyt := yyt . ALL . "); WI (iClassName); 
                       WriteS (f, " . "); WI (Iterator^.Child.Name); WriteS (f, " ; "); WriteNl (f);
           END;
        END;
        Mark ( Next ) ; 
}; .

Child (..) :- {
        IF t # Iterator THEN
           WriteS (f, "      yyMark ( yyt . ALL . "); WI (iClassName); WriteS (f, " . "); WI (Name); WriteS (f, " ) ; "); WriteNl (f);
        END;
}; .

Attribute (..) :- {
        IF Link IN Properties THEN
           WriteS (f, "      yyMark ( yyt . ALL . "); WI (iClassName); WriteS (f, " . "); WI (Name); WriteS (f, " ) ; "); WriteNl (f);
        END;
}; .

PROCEDURE WriteClassName (t: Tree)

Class (..) :- {
        WriteClassName ( Extensions ) ; 
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "   | "); WI (Name); WriteS (f, " ( TNode ) => "); WriteNl (f);
           IF ({HasChildren, HasAttributes} * Properties) # {} THEN
              WriteS (f, "       yWrite"); WI (Name); WriteS (f, " ( TNode ) ; "); WriteNl (f);
              GetIterator (t);
              IF Iterator = NoTree THEN
                WriteS (f, "       EXIT ;"); WriteNl (f);
              ELSE
                 WriteS (f, '       yyIndentSelector ( "'); WI (Iterator^.Child.Name); WriteS (f, '" ) ;'); 
                 WriteS (f, "       yyt := TNode . "); WI (Iterator^.Child.Name); WriteS (f, " ;"); WriteNl (f);
              END ;
           ELSE
              WriteS (f, '       Text_Io . Put ("'); WI (Name); WriteS (f, '" ) ; yyWriteNl  ; EXIT ;'); WriteNl (f);
           END;
        END;
        WriteClassName ( Next ) ; 
}; .

PROCEDURE WriteAttributes (t: Tree)

Class (..) :- {
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           WriteS (f, "PROCEDURE yWrite"); WI (Name); WriteS (f, " ( yyt : "); WI ( Name ); WriteS (f, " )"); WriteNl (f);
           WriteS (f, "=BEGIN"); WriteNl (f);
           WriteS (f, '  Text_Io . Put ("'); WI (Name); WriteS (f, '" ) ; yyWriteNl  ;'); WriteNl (f);
           GetIterator (t);
           iClassName := Name; (* unused, at present *) 
           ForallAttributes (t, WriteAttributes);
           WriteS (f, " END yWrite"); WI (Name); WriteS (f, " ;"); WriteNl (f);
           WriteNl (f);
        END;
}; .
Child (..) :- {
        IF t # Iterator THEN
           WriteS (f, '  yyIndentSelectorTree ( "'); WI (Name); WriteS (f, '" , yyt . '); WI (Name); WriteS (f, ' ) ;'); WriteNl (f);
        END;
}; .
Attribute (..) :- {
        IF (NoCodeAttr * Properties) = {} THEN 
         IF Link IN Properties 
         THEN
           WriteS (f, '  yyIndentSelectorTree ( "'); WI (Name); WriteS (f, '" , yyt . '); WI (Name); WriteS (f, ' ) ;'); WriteNl (f);
         ELSE 
           WriteS (f, '  yyIndentSelector ( "'); WI (Name); WriteS (f, '" ) ; '); 
           WriteS (f, "write"); WI (Type); WriteS (f, " ( yyt . "); WI (Name); WriteS (f, " ) yyWriteNl  ;"); WriteNl (f);
         END (* IF *) ; 
        END;
}; .

(* Html writer support routines *) 

PROCEDURE NodeKinds ( t : Tree ) 

Class ( .. ) 
:- { NodeKinds ( Extensions ) ; 
     IF ( NoCodeClass * Properties = { } ) 
     THEN
       WriteS (f, "    WHEN "); WI ( Name ) ; WriteS (f, ' => RETURN "'); WI ( Name ) ; WriteS (f, '" ; '); WriteNl (f);
     END (* IF *) ; 
     NodeKinds ( Next ) ; 
   } ; . 

PROCEDURE WriteHtmlNodes ( t : Tree ) 

Class ( .. ) 
:- { 
     IF ( NoCodeClass * Properties = { } ) 
     THEN
       WriteS (f, "  PROCEDURE Write"); WI ( Name ) ; WriteS (f, "Html ( TNode : tAst ) "); WriteNl (f);
       WriteS (f, "  IS "); WriteNl (f);
       WriteS (f, "    LNodeTag : STRING := yyNodeTag ( TNode ) ; "); WriteNl (f);
       WriteS (f, "  BEGIN "); WriteNl (f);
       WriteS (f, '    Text_Io . Put ( "<a name=__ADA_DQUOTE_IN_STRING__" ) ; '); WriteNl (f);
       WriteS (f, "    Text_Io . Put ( LNodeTag ) ; "); WriteNl (f);
       WriteS (f, '    Text_Io . Put ( "__ADA_DQUOTE_IN_STRING__>DEF " ) ; '); WriteNl (f);
       WriteS (f, "    Text_Io . Put ( LNodeTag ) ; "); WriteNl (f);
       WriteS (f, '    Text_Io . Put ( "(" ) ; '); WriteNl (f);
       WriteS (f, "    yyWriteAdr ( TNode ) ; "); WriteNl (f);
       WriteS (f, '    Text_Io . Put ( ")'); WI ( Name ) ; WriteS (f, '</a>" ) ; '); WriteNl (f);
       WriteS (f, "    yyWriteNl ; "); WriteNl (f);
       IF ( { HasChildren , HasAttributes } * Properties # { } ) 
       THEN 
         iClassName := Name; 
         ForallAttributes ( t , WriteHtmlNodes ) ; 
       END (* IF *) ; 
       WriteS (f, "    yyWriteNl ; "); WriteNl (f);
       WriteS (f, "  END Write"); WI ( Name ) ; WriteS (f, "Html ; "); WriteNl (f);
       WriteNl (f);
     END (* IF *) ; 
   } ; . 

Child ( .. ) 
:- { WriteS (f, '    WriteChildOrLink ( "'); WI ( Name ) ; WriteS (f, '" , "'); WI ( Type ) ; 
     WriteS (f, '" , TNode . ALL . '); WI ( iClassName ) ; WriteS (f, ' . '); WI ( Name ) ; WriteS (f, ' ) ; '); WriteNl (f);
   } ; . 

Attribute ( .. ) 
:- { IF (NoCodeAttr * Properties) = {} 
     THEN 
       IF Link IN Properties 
       THEN 
         WriteS (f, '    WriteChildOrLink ( "'); WI ( Name ) ; WriteS (f, '" , "'); WI ( Type ) ; 
         WriteS (f, '" , TNode . ALL . '); WI ( iClassName ) ; WriteS (f, ' . '); WI ( Name ) ; WriteS (f, ' , TRUE ) ; '); WriteNl (f);
       ELSIF Type = iBOOLEAN 
       THEN 
         WriteS (f, '    WriteBOOLEANAttribute ( "'); WI ( Name ) ; WriteS (f, '" , TNode . ALL . '); WI ( Name ) ; WriteS (f, ' ) ; '); WriteNl (f);
       ELSE
         WriteS (f, '    Text_Io . Put ( IndentString & "'); WI ( Name ) ; WriteS (f, ' : '); WI ( Type ) ; WriteS (f, ' = " ) ; '); WriteNl (f);
         WriteS (f, "    write"); WI ( Type ) ; WriteS (f, " ( TNode . ALL . "); WI ( iClassName ) ; WriteS (f, " . "); WI ( Name ) ; WriteS (f, " ) "); WriteNl (f);
         (* ^ No semicolon, as the write<type> macro expands to include it *) 
         WriteS (f, "    yyWriteNl ; "); WriteNl (f);
       END (* IF *) ; 
     END (* IF *) ; 
   } ; . 

PROCEDURE WriteHtmlCases ( t : Tree ) 

Class ( .. ) 
:- { WriteHtmlCases ( Extensions ) ; 
     IF ( NoCodeClass * Properties = { } ) 
     THEN
       WriteS (f, "     WHEN "); WI ( Name ) ; WriteS (f, " => "); WriteNl (f);
       WriteS (f, "         Write"); WI ( Name ) ; WriteS (f, "Html ( yyt ) ; "); WriteNl (f);
       IF ( { HasChildren , HasAttributes } * Properties # { } ) 
       THEN 
         GetIterator ( t ) ; 
         iClassName := Name; 
         ForallAttributes ( t , WriteHtmlCases ) ;  
         IF Iterator = NoTree THEN
           WriteS (f, "         EXIT ; "); WriteNl (f);
         ELSE
           WriteS (f, "         yyt := yyt . ALL . "); WI (iClassName); WriteS (f, " . "); WI ( Iterator ^ . Child . Name ) ; WriteS (f, " ; "); WriteNl (f);
         END;
       END (* IF *) 
     END (* IF *) ;  
     WriteHtmlCases ( Next ) ;  
   } ; . 

Child ( .. )  
:- { IF t # Iterator 
     THEN
         WriteS (f, "         WriteHtmlRecurse ( yyt . ALL . "); WI (iClassName); WriteS (f, " . "); WI ( Name ) ; WriteS (f, " ) ;"); WriteNl (f);
     END (* IF *) ; 
   } ; . 

Attribute ( .. )  
:- { IF Link IN Properties  
     THEN
         WriteS (f, "         WriteHtmlRecurse ( yyt . ALL . "); WI (iClassName); WriteS (f, " . "); WI ( Name ) ; WriteS (f, " ) ;"); WriteNl (f);
     END (* IF *) ; 
   } ; . 

(* Ascii reader not generated for M3.  Prefer to use Pickle. to avoid UNSAFE constructs which
   Ascii reader would need. 

PROCEDURE ReadAttributes (t: Tree)

Class (..) :- {
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           WriteS (f, "| "); WI (Name); WriteS (f, ":"); WriteNl (f);
           GetIterator (t);
           iClassName := Name;
           ForallAttributes (t, ReadAttributes);
           IF Iterator = NoTree THEN
              WriteS (f, "RETURN;"); WriteNl (f);
           ELSE
              WriteS (f, "yySkip; yyt := SYSTEM.ADR (yyt^^."); WI (iClassName); WriteS (f, "."); WI (Iterator^.Child.Name); WriteS (f, ");"); WriteNl (f);
           END;
        END;
}; .
Child (..) :- {
        IF t # Iterator THEN
           WriteS (f, "yySkip; read"); WI (itTree); WriteS (f, " (SYSTEM.ADR (yyt^^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, "))"); WriteNl (f);
        END;
}; .
Attribute (..) :- {
        IF (NoCodeAttr * Properties) = {} THEN 
           WriteS (f, "yySkip; read"); WI (Type); WriteS (f, " (yyt^^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ") yyReadNl;"); WriteNl (f);
        END;
}; .

PROCEDURE InitKindToIdent (t: Tree)

Class (..) :- {
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "  yyInitKindToIdent2 ('"); WI (Name); WriteS (f, "', "); WI (Name); WriteS (f, ");"); WriteNl (f);
        END;
}; .

*)


PROCEDURE GetIterator (t: Tree)

Class (..) :- {
        Iterator := NoTree;
        RevChild := NoTree;
        ForallAttributes (t, GetIterator);
        IF RevChild # NoTree THEN Iterator := RevChild; END;
}; .
Child (..) :- {
        Iterator := t;
        IF Reverse IN Properties THEN RevChild := t; END;
}; .


