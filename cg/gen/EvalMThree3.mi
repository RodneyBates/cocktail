
(* This file was mechanically generated by puma. *)

IMPLEMENTATION MODULE EvalMThree3;








IMPORT SYSTEM, System, IO, Tree;
(* line 20 "" *)


FROM SYSTEM     IMPORT ADR, TSIZE;
FROM General	IMPORT Max;
FROM DynArray	IMPORT MakeArray;
FROM IO		IMPORT WriteS, WriteNl, WriteI, WriteB, StdOutput;
FROM Texts	IMPORT WriteText;
FROM Sets	IMPORT tSet, MakeSet, ReleaseSet, Include, Exclude, Minimum,
			Maximum, IsElement, WriteSet, IsEmpty, Extract;
FROM Relations	IMPORT IsRelated;
FROM TreeMThree2	IMPORT GetIterator, Iterator, WriteLine;
FROM EvalMThree	IMPORT Class;
FROM Errors	IMPORT Error, Short, MessageI;
FROM Positions	IMPORT NoPosition;
IMPORT EvalMThree;

FROM Tree	IMPORT
   NoTree	, tTree		, Referenced	, NoCodeClass	,
   Computed	, Reverse	, Write		, Read		,
   Inherited	, Synthesized	, Input		, Output	,
   Virtual	, Test		, Left		, Right		,
   HasOutput	, NonBaseComp	, Dummy		, Trace		,
   Demand	, Funct		, NoClass	, Options	,
   TreeRoot	, iModule	, iMain		, itTree	,
   ForallClasses, ForallClassesExtensionsFirst  , ForallAttributes, 
   f		, WI	        , WN	        ,
   ClassCount	, IdentifyClass	, IdentifyAttribute, 
   tBitIndex	, tBitInfo	, iNoTree	, QueryTree	;

VAR
   i, i2, j, k, n, MaxBit, MaxInstCount, Check: SHORTCARD;
   Node, Attr, ChildsClass	: tTree;
   Success, IsStable		: BOOLEAN;
   BitIndexSize			: LONGINT;
   gBitIndex			: tBitIndex;
   InhIndices			: tSet;
   InhIndexSize			: LONGINT;
   InhIndexCount		: POINTER TO ARRAY [1..1000000] OF SHORTCARD;

PROCEDURE GenCall (t: tTree; j: SHORTCARD);
   BEGIN
      WITH t^.Class.Instance^ [j] DO
	 IF ({Synthesized, Left} <= Properties) THEN
	    k := ToBit0 (t, j);
	    WriteS (f, "      IFNOTIN ("); WN ( k ); WriteS (f, ", TNode . yyHead . yyIsComp ) "); 
	    WriteS (f, "yyS"); WN (k); WriteS (f, " ( TNode ) ; (* "); WI (Attribute^.Child.Name); WriteS (f, " *) END;"); WriteNl (f);
	 ELSIF ({Inherited, Left} <= Properties) THEN
	    k := ToBit0 (t, j);
	    WriteS (f, "      IFNOTIN ("); WN ( k ); WriteS (f, " , TNode . yyHead . yyIsComp ) "); 
   IF IsElement (ORD ('Z'), Options) AND (Trace IN t^.Class.Properties) THEN
	    WriteS (f, "      yyVisitParent ( TNode ) ; "); 
	    WriteS (f, "      yyI [ TNode . yyHead . yyOffset + "); WN (k); WriteS (f, " ] ( TNode . yyHead . yyParent ) ; (* "); 
	    WI (Attribute^.Child.Name); WriteS (f, " *) "); 
	    WriteS (f, '      yyWriteVisit ( TNode . yyHead . yyParent , "?") ; END ;'); WriteNl (f);
   ELSE
	    WriteS (f, "      yyI [ TNode . yyHead . yyOffset + "); WN (k); WriteS (f, " ] ( TNode . yyHead . yyParent ) ; (* "); 
	    WI (Attribute^.Child.Name); WriteS (f, " *) END ;"); WriteNl (f);
   END;
	 ELSIF ({Inherited, Right} <= Properties) THEN
	    k := ToBit1 (Selector, j - t^.Class.AttrCount - Selector^.Child.InstOffset);
	    WriteS (f, "      IFNOTIN ("); WN (k); WriteS (f, " , TNode . "); WI (Selector^.Child.Name); WriteS (f, " . yyHead.yyIsComp ) "); 
	    k := ToBit2 (t, Selector, j);
	    WriteS (f, "      yyI"); WN (k); WriteS (f, " ( TNode ) ; (* "); WI (Selector^.Child.Name);
	    WriteS (f, ":"); WI (Attribute^.Child.Name); WriteS (f, " *) END ;"); WriteNl (f);
	 ELSIF ({Synthesized, Right} <= Properties) THEN
	    k := ToBit1 (Selector, j - t^.Class.AttrCount - Selector^.Child.InstOffset);
	    WriteS (f, "      IFNOTIN ("); WN (k); WriteS (f, " , TNode . "); WI (Selector^.Child.Name); WriteS (f, " . yyHead . yyIsComp ) "); 
   IF IsElement (ORD ('Z'), Options) AND (Trace IN t^.Class.Properties) THEN
	    WriteS (f, '      yyWriteVisit ( TNode , "'); WI (Selector^.Child.Name); WriteS (f, '" ) ;'); WriteNl (f);
	    WriteS (f, "      yyS"); WN (k);
	    WriteS (f, " ( TNode . "); WI (Selector^.Child.Name);
	    WriteS (f, " ) ; (* "); WI (Selector^.Child.Name); WriteS (f, ":"); WI (Attribute^.Child.Name); WriteS (f, " *) "); 
	    WriteS (f, "      yyVisitParent ( TNode . "); WI (Selector^.Child.Name); WriteS (f, " ) ; END ;"); WriteNl (f);
   ELSE
	    WriteS (f, "      yyS"); WN (k);
	    WriteS (f, " ( TNode . "); WI (Selector^.Child.Name);
	    WriteS (f, " ) ; (* "); WI (Selector^.Child.Name); WriteS (f, ":"); WI (Attribute^.Child.Name); WriteS (f, " *) END ;"); WriteNl (f);
   END;
	 END;
      END;
   END GenCall;

PROCEDURE GenEvalAttr (t: tTree; i: INTEGER);
   BEGIN
      Class := t;
      WITH t^.Class.Instance^ [i] DO
   IF IsElement (ORD ('X'), Options) AND (Trace IN t^.Class.Properties) THEN
	 WriteS (f, '      yyWriteEval ( TNode , "'); WI (Attribute^.Child.Name); WriteS (f, '" ) ;'); WriteNl (f);
	 IF (Action # ADR (Action)) AND NOT (Virtual IN Properties) THEN
	    GenEvaluator (Action);
	    EvalMThree.GenEvaluator (Action); WriteNl (f);
	    IF Test IN Properties THEN
	       WriteS (f, "      writeBOOLEAN ( yyb ) yyWriteNl ( ) ;"); WriteNl (f);
	    ELSIF (Attribute^.Kind = Tree.Child) OR (Attribute^.Attribute.Type = itTree) THEN
	       WriteS (f, "      write"); WI (itTree);
	       WriteS (f, " ( TNode . "); WI (Attribute^.Child.Name); WriteS (f, " )"); WriteNl (f);
	    ELSE
	       WriteS (f, "      write"); WI (Attribute^.Child.Type);
	       WriteS (f, " ( TNode . "); WI (Attribute^.Child.Name); WriteS (f, " ) yyWriteNl ( ) ;"); WriteNl (f);
	    END;
	 ELSE
	    WriteS (f, "      yyWriteNl ( ) ;"); WriteNl (f);
	 END;
   ELSIF IsElement (ORD ('Y'), Options) AND (Trace IN t^.Class.Properties) THEN
	 WriteS (f, '      yyWriteEval ( TNode , "'); WI (Attribute^.Child.Name); WriteS (f, '") ;'); WriteNl (f);
	 IF (Action # ADR (Action)) AND NOT (Virtual IN Properties) THEN
	    GenEvaluator (Action);
	    EvalMThree.GenEvaluator (Action);
	 END;
   ELSE
	 IF (Action # ADR (Action)) AND NOT (Virtual IN Properties) THEN
	    GenEvaluator (Action);
	    EvalMThree.GenEvaluator (Action);
	 END;
   END;
      END;
   END GenEvalAttr;












































































































PROCEDURE yyAbort (yyFunction: ARRAY OF CHAR);
 BEGIN
  IO.WriteS (IO.StdError, 'Error: module EvalMThree3, routine ');
  IO.WriteS (IO.StdError, yyFunction);
  IO.WriteS (IO.StdError, ' failed');
  IO.WriteNl (IO.StdError);
  Exit;
 END yyAbort;

PROCEDURE yyIsEqual (yya, yyb: ARRAY OF SYSTEM.BYTE): BOOLEAN;
 VAR yyi       : INTEGER;
 BEGIN
  FOR yyi := 0 TO INTEGER (HIGH (yya)) DO
   IF yya [yyi] # yyb [yyi] THEN RETURN FALSE; END;
  END;
  RETURN TRUE;
 END yyIsEqual;

PROCEDURE EvalModule (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 2: yyR2: RECORD
  a: SHORTCARD;
  END;
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Ag:
(* line 141 "" *)
     WITH t^.Ag DO
(* line 141 "" *)
      
	MaxBit := 0;
	MaxInstCount := 0;
	ForallClasses (Classes, CompBitInfo);
	MakeSet (InhIndices, MaxInstCount);
	InhIndexSize := MaxInstCount;
	MakeArray (InhIndexCount, InhIndexSize, TSIZE (SHORTCARD));
	FOR i := 1 TO MaxInstCount DO InhIndexCount^ [i] := 0; END;
	ForallClasses (Classes, CompInhIndices);
	WriteS (f, "# define IFNOTIN(b, s) IF NOT ((b) IN (s)) THEN"); WriteNl (f);
	WriteS (f, "# define REMOTE_SYN(i, b, c, n, t, a) n.t.a"); WriteNl (f);
	WriteS (f, "# define REMOTE_INH(i, b, k, n, t, a) n.t.a"); WriteNl (f);
        WriteS (f, "# define INCLUDE(s, b) WITH yyTemp = ( s ) DO yyTemp := yyTemp + "); WI (iMain); WriteS (f, " . BitSet { b } END ;"); WriteNl (f);
	EvalMThree.EvalModuleHead (t);
	WriteNl (f);
	WriteS (f, "VAR yyI: ARRAY [0 .. "); WN (Maximum (InhIndices)); WriteS (f, "] OF "); WI (iMain); WriteS (f, ".tProcTree;"); WriteNl (f);
	WriteNl (f);
	WriteS (f, "PROCEDURE yyAbort (yyt: "); WI (iMain); WriteS (f, " . "); WI (itTree); WriteS (f, " )"); WriteNl (f);
	WriteS (f, "=BEGIN"); WriteNl (f);
	WriteS (f, '  Wr . PutText ( Stdio . Stderr, "Error: module '); WI (EvalName); WriteS (f, ', cyclic dependencies" ) ;'); WriteNl (f);
	WriteS (f, "  Wr . PutText ( Stdio . Stderr , Wr . EOL ) ;"); WriteNl (f);
	WriteS (f, "  "); WI (iMain); WriteS (f, " . yyExit ( ) ;"); WriteNl (f);
	WriteS (f, " END yyAbort;"); WriteNl (f);
	WriteNl (f);
      IF NOT IsElement (ORD ('9'), Options) THEN
	WriteNl (f);
	WriteS (f, "PROCEDURE Eval ( yyt : "); WI (iMain); WriteS (f, " . "); WI (itTree); WriteS (f, " )"); WriteNl (f);
	WriteS (f, "=BEGIN "); WI (iMain); WriteS (f, " . Init"); WI (iModule); WriteS (f, " ( yyt ) ; yyE ( yyt ) ; END Eval ;"); WriteNl (f);
      ELSE
	WriteNl (f);
	WriteS (f, "VAR xxStack : INTEGER ;"); WriteNl (f);
	WriteNl (f);
	WriteS (f, "PROCEDURE Eval ( yyt : "); WI (iMain); WriteS (f, " . "); WI (itTree); WriteS (f, " )"); WriteNl (f);
	WriteS (f, "= VAR xxHigh : BOOLEAN ;"); WriteNl (f);
	WriteS (f, "  BEGIN"); WriteNl (f);
	WriteS (f, "    xxStack := LAST ( INTEGER ) ;"); WriteNl (f);
	WriteS (f, "    "); WI (iMain); WriteS (f, " . Init"); WI (iModule); WriteS (f, " ( yyt ) ; yyE ( yyt ) ;"); WriteNl (f);
	WriteS (f, '    Wr . PutText ( Stdio . Stdout , "Stacksize " ) ;'); WriteNl (f);
	WriteS (f, "    Wr . PutText ( Stdio . Stdout"); WriteNl (f);
        WriteS (f, "               , Fmt . Int ( LOOPHOLE ( ADR ( xxHigh ) , INTEGER ) - xxStack ) ) ;"); WriteNl (f);
	WriteS (f, "    Wr . PutText ( Stdio . Stdout , Wr . EOL );"); WriteNl (f);
	WriteS (f, "  END Eval ;"); WriteNl (f);
      END;
	WriteNl (f);
	REPEAT IsStable := TRUE; ForallClasses (Classes, CompOutput); UNTIL IsStable;
	WriteS (f, "PROCEDURE yyE ( yyt : "); WI (iMain); WriteS (f, " . "); WI (itTree); WriteS (f, " ) ="); WriteNl (f);
	WriteLine (TreeRoot^.Ag.EvalCodes^.Codes.LocalLine);
	WriteText (f, TreeRoot^.Ag.EvalCodes^.Codes.Local);
	Node := TreeRoot^.Ag.Modules;
	WHILE Node^.Kind = Tree.Module DO
	   WriteLine (Node^.Module.EvalCodes^.Codes.LocalLine);
	   WriteText (f, Node^.Module.EvalCodes^.Codes.Local);
	   Node := Node^.Module.Next;
	END;
      IF IsElement (ORD ('9'), Options) THEN
	WriteS (f, "  VAR xxLow : BOOLEAN ;"); WriteNl (f);
	WriteS (f, "  BEGIN"); WriteNl (f);
        WriteS (f, "    xxStack := MIN ( xxStack , LOOPHOLE ( ADR ( xxLow ) , INTEGER ) ) ;"); WriteNl (f);

      ELSE
	WriteS (f, "  BEGIN"); WriteNl (f);
      END;
	WriteS (f, "   LOOP"); WriteNl (f);
	WriteS (f, "    IF ( yyt = "); WI (iMain); WriteS (f, " . "); WI (iNoTree); WriteS (f, " ) OR ( 0 IN yyt . yyHead . yyIsComp ) THEN RETURN ; END ;"); WriteNl (f);
	WriteS (f, "    INCLUDE ( yyt . yyHead . yyIsComp , 0 )"); WriteNl (f);
	WriteS (f, "    TYPECASE yyt OF"); WriteNl (f);
	ForallClassesExtensionsFirst (Classes, GenE);
	WriteS (f, "    ELSE RETURN ;"); WriteNl (f);
	WriteS (f, "    END ;"); WriteNl (f);
	WriteS (f, "   END ;"); WriteNl (f);
	WriteS (f, "  END yyE ;"); WriteNl (f);
	WriteNl (f);
	FOR i := 2 TO MaxBit DO
	   n := 0;			
	   ForallClasses (Classes, CountSynAttr);
	   IF n > 0 THEN
	      WriteS (f, "PROCEDURE yyS"); WN (i - 1); WriteS (f, " ( yyt : "); WI (iMain); WriteS (f, " . "); WI (itTree); WriteS (f, " )="); WriteNl (f);
	      WriteLine (TreeRoot^.Ag.EvalCodes^.Codes.LocalLine);
	      WriteText (f, TreeRoot^.Ag.EvalCodes^.Codes.Local);
	      Node := TreeRoot^.Ag.Modules;
	      WHILE Node^.Kind = Tree.Module DO
		 WriteLine (Node^.Module.EvalCodes^.Codes.LocalLine);
		 WriteText (f, Node^.Module.EvalCodes^.Codes.Local);
		 Node := Node^.Module.Next;
	      END;
      IF IsElement (ORD ('9'), Options) THEN
	      WriteS (f, "  VAR xxLow : BOOLEAN ;"); WriteNl (f);
	      WriteS (f, "  BEGIN"); WriteNl (f);
              WriteS (f, "    xxStack := MIN ( xxStack , LOOPHOLE ( ADR ( xxLow ) , INTEGER ) ) ;"); WriteNl (f);

      ELSE
	      WriteS (f, "  BEGIN"); WriteNl (f);
      END;
      IF IsElement (ORD ('5'), Options) THEN
	      WriteS (f, "    IFNOTIN ("); WN (i - 1); WriteS (f, ", yyt . yyHead . yyIsDone )"); WriteNl (f);
	      WriteS (f, "    INCLUDE  (yyt . yyHead . yyIsDone, "); WN (i - 1); WriteS (f, " )"); WriteNl (f);
              WriteS (f, "    ELSE yyAbort ( yyt ) ; END ;"); WriteNl (f);
      END;
	      IF n > 1 THEN
		 WriteS (f, "    TYPECASE yyt OF"); WriteNl (f);
		 ForallClassesExtensionsFirst (Classes, GenS);
		 WriteS (f, "    END ;"); WriteNl (f);
	      ELSE
		 ForallClassesExtensionsFirst (Classes, GenS);
	      END;
	      WriteS (f, "    INCLUDE ( yyt . yyHead . yyIsComp , "); WN (i - 1); WriteS (f, " )"); WriteNl (f);
	      WriteS (f, "  END yyS"); WN (i - 1); WriteS (f, " ;"); WriteNl (f);
	      WriteNl (f);
	   END;
	END;
	FOR i := Minimum (InhIndices) TO Maximum (InhIndices) DO
	   IF IsElement (i, InhIndices) THEN
	      WriteS (f, "PROCEDURE yyI"); WN (i); WriteS (f, "  (yyt : "); WI (iMain); WriteS (f, " . "); WI (itTree); WriteS (f, " )="); WriteNl (f);
	      WriteLine (TreeRoot^.Ag.EvalCodes^.Codes.LocalLine);
	      WriteText (f, TreeRoot^.Ag.EvalCodes^.Codes.Local);
	      Node := TreeRoot^.Ag.Modules;
	      WHILE Node^.Kind = Tree.Module DO
		 WriteLine (Node^.Module.EvalCodes^.Codes.LocalLine);
		 WriteText (f, Node^.Module.EvalCodes^.Codes.Local);
		 Node := Node^.Module.Next;
	      END;
      IF IsElement (ORD ('9'), Options) THEN
	      WriteS (f, "  VAR xxLow : BOOLEAN ;"); WriteNl (f);
	      WriteS (f, "  BEGIN"); WriteNl (f);
	      WriteS (f, "    xxStack := MIN ( xxStack , LOOPHOLE ( ADR ( xxLow ) , INTEGER ) ) ;"); WriteNl (f);

      ELSE
	      WriteS (f, "  BEGIN"); WriteNl (f);
      END;
	      Check := 0;
	      IF InhIndexCount^ [i] > 1 THEN
		 WriteS (f, "    TYPECASE yyt  OF"); WriteNl (f);
		 ForallClassesExtensionsFirst (Classes, EvalModule);
		 WriteS (f, "    END ;"); WriteNl (f);
	      ELSE
		 ForallClassesExtensionsFirst (Classes, EvalModule);
	      END;
	      IF Check # InhIndexCount^ [i] THEN
	         MessageI ("internal error in yyI", Error, NoPosition, Short, ADR (i));
	      END;
	      WriteS (f, "  END yyI"); WN (i); WriteS (f, " ;"); WriteNl (f);
	      WriteNl (f);
	   END;
	END;
	WriteS (f, "PROCEDURE Begin"); WI (EvalName); WriteS (f, " ( )"); WriteNl (f);
	WriteS (f, "= BEGIN"); WriteNl (f);
	WriteLine (EvalCodes^.Codes.BeginLine);
	WriteText (f, EvalCodes^.Codes.Begin);
	Node := Modules;
	WHILE Node^.Kind = Tree.Module DO
	   WriteLine (Node^.Module.EvalCodes^.Codes.BeginLine);
	   WriteText (f, Node^.Module.EvalCodes^.Codes.Begin);
	   Node := Node^.Module.Next;
	END;
	WriteS (f, "  END Begin"); WI (EvalName); WriteS (f, " ;"); WriteNl (f);
	WriteNl (f);
	WriteS (f, "PROCEDURE Close"); WI (EvalName); WriteS (f, " ( )"); WriteNl (f);
	WriteS (f, "= BEGIN"); WriteNl (f);
	WriteLine (EvalCodes^.Codes.CloseLine);
	WriteText (f, EvalCodes^.Codes.Close);
	Node := Modules;
	WHILE Node^.Kind = Tree.Module DO
	   WriteLine (Node^.Module.EvalCodes^.Codes.CloseLine);
	   WriteText (f, Node^.Module.EvalCodes^.Codes.Close);
	   Node := Node^.Module.Next;
	END;
	WriteS (f, "  END Close"); WI (EvalName); WriteS (f, " ;"); WriteNl (f);
	WriteNl (f);
	WriteS (f, "BEGIN"); WriteNl (f);
      IF IsElement (ORD ('X'), Options) THEN
	WriteS (f, "  yyf := Stdio . Stdout ;"); WriteNl (f);
      END;
	FOR i := Minimum (InhIndices) TO Maximum (InhIndices) DO
	   IF IsElement (i, InhIndices) THEN
	      WriteS (f, "  yyI [ "); WN (i); WriteS (f, " ] := yyI"); WN (i); WriteS (f, " ;"); WriteNl (f);
	   END;
	END;
	WriteS (f, "END "); WI (EvalName); WriteS (f, " ."); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Class:
(* line 320 "" *)
    WITH yyTempo.yyR2 DO  
   LOOP
     WITH t^.Class DO
(* line 321 "" *)
      IF NOT (NoCodeClass * Properties = {}) THEN EXIT; END;
(* line 322 "" *)
      IF NOT (i <= InstCount) THEN EXIT; END;
(* line 323 "" *)
      ;
(* line 324 "" *)
      	a := ToAttr (t, i);
	IF a = 0 THEN RETURN; END;
	WITH Instance^ [a] DO
	   IF {Inherited, Right} <= Properties THEN
	      Class := t;
	      IF InhIndexCount^ [i] > 1 THEN
		 WriteS (f, "     | "); WI (iMain); WriteS (f, " . "); WI (Name); WriteS (f, " ( TNode ) =>"); WriteNl (f);
	      END;
	      INC (Check);
	      k := ToBit1 (Selector, a - AttrCount - Selector^.Child.InstOffset);
      IF IsElement (ORD ('5'), Options) THEN
	      WriteS (f, "      IFNOTIN ("); WN (k); WriteS (f, ", TNode . "); WI (Selector^.Child.Name); WriteS (f, " . yyHead . yyIsDone )"); WriteNl (f);
	      WriteS (f, "      INCLUDE ( TNode . "); WI (Selector^.Child.Name);
	      WriteS (f, " . yyHead . yyIsDone , "); WN (k); WriteS (f, " )"); WriteNl (f);
              WriteS (f, "      ELSE yyAbort ( TNode ) ;"); WriteNl (f);
              WriteS (f, "      END ;"); WriteNl (f);
      END;
	      FOR j := 1 TO InstCount DO
		 IF IsRelated (a, j, DP) THEN
		    GenCall (t, j);
		 END;
	      END;
      IF IsElement (ORD ('X'), Options) AND (Trace IN t^.Class.Properties) THEN
	      WriteS (f, '      yyWriteEval ( TNode , "'); WI (Selector^.Child.Name); WriteS (f, ":"); WI (Attribute^.Child.Name); WriteS (f, '" ) ;'); WriteNl (f);
	      IF (Action # ADR (Action)) AND NOT (Virtual IN Properties) THEN
		 GenEvaluator (Action);
		 EvalMThree.GenEvaluator (Action); WriteNl (f);
		 IF (Attribute^.Kind = Tree.Child) OR (Attribute^.Attribute.Type = itTree) THEN
		    WriteS (f, "      write"); WI (itTree);
		    WriteS (f, " ( TNode . "); WI (Selector^.Child.Name);
		    WriteS (f, " . "); WI (Attribute^.Child.Name); WriteS (f, " )"); WriteNl (f);
		 ELSE
		    WriteS (f, "     write"); WI (Attribute^.Child.Type);
		    WriteS (f, " ( TNode . "); WI (Selector^.Child.Name);
		    WriteS (f, " . "); WI (Attribute^.Child.Name); WriteS (f, " )"); WriteNl (f);
                    WriteS (f, "     yyWriteNl ( ) ;"); WriteNl (f);
		 END;
	      ELSE
		 WriteS (f, "     yyWriteNl ( ) ;"); WriteNl (f);
	      END;
      ELSIF IsElement (ORD ('Y'), Options) AND (Trace IN t^.Class.Properties) THEN
	      WriteS (f, '     yyWriteEval ( TNode , "'); WI (Selector^.Child.Name); WriteS (f, ":"); WI (Attribute^.Child.Name); WriteS (f, '" ) ;'); WriteNl (f);
	      IF (Action # ADR (Action)) AND NOT (Virtual IN Properties) THEN
		 GenEvaluator (Action);
		 EvalMThree.GenEvaluator (Action);
	      END;
      ELSE
	      IF (Action # ADR (Action)) AND NOT (Virtual IN Properties) THEN
		 GenEvaluator (Action);
		 EvalMThree.GenEvaluator (Action);
	      END;
      END;
	      IF NOT (Input IN Properties) AND (Attribute^.Kind = Tree.Child) THEN
		 WriteS (f, "      WITH yyTemp = TNode . "); WI (Selector^.Child.Name);
		 WriteS (f, " . "); WI (Attribute^.Child.Name);
		 WriteS (f, " . yyHead DO"); WriteNl (f);
                 WriteS (f, "         IF yyTemp . yyParent = "); WI (iMain); WriteS (f, " . "); WI (iNoTree); WriteS (f, " THEN"); 
                 WriteS (f, "            yyOffset := "); 
		 WN (Selector^.Child.Class^.Class.BitCount + Attribute^.Child.BitOffset); WriteS (f, " ;"); WriteNl (f);
		 WriteS (f, "            yyTemp . yyParent := TNode . "); WI (Selector^.Child.Name); WriteS (f, " ;"); WriteNl (f);
		 WI (iMain); WriteS (f, " . Init"); WI (iModule); WriteS (f, " ( TNode . "); WI (Selector^.Child.Name); 
		 WriteS (f, " . "); WI (Attribute^.Child.Name); WriteS (f, " ) ;"); WriteNl (f);
                 WriteS (f, "         END ;"); WriteNl (f);
                 WriteS (f, "      END ;"); WriteNl (f);
	      END;
	      FOR i2 := 1 TO InstCount DO	
		 IF Instance^[i2].Action = Action THEN
		    WITH Instance^[i2] DO
		       IF Synthesized IN Properties THEN
			  k := ToBit0 (Class, i2);
			  WriteS (f, "     INCLUDE ( TNode . yyHead . yyIsComp , "); WN (k); WriteS (f, " )"); WriteNl (f);
		       ELSIF Inherited IN Properties THEN
			  k := ToBit1 (Selector, i2 - AttrCount - Selector^.Child.InstOffset);
			  WriteS (f, "     INCLUDE ( TNode . "); WI (Selector^.Child.Name);
			  WriteS (f, " . yyHead . yyIsComp , "); WN (k); WriteS (f, " )"); WriteNl (f);
		       END;
		    END;
		 END;
	      END;
	   END;
	END;
;
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  ELSE END;

 END EvalModule;

PROCEDURE CompBitInfo (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 409 "" *)
     WITH t^.Class DO
(* line 410 "" *)
      BitIndexSize := AttrCount;
(* line 411 "" *)
      MakeArray (BitIndex, BitIndexSize, TSIZE (tBitInfo));
(* line 412 "" *)
      i := 1;
(* line 413 "" *)
      gBitIndex := BitIndex;
(* line 414 "" *)
      ForallAttributes (t, CompBitInfo);
(* line 415 "" *)
      MaxBit := Max (i, MaxBit);
(* line 416 "" *)
      MaxInstCount := Max (InstCount, MaxInstCount);
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 418 "" *)
   LOOP
     WITH t^.Child DO
(* line 420 "" *)
      IF NOT (({Input, Test, Dummy} * Properties = {})) THEN EXIT; END;
(* line 421 "" *)
      INC (i);
(* line 422 "" *)
      gBitIndex ^ [AttrIndex] . ToBit := i;
(* line 423 "" *)
      gBitIndex ^ [i] . ToAttr := AttrIndex;
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.Attribute:
(* line 418 "" *)
   LOOP
     WITH t^.Attribute DO
(* line 420 "" *)
      IF NOT (({Input, Test, Dummy} * Properties = {})) THEN EXIT; END;
(* line 421 "" *)
      INC (i);
(* line 422 "" *)
      gBitIndex ^ [AttrIndex] . ToBit := i;
(* line 423 "" *)
      gBitIndex ^ [i] . ToAttr := AttrIndex;
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  ELSE END;

 END CompBitInfo;

PROCEDURE CompInhIndices (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 1: yyR1: RECORD
  b: INTEGER;
  END;
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 428 "" *)
    WITH yyTempo.yyR1 DO  
     WITH t^.Class DO
(* line 429 "" *)
      ;
(* line 430 "" *)
      	FOR j := AttrCount + 1 TO InstCount DO
	   WITH Instance^ [j] DO
	      IF Inherited IN Properties THEN
		 b := ToBit2 (t, Selector, j);
		 Include (InhIndices, b);
		 INC (InhIndexCount^ [b]);
	      END;
	   END;
	END;
;
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  END;
 END CompInhIndices;

PROCEDURE CountSynAttr (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 443 "" *)
   LOOP
     WITH t^.Class DO
(* line 444 "" *)
      IF NOT (NoCodeClass * Properties = {}) THEN EXIT; END;
(* line 445 "" *)
      IF NOT (i <= BitCount) THEN EXIT; END;
(* line 446 "" *)
      	WITH Instance^ [BitIndex^ [i].ToAttr] DO
	   IF ({Synthesized, Left} <= Properties) AND NOT (Test IN Properties) THEN
	      INC (n);
	   END;
	END;
;
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
 END CountSynAttr;

PROCEDURE GenS (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 465 "" *)
   LOOP
     WITH t^.Class DO
(* line 466 "" *)
      IF NOT (NoCodeClass * Properties = {}) THEN EXIT; END;
(* line 467 "" *)
      IF NOT (i <= BitCount) THEN EXIT; END;
(* line 468 "" *)
      	WITH Instance^ [BitIndex^ [i].ToAttr] DO
	   IF ({Synthesized, Left} <= Properties) AND NOT (Test IN Properties) THEN
	      Class := t;
	      IF n > 1 THEN
		 WriteS (f, "     | "); WI (iMain); WriteS (f, " . "); WI (Name); WriteS (f, " ( TNode ) =>"); WriteNl (f);
              ELSE
                 WriteS (f, "     WITH TNode = NARROW ( yyt , "); WI (iMain); WriteS (f, " . "); WI (Name); WriteS (f, " ) DO"); WriteNl (f);
	      END;
	      FOR j := 1 TO InstCount DO
		 IF IsRelated (BitIndex^ [i].ToAttr, j, DP) THEN
		    GenCall (t, j);
		 END;
	      END;
	      GenEvalAttr (t, BitIndex^ [i].ToAttr);
	      IF NOT (Input IN Properties) AND (Attribute^.Kind = Tree.Child) THEN
		 WriteS (f, "      WITH yyTemp = TNode . "); WI (Attribute^.Child.Name);
		 WriteS (f, " . yyHead DO"); WriteNl (f);
                 WriteS (f, "        IF yyTemp . yyParent = "); WI (iMain); WriteS (f, " . "); WI (iNoTree); WriteS (f, " THEN"); WriteNl (f);
                 WriteS (f, "          yyOffset := "); 
		 WN (BitCount + Attribute^.Child.BitOffset); WriteS (f, ";"); WriteNl (f);
                 WriteS (f, "          yyParent := TNode ;"); 
		 WriteS (f, "          "); WI (iMain); WriteS (f, " . Init"); WI (iModule); WriteS (f, " ( TNode . "); WI (Attribute^.Child.Name); WriteS (f, " ) ;"); WriteNl (f);
                 WriteS (f, "        END ;"); WriteNl (f);
                 WriteS (f, "      END ;"); WriteNl (f);
	      END;
	      FOR i2 := 1 TO InstCount DO	
		 IF Instance^[i2].Action = Action THEN
		    WITH Instance^[i2] DO
		       IF Synthesized IN Properties THEN
			  k := ToBit0 (Class, i2);
			  IF k # i - 1 THEN
			     WriteS (f, "      INCLUDE ( TNode . yyHead . yyIsComp , "); WN (k); WriteS (f, " )"); WriteNl (f);
			  END;
		       ELSIF Inherited IN Properties THEN
			  k := ToBit1 (Selector, i2 - AttrCount - Selector^.Child.InstOffset);
			  WriteS (f, "         INCLUDE ( TNode . "); WI (Selector^.Child.Name);
			  WriteS (f, " . yyHead . yyIsComp , "); WN (k); WriteS (f, " )"); WriteNl (f);
		       END;
		    END;
		 END;
	      END;
	      IF n > 1 THEN
              ELSE
                 WriteS (f, "     END (* WITH TNode *)"); WriteNl (f);
	      END;
              
	   END;
	END;
;
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
 END GenS;

PROCEDURE GenE (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 1: yyR1: RECORD
  ToCompute: tSet;
  END;
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 520 "" *)
    WITH yyTempo.yyR1 DO  
     WITH t^.Class DO
(* line 521 "" *)
      ;
(* line 522 "" *)
      	GetIterator (t);
	n := 0;
	j := 2;
	LOOP
	   IF j > InstCount THEN EXIT; END;
	   WITH Instance^ [j] DO
	      IF {Dummy, Output, Test} * Properties # {} THEN
	         IF (Test IN Properties) OR
		    ({Synthesized, Left} <= Properties) OR
		    ({Inherited,  Right} <= Properties) OR
		    ({Inherited,   Left} <= Properties) AND
		    NOT (Input IN Properties) AND (Attribute^.Kind = Tree.Child) OR
		    ({Synthesized, Right, Dummy} <= Properties) AND (Selector # Iterator) AND
		    (HasOutput IN Selector^.Child.Class^.Class.Properties) THEN
		    INC (n); EXIT;
		 END;
	      END;
	   END;
	   INC (j);
	END;
	IF (n = 0) AND ((Iterator = NoTree) OR NOT (HasOutput IN Iterator^.Child.Class^.Class.Properties)) THEN RETURN; END;

	Class := t;
	WriteS (f, "      | "); WI (iMain); WriteS (f, " . "); WI (Name); WriteS (f, " ( TNode ) =>"); WriteNl (f);
	FOR j := 2 TO InstCount DO
	   WITH Instance^ [j] DO
	      IF {Dummy, Output} * Properties # {} THEN
		 IF ({Synthesized, Left} <= Properties) OR
		    ({Inherited,  Right} <= Properties) OR
		    ({Inherited,   Left} <= Properties) AND
		    NOT (Input IN Properties) AND (Attribute^.Kind = Tree.Child) THEN
		    GenCall (t, j);
		 ELSIF ({Synthesized, Right, Dummy} <= Properties) AND (Selector # Iterator) AND
		    (HasOutput IN Selector^.Child.Class^.Class.Properties) THEN
      IF IsElement (ORD ('Z'), Options) AND (Trace IN t^.Class.Properties) THEN
		    WriteS (f, '      yyWriteVisit ( TNode , "'); WI (Selector^.Child.Name); WriteS (f, '" ) ;'); WriteNl (f);
      END;
		    WriteS (f, "      yyE ( TNode . "); WI (Selector^.Child.Name); WriteS (f, " ) ;"); WriteNl (f);
      IF IsElement (ORD ('Z'), Options) AND (Trace IN t^.Class.Properties) THEN
		    WriteS (f, "      yyVisitParent ( TNode . "); WI (Selector^.Child.Name); WriteS (f, " ) ;"); WriteNl (f);
      END;
		 END;
	      END;
	   END;
	END;

	MakeSet (ToCompute, InstCount);
	FOR i := 2 TO AttrCount DO
	   WITH Instance^ [i] DO
	      IF Test IN Properties THEN
		 FOR j := 2 TO InstCount DO
		    IF IsRelated (i, j, DP) THEN
		       IF {Synthesized, Inherited} * Instance^ [j].Properties # {} THEN
			  Include (ToCompute, j);
		       END;
		    END;
		 END;
	      END;
	   END;
	END;
	FOR i := 2 TO InstCount DO
	   WITH Instance^ [i] DO
	      IF ({Synthesized, Left, Output} <= Properties) OR
		 ({Inherited,  Right, Output} <= Properties) THEN
		 Exclude (ToCompute, i);
	      END;
	   END;
	END;
	WHILE NOT IsEmpty (ToCompute) DO
	   GenCall (t, Extract (ToCompute));
	END;
	ReleaseSet (ToCompute);
	FOR i := 2 TO AttrCount DO
	   IF Test IN Instance^ [i].Properties THEN
	      GenEvalAttr (t, i);
	   END;
	END;

	IF (Iterator = NoTree) OR NOT (HasOutput IN Iterator^.Child.Class^.Class.Properties) THEN
	   WriteS (f, "RETURN ;"); WriteNl (f);
	ELSE
   IF IsElement (ORD ('Z'), Options) AND (Trace IN t^.Class.Properties) THEN
	   WriteS (f, '      yyWriteVisit ( TNode , "'); WI (Iterator^.Child.Name); WriteS (f, '" ) ;'); WriteNl (f);
   END;
	   WriteS (f, "      yyt := TNode . "); WI (Iterator^.Child.Name); WriteS (f, " ;"); WriteNl (f);
	END;
;
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  END;
 END GenE;

PROCEDURE CompOutput (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 612 "" *)
   LOOP
     WITH t^.Class DO
(* line 613 "" *)
      IF NOT (NOT (HasOutput IN Properties)) THEN EXIT; END;
(* line 614 "" *)
      Success := FALSE;
(* line 615 "" *)
      ForallAttributes (t, CompOutput);
(* line 616 "" *)
      ForallClasses (Extensions, CompOutput2);
(* line 617 "" *)
      IF NOT (Success) THEN EXIT; END;
(* line 618 "" *)
      INCL (Properties, HasOutput);
(* line 619 "" *)
      IsStable := FALSE;
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.Child:
(* line 621 "" *)
   LOOP
     WITH t^.Child DO
(* line 622 "" *)
      IF NOT ((Output IN Properties) OR (HasOutput IN Class ^ . Class . Properties)) THEN EXIT; END;
(* line 623 "" *)
      Success := TRUE;
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.Attribute:
(* line 625 "" *)
   LOOP
     WITH t^.Attribute DO
(* line 626 "" *)
      IF NOT (({Test, Output} * Properties # {})) THEN EXIT; END;
(* line 627 "" *)
      Success := TRUE;
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  ELSE END;

 END CompOutput;

PROCEDURE CompOutput2 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 632 "" *)
   LOOP
     WITH t^.Class DO
(* line 633 "" *)
      IF NOT (HasOutput IN Properties) THEN EXIT; END;
(* line 634 "" *)
      Success := TRUE;
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  END;
 END CompOutput2;

PROCEDURE ToBit0 (yyP2: Tree.tTree; yyP1: INTEGER): INTEGER;

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
(* line 638 "" *)
      RETURN yyP2 ^ . Class . BitIndex ^ [yyP1] . ToBit - 1;

 END ToBit0;

PROCEDURE ToBit1 (yyP4: Tree.tTree; yyP3: INTEGER): INTEGER;

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
(* line 641 "" *)
      RETURN yyP4 ^ . Child . Class ^ . Class . BitIndex ^ [yyP3] . ToBit - 1;

 END ToBit1;

PROCEDURE ToBit2 (yyP7: Tree.tTree; yyP6: Tree.tTree; yyP5: SHORTCARD): INTEGER;

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 1: yyR1: RECORD
  yyV1: INTEGER;
  END;
 END; END;
 BEGIN
(* line 644 "" *)
    WITH yyTempo.yyR1 DO  
(* line 645 "" *)
        WITH yyP6^.Child DO
      RETURN yyP7^.Class.BitCount + BitOffset +
	 Class^.Class.BitIndex^ [yyP5 - yyP7^.Class.AttrCount - InstOffset].ToBit - 1;
   END;
;
      RETURN yyV1;
    END (* WITH yyTempos.yyR ... *) ;  

 END ToBit2;

PROCEDURE ToAttr (yyP9: Tree.tTree; yyP8: INTEGER): INTEGER;
(* line 652 "" *)
 VAR a: SHORTCARD; 

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 1: yyR1: RECORD
  yyV1: INTEGER;
  END;
 END; END;
 BEGIN
(* line 653 "" *)
    WITH yyTempo.yyR1 DO  
(* line 654 "" *)
        WITH yyP9^.Class DO
      FOR a := AttrCount + 1 TO InstCount DO
	 WITH Instance^ [a] DO
	    IF ({Input, Test, Dummy} * Properties = {}) AND
	       (ToBit2 (yyP9, Selector, a) = yyP8) THEN RETURN a; END;
	 END;
      END;
   END;
   RETURN 0;
;
      RETURN yyV1;
    END (* WITH yyTempos.yyR ... *) ;  

 END ToAttr;

PROCEDURE GenEvaluator (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 | 9: yyR9: RECORD
  TheClass: Tree.tTree;
  k: INTEGER;
  END;
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Assign:
(* line 667 "" *)
     WITH t^.Assign DO
(* line 669 "" *)
      GenEvaluator (Arguments);
      RETURN;
     END (* WITH *) ;

  | Tree.Copy:
(* line 667 "" *)
     WITH t^.Copy DO
(* line 669 "" *)
      GenEvaluator (Arguments);
      RETURN;
     END (* WITH *) ;

  | Tree.TargetCode:
(* line 671 "" *)
     WITH t^.TargetCode DO
(* line 672 "" *)
      GenEvaluator (Code);
      RETURN;
     END (* WITH *) ;

  | Tree.Check:
(* line 674 "" *)
     WITH t^.Check DO
(* line 675 "" *)
      GenEvaluator (Condition);
(* line 676 "" *)
      GenEvaluator (Statement);
(* line 677 "" *)
      GenEvaluator (Actions);
      RETURN;
     END (* WITH *) ;

  | Tree.Designator:
(* line 679 "" *)
     WITH t^.Designator DO
(* line 683 "" *)
      GenEvaluator (Next);
      RETURN;
     END (* WITH *) ;

  | Tree.Ident:
(* line 679 "" *)
     WITH t^.Ident DO
(* line 683 "" *)
      GenEvaluator (Next);
      RETURN;
     END (* WITH *) ;

  | Tree.Any:
(* line 679 "" *)
     WITH t^.Any DO
(* line 683 "" *)
      GenEvaluator (Next);
      RETURN;
     END (* WITH *) ;

  | Tree.Anys:
(* line 679 "" *)
     WITH t^.Anys DO
(* line 683 "" *)
      GenEvaluator (Next);
      RETURN;
     END (* WITH *) ;

  | Tree.Remote:
(* line 685 "" *)
    WITH yyTempo.yyR9 DO  
     WITH t^.Remote DO
(* line 686 "" *)
      ;
(* line 687 "" *)
      ;
(* line 688 "" *)
      TheClass := IdentifyClass (TreeRoot ^ . Ag . Classes, Type);
(* line 689 "" *)
        IF TheClass # NoTree THEN
      Attr := IdentifyAttribute (TheClass, Attribute);
      IF Attr # NoTree THEN
	 WITH Attr^.Attribute DO
	    k := ToBit0 (TheClass, AttrIndex);
	    IF Synthesized IN Properties THEN
	       WriteS (f, "      IFNOTIN ( "); WN (k); WriteS (f, " , "); EvalMThree.GenEvaluator (Designators);
	       WriteS (f, " . yyHead . yyIsComp )"); WriteNl (f);
               WriteS (f, "      yyS"); WN (k); WriteS (f, " ( "); 
	       EvalMThree.GenEvaluator (Designators); WriteS (f, " ) ;"); WriteNl (f);
               WriteS (f, "    END ;"); WriteNl (f);
	    ELSIF Inherited IN Properties THEN
	       WriteS (f, "      IFNOTIN ( "); WN (k); WriteS (f, " , "); EvalMThree.GenEvaluator (Designators);
	       WriteS (f, " . yyHead . yyIsComp ) yyI ["); 
	       EvalMThree.GenEvaluator (Designators); WriteS (f, " . yyHead . yyOffset + "); WN (k);
	       WriteS (f, " ] ( "); EvalMThree.GenEvaluator (Designators); WriteS (f, " . yyHead . yyParent ) ;"); WriteNl (f);
               WriteS (f, "    END ;"); WriteNl (f);
	    END; 
	 END;
      END;
   END;
   GenEvaluator (Next);
;
      RETURN;
     END (* WITH *) ;
    END (* WITH yyTempos.yyR ... *) ;  

  ELSE END;

 END GenEvaluator;

PROCEDURE BeginEvalMThree3;
 BEGIN

 END BeginEvalMThree3;

PROCEDURE CloseEvalMThree3;
 BEGIN

 END CloseEvalMThree3;

PROCEDURE yyExit;
 BEGIN
  IO.CloseIO; System.Exit (1);
 END yyExit;

BEGIN
 yyf   := IO.StdOutput;
 Exit  := yyExit;
 BeginEvalMThree3;
END EvalMThree3.

