
(* This file was mechanically generated by puma. *)

IMPLEMENTATION MODULE TreeC1;








IMPORT SYSTEM, System, IO, Tree;
(* line 22 "" *)


FROM General    IMPORT Max;
FROM IO         IMPORT WriteS, WriteNl;
FROM Idents     IMPORT tIdent;
FROM Texts      IMPORT WriteText;
FROM Sets       IMPORT IsElement, Include;
FROM TreeC2     IMPORT TreeIO, GetIterator, Iterator, WriteLine;
FROM IOUtils    IMPORT WriteBackslash ; 

FROM Tree       IMPORT
   NoTree       , tTree         , Input         , Reverse       ,
   Class        , Child         , Attribute     , Abstract      ,
   HasChildren  , HasAttributes , NoCodeAttr    , NoCodeClass   ,
   Options      , TreeRoot      , ClassCount    , iNoTree       ,
   itTree       , iMain         , iModule       , f             ,
   WI   , WN    , ForallClasses , ForallAttributes, Ignore      ,
   Test         , Dummy         , Link ;

IMPORT Strings;

VAR
   ConstCount   ,
   ListCount    : INTEGER;
   iRange       ,
   iClassName   : tIdent;
   Node         : tTree;
   gBitCount    : SHORTCARD;
   i, MaxBit    : SHORTCARD;






































































































PROCEDURE yyAbort (yyFunction: ARRAY OF CHAR);
 BEGIN
  IO.WriteS (IO.StdError, 'Error: module TreeC1, routine ');
  IO.WriteS (IO.StdError, yyFunction);
  IO.WriteS (IO.StdError, ' failed');
  IO.WriteNl (IO.StdError);
  Exit;
 END yyAbort;

PROCEDURE yyIsEqual (yya, yyb: ARRAY OF SYSTEM.BYTE): BOOLEAN;
 VAR yyi       : INTEGER;
 BEGIN
  FOR yyi := 0 TO INTEGER (HIGH (yya)) DO
   IF yya [yyi] # yyb [yyi] THEN RETURN FALSE; END;
  END;
  RETURN TRUE;
 END yyIsEqual;

PROCEDURE TreeDefC (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Ag) THEN
(* line 57 "" *)
     WITH t^.Ag DO
(* line 57 "" *)
      
        WriteS (f, "# ifndef yy"); WI (iModule); WriteNl (f);
        WriteS (f, "# define yy"); WI (iModule); WriteNl (f);
        WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, "# define ARGS(parameters)      parameters"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, "# define ARGS(parameters)      ()"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteNl (f);
      IF IsElement (ORD ('<'), Options) THEN
        WriteS (f, '# include "'); WI (iMain); WriteS (f, '.h"'); WriteNl (f);
      END;
        WriteLine (TreeCodes^.Codes.ImportLine);
        WriteText (f, TreeCodes^.Codes.Import);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.ImportLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Import);
           Node := Node^.Module.Next;
        END;
        WriteNl (f);
        WriteS (f, "# ifndef bool"); WriteNl (f);
        WriteS (f, "# define bool char"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
      IF NOT IsElement (ORD ('<'), Options) THEN
        WriteS (f, "# define "); WI (iNoTree); WriteS (f, " ("); WI (itTree); WriteS (f, ") 0L"); WriteNl (f);
        ForallClasses (Classes, ConstDecls);
        WriteNl (f);
        IF ClassCount > 251 THEN
        WriteS (f, "typedef unsigned short "); WI (iMain); WriteS (f, "_tKind;"); WriteNl (f);
        ELSE
        WriteS (f, "typedef unsigned char "); WI (iMain); WriteS (f, "_tKind;"); WriteNl (f);
        END;
        WriteS (f, "typedef unsigned short "); WI (iMain); WriteS (f, "_tMark;"); WriteNl (f);
        WriteS (f, "typedef unsigned short "); WI (iMain); WriteS (f, "_tLabel;"); WriteNl (f);
        WriteS (f, "typedef union "); WI (iMain); WriteS (f, "_Node * "); WI (itTree); WriteS (f, ";"); WriteNl (f);
        WriteS (f, "typedef void (* "); WI (iMain); WriteS (f, "_tProcTree) ARGS(("); WI (itTree); WriteS (f, "));"); WriteNl (f);
      END;
        WriteLine (TreeCodes^.Codes.ExportLine);
        WriteText (f, TreeCodes^.Codes.Export);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.ExportLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Export);
           Node := Node^.Module.Next;
        END;
        WriteNl (f);
      IF NOT IsElement (ORD ('<'), Options) THEN
        WriteS (f, "# ifndef "); WI (iMain); WriteS (f, "_NodeHead"); WriteNl (f);
        WriteS (f, "# define "); WI (iMain); WriteS (f, "_NodeHead"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
      IF IsElement (ORD ('L'), Options) THEN
        MaxBit := 0;
        ForallClasses (Classes, CompMaxBit);
        WriteS (f, "typedef struct { "); WI (iMain); WriteS (f, "_tKind yyKind; unsigned char yyIsComp0"); 
      IF IsElement (ORD ('5'), Options) THEN
        WriteS (f, ", yyIsDone0"); 
      END;
        FOR i := 1 TO (MaxBit - 1) DIV BSS DO
           WriteS (f, ", yyIsComp"); WN (i);
      IF IsElement (ORD ('5'), Options) THEN
           WriteS (f, ", yyIsDone"); WN (i);
      END;
        END;
        WriteS (f, "; "); WI (iMain); WriteS (f, "_tMark yyMark, yyOffset; "); WI (itTree); WriteS (f, " yyParent; "); 
        WI (iMain); WriteS (f, "_NodeHead } "); WI (iMain); WriteS (f, "_tNodeHead;"); WriteNl (f);
      ELSE
        WriteS (f, "typedef struct { "); WI (iMain); WriteS (f, "_tKind yyKind; "); WI (iMain); WriteS (f, "_tMark yyMark; "); 
        WI (iMain); WriteS (f, "_NodeHead } "); WI (iMain); WriteS (f, "_tNodeHead;"); WriteNl (f);
      END;
        ForallClasses (Classes, TypeDeclNode);
        WriteNl (f);
        WriteS (f, "union "); WI (iMain); WriteS (f, "_Node {"); WriteNl (f);
        WriteS (f, " "); WI (iMain); WriteS (f, "_tKind Kind;"); WriteNl (f);
        WriteS (f, " "); WI (iMain); WriteS (f, "_tNodeHead yyHead;"); WriteNl (f);
        ForallClasses (Classes, TypeDeclRecord);
        WriteS (f, "};"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "extern "); WI (itTree); WriteS (f, " "); WI (iMain); WriteS (f, "Root;"); WriteNl (f);
        WriteS (f, "extern unsigned long "); WI (iMain); WriteS (f, "_HeapUsed;"); WriteNl (f);
        WriteS (f, "extern char * "); WI (iMain); WriteS (f, "_PoolFreePtr, * "); WI (iMain); WriteS (f, "_PoolMaxPtr;"); WriteNl (f);
        WriteS (f, "extern unsigned short "); WI (iMain); WriteS (f, "_NodeSize ["); WN (ClassCount); WriteS (f, " + 1];"); WriteNl (f);
        WriteS (f, "extern char * "); WI (iMain); WriteS (f, "_NodeName ["); WN (ClassCount); WriteS (f, " + 1];"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "extern void (* "); WI (iMain); WriteS (f, "_Exit) ();"); WriteNl (f);
        WriteS (f, "extern "); WI (itTree); WriteS (f, " "); WI (iMain); WriteS (f, "_Alloc ();"); WriteNl (f);
        WriteS (f, "extern "); WI (itTree); WriteS (f, " Make"); WI (iMain); WriteS (f, " ARGS(("); WI (iMain); WriteS (f, "_tKind yyKind));"); WriteNl (f);
        WriteS (f, "extern bool "); WI (iMain); WriteS (f, "_IsType ARGS((register "); WI (itTree); WriteS (f, " yyt, register "); WI (iMain); WriteS (f, "_tKind yyKind));"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('n'), Options) THEN
        ForallClasses (Classes, ProcedureDeclsn);
        WriteNl (f);
      END;
      IF IsElement (ORD ('m'), Options) THEN
        ForallClasses (Classes, ProcedureDeclsm);
        WriteNl (f);
      END;
      IF IsElement (ORD ('f'), Options) THEN
        WriteS (f, "extern void Release"); WI (iModule); WriteS (f, " ARGS(("); WI (itTree); WriteS (f, " yyt));"); WriteNl (f);
      END;
      IF IsElement (ORD ('F'), Options) AND NOT IsElement (ORD ('<'), Options) THEN
        WriteS (f, "extern void Release"); WI (iModule); WriteS (f, "Module ();"); WriteNl (f);
      END;
      IF IsElement (ORD ('o'), Options) THEN
        WriteS (f, "extern void Write"); WI (iModule); WriteS (f, "Node ARGS((FILE * yyyf, "); WI (itTree); WriteS (f, " yyt));"); WriteNl (f);
      END;
      IF IsElement (ORD ('w'), Options) THEN
        WriteS (f, "extern void Write"); WI (iModule); WriteS (f, " ARGS((FILE * yyyf, "); WI (itTree); WriteS (f, " yyt));"); WriteNl (f);
      END;
      IF IsElement (ORD ('r'), Options) THEN
        WriteS (f, "extern "); WI (itTree); WriteS (f, " Read"); WI (iModule); WriteS (f, " ARGS((FILE * yyyf));"); WriteNl (f);
      END;
      IF IsElement (ORD ('p'), Options) THEN
        WriteS (f, "extern void Put"); WI (iModule); WriteS (f, " ARGS((FILE * yyyf, "); WI (itTree); WriteS (f, " yyt));"); WriteNl (f);
      END;
      IF IsElement (ORD ('g'), Options) THEN
        WriteS (f, "extern "); WI (itTree); WriteS (f, " Get"); WI (iModule); WriteS (f, " ARGS((FILE * yyyf));"); WriteNl (f);
      END;
      IF IsElement (ORD ('t'), Options) THEN
        WriteS (f, "extern void Traverse"); WI (iModule); WriteS (f, "TD ARGS(("); WI (itTree); WriteS (f, " yyt, "); WI (iMain); WriteS (f, "_tProcTree yyyProc));"); WriteNl (f);
      END;
      IF IsElement (ORD ('b'), Options) THEN
        WriteS (f, "extern void Traverse"); WI (iModule); WriteS (f, "BU ARGS(("); WI (itTree); WriteS (f, " yyt, "); WI (iMain); WriteS (f, "_tProcTree yyyProc));"); WriteNl (f);
      END;
      IF IsElement (ORD ('R'), Options) THEN
        WriteS (f, "extern "); WI (itTree); WriteS (f, " Reverse"); WI (iModule); WriteS (f, " ARGS(("); WI (itTree); WriteS (f, " yyOld));"); WriteNl (f);
      END;
      IF IsElement (ORD ('y'), Options) THEN
        WriteS (f, "extern "); WI (itTree); WriteS (f, " Copy"); WI (iModule); WriteS (f, " ARGS(("); WI (itTree); WriteS (f, " yyt));"); WriteNl (f);
      END;
      IF IsElement (ORD ('k'), Options) THEN
        WriteS (f, "extern bool Check"); WI (iModule); WriteS (f, " ARGS(("); WI (itTree); WriteS (f, " yyt));"); WriteNl (f);
      END;
      IF IsElement (ORD ('q'), Options) THEN
        WriteS (f, "extern void Query"); WI (iModule); WriteS (f, " ARGS(("); WI (itTree); WriteS (f, " yyt));"); WriteNl (f);
      END;
      IF IsElement (ORD ('='), Options) THEN
        WriteS (f, "extern bool IsEqual"); WI (iModule); WriteS (f, " ARGS(("); WI (itTree); WriteS (f, " yyt1, "); WI (itTree); WriteS (f, " yyt2));"); WriteNl (f);
      END;
      IF IsElement (ORD ('L'), Options) THEN
        WriteS (f, "extern void Init"); WI (iModule); WriteS (f, " ARGS((register "); WI (itTree); WriteS (f, " yyt));"); WriteNl (f);
      END;
        WriteS (f, "extern void Begin"); WI (iModule); WriteS (f, " ();"); WriteNl (f);
        WriteS (f, "extern void Close"); WI (iModule); WriteS (f, " ();"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  END;
 END TreeDefC;

PROCEDURE ConstDecls (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 210 "" *)
     WITH t^.Class DO
(* line 210 "" *)
      
        IF NOT (Abstract IN Properties) THEN
           INC (ConstCount);
           IF NOT (Ignore IN Properties) THEN
              WriteS (f, "# define k"); WI (Name); WriteS (f, " "); WN (ConstCount); WriteNl (f);
           END;
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END ConstDecls;

PROCEDURE TypeDeclNode (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 222 "" *)
     WITH t^.Class DO
(* line 222 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "typedef struct { "); WI (iMain); WriteS (f, "_tNodeHead yyHead; "); 
           ForallAttributes (t, TypeDeclNode);
           WriteS (f, "} y"); WI (Name); WriteS (f, ";"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 229 "" *)
     WITH t^.Child DO
(* line 229 "" *)
      
        WI (itTree); WriteS (f, " "); WI (Name); WriteS (f, "; "); 
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 232 "" *)
     WITH t^.Attribute DO
(* line 232 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
           WI (Type); WriteS (f, " "); WI (Name); WriteS (f, "; "); 
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END TypeDeclNode;

PROCEDURE TypeDeclRecord (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 241 "" *)
     WITH t^.Class DO
(* line 241 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, " y"); WI (Name); WriteS (f, " "); WI (Name); WriteS (f, ";"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END TypeDeclRecord;

PROCEDURE ProcedureDeclsn (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 250 "" *)
     WITH t^.Class DO
(* line 250 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "extern "); WI (itTree); WriteS (f, " n"); WI (Name); WriteS (f, " ();"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END ProcedureDeclsn;

PROCEDURE ProcedureDeclsm (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 259 "" *)
     WITH t^.Class DO
(* line 259 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "extern "); WI (itTree); WriteS (f, " m"); WI (Name); WriteS (f, " ARGS(("); 
           ListCount := 0;
           ForallAttributes (t, ProcedureDeclsm);
           WriteS (f, "));"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 267 "" *)
     WITH t^.Child DO
(* line 267 "" *)
      
        IF Input IN Properties THEN
           IF ListCount > 0 THEN WriteS (f, ", "); END;
           WI (itTree); WriteS (f, " p"); WI (Name);
           INC (ListCount);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 274 "" *)
     WITH t^.Attribute DO
(* line 274 "" *)
      
        IF Input IN Properties THEN
           IF ListCount > 0 THEN WriteS (f, ", "); END;
           WI (Type); WriteS (f, " p"); WI (Name);
           INC (ListCount);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ProcedureDeclsm;

PROCEDURE ProcedureHeadingm (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 285 "" *)
     WITH t^.Class DO
(* line 285 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WI (itTree); WriteS (f, " m"); WI (Name); WriteNl (f);
           WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
           ListCount := 0;
           WriteS (f, "("); ForallAttributes (t, ProcedureDeclsm); WriteS (f, ")"); WriteNl (f);
           WriteS (f, "# else"); WriteNl (f);
           ListCount := 0;
           WriteS (f, "("); ForallAttributes (t, ProcedureHeadingm); WriteS (f, ")"); WriteNl (f);
           ForallAttributes (t, ProcedureHeadingm2);
           WriteS (f, "# endif"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 298 "" *)
     WITH t^.Child DO
(* line 298 "" *)
      
        IF Input IN Properties THEN
           IF ListCount > 0 THEN WriteS (f, ", "); END;
           WriteS (f, "p"); WI (Name);
           INC (ListCount);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 305 "" *)
     WITH t^.Attribute DO
(* line 305 "" *)
      
        IF Input IN Properties THEN
           IF ListCount > 0 THEN WriteS (f, ", "); END;
           WriteS (f, "p"); WI (Name);
           INC (ListCount);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ProcedureHeadingm;

PROCEDURE ProcedureHeadingm2 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Child:
(* line 316 "" *)
     WITH t^.Child DO
(* line 316 "" *)
      
        IF Input IN Properties THEN
           WI (itTree); WriteS (f, " p"); WI (Name); WriteS (f, ";"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 321 "" *)
     WITH t^.Attribute DO
(* line 321 "" *)
      
        IF Input IN Properties THEN
           WI (Type); WriteS (f, " p"); WI (Name); WriteS (f, ";"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ProcedureHeadingm2;

PROCEDURE TreeImplC (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Ag) THEN
(* line 330 "" *)
     WITH t^.Ag DO
(* line 330 "" *)
      
        WriteS (f, '# include "'); WI (iMain); WriteS (f, '.h"'); WriteNl (f);
        WriteS (f, "# define yyALLOC(ptr, size)    if ((ptr = ("); WI (itTree); WriteS (f, ") "); WI (iMain); WriteS (f, "_PoolFreePtr) >= ("); WI (itTree); WriteS (f, ") "); WI (iMain); WriteS (f, "_PoolMaxPtr) "); WriteBackslash ( f ) ; WriteNl (f);
        WriteS (f, "  ptr = "); WI (iMain); WriteS (f, "_Alloc (); "); WriteBackslash ( f ) ; WriteNl (f);
        WriteS (f, "  "); WI (iMain); WriteS (f, "_PoolFreePtr += size;"); WriteNl (f);
        WriteS (f, "# define yyFREE(ptr, size)     "); WriteNl (f);
        WriteS (f, "# include <stdio.h>"); WriteNl (f);
        WriteS (f, "# ifdef __cplusplus"); WriteNl (f);
        WriteS (f, 'extern "C" {'); WriteNl (f);
        WriteS (f, '# include "System.h"'); WriteNl (f);
        WriteS (f, '# include "General.h"'); WriteNl (f);
        WriteS (f, '# include "Memory.h"'); WriteNl (f);
        WriteS (f, '# include "DynArray.h"'); WriteNl (f);
        WriteS (f, '# include "StringMem.h"'); WriteNl (f);
        WriteS (f, '# include "Idents.h"'); WriteNl (f);
        WriteS (f, '# include "Sets.h"'); WriteNl (f);
        WriteS (f, '# include "Positions.h"'); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, '# include "System.h"'); WriteNl (f);
        WriteS (f, '# include "General.h"'); WriteNl (f);
        WriteS (f, '# include "Memory.h"'); WriteNl (f);
        WriteS (f, '# include "DynArray.h"'); WriteNl (f);
        WriteS (f, '# include "StringMem.h"'); WriteNl (f);
        WriteS (f, '# include "Idents.h"'); WriteNl (f);
        WriteS (f, '# include "Sets.h"'); WriteNl (f);
        WriteS (f, '# include "Positions.h"'); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteNl (f);
        WriteLine (TreeCodes^.Codes.GlobalLine);
        WriteText (f, TreeCodes^.Codes.Global);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.GlobalLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Global);
           Node := Node^.Module.Next;
        END;
        WriteLine (TreeCodes^.Codes.LocalLine);
        WriteText (f, TreeCodes^.Codes.Local);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.LocalLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Local);
           Node := Node^.Module.Next;
        END;
        WriteS (f, "# ifdef getchar"); WriteNl (f);
        WriteS (f, "# undef getchar"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "# ifdef putchar"); WriteNl (f);
        WriteS (f, "# undef putchar"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, '# include "yy'); WI (iModule); WriteS (f, '.w"'); WriteNl (f);
        WriteNl (f);
      IF NOT IsElement (ORD ('<'), Options) THEN
        WriteS (f, "static void yyExit () { Exit (1); }"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "void (* "); WI (iMain); WriteS (f, "_Exit) () = yyExit;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "# define yyBlockSize 20480"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "typedef struct yysBlock {"); WriteNl (f);
        WriteS (f, " char yyBlock [yyBlockSize];"); WriteNl (f);
        WriteS (f, " struct yysBlock * yySuccessor;"); WriteNl (f);
        WriteS (f, "} yytBlock, * yytBlockPtr;"); WriteNl (f);
        WriteNl (f);
        WI (itTree); WriteS (f, " "); WI (iMain); WriteS (f, "Root;"); WriteNl (f);
        WriteS (f, "unsigned long "); WI (iMain); WriteS (f, "_HeapUsed = 0;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static yytBlockPtr yyBlockList = (yytBlockPtr) "); WI (iNoTree); WriteS (f, ";"); WriteNl (f);
        WriteS (f, "char * "); WI (iMain); WriteS (f, "_PoolFreePtr     = (char *) "); WI (iNoTree); WriteS (f, ";"); WriteNl (f);
        WriteS (f, "char * "); WI (iMain); WriteS (f, "_PoolMaxPtr      = (char *) "); WI (iNoTree); WriteS (f, ";"); WriteNl (f);
        WriteS (f, "static unsigned short yyMaxSize        = 0;"); WriteNl (f);
        WriteS (f, "unsigned short "); WI (iMain); WriteS (f, "_NodeSize ["); WN (ClassCount); WriteS (f, " + 1] = { 0,"); WriteNl (f);
        ForallClasses (Classes, InitNodeSize);
        WriteS (f, "};"); WriteNl (f);
        WriteS (f, "char * "); WI (iMain); WriteS (f, "_NodeName ["); WN (ClassCount); WriteS (f, " + 1] = {"); WriteNl (f);
        WriteS (f, ' "'); WI (iNoTree); WriteS (f, '",'); WriteNl (f);
        ForallClasses (Classes, InitNodeName);
        WriteS (f, "};"); WriteNl (f);
        WriteS (f, "static "); WI (iMain); WriteS (f, "_tKind yyTypeRange ["); WN (ClassCount); WriteS (f, " + 1] = { 0,"); WriteNl (f);
        ForallClasses (Classes, InitTypeRange);
        WriteS (f, "};"); WriteNl (f);
        WriteNl (f);
        WI (itTree); WriteS (f, " "); WI (iMain); WriteS (f, "_Alloc ()"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " register yytBlockPtr yyBlockPtr = yyBlockList;"); WriteNl (f);
        WriteS (f, " register int i;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, " if (yyMaxSize == 0)"); WriteNl (f);
        WriteS (f, "  for (i = 1; i <= "); WN (ClassCount); WriteS (f, "; i ++) {"); WriteNl (f);
        WriteS (f, "   "); WI (iMain); WriteS (f, "_NodeSize [i] = ("); WI (iMain); WriteS (f, "_NodeSize [i] + yyMaxAlign - 1) & yyAlignMasks [yyMaxAlign];"); WriteNl (f);
        WriteS (f, "   yyMaxSize = Max ("); WI (iMain); WriteS (f, "_NodeSize [i], yyMaxSize);"); WriteNl (f);
        WriteS (f, "  }"); WriteNl (f);
        WriteS (f, " yyBlockList = (yytBlockPtr) Alloc (sizeof (yytBlock));"); WriteNl (f);
        WriteS (f, " yyBlockList->yySuccessor = yyBlockPtr;"); WriteNl (f);
        WriteS (f, " "); WI (iMain); WriteS (f, "_PoolFreePtr = yyBlockList->yyBlock;"); WriteNl (f);
        WriteS (f, " "); WI (iMain); WriteS (f, "_PoolMaxPtr = "); WI (iMain); WriteS (f, "_PoolFreePtr + yyBlockSize - yyMaxSize + 1;"); WriteNl (f);
        WriteS (f, " "); WI (iMain); WriteS (f, "_HeapUsed += yyBlockSize;"); WriteNl (f);
        WriteS (f, " return ("); WI (itTree); WriteS (f, ") "); WI (iMain); WriteS (f, "_PoolFreePtr;"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        WI (itTree); WriteS (f, " Make"); WI (iMain); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " ("); WI (iMain); WriteS (f, "_tKind yyKind)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyKind) "); WI (iMain); WriteS (f, "_tKind yyKind;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " register "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
        WriteS (f, " yyALLOC (yyt, "); WI (iMain); WriteS (f, "_NodeSize [yyKind])"); WriteNl (f);
        WriteS (f, " yyt->Kind = yyKind;"); WriteNl (f);
        WriteS (f, " yyt->yyHead.yyMark = 0;"); WriteNl (f);
      IF IsElement (ORD ('L'), Options) THEN
        WriteS (f, " yyt->yyHead.yyParent = "); WI (iNoTree); WriteS (f, ";"); WriteNl (f);
      END;
        WriteS (f, " return yyt;"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "bool "); WI (iMain); WriteS (f, "_IsType"); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " (register "); WI (itTree); WriteS (f, " yyt, register "); WI (iMain); WriteS (f, "_tKind yyKind)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyt, yyKind) register "); WI (itTree); WriteS (f, " yyt; register "); WI (iMain); WriteS (f, "_tKind yyKind;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, ' return yyt != '); WI (iNoTree); WriteS (f, " && yyKind <= yyt->Kind && yyt->Kind <= yyTypeRange [yyKind];"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('n'), Options) THEN
        ForallClasses (Classes, ProcedureBodyn);
      END;
        WriteNl (f);
      IF IsElement (ORD ('m'), Options) THEN
        ForallClasses (Classes, ProcedureBodym);
      END;
        TreeIO (t);
      IF IsElement (ORD ('f'), Options) THEN
        WriteS (f, "static "); WI (itTree); WriteS (f, " yyChild;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static void yyRelease"); WI (iModule); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " ("); WI (itTree); WriteS (f, " yyt)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyt) "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " if (yyt == "); WI (iNoTree); WriteS (f, ") return;"); WriteNl (f);
        WriteS (f, " switch (yyt->Kind) {"); WriteNl (f);
        ForallClasses (Classes, ReleaseAttributes1);
        WriteS (f, " default: ;"); WriteNl (f);
        WriteS (f, " }"); WriteNl (f);
        WriteNl (f);
        WriteS (f, " if (-- yyt->yyHead.yyMark == 0) {"); WriteNl (f);
        WriteS (f, "  switch (yyt->Kind) {"); WriteNl (f);
        ForallClasses (Classes, ReleaseAttributes2);
        WriteS (f, "  default: ;"); WriteNl (f);
        WriteS (f, "  }"); WriteNl (f);
        WriteS (f, "  yyFREE (yyt, "); WI (iMain); WriteS (f, "_NodeSize [yyt->Kind])"); WriteNl (f);
        WriteS (f, " }"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "void Release"); WI (iModule); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " ("); WI (itTree); WriteS (f, " yyt)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyt) "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " yyMark (yyt);"); WriteNl (f);
        WriteS (f, " yyRelease"); WI (iModule); WriteS (f, " (yyt);"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('F'), Options) AND NOT IsElement (ORD ('<'), Options) THEN
        WriteS (f, "void Release"); WI (iModule); WriteS (f, "Module ()"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " yytBlockPtr yyBlockPtr;"); WriteNl (f);
        WriteS (f, ' while (yyBlockList != (yytBlockPtr) '); WI (iNoTree); WriteS (f, ') {'); WriteNl (f);
        WriteS (f, "  yyBlockPtr = yyBlockList;"); WriteNl (f);
        WriteS (f, "  yyBlockList = yyBlockList->yySuccessor;"); WriteNl (f);
        WriteS (f, "  Free (sizeof (yytBlock), (char *) yyBlockPtr);"); WriteNl (f);
        WriteS (f, " }"); WriteNl (f);
        WriteS (f, " "); WI (iMain); WriteS (f, "_PoolFreePtr = (char *) "); WI (iNoTree); WriteS (f, ";"); WriteNl (f);
        WriteS (f, " "); WI (iMain); WriteS (f, "_PoolMaxPtr = (char *) "); WI (iNoTree); WriteS (f, ";"); WriteNl (f);
        WriteS (f, " "); WI (iMain); WriteS (f, "_HeapUsed = 0;"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('t'), Options) OR
         IsElement (ORD ('b'), Options) THEN
        WriteS (f, "static "); WI (iMain); WriteS (f, "_tProcTree yyProc;"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('t'), Options) THEN
        WriteS (f, "static void yyTraverse"); WI (iModule); WriteS (f, "TD"); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " ("); WI (itTree); WriteS (f, " yyt)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyt) "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " for (;;) {"); WriteNl (f);
        WriteS (f, "  if (yyt == "); WI (iNoTree); WriteS (f, " || yyt->yyHead.yyMark == 0) return;"); WriteNl (f);
        WriteS (f, "  yyt->yyHead.yyMark = 0;"); WriteNl (f);
        WriteS (f, "  yyProc (yyt);"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  switch (yyt->Kind) {"); WriteNl (f);
        ForallClasses (Classes, TraverseTD);
        WriteS (f, "  default: return;"); WriteNl (f);
        WriteS (f, "  }"); WriteNl (f);
        WriteS (f, " }"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "void Traverse"); WI (iModule); WriteS (f, "TD"); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " ("); WI (itTree); WriteS (f, " yyt, "); WI (iMain); WriteS (f, "_tProcTree yyyProc)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyt, yyyProc) "); WI (itTree); WriteS (f, " yyt; "); WI (iMain); WriteS (f, "_tProcTree yyyProc;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " yyMark (yyt);"); WriteNl (f);
        WriteS (f, " yyProc = yyyProc;"); WriteNl (f);
        WriteS (f, " yyTraverse"); WI (iModule); WriteS (f, "TD (yyt);"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('b'), Options) THEN
        WriteS (f, "static void yyTraverse"); WI (iModule); WriteS (f, "BU"); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " ("); WI (itTree); WriteS (f, " yyt)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyt) "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " if (yyt == "); WI (iNoTree); WriteS (f, " || yyt->yyHead.yyMark == 0) return;"); WriteNl (f);
        WriteS (f, " yyt->yyHead.yyMark = 0;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, " switch (yyt->Kind) {"); WriteNl (f);
        ForallClasses (Classes, TraverseBU);
        WriteS (f, " default: ;"); WriteNl (f);
        WriteS (f, " }"); WriteNl (f);
        WriteS (f, " yyProc (yyt);"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "void Traverse"); WI (iModule); WriteS (f, "BU"); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " ("); WI (itTree); WriteS (f, " yyt, "); WI (iMain); WriteS (f, "_tProcTree yyyProc)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyt, yyyProc) "); WI (itTree); WriteS (f, " yyt; "); WI (iMain); WriteS (f, "_tProcTree yyyProc;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " yyMark (yyt);"); WriteNl (f);
        WriteS (f, " yyProc = yyyProc;"); WriteNl (f);
        WriteS (f, " yyTraverse"); WI (iModule); WriteS (f, "BU (yyt);"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
      END;
      TreeImplC1 ( t ) ; 
;
      RETURN;
     END (* WITH *) ;

  END;
 END TreeImplC;

PROCEDURE TreeImplC1 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Ag) THEN
(* line 593 "" *)
     WITH t^.Ag DO
(* line 593 "" *)
      

      IF IsElement (ORD ('R'), Options) THEN
        WI (itTree); WriteS (f, " Reverse"); WI (iModule); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " ("); WI (itTree); WriteS (f, " yyOld)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyOld) "); WI (itTree); WriteS (f, " yyOld;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " register "); WI (itTree); WriteS (f, " yyNew, yyNext, yyTail;"); WriteNl (f);
        WriteS (f, " yyNew = yyOld;"); WriteNl (f);
        WriteS (f, " yyTail = yyOld;"); WriteNl (f);
        WriteS (f, " for (;;) {"); WriteNl (f);
        WriteS (f, "  switch (yyOld->Kind) {"); WriteNl (f);
        ForallClasses (Classes, Reverse1);
        WriteS (f, "  default: goto yyExit;"); WriteNl (f);
        WriteS (f, "  }"); WriteNl (f);
        WriteS (f, "  yyNew = yyOld;"); WriteNl (f);
        WriteS (f, "  yyOld = yyNext;"); WriteNl (f);
        WriteS (f, " }"); WriteNl (f);
        WriteS (f, "yyExit:"); WriteNl (f);
        WriteS (f, " switch (yyTail->Kind) {"); WriteNl (f);
        ForallClasses (Classes, Reverse2);
        WriteS (f, " default: ;"); WriteNl (f);
        WriteS (f, " }"); WriteNl (f);
        WriteS (f, " return yyNew;"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('y'), Options) THEN
        WriteS (f, "# define yyInitOldToNewStoreSize 32"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "typedef struct { "); WI (itTree); WriteS (f, " yyOld, yyNew; } yytOldToNew;"); WriteNl (f);
        WriteS (f, "static unsigned long yyOldToNewStoreSize = yyInitOldToNewStoreSize;"); WriteNl (f);
        WriteS (f, "static yytOldToNew yyOldToNewStore [yyInitOldToNewStoreSize];"); WriteNl (f);
        WriteS (f, "static yytOldToNew * yyOldToNewStorePtr = yyOldToNewStore;"); WriteNl (f);
        WriteS (f, "static int yyOldToNewCount;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static void yyStoreOldToNew"); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " ("); WI (itTree); WriteS (f, " yyOld, "); WI (itTree); WriteS (f, " yyNew)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyOld, yyNew) "); WI (itTree); WriteS (f, " yyOld, yyNew;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " if (++ yyOldToNewCount == yyOldToNewStoreSize)"); WriteNl (f);
        WriteS (f, "  ExtendArray ((char * *) & yyOldToNewStorePtr, & yyOldToNewStoreSize, sizeof (yytOldToNew));"); WriteNl (f);
        WriteS (f, " yyOldToNewStorePtr [yyOldToNewCount].yyOld = yyOld;"); WriteNl (f);
        WriteS (f, " yyOldToNewStorePtr [yyOldToNewCount].yyNew = yyNew;"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static "); WI (itTree); WriteS (f, " yyMapOldToNew"); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " ("); WI (itTree); WriteS (f, " yyOld)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyOld) "); WI (itTree); WriteS (f, " yyOld;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " register int yyi;"); WriteNl (f);
        WriteS (f, " for (yyi = 1; yyi <= yyOldToNewCount; yyi ++)"); WriteNl (f);
        WriteS (f, "  if (yyOldToNewStorePtr [yyi].yyOld == yyOld) return yyOldToNewStorePtr [yyi].yyNew;"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static "); WI (itTree); WriteS (f, " yyCopy"); WI (iModule); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " ("); WI (itTree); WriteS (f, " yyt, yyPtrtTree yyNew)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyt, yyNew) "); WI (itTree); WriteS (f, " yyt; yyPtrtTree yyNew;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " for (;;) {"); WriteNl (f);
        WriteS (f, "  if (yyt == "); WI (iNoTree); WriteS (f, ") { * yyNew = "); WI (iNoTree); WriteS (f, "; return; }"); WriteNl (f);
        WriteS (f, "  if (yyt->yyHead.yyMark == 0) { * yyNew = yyMapOldToNew (yyt); return; }"); WriteNl (f);
        WriteS (f, "  yyALLOC (* yyNew, "); WI (iMain); WriteS (f, "_NodeSize [yyt->Kind])"); WriteNl (f);
        WriteS (f, "  if (yyt->yyHead.yyMark > 1) { yyStoreOldToNew (yyt, * yyNew); }"); WriteNl (f);
        WriteS (f, "  yyt->yyHead.yyMark = 0;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  switch (yyt->Kind) {"); WriteNl (f);
        ForallClasses (Classes, Copy);
        WriteS (f, "  default: ;"); WriteNl (f);
        WriteS (f, "  }"); WriteNl (f);
        WriteS (f, " }"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        WI (itTree); WriteS (f, " Copy"); WI (iModule); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " ("); WI (itTree); WriteS (f, " yyt)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyt) "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " "); WI (itTree); WriteS (f, " yyNew;"); WriteNl (f);
        WriteS (f, " yyMark (yyt);"); WriteNl (f);
        WriteS (f, " yyOldToNewCount = 0;"); WriteNl (f);
        WriteS (f, " yyCopy"); WI (iModule); WriteS (f, " (yyt, & yyNew);"); WriteNl (f);
        WriteS (f, " return yyNew;"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('k'), Options) THEN
        WriteS (f, "static bool yyCheck"); WI (iModule); WriteS (f, " ARGS(("); WI (itTree); WriteS (f, " yyt));"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "bool Check"); WI (iModule); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " ("); WI (itTree); WriteS (f, " yyt)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyt) "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " yyMark (yyt);"); WriteNl (f);
        WriteS (f, " return yyCheck"); WI (iModule); WriteS (f, " (yyt);"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static bool yyCheckChild"); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " ("); WI (itTree); WriteS (f, " yyParent, "); WI (itTree); WriteS (f, " yyyChild, "); WI (iMain); WriteS (f, "_tKind yyType, char * yySelector)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyParent, yyyChild, yyType, yySelector)"); WriteNl (f);
        WriteS (f, " "); WI (itTree); WriteS (f, " yyParent, yyyChild;"); WriteNl (f);
        WriteS (f, " "); WI (iMain); WriteS (f, "_tKind yyType;"); WriteNl (f);
        WriteS (f, " char * yySelector;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " bool yySuccess = "); WI (iMain); WriteS (f, "_IsType (yyyChild, yyType);"); WriteNl (f);
        WriteS (f, ' if (! yySuccess) {'); WriteNl (f);
        WriteS (f, '  (void) fputs ("CheckTree: parent = ", stderr);'); WriteNl (f);
        WriteS (f, "  Write"); WI (iModule); WriteS (f, "Node (stderr, yyParent);"); WriteNl (f);
        WriteS (f, '  (void) fprintf (stderr, "\nselector: %s child = ", yySelector);'); WriteNl (f);
        WriteS (f, "  Write"); WI (iModule); WriteS (f, "Node (stderr, yyyChild);"); WriteNl (f);
        WriteS (f, "  (void) fputc ('\n', stderr);"); WriteNl (f);
        WriteS (f, " }"); WriteNl (f);
        WriteS (f, " return yyCheck"); WI (iModule); WriteS (f, " (yyyChild) && yySuccess;"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static bool yyCheck"); WI (iModule); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " ("); WI (itTree); WriteS (f, " yyt)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyt) "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " bool yyResult;"); WriteNl (f);
        WriteS (f, " if (yyt == "); WI (iNoTree); WriteS (f, ") return false;"); WriteNl (f);
        WriteS (f, " else if (yyt->yyHead.yyMark == 0) return true;"); WriteNl (f);
        WriteS (f, " yyt->yyHead.yyMark = 0;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, " yyResult = true;"); WriteNl (f);
        WriteS (f, " switch (yyt->Kind) {"); WriteNl (f);
        ForallClasses (Classes, CheckAttributes);
        WriteS (f, " default: ;"); WriteNl (f);
        WriteS (f, " }"); WriteNl (f);
        WriteS (f, " return yyResult;"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('q'), Options) THEN
        WriteS (f, "# define yyyWrite      1"); WriteNl (f);
        WriteS (f, "# define yyyRead       2"); WriteNl (f);
        WriteS (f, "# define yyyQuit       3"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static char yyyString [32], yyCh;"); WriteNl (f);
        WriteS (f, "static int yyLength, yyState;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "static bool yyyIsEqual"); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " (char * yya)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yya) char * yya;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " register int yyi;"); WriteNl (f);
        WriteS (f, " if (yyLength >= 0 && yyyString [yyLength] == ' ') {"); WriteNl (f);
        WriteS (f, '  if (yyLength != strlen (yya)) return false;'); WriteNl (f);
        WriteS (f, "  for (yyi = 0; yyi < yyLength; yyi ++)"); WriteNl (f);
        WriteS (f, '   if (yyyString [yyi] != yya [yyi]) return false;'); WriteNl (f);
        WriteS (f, " } else {"); WriteNl (f);
        WriteS (f, "  if (yyLength >= strlen (yya)) return false;"); WriteNl (f);
        WriteS (f, "  for (yyi = 0; yyi <= yyLength; yyi ++)"); WriteNl (f);
        WriteS (f, '   if (yyyString [yyi] != yya [yyi]) return false;'); WriteNl (f);
        WriteS (f, " }"); WriteNl (f);
        WriteS (f, " return true;"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "void Query"); WI (iModule); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " ("); WI (itTree); WriteS (f, " yyt)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyt) "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " yyState = yyyWrite;"); WriteNl (f);
        WriteS (f, " for (;;) {"); WriteNl (f);
        WriteS (f, "  switch (yyState) {"); WriteNl (f);
        WriteS (f, "  case yyyQuit : return;"); WriteNl (f);
        WriteS (f, "  case yyyWrite: Write"); WI (iModule); WriteS (f, "Node (stdout, yyt); yyState = yyyRead;"); WriteNl (f);
        WriteS (f, '  case yyyRead : (void) printf ("? "); yyLength = -1; yyCh = getc (stdin);'); WriteNl (f);
        WriteS (f, '   while (yyCh != ');WriteS (f, "'\n' && yyCh > 0)"); WriteNl (f);
        WriteS (f, "    { yyyString [++ yyLength] = yyCh; yyCh = getc (stdin); }"); WriteNl (f);
        WriteS (f, '   if (yyCh < 0) { (void) fputs ("QueryTree: eof reached\n", stderr);'); WriteNl (f);
        WriteS (f, "    yyState = yyyQuit; return; }"); WriteNl (f);
        WriteS (f, '   if      (yyyIsEqual ("parent")) { yyState = yyyWrite; return; }'); WriteNl (f);
        WriteS (f, '   else if (yyyIsEqual ("quit"  )) { yyState = yyyQuit ; return; }'); WriteNl (f);
        WriteS (f, '   else if (yyt != '); WI (iNoTree); WriteS (f, ") {"); WriteNl (f);
        WriteS (f, "    switch (yyt->Kind) {"); WriteNl (f);
        ForallClasses (Classes, QueryAttributes);
        WriteS (f, "    default: ;"); WriteNl (f);
        WriteS (f, "    }"); WriteNl (f);
        WriteS (f, "   }"); WriteNl (f);
        WriteS (f, "  }"); WriteNl (f);
        WriteS (f, " }"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('='), Options) THEN
        WriteS (f, "bool IsEqual"); WI (iModule); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " ("); WI (itTree); WriteS (f, " yyt1, "); WI (itTree); WriteS (f, " yyt2)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyt1, yyt2) "); WI (itTree); WriteS (f, " yyt1, yyt2;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " if (yyt1 == yyt2) return true;"); WriteNl (f);
        WriteS (f, " if (yyt1 == "); WI (iNoTree); WriteS (f, " || yyt2 == "); WI (iNoTree); WriteS (f, ' || yyt1->Kind != yyt2->Kind) return false;'); WriteNl (f);
        WriteS (f, " switch (yyt1->Kind) {"); WriteNl (f);
        ForallClasses (Classes, IsEqualAttributes);
        WriteS (f, " default: return true;"); WriteNl (f);
        WriteS (f, " }"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('L'), Options) THEN
        MaxBit := 0;
        ForallClasses (Classes, CompMaxBit);
        WriteS (f, "void Init"); WI (iModule); WriteNl (f);
        WriteS (f, "# if defined __STDC__ | defined __cplusplus"); WriteNl (f);
        WriteS (f, " (register "); WI (itTree); WriteS (f, " yyt)"); WriteNl (f);
        WriteS (f, "# else"); WriteNl (f);
        WriteS (f, " (yyt) register "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteS (f, " register "); WI (itTree); WriteS (f, " yyr;"); WriteNl (f);
        WriteS (f, " for (;;) {"); WriteNl (f);
        FOR i := 0 TO (MaxBit - 1) DIV BSS DO
           WriteS (f, "  yyt->yyHead.yyIsComp"); WN (i); WriteS (f, " = 0;"); WriteNl (f);
      IF IsElement (ORD ('5'), Options) THEN
           WriteS (f, "  yyt->yyHead.yyIsDone"); WN (i); WriteS (f, " = 0;"); WriteNl (f);
      END;
        END;
        WriteS (f, "  switch (yyt->Kind) {"); WriteNl (f);
        ForallClasses (Classes, InitAttributes);
        WriteS (f, "  default: return;"); WriteNl (f);
        WriteS (f, "  }"); WriteNl (f);
        WriteS (f, " }"); WriteNl (f);
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
      END;
        WriteS (f, "void Begin"); WI (iModule); WriteS (f, " ()"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteLine (TreeCodes^.Codes.BeginLine);
        WriteText (f, TreeCodes^.Codes.Begin);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.BeginLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Begin);
           Node := Node^.Module.Next;
        END;
        WriteS (f, "}"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "void Close"); WI (iModule); WriteS (f, " ()"); WriteNl (f);
        WriteS (f, "{"); WriteNl (f);
        WriteLine (TreeCodes^.Codes.CloseLine);
        WriteText (f, TreeCodes^.Codes.Close);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.CloseLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Close);
           Node := Node^.Module.Next;
        END;
        WriteS (f, "}"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  END;
 END TreeImplC1;

PROCEDURE ProcedureBodyn (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 878 "" *)
     WITH t^.Class DO
(* line 878 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WI (itTree); WriteS (f, " n"); WI (Name); WriteS (f, " () {"); WriteNl (f);
           WriteS (f, " register "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
           WriteS (f, " yyALLOC (yyt, "); WI (iMain); WriteS (f, "_NodeSize [k"); WI (Name); WriteS (f, "])"); WriteNl (f);
           WriteS (f, " yyt->Kind = k"); WI (Name); WriteS (f, ";"); WriteNl (f);
           WriteS (f, " yyt->yyHead.yyMark = 0;"); WriteNl (f);
         IF IsElement (ORD ('L'), Options) THEN
           WriteS (f, " yyt->yyHead.yyParent = "); WI (iNoTree); WriteS (f, ";"); WriteNl (f);
         END;
           iClassName := Name;
           ForallAttributes (t, ProcedureBodyn);
           WriteS (f, " return yyt;"); WriteNl (f);
           WriteS (f, "}"); WriteNl (f);
           WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 895 "" *)
     WITH t^.Child DO
(* line 895 "" *)
      
        WriteS (f, " begin"); WI (itTree); WriteS (f, "(yyt->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ")"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 898 "" *)
     WITH t^.Attribute DO
(* line 898 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
           WriteS (f, " begin"); WI (Type); WriteS (f, "(yyt->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ")"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ProcedureBodyn;

PROCEDURE ProcedureBodym (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 907 "" *)
     WITH t^.Class DO
(* line 907 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           ProcedureHeadingm (t);
           WriteS (f, "{"); WriteNl (f);
           WriteS (f, " register "); WI (itTree); WriteS (f, " yyt;"); WriteNl (f);
           WriteS (f, " yyALLOC (yyt, "); WI (iMain); WriteS (f, "_NodeSize [k"); WI (Name); WriteS (f, "])"); WriteNl (f);
           WriteS (f, " yyt->Kind = k"); WI (Name); WriteS (f, ";"); WriteNl (f);
           WriteS (f, " yyt->yyHead.yyMark = 0;"); WriteNl (f);
         IF IsElement (ORD ('L'), Options) THEN
           WriteS (f, " yyt->yyHead.yyParent = "); WI (iNoTree); WriteS (f, ";"); WriteNl (f);
         END;
           iClassName := Name;
           ForallAttributes (t, ProcedureBodym);
           WriteS (f, " return yyt;"); WriteNl (f);
           WriteS (f, "}"); WriteNl (f);
           WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 925 "" *)
     WITH t^.Child DO
(* line 925 "" *)
      
        IF Input IN Properties THEN
           WriteS (f, " yyt->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, " = p"); WI (Name); WriteS (f, ";"); WriteNl (f);
        ELSE
           WriteS (f, " begin"); WI (itTree); WriteS (f, "(yyt->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ")"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 932 "" *)
     WITH t^.Attribute DO
(* line 932 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
           IF Input IN Properties THEN
              WriteS (f, " yyt->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, " = p"); WI (Name); WriteS (f, ";"); WriteNl (f);
           ELSE
              WriteS (f, " begin"); WI (Type); WriteS (f, "(yyt->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ")"); WriteNl (f);
           END;
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ProcedureBodym;

PROCEDURE ReleaseAttributes1 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 945 "" *)
     WITH t^.Class DO
(* line 945 "" *)
      
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           WriteS (f, "case k"); WI (Name); WriteS (f, ":"); WriteNl (f);
           iClassName := Name;
           ForallAttributes (t, ReleaseAttributes1);
           WriteS (f, "break;"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 953 "" *)
     WITH t^.Child DO
(* line 953 "" *)
      
        WriteS (f, "close"); WI (itTree); WriteS (f, " (yyt->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ")"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ReleaseAttributes1;

PROCEDURE ReleaseAttributes2 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 960 "" *)
     WITH t^.Class DO
(* line 960 "" *)
      
        IF ((NoCodeClass * Properties) = {}) AND (HasAttributes IN Properties) THEN
           WriteS (f, "case k"); WI (Name); WriteS (f, ":"); WriteNl (f);
           iClassName := Name;
           ForallAttributes (t, ReleaseAttributes2);
           WriteS (f, "break;"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 968 "" *)
     WITH t^.Attribute DO
(* line 968 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
           WriteS (f, "close"); WI (Type); WriteS (f, " (yyt->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ")"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ReleaseAttributes2;

PROCEDURE TraverseTD (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 977 "" *)
     WITH t^.Class DO
(* line 977 "" *)
      
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           WriteS (f, "case k"); WI (Name); WriteS (f, ":"); WriteNl (f);
           GetIterator (t);
           iClassName := Name;
           ForallAttributes (t, TraverseTD);
           IF Iterator = NoTree THEN
              WriteS (f, "return;"); WriteNl (f);
           ELSE
              WriteS (f, "yyt = yyt->"); WI (iClassName); WriteS (f, "."); WI (Iterator^.Child.Name); WriteS (f, "; break;"); WriteNl (f);
           END;
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 990 "" *)
     WITH t^.Child DO
(* line 990 "" *)
      
        IF t # Iterator THEN
           WriteS (f, "yyTraverse"); WI (iModule); WriteS (f, "TD (yyt->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ");"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END TraverseTD;

PROCEDURE TraverseBU (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 999 "" *)
     WITH t^.Class DO
(* line 999 "" *)
      
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           WriteS (f, "case k"); WI (Name); WriteS (f, ":"); WriteNl (f);
           GetIterator (t);
           iClassName := Name;
           ForallAttributes (t, TraverseBU);
           IF Iterator = NoTree THEN
              WriteS (f, "return;"); WriteNl (f);
           ELSE
              WriteS (f, "yyTraverse"); WI (iModule); WriteS (f, "BU (yyt->"); WI (iClassName); WriteS (f, "."); WI (Iterator^.Child.Name); WriteS (f, "); break;"); WriteNl (f);
           END;
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1012 "" *)
     WITH t^.Child DO
(* line 1012 "" *)
      
        IF t # Iterator THEN
           WriteS (f, "yyTraverse"); WI (iModule); WriteS (f, "BU (yyt->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ");"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END TraverseBU;

PROCEDURE Reverse1 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1021 "" *)
     WITH t^.Class DO
(* line 1021 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           iClassName := Name;
           ForallAttributes (t, Reverse1);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1027 "" *)
     WITH t^.Child DO
(* line 1027 "" *)
      
        IF Reverse IN Properties THEN
           WriteS (f, "case k"); WI (iClassName); WriteS (f, ": yyNext = yyOld->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ";"); 
           WriteS (f, " yyOld->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, " = yyNew; break;"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Reverse1;

PROCEDURE Reverse2 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1037 "" *)
     WITH t^.Class DO
(* line 1037 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           iClassName := Name;
           ForallAttributes (t, Reverse2);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1043 "" *)
     WITH t^.Child DO
(* line 1043 "" *)
      
        IF Reverse IN Properties THEN
           WriteS (f, "case k"); WI (iClassName); WriteS (f, ": yyTail->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, " = yyOld; break;"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Reverse2;

PROCEDURE Copy (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1052 "" *)
     WITH t^.Class DO
(* line 1052 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "case k"); WI (Name); WriteS (f, ": (* yyNew)->"); WI (Name); WriteS (f, " = yyt->"); WI (Name); WriteS (f, ";"); WriteNl (f);
           GetIterator (t);
           iClassName := Name;
           ForallAttributes (t, Copy);
           IF Iterator = NoTree THEN
              WriteS (f, "return;"); WriteNl (f);
           ELSE
              WriteS (f, "yyt = yyt->"); WI (Name); WriteS (f, "."); WI (Iterator^.Child.Name); WriteS (f, ";"); WriteNl (f);
              WriteS (f, "yyNew = & (* yyNew)->"); WI (Name); WriteS (f, "."); WI (Iterator^.Child.Name); WriteS (f, "; break;"); WriteNl (f);
           END;
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1066 "" *)
     WITH t^.Child DO
(* line 1066 "" *)
      
        IF t # Iterator THEN
           WriteS (f, "copy"); WI (itTree); WriteS (f, " ((* yyNew)->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ", "); 
              WriteS (f, "yyt->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ")"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 1072 "" *)
     WITH t^.Attribute DO
(* line 1072 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
           WriteS (f, "copy"); WI (Type); WriteS (f, " ((* yyNew)->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ", "); 
              WriteS (f, "yyt->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ")"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Copy;

PROCEDURE CheckAttributes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1082 "" *)
     WITH t^.Class DO
(* line 1082 "" *)
      
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           WriteS (f, "case k"); WI (Name); WriteS (f, ":"); WriteNl (f);
           iClassName := Name;
           ForallAttributes (t, CheckAttributes);
           WriteS (f, "break;"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1090 "" *)
     WITH t^.Child DO
(* line 1090 "" *)
      
        WriteS (f, "yyResult = yyCheckChild (yyt, yyt->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ", k"); 
        WI (Type); WriteS (f, ', "'); WI (Name); WriteS (f, '") && yyResult;'); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END CheckAttributes;

PROCEDURE InitTypeRange (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 1098 "" *)
     WITH t^.Class DO
(* line 1098 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           iRange := Name;
           ForallClasses (Extensions, InitTypeRange2);
           WriteS (f, " k"); WI (iRange); WriteS (f, ","); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END InitTypeRange;

PROCEDURE InitTypeRange2 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 1109 "" *)
     WITH t^.Class DO
(* line 1109 "" *)
      
        iRange := Name;
;
      RETURN;
     END (* WITH *) ;

  END;
 END InitTypeRange2;

PROCEDURE QueryAttributes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1116 "" *)
     WITH t^.Class DO
(* line 1116 "" *)
      
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           WriteS (f, "case k"); WI (Name); WriteS (f, ": if (false) ;"); WriteNl (f);
           iClassName := Name;
           ForallAttributes (t, QueryAttributes);
           WriteS (f, "break;"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1124 "" *)
     WITH t^.Child DO
(* line 1125 "" *)
       WriteS (f, 'else if (yyyIsEqual ("'); WI (Name); WriteS (f, '")) Query'); WI (iModule);
       WriteS (f, " (yyt->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ");"); WriteNl (f);
     ;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 1128 "" *)
   LOOP
     WITH t^.Attribute DO
(* line 1129 "" *)
      IF NOT (( Link IN Properties )) THEN EXIT; END;
(* line 1130 "" *)
       WriteS (f, 'else if (yyyIsEqual ("'); WI (Name); WriteS (f, '")) Query'); WI (iModule);
       WriteS (f, " (yyt->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ");"); WriteNl (f);
     ;
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  ELSE END;

 END QueryAttributes;

PROCEDURE IsEqualAttributes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1137 "" *)
     WITH t^.Class DO
(* line 1137 "" *)
      
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           WriteS (f, "case k"); WI (Name); WriteS (f, ": return true"); WriteNl (f);
           iClassName := Name;
           ForallAttributes (t, IsEqualAttributes);
           WriteS (f, ";"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1146 "" *)
     WITH t^.Child DO
(* line 1146 "" *)
      
        WriteS (f, "&& equal"); WI (itTree); WriteS (f, " (yyt1->"); WI (iClassName); WriteS (f, "."); WI (Name);
        WriteS (f, ", yyt2->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ")"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 1150 "" *)
     WITH t^.Attribute DO
(* line 1150 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
           WriteS (f, "&& (equal"); WI (Type); WriteS (f, " (yyt1->"); WI (iClassName); WriteS (f, "."); WI (Name);
           WriteS (f, ", yyt2->"); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, "))"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END IsEqualAttributes;

PROCEDURE InitAttributes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1160 "" *)
   LOOP
     WITH t^.Class DO
(* line 1161 "" *)
      IF NOT (((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties)) THEN EXIT; END;
(* line 1162 "" *)
      WriteS (f, "case k");
(* line 1162 "" *)
      WI (Name);
(* line 1162 "" *)
      WriteS (f, ":");
(* line 1162 "" *)
      WriteNl (f);
(* line 1163 "" *)
      GetIterator (t);
(* line 1164 "" *)
      iClassName := Name;
(* line 1165 "" *)
      gBitCount := BitCount;
(* line 1166 "" *)
      ForallAttributes (t, InitAttributes);
(* line 1167 "" *)
             IF (Iterator = NoTree) OR NOT (Input IN Iterator^.Child.Properties) THEN
           WriteS (f, "return;"); WriteNl (f);
        ELSE
           WriteS (f, "yyt = yyt->"); WI (iClassName); WriteS (f, "."); WI (Iterator^.Child.Name); WriteS (f, "; break;"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.Child:
(* line 1173 "" *)
   LOOP
     WITH t^.Child DO
(* line 1174 "" *)
      IF NOT (Input IN Properties) THEN EXIT; END;
(* line 1175 "" *)
      WriteS (f, "yyr = yyt->");
(* line 1175 "" *)
      WI (iClassName);
(* line 1175 "" *)
      WriteS (f, ".");
(* line 1175 "" *)
      WI (Name);
(* line 1175 "" *)
      WriteS (f, "; yyr->yyHead.yyOffset = ");
(* line 1176 "" *)
      WN (gBitCount + BitOffset);
(* line 1176 "" *)
      WriteS (f, "; yyr->yyHead.yyParent = yyt;");
(* line 1176 "" *)
      WriteNl (f);
(* line 1177 "" *)
      IF NOT (t # Iterator) THEN EXIT; END;
(* line 1178 "" *)
      WriteS (f, "Init");
(* line 1178 "" *)
      WI (iModule);
(* line 1178 "" *)
      WriteS (f, " (yyr);");
(* line 1178 "" *)
      WriteNl (f);
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  ELSE END;

 END InitAttributes;

PROCEDURE InitNodeSize (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 1183 "" *)
     WITH t^.Class DO
(* line 1183 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, " sizeof (y"); WI (Name); WriteS (f, "),"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END InitNodeSize;

PROCEDURE InitNodeName (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 1193 "" *)
     WITH t^.Class DO
(* line 1193 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, ' "'); WI (Name); WriteS (f, '",'); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END InitNodeName;

PROCEDURE CompMaxBit (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1202 "" *)
     WITH t^.Class DO
(* line 1203 "" *)
      i := 1;
(* line 1204 "" *)
      ForallAttributes (t, CompMaxBit);
(* line 1205 "" *)
      MaxBit := Max (i, MaxBit);
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1207 "" *)
   LOOP
     WITH t^.Child DO
(* line 1209 "" *)
      IF NOT (({Input, Test, Dummy} * Properties = {})) THEN EXIT; END;
(* line 1210 "" *)
      INC (i);
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.Attribute:
(* line 1207 "" *)
   LOOP
     WITH t^.Attribute DO
(* line 1209 "" *)
      IF NOT (({Input, Test, Dummy} * Properties = {})) THEN EXIT; END;
(* line 1210 "" *)
      INC (i);
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  ELSE END;

 END CompMaxBit;

PROCEDURE BeginTreeC1;
 BEGIN
(* line 53 "" *)
 ConstCount := 0; 

 END BeginTreeC1;

PROCEDURE CloseTreeC1;
 BEGIN

 END CloseTreeC1;

PROCEDURE yyExit;
 BEGIN
  IO.CloseIO; System.Exit (1);
 END yyExit;

BEGIN
 yyf   := IO.StdOutput;
 Exit  := yyExit;
 BeginTreeC1;
END TreeC1.

