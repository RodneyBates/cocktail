
(* file MThree2.puma *) 

(* Modula-3 generation of Tree io, etc. 
   Rodney M. Bates Oct 1997 
   Extensively modified from file mod2.puma, which had these header comments:  
     (* Ich, Doktor Josef Grosch, Informatiker, 26.1.1989 *)
     (* Modified Rodney M. Bates: 
        RMB Dec 1995: Made tree writer reduce the amount of space on the
                      left of deeply indented lines by replacing whole
                      multiples of yyIndentFactor (initially = 20) blanks
                      by a modula-2 style comment containing a count of 
                      the blanks replaced. 

     *)
   Dec 1997 Added <*LINE...*> pragma output with -# option  
   Jan 1999 Added html tree dumper generation 
   Jan 1999 Added cases to Mark, WriteTREEm and WriteTREEHtml to follow 
            LINK Attributes 
   Jan 1999 changed procedure name yWriteNode to yyyWriteNode, to avoid
            possible conflict with yWrite<Class>, where <Class> = "Node"
*)

TRAFO TreeMThree2
TREE Tree
PUBLIC TreeIO TreeIOInit GetIterator

EXPORT  {
FROM Positions  IMPORT tPosition;

VAR Iterator    : Tree.tTree;

PROCEDURE WriteLine (Line: tPosition);
}

GLOBAL  {

IMPORT Idents , Strings ; 
FROM IO         IMPORT WriteS, WriteNl;
FROM Sets       IMPORT IsElement;
FROM Idents     IMPORT tIdent;
FROM Positions  IMPORT tPosition;

FROM Tree       IMPORT
   NoTree       , tTree         , Options       , ClassCount    ,
   f            , WI    , WN    , iInteger      , itTree        ,
   iNoTree      , iModule       , iMain         , HasChildren   ,
   HasAttributes, NoCodeAttr    , NoCodeClass   , Link          , 
   ForallClassesExtensionsFirst, ForallAttributes, Reverse      ;

VAR
   iClassName   : Idents . tIdent;
   sBOOLEAN     : Strings . tString;
   iBOOLEAN     : Idents . tIdent;
   RevChild     : tTree;

PROCEDURE WriteLine (Line: tPosition);
   BEGIN
      IF Line.Line # 0 THEN
         WriteS (f, "(* line "); WN (Line.Line); WriteS (f, ' "'); WI (Line.File); WriteS (f, '" *)'); WriteNl (f);
         IF IsElement (ORD ('#'), Options) THEN 
           WriteS (f, "<*LINE "); WN (Line.Line); WriteS (f, ' "'); WI (Line.File); WriteS (f, '" *>'); WriteNl (f);
         END; 
      END;
   END WriteLine;
} (* End of GLOBAL *) 

BEGIN { 

  Strings . ArrayToString ( "BOOLEAN" , sBOOLEAN ) ; 
  iBOOLEAN := Idents . MakeIdent ( sBOOLEAN ) ; 

} (* End of BEGIN *)  

PROCEDURE TreeIO (t: Tree)

Ag (..) :- {
        WriteNl (f);
      IF IsElement (ORD ('w'), Options) 
         OR IsElement (ORD ('o'), Options) 
         OR IsElement (ORD ( '^' ), Options) THEN
        WriteS (f, "VAR yyf        : Wr . T ;"); WriteNl (f);
      END; 
      IF IsElement (ORD ('r'), Options) THEN 
(* These are used only by the Ascii reader, which is  not generated for M3.
        WriteS (f, "VAR yyLabel    : CARDINAL ;"); WriteNl (f);
        WriteS (f, "VAR yyKind     : CARDINAL ;"); WriteNl (f);
        WriteS (f, "VAR yyc        : CHAR;"); WriteNl (f);
*)
      END;  
        WriteNl (f);
      IF IsElement (ORD (','), Options) THEN
        WriteS (f, "PROCEDURE yyMark  (yyt : "); WI (itTree); WriteS (f, " )"); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteS (f, "  LOOP"); WriteNl (f);
        WriteS (f, "   IF yyt = "); WI (iNoTree); WriteS (f, " THEN RETURN; END;"); WriteNl (f);
        WriteS (f, "   INC ( yyt . yyHead . yyMark ) ;"); WriteNl (f);
        WriteS (f, "   IF yyt . yyHead . yyMark > 1 THEN RETURN; END;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "   TYPECASE yyt OF"); WriteNl (f);
        Mark ( Classes ) ; 
        WriteS (f, "   ELSE RETURN ;"); WriteNl (f);
        WriteS (f, "   END ;"); WriteNl (f);
        WriteS (f, "  END ;"); WriteNl (f);
        WriteS (f, " END yyMark ;"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD (';'), Options) THEN
        WriteS (f, "CONST yyInitTreeStoreSize      = 32 ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "TYPE yytTreeStore = ARRAY OF "); WI (itTree); WriteS (f, " ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "VAR yyTreeStorePtr     : REF yytTreeStore ;"); WriteNl (f);
        WriteS (f, "VAR yyLabelCount       : CARDINAL ;"); WriteNl (f);
        WriteS (f, "VAR yyRecursionLevel   : CARDINAL ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyMapToLabel ( yyTree : "); WI (itTree); WriteS (f, " ) : CARDINAL"); WriteNl (f);
        WriteS (f, "=VAR yyi       : CARDINAL ;"); WriteNl (f);
        WriteS (f, " VAR LNewTreeStorePtr : REF yytTreeStore ;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  FOR yyi := 0 TO yyLabelCount - 1 DO"); WriteNl (f);
        WriteS (f, "   IF yyTreeStorePtr ^ [ yyi ] = yyTree THEN RETURN yyi ; END ;"); WriteNl (f);
        WriteS (f, "  END ;"); WriteNl (f);
        WriteS (f, "  IF yyLabelCount = NUMBER ( yyTreeStorePtr ^ ) THEN"); WriteNl (f);
        WriteS (f, "     LNewTreeStorePtr := NEW ( REF yytTreeStore , NUMBER ( yyTreeStorePtr ^ ) * 2 ) ;"); WriteNl (f);
        WriteS (f, "     SUBARRAY ( LNewTreeStorePtr ^ , 0 , NUMBER ( yyTreeStorePtr ^ ) ) := yyTreeStorePtr ^ ; "); WriteNl (f);
        WriteS (f, "     yyTreeStorePtr := LNewTreeStorePtr ; "); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, "  yyi := yyLabelCount ;"); WriteNl (f);
        WriteS (f, "  yyTreeStorePtr ^ [ yyi ] := yyTree ;"); WriteNl (f);
        WriteS (f, "  INC ( yyLabelCount ) ;"); WriteNl (f);
        WriteS (f, "  RETURN yyi ;"); WriteNl (f);
        WriteS (f, " END yyMapToLabel;"); WriteNl (f);
        WriteNl (f);
       IF IsElement (ORD ('r'), Options) THEN 
(* This is used only by the Ascii reader, which is  not generated for M3.
        WriteS (f, "PROCEDURE yyMapToTree ( yyLabel : CARDINAL ) : "); WI (itTree); WriteNl (f);
        WriteS (f, "=BEGIN RETURN yyTreeStorePtr ^ [ yyLabel ] ; END yyMapToTree ;"); WriteNl (f);
        WriteNl (f);
*) 
       END;
      END;
      IF IsElement (ORD ('w'), Options) OR
         IsElement (ORD ('^'), Options) OR
         IsElement (ORD ('o'), Options) THEN
        WriteS (f, "PROCEDURE yyWriteNl ( ) = BEGIN Wr . PutText ( yyf , Wr . EOL ) ; END yyWriteNl ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyWriteSelector ( yys : TEXT ) "); WriteNl (f);
        WriteS (f, "=BEGIN Wr . PutText  ( yyf , yys ) ; "); WriteNl (f);
        WriteS (f, '   Wr . PutText ( yyf , Fmt . Pad ( "" , MAX ( 0 , 16 - Text . Length ( yys ) ) ) ) ;'); WriteNl (f);
        WriteS (f, '   Wr . PutText (yyf, " = " ) ;'); WriteNl (f);
        WriteS (f, " END yyWriteSelector ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "VAR LittleEndian := TRUE ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyWriteHex ( VAR yyx : ARRAY OF CHAR ) "); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteS (f, "  IF LittleEndian"); WriteNl (f);
        WriteS (f, "  THEN"); WriteNl (f);
        WriteS (f, "   FOR yyi := NUMBER ( yyx ) - 1 TO 0 BY - 1 DO"); WriteNl (f);
        WriteS (f, "    Wr . PutText ( yyf , Fmt . Pad ( Fmt . Int ( ORD ( yyx [ yyi ] ) , 16 ) , 2 , '0' ) ) ;"); WriteNl (f);
        (* WriteS (f, "    Wr . PutChar ( yyf, ' ' ) ;"); *) 
        WriteS (f, "   END ;"); WriteNl (f);
        WriteS (f, "  ELSE"); WriteNl (f);
        WriteS (f, "   FOR yyi := 0 TO NUMBER ( yyx ) - 1 DO"); WriteNl (f);
        WriteS (f, "    Wr . PutText ( yyf , Fmt . Pad ( Fmt . Int ( ORD ( yyx [ yyi ] ) , 16 ) , 2 , '0' ) ) ;"); WriteNl (f);
        (* WriteS (f, "    Wr . PutChar ( yyf, ' ' ) ;"); *) 
        WriteS (f, "   END ;"); WriteNl (f);
        WriteS (f, "  END"); WriteNl (f);
        WriteS (f, " END yyWriteHex ;"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('o'), Options) THEN
        WriteS (f, "PROCEDURE yyWriteAdr ( yyt : "); WI (itTree); WriteS (f, " )"); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteS (f, "  IF yyt = "); WI (iNoTree); WriteS (f, " THEN"); WriteNl (f);
        WriteS (f, '   Wr . PutText ( yyf , "'); WI (iNoTree); WriteS (f, '" ) ;'); WriteNl (f);
        WriteS (f, "  ELSE"); WriteNl (f);
        WriteS (f, "   yyWriteHex ( LOOPHOLE ( yyt , ARRAY [ 0 .. 3 ] OF CHAR ) ) ;"); WriteNl (f);
(* ^Revisit this. *) 
        WriteS (f, "  END ;"); WriteNl (f);
        WriteS (f, "  yyWriteNl ( ) ;"); WriteNl (f);
        WriteS (f, " END yyWriteAdr;"); WriteNl (f);
        WriteNl (f);
        ForallClassesExtensionsFirst (Classes, WriteNode);
        WriteS (f, "PROCEDURE Write"); WI (iModule); WriteS (f, "Node ( f : Wr . T ; Tree : "); WI (itTree); WriteS (f, " ) "); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteS (f, "  yyf := f ;"); WriteNl (f);
        WriteS (f, "  IF Tree = "); WI (iNoTree); WriteS (f, " THEN"); WriteNl (f);
        WriteS (f, '   Wr . PutText ( yyf , "'); WI (iNoTree); WriteS (f, '" ) ; yyWriteNl ( ) ; RETURN ;'); WriteNl (f);
        WriteS (f, "  END ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  TYPECASE Tree OF"); WriteNl (f);
        WriteNodeName ( Classes ) ;
        WriteS (f, "  ELSE"); WriteNl (f);
        WriteS (f, "  END ;"); WriteNl (f);
        WriteS (f, " END Write"); WI (iModule); WriteS (f, "Node ;"); WriteNl (f);
        WriteNl (f);
      END;
      (* Generate ascii writer, original Cocktail format *) 
      IF IsElement (ORD ('w'), Options) THEN
        WriteS (f, "VAR yyIndentLevel      : INTEGER ;"); WriteNl (f);
        WriteS (f, "VAR yyActualIndent , yyIndentQuotient , yyIndentRemainder : INTEGER ;"); WriteNl (f);
        WriteS (f, "CONST yyIndentFactor = 20 ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yySetIndentInfo ( ) "); WriteNl (f);
        WriteS (f, " =BEGIN "); WriteNl (f);
        WriteS (f, "   yyIndentQuotient := yyIndentLevel DIV yyIndentFactor ; "); WriteNl (f);
        WriteS (f, "   yyIndentRemainder := yyIndentLevel MOD yyIndentFactor ; "); WriteNl (f);
        WriteS (f, "   yyActualIndent "); WriteNl (f);
        WriteS (f, "     := 10 * ORD ( yyIndentQuotient > 0 ) "); WriteNl (f);
        WriteS (f, "        + yyIndentRemainder "); WriteNl (f);
        WriteS (f, "  END yySetIndentInfo ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE Write"); WI (iModule); WriteS (f, " ( f : Wr . T ; Tree : "); WI (itTree); WriteS (f, " ) "); WriteNl (f);
        WriteS (f, "=VAR yySaveLevel : INTEGER ;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  yyf := f ;"); WriteNl (f);
        WriteS (f, "  IF yyRecursionLevel = 0 THEN yyLabelCount := 0 END ;"); WriteNl (f);
        WriteS (f, "  INC ( yyRecursionLevel ) ;"); WriteNl (f);
        WriteS (f, "  yyMark ( Tree ) ;"); WriteNl (f);
        WriteS (f, "  yySaveLevel := yyIndentLevel ;"); WriteNl (f);
        WriteS (f, "  yyIndentLevel := 0 ;"); WriteNl (f);
        WriteS (f, "  yySetIndentInfo ( ) ; "); WriteNl (f);
        WriteS (f, "  yyWrite"); WI (iModule); WriteS (f, " ( Tree );"); WriteNl (f);
        WriteS (f, "  yyIndentLevel := yySaveLevel ;"); WriteNl (f);
        WriteS (f, "  yySetIndentInfo ( ) ; "); WriteNl (f);
        WriteS (f, "  DEC ( yyRecursionLevel ) ;"); WriteNl (f);
        WriteS (f, " END Write"); WI (iModule); WriteS (f, " ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyIndentSelector ( yys : TEXT )"); WriteNl (f);
        WriteS (f, "=BEGIN "); WriteNl (f);
        WriteS (f, "   IF yyIndentQuotient > 0 "); WriteNl (f);
        WriteS (f, "   THEN Wr . PutChar ( yyf , '(' ) ; Wr . PutChar ( yyf , '*' ) ;"); WriteNl (f);
        WriteS (f, "     Wr . PutText ( yyf , Fmt . Pad ( Fmt . Int ( yyIndentQuotient * yyIndentFactor ) , 6 ) ) ; "); WriteNl (f);
        WriteS (f, "     Wr . PutChar ( yyf , '*' ) ; Wr . PutChar ( yyf , ')' ) ;"); WriteNl (f);
        WriteS (f, "   END ; "); WriteNl (f);
        WriteS (f, '   Wr . PutText ( yyf , Fmt . Pad ( "" , yyIndentRemainder ) ) ;'); WriteNl (f);
        WriteS (f, "   yyWriteSelector ( yys ) ; "); WriteNl (f);
        WriteS (f, " END yyIndentSelector ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyIndentSelectorTree ( yys : TEXT ; yyt : "); WI (itTree); WriteS (f, " )"); WriteNl (f);
        WriteS (f, "=BEGIN yyIndentSelector  ( yys ) ; write"); WI (itTree); WriteS (f, " (yyt) END yyIndentSelectorTree ;"); WriteNl (f);
        WriteNl (f);
        ForallClassesExtensionsFirst (Classes, WriteAttributes);
        WriteS (f, "PROCEDURE yyWrite"); WI (iModule); WriteS (f, " ( yyt : "); WI (itTree); WriteS (f, " )"); WriteNl (f);
        WriteS (f, "=VAR yyLevel : CARDINAL ;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  yyLevel := yyIndentLevel ;"); WriteNl (f);
        WriteS (f, "  LOOP"); WriteNl (f);
        WriteS (f, "   IF yyt = "); WI (iNoTree); WriteS (f, " THEN"); WriteNl (f);
        WriteS (f, '    Wr . PutText ( yyf , " '); WI (iNoTree); WriteS (f, '" ) ; yyWriteNl ( ) ; EXIT ; '); WriteNl (f);
        WriteS (f, "   ELSIF yyt . yyHead . yyMark = 0 THEN"); WriteNl (f);
        WriteS (f, "    Wr . PutChar ( yyf, '^') ;"); WriteNl (f);
        WriteS (f, "    Wr . PutText  ( yyf , Fmt . Int ( yyMapToLabel ( yyt ) ) ) ; yyWriteNl ( ) ; EXIT ;"); WriteNl (f);
        WriteS (f, "   ELSIF yyt . yyHead . yyMark > 1 THEN"); WriteNl (f);
        WriteS (f, "    yyWriteNl ( ) ;"); WriteNl (f);
        WriteS (f, "    Wr . PutText ( yyf , Fmt . Pad ( Fmt . Int ( yyMapToLabel ( yyt ) ) , 6 ) ) ;"); WriteNl (f);
        WriteS (f, "    Wr . PutChar ( yyf , ':') ;"); WriteNl (f);
        WriteS (f, '    Wr . PutText ( yyf , Fmt . Pad ( "" , MAX ( 0 , yyActualIndent - 7 ) ) ) ;'); WriteNl (f);
        WriteS (f, "   ELSE"); WriteNl (f);
        WriteS (f, "    Wr . PutChar ( yyf , ' ' ) ;"); WriteNl (f);
        WriteS (f, "   END ;"); WriteNl (f);
        WriteS (f, "   yyt . yyHead . yyMark := 0 ;"); WriteNl (f);
        WriteS (f, "   INC ( yyIndentLevel , 2 ) ;"); WriteNl (f);
        WriteS (f, "   yySetIndentInfo ( ) ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "   TYPECASE yyt OF"); WriteNl (f);
        WriteClassName ( Classes );
        WriteS (f, "   ELSE EXIT ;"); WriteNl (f);
        WriteS (f, "   END ;"); WriteNl (f);
        WriteS (f, "  END ;"); WriteNl (f);
        WriteS (f, "  yyIndentLevel := yyLevel ;"); WriteNl (f);
        WriteS (f, "  yySetIndentInfo ( ) ; "); WriteNl (f);
        WriteS (f, " END yyWrite"); WI (iModule); WriteS (f, " ;"); WriteNl (f);
        WriteNl (f);
      END;
      (* Generate html dumper *) 
      IF IsElement (ORD ('^'), Options) THEN
        WriteS (f, "PROCEDURE yyNodeTag ( yyt : "); WI ( itTree ) ; WriteS (f, " ) : TEXT "); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteS (f, '   RETURN "Node" & Fmt . Int ( yyMapToLabel ( yyt ) ) '); WriteNl (f);
        WriteS (f, " END yyNodeTag ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, " PROCEDURE yyNodeKind ( yyt : "); WI ( itTree ) ; WriteS (f, " ) : TEXT "); WriteNl (f);
        WriteS (f, " =BEGIN"); WriteNl (f);
        WriteS (f, "   IF yyt = "); WI (iNoTree); WriteNl (f);
        WriteS (f, "   THEN"); WriteNl (f);
        WriteS (f, '    RETURN "NIL" '); WriteNl (f);
        WriteS (f, "   ELSE"); WriteNl (f);
        WriteS (f, "    TYPECASE yyt OF"); WriteNl (f);
        NodeKinds ( Classes ) ; 
        WriteS (f, "    ELSE "); 
        WriteS (f, '     RETURN "<Unknown>" '); WriteNl (f);
        WriteS (f, "    END (* TYPECASE *) "); WriteNl (f);
        WriteS (f, "   END (* IF *) "); WriteNl (f);
        WriteS (f, "  END yyNodeKind ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE Write"); WI (iModule); WriteS (f, "Html "); WriteNl (f);
        WriteS (f, '  ( f : Wr . T ; Tree : '); WI (itTree); WriteS (f, ' ; Title : TEXT := "" '); WriteNl (f);
        WriteS (f, "  ; SuppressNullFields : BOOLEAN := FALSE ) "); WriteNl (f);
        WriteNl (f);
        WriteS (f, '=CONST IndentString = "  " ; '); 
        WriteNl (f);
        WriteS (f, " PROCEDURE WriteChildOrLink "); WriteNl (f);
        WriteS (f, "   ( Name , Type : TEXT ; Value : "); WI ( itTree ) ; WriteS (f, " ; IsLink : BOOLEAN := FALSE ) "); WriteNl (f);
        WriteS (f, " =VAR LNodeTag : TEXT ; "); WriteNl (f);
        WriteS (f, "  BEGIN "); WriteNl (f);
        WriteS (f, "   IF Value # NIL OR NOT SuppressNullFields "); 
        WriteS (f, "   THEN "); WriteNl (f);
        WriteS (f, "    Wr . PutText ( yyf , IndentString ) ; "); WriteNl (f);
        WriteS (f, "    Wr . PutText ( yyf , Name ) ; "); WriteNl (f);
        WriteS (f, '    Wr . PutText ( yyf , " : " ) ; '); WriteNl (f);
        WriteS (f, "    Wr . PutText ( yyf , Type ) ; "); WriteNl (f);
        WriteS (f, "    IF IsLink  "); WriteNl (f);
        WriteS (f, "    THEN "); WriteNl (f);
        WriteS (f, '      Wr . PutText ( yyf , " LINK" ) ; '); WriteNl (f);
        WriteS (f, "    END (* IF *) ; "); WriteNl (f);
        WriteS (f, '    Wr . PutText ( yyf , " = " ) ; '); WriteNl (f);
        WriteS (f, "    LNodeTag := yyNodeTag ( Value ) ; "); WriteNl (f);
        WriteS (f, '    Wr . PutText ( yyf , "<a href=\"#" ) ; '); WriteNl (f);
        WriteS (f, "    Wr . PutText ( yyf , LNodeTag ) ; "); WriteNl (f);
        WriteS (f, '    Wr . PutText ( yyf , "\">REF " ) ; '); WriteNl (f);
        WriteS (f, "    Wr . PutText ( yyf , LNodeTag ) ; "); WriteNl (f);
        WriteS (f, '    Wr . PutText ( yyf , "(" ) ; '); WriteNl (f);
        WriteS (f, "    yyWriteHex ( LOOPHOLE ( Value , ARRAY [ 0 .. 3 ] OF CHAR ) ) ; "); WriteNl (f);
        WriteS (f, '    Wr . PutText ( yyf , ")" ) ; '); WriteNl (f);
        WriteS (f, "    Wr . PutText ( yyf , yyNodeKind ( Value ) ) ; "); WriteNl (f);
        WriteS (f, '    Wr . PutText ( yyf , "</a>" ) ; '); WriteNl (f);
        WriteS (f, "    yyWriteNl ( ) ; "); WriteNl (f);
        WriteS (f, "   END (* IF *) "); 
        WriteS (f, "  END WriteChildOrLink ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, " PROCEDURE WriteBOOLEANAttribute "); WriteNl (f);
        WriteS (f, "   ( Name : TEXT ; Value : BOOLEAN ) "); WriteNl (f);
        WriteS (f, " =BEGIN "); WriteNl (f);
        WriteS (f, "   IF Value OR NOT SuppressNullFields "); 
        WriteS (f, "   THEN "); WriteNl (f);
        WriteS (f, "    Wr . PutText ( yyf , IndentString ) ; "); WriteNl (f);
        WriteS (f, "    Wr . PutText ( yyf , Name ) ; "); WriteNl (f);
        WriteS (f, '    Wr . PutText ( yyf , " : " ) ; '); WriteNl (f);
        WriteS (f, '    Wr . PutText ( yyf , "BOOLEAN = " ) ; '); 
        WriteS (f, "    writeBOOLEAN ( Value ) "); 
        WriteS (f, "    yyWriteNl ( ) ; "); WriteNl (f);
        WriteS (f, "   END (* IF *) "); 
        WriteS (f, "  END WriteBOOLEANAttribute ; "); WriteNl (f);
        WriteNl (f);
     (* WriteS (f, " PROCEDURE WriteAttributeHeader "); WriteNl (f);
        WriteS (f, "   ( Name , Type : TEXT ) "); WriteNl (f);
        WriteS (f, " =BEGIN "); WriteNl (f);
        WriteS (f, "   Wr . PutText ( yyf , IndentString ) ; "); WriteNl (f);
        WriteS (f, "   Wr . PutText ( yyf , Name ) ; "); WriteNl (f);
        WriteS (f, '   Wr . PutText ( yyf , " : " ) ; '); WriteNl (f);
        WriteS (f, "   Wr . PutText ( yyf , Type ) ; "); WriteNl (f);
        WriteS (f, '   Wr . PutText ( yyf , " = " ) ; '); WriteNl (f);
        WriteS (f, "  END WriteAttribute ; "); WriteNl (f);
        WriteS (f, ""); *) 
        ForallClassesExtensionsFirst ( Classes , WriteHtmlNodes ) ;
        WriteS (f, " PROCEDURE WriteHtmlRecurse ( yyt : "); WI ( itTree ) ; WriteS (f, " )"); WriteNl (f);
        WriteS (f, " =BEGIN"); WriteNl (f);
        WriteS (f, "   LOOP"); WriteNl (f);
        WriteS (f, "    IF yyt = "); WI (iNoTree); WriteS (f, " OR yyt . yyHead . yyMark = 0"); WriteNl (f);
        WriteS (f, "    THEN"); WriteNl (f);
        WriteS (f, "     EXIT"); WriteNl (f);
        WriteS (f, "    ELSE"); WriteNl (f);
        WriteS (f, "     yyt . yyHead . yyMark := 0 ;"); WriteNl (f);
        WriteS (f, "     TYPECASE yyt OF"); WriteNl (f);
        WriteHtmlCases ( Classes );
        WriteS (f, "     ELSE EXIT"); 
        WriteS (f, "     END (* TYPECASE *)"); WriteNl (f);
        WriteS (f, "    END (* IF *)"); WriteNl (f);
        WriteS (f, "   END (* LOOP *)"); WriteNl (f);
        WriteS (f, "  END WriteHtmlRecurse ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, " BEGIN (* Write"); WI (iModule); WriteS (f, "Html *)"); WriteNl (f);
        WriteS (f, "  yyf := f ;"); WriteNl (f);
        WriteS (f, "  IF yyRecursionLevel = 0 THEN yyLabelCount := 0 END ;"); WriteNl (f);
        WriteS (f, "  INC ( yyRecursionLevel ) ;"); WriteNl (f);
        WriteS (f, "  yyMark ( Tree ) ;"); WriteNl (f);
        WriteS (f, '  Wr . PutText ( yyf , "<html> " ) ; yyWriteNl ( ) ; '); 
        WriteS (f, '  Wr . PutText ( yyf , "<head>" ) ; yyWriteNl ( ) ; '); 
        WriteS (f, '  Wr . PutText ( yyf , "<title>" ) ; '); 
        WriteS (f, '  Wr . PutText ( yyf , "Tree \"" ) ; '); 
        WriteS (f, '  Wr . PutText ( yyf , Title ) ; '); 
        WriteS (f, '  Wr . PutText ( yyf , "\"</title>" ) ; yyWriteNl ( ) ; '); 
        WriteS (f, '  Wr . PutText ( yyf , "</head>" ) ; yyWriteNl ( ) ; '); 
        WriteS (f, '  Wr . PutText ( yyf , "<body>" ) ; yyWriteNl ( ) ; '); 
        WriteS (f, '  Wr . PutText ( yyf , "<pre>" ) ; yyWriteNl ( ) ; '); 
        WriteS (f, "  yyWriteNl ( ) ; "); WriteNl (f);
        WriteS (f, "  WriteHtmlRecurse ( Tree );"); WriteNl (f);
        WriteS (f, '  Wr . PutText ( yyf , "</pre>" ) ; yyWriteNl ( ) ; '); 
        WriteS (f, '  Wr . PutText ( yyf , "</body>" ) ; yyWriteNl ( ) ; '); 
        WriteS (f, '  Wr . PutText ( yyf , "</html>" ) ; yyWriteNl ( ) ; '); 
        WriteS (f, "  DEC ( yyRecursionLevel ) ;"); WriteNl (f);
        WriteS (f, " END Write"); WI (iModule); WriteS (f, "Html ;"); WriteNl (f);
        WriteNl (f);
      END;
(* Ascii reader not generated for M3.  Prefer to use Pickle. to avoid UNSAFE constructs which
   Ascii reader would need. 
      IF IsElement (ORD ('r'), Options) THEN 
        WriteS (f, "PROCEDURE Read"); WI (iModule); WriteS (f, "        (f: Rd.T): "); WI (itTree); WriteS (f, ";"); WriteNl (f);
        WriteS (f, " VAR yyt       : "); WI (itTree); WriteS (f, ";"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  yyf := f;"); WriteNl (f);
        WriteS (f, "  IF yyRecursionLevel = 0 THEN yyLabelCount := 0; END;"); WriteNl (f);
        WriteS (f, "  INC (yyRecursionLevel);"); WriteNl (f);
        WriteS (f, "  IF NOT yyIsInitialized THEN"); WriteNl (f);
        WriteS (f, "   yyInitKindToIdent; yyIsInitialized := TRUE;"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, "  yyRead"); WI (iModule); WriteS (f, " (SYSTEM.ADR (yyt));"); WriteNl (f);
        WriteS (f, "  DEC (yyRecursionLevel);"); WriteNl (f);
        WriteS (f, "  RETURN yyt;"); WriteNl (f);
        WriteS (f, " END Read"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyRead"); WI (iModule); WriteS (f, " (yyt: yyPtrtTree);"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  LOOP"); WriteNl (f);
        WriteS (f, "   CASE IO.ReadC (yyf) OF"); WriteNl (f);
        WriteS (f, "   | '^': yyLabel := IO.ReadI (yyf); yyReadNl; yyt^ := yyMapToTree (yyLabel); RETURN;"); WriteNl (f);
        WriteS (f, "   | 12C, '0': yyLabel := IO.ReadI (yyf); yyc := IO.ReadC (yyf);"); WriteNl (f);
        WriteS (f, "    Layout.SkipSpaces (yyf); Strings.ReadL (yyf, yys);"); WriteNl (f);
        WriteS (f, "    yyKind := yyMapToKind (yys); yyt^ := Make"); WI (iMain); WriteS (f, " (yyKind);"); WriteNl (f);
        WriteS (f, '    IF yyLabel # yyMapToLabel (yyt^) THEN Wr . PutText ( Stdio . stderr , "'); WI (iModule); WriteS (f, ': error in Read'); 
        WI (iModule); WriteS (f, '" ) ; Wr . PutText ( Stdio . stderr , Wr . EOL ) ; yyExit ; END ;'); WriteNl (f);
        WriteS (f, "   ELSE"); WriteNl (f);
        WriteS (f, "    Layout.SkipSpaces (yyf); Strings.ReadL (yyf, yys);"); WriteNl (f);
        WriteS (f, "    yyKind := yyMapToKind (yys);"); WriteNl (f);
        WriteS (f, "    IF yyKind = 0 THEN yyt^ := "); WI (iNoTree); WriteS (f, "; RETURN; END;"); WriteNl (f);
        WriteS (f, "    yyt^ := Make"); WI (iMain); WriteS (f, " (yyKind);"); WriteNl (f);
        WriteS (f, "   END;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "   CASE yyKind OF"); WriteNl (f);
        ForallClassesExtensionsFirst (Classes, ReadAttributes);
        WriteS (f, "   ELSE RETURN;"); WriteNl (f);
        WriteS (f, "   END;"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, " END yyRead"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "VAR yyKindToIdent      : ARRAY [0 .. "); WN (ClassCount); WriteS (f, "] OF Idents.tIdent;"); WriteNl (f);
        WriteS (f, "VAR yyIsInitialized    : BOOLEAN;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyMapToKind (VAR yys: Strings.tString): CARDINAL;"); WriteNl (f);
        WriteS (f, " VAR yyi       : Idents.tIdent;"); WriteNl (f);
        WriteS (f, " VAR yyk       : CARDINAL;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  yyi := Idents.MakeIdent (yys);"); WriteNl (f);
        WriteS (f, "  FOR yyk := 0 TO "); WN (ClassCount); WriteS (f, " DO"); WriteNl (f);
        WriteS (f, "   IF yyKindToIdent [yyk] = yyi THEN RETURN yyk; END;"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, "  RETURN 0;"); WriteNl (f);
        WriteS (f, " END yyMapToKind;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyInitKindToIdent2 (yya: ARRAY OF CHAR; yyKind: CARDINAL);"); WriteNl (f);
        WriteS (f, " VAR yys       : Strings.tString;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  Strings.ArrayToString (yya, yys);"); WriteNl (f);
        WriteS (f, "  yyKindToIdent [yyKind] := Idents.MakeIdent (yys);"); WriteNl (f);
        WriteS (f, " END yyInitKindToIdent2;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyInitKindToIdent;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  yyInitKindToIdent2 ('"); WI (iNoTree); WriteS (f, "', 0);"); WriteNl (f);
        ForallClassesExtensionsFirst (Classes, InitKindToIdent);
        WriteS (f, " END yyInitKindToIdent;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyReadNl; BEGIN IO.ReadNl (yyf); END yyReadNl;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyReadIdent (): Idents.tIdent;"); WriteNl (f);
        WriteS (f, " VAR yys       : Strings.tString;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  Strings.ReadL (yyf, yys);"); WriteNl (f);
        WriteS (f, "  IO.UnRead (yyf);"); WriteNl (f);
        WriteS (f, "  RETURN Idents.MakeIdent (yys);"); WriteNl (f);
        WriteS (f, " END yyReadIdent;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyReadHex (VAR yyx: ARRAY OF SYSTEM.BYTE);"); WriteNl (f);
        WriteS (f, " VAR yyi       : INTEGER;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  FOR yyi := 0 TO INTEGER (HIGH (yyx)) DO"); WriteNl (f);
        WriteS (f, "   yyx [yyi] := SYSTEM.BYTE (CHR (CARDINAL (IO.ReadN (yyf, 16))));"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, " END yyReadHex;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yySkip;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  REPEAT UNTIL IO.ReadC (yyf) = '='; yyc := IO.ReadC (yyf);"); WriteNl (f);
        WriteS (f, " END yySkip;"); WriteNl (f);
        WriteNl (f);
      END;
*) 
      IF IsElement (ORD ('p'), Options) 
         OR IsElement (ORD ('g'), Options) THEN
        WriteS (f, "TYPE AtomSpecialTyp = Pickle . Special OBJECT"); WriteNl (f);
        WriteS (f, "  OVERRIDES"); WriteNl (f);
        WriteS (f, "    write := WriteAtom"); WriteNl (f);
        WriteS (f, "  ; read := ReadAtom"); WriteNl (f);
        WriteS (f, "  END ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE WriteAtom ( Self : AtomSpecialTyp ; r : REFANY ; wr : Pickle . Writer )"); WriteNl (f);
        WriteS (f, "  RAISES { Pickle . Error , Wr . Failure , Thread . Alerted }"); WriteNl (f);
        WriteS (f, "= VAR LText : TEXT := Atom . ToText ( NARROW ( r , Atom . T ) )"); WriteNl (f);
        WriteS (f, "      (* Why does M3 accept this without the NARROW? *) "); WriteNl (f);
        WriteS (f, "; VAR LLength : INTEGER := Text . Length ( LText )"); WriteNl (f);
        WriteS (f, "; BEGIN"); WriteNl (f);
        WriteS (f, "    wr . writeInt ( LLength ) "); WriteNl (f);
        WriteS (f, "  ; FOR i := 0 TO LLength "); WriteNl (f);
        WriteS (f, "    DO"); WriteNl (f);
        WriteS (f, "      Wr . PutChar ( wr . wr , Text . GetChar ( LText , i ) )"); WriteNl (f);
        WriteS (f, "    END (* FOR *) "); WriteNl (f);
        WriteS (f, "  END WriteAtom ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE ReadAtom "); WriteNl (f);
        WriteS (f, "  ( Self : AtomSpecialTyp ; rd : Pickle . Reader ; id : Pickle . RefID ) "); WriteNl (f);
        WriteS (f, "  : REFANY"); WriteNl (f);
        WriteS (f, "  RAISES { Pickle . Error , Rd . EndOfFile , Rd . Failure , Thread . Alerted }"); WriteNl (f);
        WriteS (f, "= VAR LLength : INTEGER := rd . readInt ( ) "); WriteNl (f);
        WriteS (f, "; VAR LChars : REF ARRAY OF CHAR := NEW ( REF ARRAY OF CHAR , LLength ) "); WriteNl (f);
        WriteS (f, "; BEGIN"); WriteNl (f);
        WriteS (f, "    FOR i := 0 TO LLength "); WriteNl (f);
        WriteS (f, "    DO "); WriteNl (f);
        WriteS (f, "      LChars ^ [ i ] := Rd . GetChar ( rd . rd )"); WriteNl (f);
        WriteS (f, "    END (* FOR *) "); WriteNl (f);
        WriteS (f, "  ; RETURN Atom . FromText ( Text . FromChars ( LChars ^ ) )"); WriteNl (f);
        WriteS (f, "  END ReadAtom ;"); WriteNl (f);
        WriteNl (f);
      END; 
      IF IsElement (ORD ('p'), Options) THEN
        WriteS (f, "PROCEDURE Put"); WI (iModule); WriteS (f, " ( f : Wr . T ; Tree : "); WI (itTree); WriteS (f, " )"); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteS (f, "   Pickle . Write ( f , Tree )"); WriteNl (f);
        WriteS (f, " END Put"); WI (iModule); WriteS (f, " ;"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('g'), Options) THEN
        WriteS (f, "PROCEDURE Get"); WI (iModule); WriteS (f, " ( f : Rd . T ) : "); WI (itTree); 
        WriteS (f, "= BEGIN"); WriteNl (f);
        WriteS (f, "    RETURN NARROW ( Pickle . Read ( f ) , "); WI ( itTree ) ; WriteS (f, " )"); WriteNl (f);
        WriteS (f, "  END Get"); WI (iModule); WriteS (f, " ;"); WriteNl (f);
        WriteNl (f);
      END;
}; .


PROCEDURE TreeIOInit (t: Tree)

Ag (..) :- {
      IF IsElement (ORD ('p'), Options) 
         OR IsElement (ORD ('g'), Options) THEN
        WriteS (f, "Pickle . RegisterSpecial ( NEW ( AtomSpecialTyp , sc := TYPECODE ( Atom . T ) ) ) ;"); WriteNl (f);
      END; 
}; .


PROCEDURE WriteNodeName (t: Tree)

Class (..) :- {
        WriteNodeName ( Extensions ) ; 
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "   | "); WI (Name); WriteS (f, " ( TNode ) =>"); WriteNl (f);
           WriteS (f, '        Wr . PutText ( yyf , "'); WI (Name); WriteS (f, '" ) ; yyWriteNl ( ) ;'); 
           IF ({HasChildren, HasAttributes} * Properties) # {} THEN
             WriteS (f, "        yyyWriteNode"); WI (Name); WriteS (f, " ( TNode ) ;"); WriteNl (f);
           END;
           WriteNl (f);
        END;
        WriteNodeName ( Next ) ; 
}; .


PROCEDURE WriteNode (t: Tree)

Class (..) :- {
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           WriteS (f, "PROCEDURE yyyWriteNode"); WI (Name); WriteS (f, " ( yyt : "); WI ( Name ); WriteS (f, " )"); WriteNl (f);
           WriteS (f, "=BEGIN"); WriteNl (f);
           IF (BaseClass^.Kind = Tree.Class) AND                (* NOT Top ? *)
              (({HasChildren, HasAttributes} * BaseClass^.Class.Properties) # {}) THEN
           WriteS (f, "  yyyWriteNode"); WI (BaseClass^.Class.Name); WriteS (f, " (yyt); "); WriteNl (f);
           END;
           iClassName := Name; (* unused, at present *) 
           ForallAttributes (Attributes, WriteNode);
           WriteS (f, " END yyyWriteNode"); WI (Name); WriteS (f, ";"); WriteNl (f);
           WriteNl (f);
        END;
}; .
Child (..) :- {
        WriteS (f, '  yyWriteSelector ( "'); WI (Name); WriteS (f, '" ) ;'); 
        WriteS (f, " yyWriteAdr ( yyt . "); WI (Name); WriteS (f, " ) ;"); WriteNl (f);
}; .
Attribute (..) :- {
        IF (NoCodeAttr * Properties) = {} THEN
         IF Link IN Properties 
         THEN
           WriteS (f, '  yyWriteSelector ( "'); WI (Name); WriteS (f, '" ) ;'); 
           WriteS (f, " yyWriteAdr ( yyt . "); WI (Name); WriteS (f, " ) ;"); WriteNl (f);
         ELSE  
           WriteS (f, '  yyWriteSelector ( "'); WI (Name); WriteS (f, '" ) ; write'); WI (Type);
           WriteS (f, " ( yyt . "); WI (Name) ; WriteS (f, " ) yyWriteNl ( ) ;"); WriteNl (f);
         END; 
        END;
}; .


PROCEDURE Mark (t: Tree)

Class (..) :- {
        Mark ( Extensions ) ; 
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           WriteS (f, "    | "); WI (Name); WriteS (f, " ( TNode ) => "); WriteNl (f);
           GetIterator (t);
           iClassName := Name; (* unused, at present *) 
           ForallAttributes (t, Mark);
           IF Iterator = NoTree THEN
              WriteS (f, "RETURN ;"); WriteNl (f);
           ELSE
              WriteS (f, "yyt := TNode . "); WI (Iterator^.Child.Name); WriteS (f, " ;"); WriteNl (f);
           END;
        END;
        Mark ( Next ) ; 
}; .

Child (..) :- {
        IF t # Iterator THEN
           WriteS (f, "yyMark ( TNode . "); WI (Name); WriteS (f, ");"); WriteNl (f);
        END;
}; .

Attribute (..) :- {
        IF Link IN Properties THEN
           WriteS (f, "yyMark ( TNode . "); WI (Name); WriteS (f, ");"); WriteNl (f);
        END;
}; .


PROCEDURE WriteClassName (t: Tree)

Class (..) :- {
        WriteClassName ( Extensions ) ; 
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "   | "); WI (Name); WriteS (f, " ( TNode ) => "); WriteNl (f);
           IF ({HasChildren, HasAttributes} * Properties) # {} THEN
              WriteS (f, "       yWrite"); WI (Name); WriteS (f, " ( TNode ) ; "); WriteNl (f);
              GetIterator (t);
              IF Iterator = NoTree THEN
                WriteS (f, "       EXIT ;"); WriteNl (f);
              ELSE
                 WriteS (f, '       yyIndentSelector ( "'); WI (Iterator^.Child.Name); WriteS (f, '" ) ;'); 
                 WriteS (f, "       yyt := TNode . "); WI (Iterator^.Child.Name); WriteS (f, " ;"); WriteNl (f);
              END ;
           ELSE
              WriteS (f, '       Wr . PutText ( yyf , "'); WI (Name); WriteS (f, '" ) ; yyWriteNl ( ) ; EXIT ;'); WriteNl (f);
           END;
        END;
        WriteClassName ( Next ) ; 
}; .


PROCEDURE WriteAttributes (t: Tree)

Class (..) :- {
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           WriteS (f, "PROCEDURE yWrite"); WI (Name); WriteS (f, " ( yyt : "); WI ( Name ); WriteS (f, " )"); WriteNl (f);
           WriteS (f, "=BEGIN"); WriteNl (f);
           WriteS (f, '  Wr . PutText ( yyf , "'); WI (Name); WriteS (f, '" ) ; yyWriteNl ( ) ;'); WriteNl (f);
           GetIterator (t);
           iClassName := Name; (* unused, at present *) 
           ForallAttributes (t, WriteAttributes);
           WriteS (f, " END yWrite"); WI (Name); WriteS (f, " ;"); WriteNl (f);
           WriteNl (f);
        END;
}; .
Child (..) :- {
        IF t # Iterator THEN
           WriteS (f, '  yyIndentSelectorTree ( "'); WI (Name); WriteS (f, '" , yyt . '); WI (Name); WriteS (f, ' ) ;'); WriteNl (f);
        END;
}; .
Attribute (..) :- {
        IF (NoCodeAttr * Properties) = {} THEN 
         IF Link IN Properties 
         THEN
           WriteS (f, '  yyIndentSelectorTree ( "'); WI (Name); WriteS (f, '" , yyt . '); WI (Name); WriteS (f, ' ) ;'); WriteNl (f);
         ELSE 
           WriteS (f, '  yyIndentSelector ( "'); WI (Name); WriteS (f, '" ) ; '); 
           WriteS (f, "write"); WI (Type); WriteS (f, " ( yyt . "); WI (Name); WriteS (f, " ) yyWriteNl ( ) ;"); WriteNl (f);
         END (* IF *) ; 
        END;
}; .

(* Html writer support routines *) 

PROCEDURE NodeKinds ( t : Tree ) 

Class ( .. ) 
:- { NodeKinds ( Extensions ) ; 
     IF ( NoCodeClass * Properties = { } ) 
     THEN
       WriteS (f, "     | "); WI ( Name ) ; WriteS (f, " => "); 
       WriteS (f, '         RETURN "'); WI ( Name ) ; WriteS (f, '" ; '); WriteNl (f);
     END (* IF *) ; 
     NodeKinds ( Next ) 
   } ; . 

PROCEDURE WriteHtmlNodes ( t : Tree ) 

Class ( .. ) 
:- { 
     IF ( NoCodeClass * Properties = { } ) 
     THEN
       WriteS (f, " PROCEDURE Write"); WI ( Name ) ; WriteS (f, "Html ( TNode : "); WI ( Name ) ; WriteS (f, " ) "); 
       WriteS (f, " =VAR LNodeTag : TEXT ; "); WriteNl (f);
       WriteS (f, "  BEGIN "); WriteNl (f);
       WriteS (f, "    LNodeTag := yyNodeTag ( TNode ) ; "); WriteNl (f);
       WriteS (f, '    Wr . PutText ( yyf , "<a name=\"" ) ; '); WriteNl (f);
       WriteS (f, "    Wr . PutText ( yyf , LNodeTag ) ; "); WriteNl (f);
       WriteS (f, '    Wr . PutText ( yyf , "\">DEF " ) ; '); WriteNl (f);
       WriteS (f, "    Wr . PutText ( yyf , LNodeTag ) ; "); WriteNl (f);
       WriteS (f, '    Wr . PutText ( yyf , "(" ) ; '); WriteNl (f);
       WriteS (f, "    yyWriteHex ( LOOPHOLE ( TNode , ARRAY [ 0 .. 3 ] OF CHAR ) ) ; "); WriteNl (f);
       WriteS (f, '    Wr . PutText ( yyf , ")'); WI ( Name ) ; WriteS (f, '</a>" ) ; '); WriteNl (f);
       WriteS (f, "    yyWriteNl ( ) ; "); WriteNl (f);
       IF ( { HasChildren , HasAttributes } * Properties # { } ) 
       THEN 
         ForallAttributes ( t , WriteHtmlNodes ) ; 
       END (* IF *) ; 
       WriteS (f, "    yyWriteNl ( ) ; "); WriteNl (f);
       WriteS (f, "  END Write"); WI ( Name ) ; WriteS (f, "Html ; "); WriteNl (f);
       WriteNl (f);
     END (* IF *) ; 
   } ; . 

Child ( .. ) 
:- { WriteS (f, '    WriteChildOrLink ( "'); WI ( Name ) ; WriteS (f, '" , "'); WI ( Type ) ; 
     WriteS (f, '" , TNode . '); WI ( Name ) ; WriteS (f, ' ) ; '); WriteNl (f);
   } ; . 

Attribute ( .. ) 
:- { IF (NoCodeAttr * Properties) = {} 
     THEN 
       IF Link IN Properties 
       THEN 
         WriteS (f, '    WriteChildOrLink ( "'); WI ( Name ) ; WriteS (f, '" , "'); WI ( Type ) ; 
         WriteS (f, '" , TNode . '); WI ( Name ) ; WriteS (f, ' , TRUE ) ; '); WriteNl (f);
       ELSIF Type = iBOOLEAN 
       THEN 
         WriteS (f, '    WriteBOOLEANAttribute ( "'); WI ( Name ) ; WriteS (f, '" , TNode . '); WI ( Name ) ; WriteS (f, ' ) ; '); WriteNl (f);
       ELSE
         WriteS (f, '    Wr . PutText ( yyf , IndentString & "'); WI ( Name ) ; WriteS (f, ' : '); WI ( Type ) ; WriteS (f, ' = " ) ; '); WriteNl (f);
         WriteS (f, "    write"); WI ( Type ) ; WriteS (f, " ( TNode . "); WI ( Name ) ; WriteS (f, " ) "); WriteNl (f);
         (* ^ No semicolon, as the write<type> macro expands to include it *) 
         WriteS (f, "    yyWriteNl ( ) ; "); WriteNl (f);
       END (* IF *) ; 
     END (* IF *) ; 
   } ; . 

PROCEDURE WriteHtmlCases ( t : Tree ) 

Class ( .. ) 
:- { WriteHtmlCases ( Extensions ) ; 
     IF ( NoCodeClass * Properties = { } ) 
     THEN
       WriteS (f, "     | "); WI ( Name ) ; WriteS (f, " ( TNode ) => "); WriteNl (f);
       WriteS (f, "         Write"); WI ( Name ) ; WriteS (f, "Html ( TNode ) ; "); WriteNl (f);
       IF ( { HasChildren , HasAttributes } * Properties # { } ) 
       THEN 
         GetIterator ( t ) ; 
         ForallAttributes ( t , WriteHtmlCases ) ;  
         IF Iterator = NoTree THEN
           WriteS (f, "         EXIT ;"); WriteNl (f);
         ELSE
           WriteS (f, "         yyt := TNode . "); WI ( Iterator ^ . Child . Name ) ; WriteS (f, " ; "); WriteNl (f);
         END;
       END (* IF *) 
     END (* IF *) ;  
     WriteHtmlCases ( Next ) ;  
   } ; . 

Child ( .. )  
:- { IF t # Iterator 
     THEN
         WriteS (f, "         WriteHtmlRecurse ( TNode . "); WI ( Name ) ; WriteS (f, " ) ;"); WriteNl (f);
     END (* IF *) ; 
   } ; . 

Attribute ( .. )  
:- { IF Link IN Properties  
     THEN
         WriteS (f, "         WriteHtmlRecurse ( TNode . "); WI ( Name ) ; WriteS (f, " ) ;"); WriteNl (f);
     END (* IF *) ; 
   } ; . 

(* Ascii reader not generated for M3.  Prefer to use Pickle. to avoid UNSAFE constructs which
   Ascii reader would need. 

PROCEDURE ReadAttributes (t: Tree)

Class (..) :- {
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           WriteS (f, "| "); WI (Name); WriteS (f, ":"); WriteNl (f);
           GetIterator (t);
           iClassName := Name;
           ForallAttributes (t, ReadAttributes);
           IF Iterator = NoTree THEN
              WriteS (f, "RETURN;"); WriteNl (f);
           ELSE
              WriteS (f, "yySkip; yyt := SYSTEM.ADR (yyt^^."); WI (iClassName); WriteS (f, "."); WI (Iterator^.Child.Name); WriteS (f, ");"); WriteNl (f);
           END;
        END;
}; .
Child (..) :- {
        IF t # Iterator THEN
           WriteS (f, "yySkip; read"); WI (itTree); WriteS (f, " (SYSTEM.ADR (yyt^^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, "))"); WriteNl (f);
        END;
}; .
Attribute (..) :- {
        IF (NoCodeAttr * Properties) = {} THEN 
           WriteS (f, "yySkip; read"); WI (Type); WriteS (f, " (yyt^^."); WI (iClassName); WriteS (f, "."); WI (Name); WriteS (f, ") yyReadNl;"); WriteNl (f);
        END;
}; .

PROCEDURE InitKindToIdent (t: Tree)

Class (..) :- {
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "  yyInitKindToIdent2 ('"); WI (Name); WriteS (f, "', "); WI (Name); WriteS (f, ");"); WriteNl (f);
        END;
}; .

*)


PROCEDURE GetIterator (t: Tree)

Class (..) :- {
        Iterator := NoTree;
        RevChild := NoTree;
        ForallAttributes (t, GetIterator);
        IF RevChild # NoTree THEN Iterator := RevChild; END;
}; .
Child (..) :- {
        Iterator := t;
        IF Reverse IN Properties THEN RevChild := t; END;
}; .


