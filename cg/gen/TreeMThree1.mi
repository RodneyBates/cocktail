
(* This file was mechanically generated by puma. *)

IMPLEMENTATION MODULE TreeMThree1;








IMPORT SYSTEM, System, IO, Tree;
(* line 31 "" *)


FROM General    IMPORT Max;
FROM IO         IMPORT WriteS, WriteNl;
FROM Idents     IMPORT tIdent;
FROM Texts      IMPORT WriteText;
FROM Sets       IMPORT IsElement, Include;
FROM TreeMThree2        IMPORT GetIterator, Iterator, WriteLine;
FROM TreeMThree2        IMPORT TreeIO , TreeIOInit ;
FROM GenGnat    IMPORT GnatModule ; 
FROM IOUtils    IMPORT WriteBackslash ; 

FROM Tree       IMPORT
   NoTree       , tTree         , Input         , Reverse       ,
   Class        , Child         , Attribute     , Abstract      ,
   HasChildren  , HasAttributes , NoCodeAttr    , NoCodeClass   ,
   Link         , 
   Options      , TreeRoot      , ClassCount    , iNoTree       ,
   itTree       , iMain         , iModule       , f             ,
   WI   , WN    , ForallClasses , ForallClassesExtensionsFirst  ,
   ForallAttributes, Ignore     ,
   Test         , Dummy         , ForallClassesPreAndPost;

IMPORT Strings;

VAR
   ConstCount   ,
   ListCount    : INTEGER;
   iRange       ,
   iClassName   : tIdent;
   Node         : tTree;
   gBitCount    : SHORTCARD;
   i, MaxBit    : SHORTCARD;






































































































PROCEDURE yyAbort (yyFunction: ARRAY OF CHAR);
 BEGIN
  IO.WriteS (IO.StdError, 'Error: module TreeMThree1, routine ');
  IO.WriteS (IO.StdError, yyFunction);
  IO.WriteS (IO.StdError, ' failed');
  IO.WriteNl (IO.StdError);
  Exit;
 END yyAbort;

PROCEDURE yyIsEqual (yya, yyb: ARRAY OF SYSTEM.BYTE): BOOLEAN;
 VAR yyi       : INTEGER;
 BEGIN
  FOR yyi := 0 TO INTEGER (HIGH (yya)) DO
   IF yya [yyi] # yyb [yyi] THEN RETURN FALSE; END;
  END;
  RETURN TRUE;
 END yyIsEqual;

PROCEDURE TreeInterface (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Ag) THEN
(* line 70 "" *)
     WITH t^.Ag DO
(* line 70 "" *)
      
        WriteS (f, "INTERFACE "); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
      IF IsElement (ORD ('<'), Options) THEN
        WriteS (f, "FROM "); WI (iMain); WriteS (f, " IMPORT "); WI (itTree); WriteS (f, ", tProcTree;"); WriteNl (f);
      END;
      IF IsElement (ORD ('w'), Options) 
         OR IsElement (ORD ('^'), Options) 
         OR IsElement (ORD ('o'), Options) 
         OR IsElement (ORD ('p'), Options) THEN  
        WriteS (f, "IMPORT Wr ;"); WriteNl (f);
      END; 
      IF IsElement (ORD ('g'), Options) THEN  
        WriteS (f, "IMPORT Rd ;"); WriteNl (f);
      END; 
      IF IsElement (ORD ('~'), Options) THEN
	WriteS (f, "IMPORT GnatTypes ;"); WriteNl (f);
      END;
        WriteLine (TreeCodes^.Codes.ImportLine);
        WriteText (f, TreeCodes^.Codes.Import);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.ImportLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Import);
           Node := Node^.Module.Next;
        END;
        WriteNl (f);
      IF NOT IsElement (ORD ('<'), Options) THEN
        WriteS (f, "CONST"); WriteNl (f);
        WI (iNoTree); WriteS (f, " = NIL;"); WriteNl (f);
        WriteNl (f);
        ForallClassesPreAndPost (Classes, ConstDeclsPre, ConstDeclsPost);
        WriteNl (f);
        WriteS (f, "TYPE SHORTCARD = BITS 16 FOR [ 0 .. 32767 ];"); WriteNl (f);
        WriteS (f, "tProcTree = PROCEDURE (Tree:"); WI (itTree); WriteS (f, ") RAISES ANY;"); WriteNl (f);
      END;
        WriteLine (TreeCodes^.Codes.ExportLine);
        WriteText (f, TreeCodes^.Codes.Export);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.ExportLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Export);
           Node := Node^.Module.Next;
        END;
        WriteNl (f);
      IF NOT IsElement (ORD ('<'), Options) THEN 
         
        WriteS (f, "# ifndef yyNodeHead"); WriteNl (f);
        WriteS (f, "# define yyNodeHead"); WriteNl (f);
        WriteS (f, "# endif"); WriteNl (f);
        WriteS (f, "TYPE"); WriteNl (f);
      IF IsElement (ORD ('L'), Options) THEN
        WriteS (f, "BitSet = SET OF 0 .. "); WN ( MaxBit ) ; WriteS (f, " ;"); WriteNl (f);
        MaxBit := 0;
        ForallClasses (Classes, CompMaxBit);
        WriteS (f, "yytNodeHead = RECORD yyMark, yyOffset: SHORTCARD; yyParent: "); WI (itTree); WriteS (f, "; yyIsComp"); 
      IF IsElement (ORD ('5'), Options) THEN
        WriteS (f, ", yyIsDone"); 
      END;

        WriteS (f, ": BitSet ; yyNodeHead END;"); WriteNl (f);
      ELSE
        WriteS (f, "yytNodeHead = RECORD yyMark: SHORTCARD; yyNodeHead END;"); WriteNl (f);
      END;
        WriteS (f, "TYPE "); WI (itTree); WriteS (f, " = OBJECT Kind : SHORTCARD ; yyHead : yytNodeHead ; END;"); WriteNl (f);
        TypeDeclNode ( Classes, t); 
        WriteNl (f);
        WriteS (f, "VAR "); WI (iMain); WriteS (f, "Root        : "); WI (itTree); WriteS (f, ";"); WriteNl (f);
        WriteS (f, "VAR yyExit     : PROCEDURE ( ) ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "EXCEPTION BadNodeKind ; "); WriteNl (f);
        WriteS (f, "(* Make"); WI (iMain); WriteS (f, " is deprecated for Modula-3. *)"); WriteNl (f);
        WriteS (f, "<*OBSOLETE*>PROCEDURE Make"); WI (iMain); WriteS (f, "  (Kind : SHORTCARD): "); WI (itTree); WriteS (f, " RAISES { BadNodeKind } ; "); WriteNl (f);
        WriteS (f, "(* IsType is deprecated for Modula-3. *)"); WriteNl (f);
        WriteS (f, "<*OBSOLETE*>PROCEDURE IsType       (Tree: "); WI (itTree); WriteS (f, "; Kind : SHORTCARD): BOOLEAN RAISES { BadNodeKind } ;"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('n'), Options) THEN
        WriteS (f, "(* Uninitialized node construtors: *)"); WriteNl (f);
        ForallClassesExtensionsFirst (Classes, ProcedureDeclsn);
        WriteNl (f);
      END;
      IF IsElement (ORD ('m'), Options) THEN
        WriteS (f, "(* Node constructors with initialization of input children and attributes: *)"); WriteNl (f);
        ForallClassesExtensionsFirst (Classes, ProcedureHeadingmInterface );
        WriteNl (f);
      END;
      IF IsElement (ORD ('o'), Options) THEN
        WriteS (f, "(* Ascii node writer: *)"); WriteNl (f);
        WriteS (f, "PROCEDURE Write"); WI (iModule); WriteS (f, "Node   (f: Wr.T; Tree: "); WI (itTree); WriteS (f, ");"); WriteNl (f);
      END;
      IF IsElement (ORD ('w'), Options) THEN
        WriteS (f, "(* Ascii graph writer: *)"); WriteNl (f);
        WriteS (f, "PROCEDURE Write"); WI (iModule); WriteS (f, "       (f: Wr.T; Tree: "); WI (itTree); WriteS (f, ");"); WriteNl (f);
      END;
      IF IsElement (ORD ('^'), Options) THEN
        WriteS (f, "(* Html graph writer: *)"); WriteNl (f);
	WriteS (f, "PROCEDURE Write"); WI (iModule); WriteS (f, "Html "); WriteNl (f);
        WriteS (f, '  ( f : Wr . T ; Tree : '); WI (itTree); WriteS (f, ' ; Title : TEXT := "" '); WriteNl (f);
        WriteS (f, "  ; SuppressNullFields : BOOLEAN := FALSE "); WriteNl (f);
        WriteS (f, "  ) ; "); WriteNl (f);
      END;
      IF IsElement (ORD ('r'), Options) THEN
        WriteS (f, "(* Ascii graph reader: *)"); WriteNl (f);
        WriteS (f, "PROCEDURE Read");WI (iModule); WriteS (f, "        (f: Rd.T): "); WI (itTree); WriteS (f, ";"); WriteNl (f);
      END;
      IF IsElement (ORD ('p'), Options) THEN
        WriteS (f, "(* Binary graph writer: *) "); WriteNl (f);
        WriteS (f, "PROCEDURE Put"); WI (iModule); WriteS (f, " (f: Wr.T; Tree: "); WI (itTree); WriteS (f, ");"); WriteNl (f);
      END;
      IF IsElement (ORD ('g'), Options) THEN
        WriteS (f, "(* Binary graph reader: *)"); WriteNl (f);
        WriteS (f, "PROCEDURE Get"); WI (iModule); WriteS (f, " (f: Rd.T): "); WI (itTree); WriteS (f, ";"); WriteNl (f);
      END;
      IF IsElement (ORD ('t'), Options) THEN
        WriteS (f, "(* Top down traverser: *)"); WriteNl (f);
        WriteS (f, "PROCEDURE Traverse"); WI (iModule); WriteS (f, "TD  (Tree: "); WI (itTree); WriteS (f, "; Proc: tProcTree);"); WriteNl (f);
      END;
      IF IsElement (ORD ('b'), Options) THEN
        WriteS (f, "(* Bottom up traverser: *)"); WriteNl (f);
        WriteS (f, "PROCEDURE Traverse"); WI (iModule); WriteS (f, "BU  (Tree: "); WI (itTree); WriteS (f, "; Proc: tProcTree);"); WriteNl (f);
      END;
      IF IsElement (ORD ('R'), Options) THEN
        WriteS (f, "PROCEDURE Reverse"); WI (iModule); WriteS (f, "     (Tree: "); WI (itTree); WriteS (f, "): "); WI (itTree); WriteS (f, ";"); WriteNl (f);
      END;
      IF IsElement (ORD ('y'), Options) THEN
        WriteS (f, "PROCEDURE Copy"); WI (iModule); WriteS (f, "        (Tree: "); WI (itTree); WriteS (f, "): "); WI (itTree); WriteS (f, ";"); WriteNl (f);
      END;
      IF IsElement (ORD ('k'), Options) THEN
        WriteS (f, "(* Graph validity checker.  Unless PSG-style classes get added to cg/puma,"); WriteNl (f);
        WriteS (f, "   this is redundant in Modula-3, since the type system ensures validity. *)"); WriteNl (f);
        WriteS (f, "PROCEDURE Check"); WI (iModule); WriteS (f, "       (Tree: "); WI (itTree); WriteS (f, "): BOOLEAN;"); WriteNl (f);
      END;
      IF IsElement (ORD ('q'), Options) THEN
        WriteS (f, "PROCEDURE Query"); WI (iModule); WriteS (f, "       (Tree: "); WI (itTree); WriteS (f, ");"); WriteNl (f);
      END;
      IF IsElement (ORD ('='), Options) THEN
        WriteS (f, "PROCEDURE IsEqual"); WI (iModule); WriteS (f, "     (Tree1, Tree2: "); WI (itTree); WriteS (f, "): BOOLEAN;"); WriteNl (f);
      END;
      IF IsElement (ORD ('~'), Options) THEN
	WriteS (f, "PROCEDURE GnatConvert"); WI (iMain); WriteS (f, " ( GnatTree : GnatTypes . Node_Id ) : "); WI (itTree); WriteS (f, " ;"); WriteNl (f);
      END;
      IF IsElement (ORD ('L'), Options) THEN
        WriteS (f, "PROCEDURE Init"); WI (iModule); WriteS (f, "        (Tree: "); WI (itTree); WriteS (f, ");"); WriteNl (f);
      END;
        WriteS (f, "PROCEDURE Begin"); WI (iModule); WriteS (f, " ( ) ;"); WriteNl (f);
        WriteS (f, "PROCEDURE Close"); WI (iModule); WriteS (f, " ( ) ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "END "); WI (iModule); WriteS (f, " ."); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  END;
 END TreeInterface;

PROCEDURE ConstDeclsPre (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 231 "" *)
     WITH t^.Class DO
(* line 231 "" *)
      
        IF NOT (Abstract IN Properties) THEN
           INC (ConstCount);
           IF NOT (Ignore IN Properties) THEN
              WriteS (f, "Nk"); WI (Name); WriteS (f, " = "); WN (ConstCount); WriteS (f, ";"); WriteNl (f);
           END;
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END ConstDeclsPre;

PROCEDURE ConstDeclsPost (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 242 "" *)
     WITH t^.Class DO
(* line 242 "" *)
      
      IF IsElement (ORD ('+'), Options) THEN
        IF NOT (Abstract IN Properties) THEN
           IF NOT (Ignore IN Properties) THEN
              WriteS (f, "Nk"); WI (Name); WriteS (f, "Max = "); WN (ConstCount); WriteS (f, ";"); WriteNl (f);
           END;
        END;
      END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END ConstDeclsPost;

PROCEDURE NodeType (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Ag:
(* line 254 "" *)
     WITH t^.Ag DO
(* line 254 "" *)
       WI ( itTree ) ; ;
      RETURN;
     END (* WITH *) ;

  | Tree.Class:
(* line 255 "" *)
     WITH t^.Class DO
(* line 255 "" *)
       WI ( Name ) ; ;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END NodeType;

PROCEDURE TypeDeclNode (t: Tree.tTree; Parent: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF Parent = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 259 "" *)
     WITH t^.Class DO
(* line 259 "" *)
      
        TypeDeclNode ( Extensions , t ) ; 
        IF (NoCodeClass * Properties) = {} THEN
           WI (Name); WriteS (f, " = "); 
           NodeType ( Parent ); 
           WriteS (f, ' BRANDED "'); WI ( Name ) ; WriteS (f, '" OBJECT '); WriteNl (f);
           ForallAttributes ( Attributes , TypeDeclNodeAttributes ) ; 
           WriteS (f, "  END (* "); WI ( Name ) ; WriteS (f, " *) ;"); WriteNl (f);
        END;
        TypeDeclNode ( Next , Parent ) ; 
;
      RETURN;
     END (* WITH *) ;

  END;
 END TypeDeclNode;

PROCEDURE TypeDeclNodeAttributes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Child:
(* line 273 "" *)
     WITH t^.Child DO
(* line 273 "" *)
      
        WriteS (f, "    "); WI (Name); WriteS (f, ": "); WI ( Class ^ . Class . Name ) ; WriteS (f, " := "); WI ( iNoTree ) ; WriteS (f, " ; "); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 277 "" *)
     WITH t^.Attribute DO
(* line 277 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
           WriteS (f, "    "); WI (Name); WriteS (f, ": "); WI (Type); WriteS (f, "; "); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END TypeDeclNodeAttributes;

PROCEDURE ProcedureDeclsn (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 285 "" *)
     WITH t^.Class DO
(* line 285 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "PROCEDURE n"); WI (Name); WriteS (f, " ( ) : "); WI ( Name ); WriteS (f, " ;"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END ProcedureDeclsn;

PROCEDURE ProcedureHeadingmInterface (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 294 "" *)
     WITH t^.Class DO
(* line 294 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           ListCount := 0;
           WriteS (f, "PROCEDURE m"); WI (Name); WriteNl (f);
           WriteS (f, "  ( "); 
           ForallAttributes (t, ProcedureHeadingm); 
           WriteS (f, "  ) : "); WI ( Name ) ; WriteS (f, " ;"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END ProcedureHeadingmInterface;

PROCEDURE ProcedureHeadingm (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 306 "" *)
     WITH t^.Class DO
(* line 306 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           ListCount := 0;
           WriteS (f, "PROCEDURE m"); WI (Name); WriteNl (f);
           WriteS (f, "  ( "); 
           ForallAttributes (t, ProcedureHeadingm); 
           WriteS (f, "  ) : "); WI ( Name ) ; WriteS (f, " ="); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 315 "" *)
     WITH t^.Child DO
(* line 315 "" *)
      
        IF Input IN Properties THEN
           IF ListCount > 0 THEN WriteS (f, "  ; "); END;
           WriteS (f, "p"); WI (Name); WriteS (f, " : "); WI ( Name ); WriteS (f, " := NIL "); WriteNl (f);
           INC (ListCount);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 322 "" *)
     WITH t^.Attribute DO
(* line 322 "" *)
      
        IF Input IN Properties THEN
           IF ListCount > 0 THEN WriteS (f, "  ; "); END;
           WriteS (f, "p"); WI (Name); WriteS (f, ": "); WI (Type); WriteNl (f);
           INC (ListCount);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ProcedureHeadingm;

PROCEDURE TreeModule (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Ag) THEN
(* line 333 "" *)
     WITH t^.Ag DO
(* line 333 "" *)
      
      IF IsElement (ORD ('~'), Options) 
      OR IsElement (ORD ('o'), Options) 
      OR IsElement (ORD ('^'), Options) 
 
      OR IsElement (ORD ('w'), Options) THEN
        WriteS (f, "UNSAFE "); 
      END ; 
        WriteS (f, "MODULE "); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
 
      IF IsElement (ORD ('w'), Options) 
         OR IsElement (ORD ('^'), Options) 
         OR IsElement (ORD ('o'), Options) 
         OR IsElement (ORD ('k'), Options) 
         OR IsElement (ORD ('q'), Options)  
         OR IsElement (ORD ('~'), Options)  
      THEN 
        WriteS (f, "IMPORT Fmt , Stdio ;"); WriteNl (f);
      END; 
      IF IsElement (ORD ('w'), Options) 
         OR IsElement (ORD ('^'), Options) 
         OR IsElement (ORD ('o'), Options) 
         OR IsElement (ORD ('p'), Options) 
         OR IsElement (ORD ('g'), Options) 
         OR IsElement (ORD ('k'), Options) 
         OR IsElement (ORD ('q'), Options) 
         OR IsElement (ORD ('~'), Options)  
      THEN 
        WriteS (f, "IMPORT Wr , Text ;"); WriteNl (f);
      END; 
      IF IsElement (ORD ('q'), Options) THEN 
        WriteS (f, "IMPORT Lex ;"); WriteNl (f);
      END; 
      IF IsElement (ORD ('p'), Options) OR IsElement (ORD ('g'), Options) 
      THEN  
        WriteS (f, "IMPORT Rd ;"); WriteNl (f);
      END; 
      IF IsElement (ORD ('y'), Options) 
         OR IsElement (ORD ('p'), Options) 
         OR IsElement (ORD ('g'), Options) THEN
        WriteS (f, "IMPORT Pickle , Atom , Thread ; "); WriteNl (f);
      END;
      IF IsElement (ORD ('y'), Options) THEN
        WriteS (f, "IMPORT FileWr , FileRd , Pipe ; "); WriteNl (f);
      END;
      IF NOT IsElement (ORD ('<'), Options) THEN
        WriteS (f, "IMPORT Process ;"); WriteNl (f);
      END;
      IF IsElement (ORD ('~'), Options) THEN
        WriteS (f, "  IMPORT Sinfo , Einfo , Elists , Nlists , Atree , GnatTypes , GnatUtils ;"); WriteNl (f);
        WriteS (f, "  IMPORT "); WI (iMain); WriteS (f, " ;"); WriteNl (f);
      END ; 
      IF IsElement (ORD ('^'), Options) THEN
        WriteS (f, "  IMPORT Display ;"); WriteNl (f);
 
      END ; 
      IF IsElement (ORD ('<'), Options) THEN
        WriteS (f, "FROM "); WI (iMain); WriteS (f, " IMPORT "); WI (itTree); WriteS (f, ", "); WI (iNoTree); WriteS (f, ", tProcTree, yyExit"); WriteNl (f);
        ForallClassesExtensionsFirst (Classes, ImportConst);
        WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
         
        WriteNl (f);
      END;
        WriteLine (TreeCodes^.Codes.GlobalLine);
        WriteText (f, TreeCodes^.Codes.Global);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.GlobalLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Global);
           Node := Node^.Module.Next;
        END;
        WriteLine (TreeCodes^.Codes.LocalLine);
        WriteText (f, TreeCodes^.Codes.Local);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.LocalLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Local);
           Node := Node^.Module.Next;
        END;
        WriteS (f, '# include "yy'); WI (iModule); WriteS (f, '.w"'); WriteNl (f);
        WriteNl (f);
      IF NOT IsElement (ORD ('<'), Options) THEN 
         
	WriteS (f, "VAR yyTypeRange : ARRAY [ 0 .. "); WN (ClassCount); WriteS (f, "] OF SHORTCARD ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "(* Make"); WI (iMain); WriteS (f, " is deprecated (<*OBSOLETE*>) for Modula-3. *)"); WriteNl (f);
        WriteS (f, "(* VISIBLE: *)"); WriteNl (f);
        WriteS (f, "PROCEDURE Make"); WI (iMain); WriteS (f, " (Kind : SHORTCARD): "); WI (itTree); WriteS (f, " RAISES { BadNodeKind }"); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteS (f, "  CASE Kind OF "); WriteNl (f);
        ForallClassesExtensionsFirst ( Classes , MakeNode ) ; 
        WriteS (f, "  ELSE RAISE BadNodeKind "); WriteNl (f);
        WriteS (f, "  END (* CASE *) "); WriteNl (f);
        WriteS (f, " END Make"); WI (iMain); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "(* IsType is deprecated (<*OBSOLETE*>) for Modula-3. *)"); WriteNl (f);
        WriteS (f, "(* VISIBLE: *)"); WriteNl (f);
        WriteS (f, "PROCEDURE IsType (Tree: "); WI (itTree); WriteS (f, "; Kind : SHORTCARD): BOOLEAN RAISES { BadNodeKind }"); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteS (f, "  IF Tree = "); WI (iNoTree); WriteNl (f);
        WriteS (f, "  THEN RETURN FALSE "); WriteNl (f);
        WriteS (f, "  ELSE "); WriteNl (f);
        WriteS (f, "   CASE Kind OF "); WriteNl (f);
        ForallClassesExtensionsFirst ( Classes , IsTypeCases ) ; 
        WriteS (f, "   ELSE RAISE BadNodeKind "); WriteNl (f);
        WriteS (f, "   END (* CASE *) "); WriteNl (f);
        WriteS (f, "  END (* IF *) "); WriteNl (f);
        WriteS (f, " END IsType;"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('n'), Options) THEN
        WriteS (f, "(* Uninitialized node construtors: *)"); WriteNl (f);
        ForallClassesExtensionsFirst (Classes, ProcedureBodyn);
      END;
        WriteNl (f);
      IF IsElement (ORD ('m'), Options) THEN
        WriteS (f, "(* Node constructors with initialization of input children and attributes: *)"); WriteNl (f);
        ForallClassesExtensionsFirst (Classes, ProcedureBodym);
      END;
        TreeIO (t);
        GnatModule ( t ); 
      IF IsElement (ORD ('t'), Options) OR
         IsElement (ORD ('b'), Options) THEN
        WriteS (f, "VAR yyProc     : tProcTree;"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('t'), Options) THEN
        WriteS (f, "(* Top down traverser: *)"); WriteNl (f);
        WriteS (f, "(* VISIBLE: *)"); WriteNl (f);
        WriteS (f, "PROCEDURE Traverse"); WI (iModule); WriteS (f, "TD ( Tree : "); WI (itTree); WriteS (f, "; Proc : tProcTree )"); WriteNl (f);
        WriteS (f, " =PROCEDURE Recurse (yyt: "); WI (itTree); WriteS (f, ")"); WriteNl (f);
        WriteS (f, "  = VAR LTree := yyt ; "); WriteNl (f);
        WriteS (f, "  ; BEGIN"); WriteNl (f);
        WriteS (f, "     LOOP"); WriteNl (f);
        WriteS (f, "      IF (LTree = "); WI (iNoTree); WriteS (f, ") OR (LTree.yyHead.yyMark = 0) THEN RETURN; END;"); WriteNl (f);
        WriteS (f, "      LTree . yyHead . yyMark := 0;"); WriteNl (f);
        WriteS (f, "      Proc ( LTree ) ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "      TYPECASE LTree OF"); WriteNl (f);
        TraverseTD ( Classes );
        WriteS (f, "      ELSE RETURN;"); WriteNl (f);
        WriteS (f, "      END;"); WriteNl (f);
        WriteS (f, "     END;"); WriteNl (f);
        WriteS (f, "    END Recurse ; "); WriteNl (f);
        WriteS (f, "  BEGIN (* Traverse"); WI (iModule); WriteS (f, "TD *) "); WriteNl (f);
        WriteS (f, "    yyMark (Tree);"); WriteNl (f);
        WriteS (f, "    Recurse (Tree);"); WriteNl (f);
        WriteS (f, "  END Traverse"); WI (iModule); WriteS (f, "TD;"); WriteNl (f);
        WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('b'), Options) THEN
        WriteS (f, "(* Bottom up traverser: *)"); WriteNl (f);
        WriteS (f, "(* VISIBLE: *)"); WriteNl (f);
        WriteS (f, "PROCEDURE Traverse"); WI (iModule); WriteS (f, "BU ( Tree : "); WI (itTree); WriteS (f, " ; Proc : tProcTree )"); WriteNl (f);
        WriteS (f, " =PROCEDURE Recurse ( yyt : "); WI (itTree); WriteS (f, " )"); WriteNl (f);
        WriteS (f, "  = VAR LTree := yyt ; "); WriteNl (f);
 
        WriteS (f, "  ; BEGIN"); WriteNl (f);
        WriteS (f, "      IF ( LTree = "); WI (iNoTree); WriteS (f, " ) OR ( LTree . yyHead . yyMark = 0) THEN RETURN; END;"); WriteNl (f);
        WriteS (f, "      LTree . yyHead . yyMark := 0;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "      TYPECASE LTree OF"); WriteNl (f);
        TraverseBU ( Classes );
        WriteS (f, "      ELSE"); WriteNl (f);
        WriteS (f, "      END;"); WriteNl (f);
        WriteS (f, "      Proc ( LTree ) ;"); WriteNl (f);
        WriteS (f, "  END Recurse ;"); WriteNl (f);
        WriteS (f, "  BEGIN (* Traverse"); WI (iModule); WriteS (f, "BU *) "); WriteNl (f);
        WriteS (f, "    yyMark ( Tree );"); WriteNl (f);
        WriteS (f, "    Recurse ( Tree );"); WriteNl (f);
        WriteS (f, "  END Traverse"); WI (iModule); WriteS (f, "BU;"); WriteNl (f);
        WriteNl (f);
        WriteNl (f);
      END;
 
      IF IsElement (ORD ('R'), Options) THEN
        WriteS (f, "(* VISIBLE: *)"); WriteNl (f);
        WriteS (f, "PROCEDURE Reverse"); WI (iModule); WriteS (f, " ( Tree : "); WI (itTree); WriteS (f, " ) : "); WI (itTree); WriteNl (f);
        WriteS (f, "=VAR yyOld, yyNew, yyNext, yyTail     : "); WI (itTree); WriteS (f, ";"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  yyOld        := Tree ; "); WriteNl (f);
        WriteS (f, "  yyNew        := yyOld;"); WriteNl (f);
        WriteS (f, "  yyTail       := yyOld;"); WriteNl (f);
        WriteS (f, "  LOOP"); WriteNl (f);
        WriteS (f, "   TYPECASE yyOld OF"); WriteNl (f);
        Reverse1 ( Classes ) ;
        WriteS (f, "   ELSE EXIT;"); WriteNl (f);
        WriteS (f, "   END;"); WriteNl (f);
        WriteS (f, "   yyNew       := yyOld;"); WriteNl (f);
        WriteS (f, "   yyOld       := yyNext;"); WriteNl (f);
        WriteS (f, "  END (* LOOP *) ;"); WriteNl (f);
        WriteS (f, "  TYPECASE yyTail OF"); WriteNl (f);
        Reverse2 ( Classes ) ;
        WriteS (f, "  ELSE"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, "  RETURN yyNew;"); WriteNl (f);
        WriteS (f, " END Reverse"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('y'), Options) THEN
        WriteNl (f);
        WriteS (f, "PROCEDURE Copy"); WI (iModule); WriteS (f, " (Tree: "); WI (itTree); WriteS (f, "): "); WI (itTree); WriteNl (f);
        WriteS (f, "=VAR yyWr : FileWr . T ;"); WriteNl (f);
        WriteS (f, " VAR yyWrPipe , yyRdPipe : Pipe . T ;"); WriteNl (f);
        WriteS (f, " TYPE yytClosure  = Thread . Closure "); WriteNl (f);
        WriteS (f, "         OBJECT"); WriteNl (f);
        WriteS (f, "           yyRd : FileRd.T "); WriteNl (f);
        WriteS (f, "           yyNew : "); WI (itTree); WriteS (f, " ;"); WriteNl (f);
        WriteS (f, "         OVERRIDES apply := yyCopyRead "); WriteNl (f);
        WriteS (f, "         END ;"); WriteNl (f);
        WriteS (f, " VAR yyClosure : yytClosure ; "); WriteNl (f);
        WriteS (f, " VAR yyThread : Thread . T ;"); WriteNl (f);
        WriteS (f, " PROCEDURE yyCopyRead ( Self : yytClosure ) = "); WriteNl (f);
        WriteS (f, "   BEGIN "); WriteNl (f);
        WriteS (f, "     Self . yyNew := NARROW ( Pickle . Read ( Self . yyRd ) , "); WI ( itTree ) ; WriteS (f, " ) ; "); WriteNl (f);
        WriteS (f, "   END yyCopyRead ; "); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  Pipe . Open ( yyRdPipe , yyWrPipe ) ; "); WriteNl (f);
        WriteS (f, "  yyWr . init ( yyWrPipe ) ; "); WriteNl (f);
        WriteS (f, "  yyClosure := NEW ( yytClosure ) ; "); WriteNl (f);
        WriteS (f, "  yyClosure . yyRd . init ( yyRdPipe ) ; "); WriteNl (f);
        WriteS (f, "  yyThread := Thread . Fork ( yyClosure ) ; "); WriteNl (f);
        WriteS (f, "  Pickle . Write ( Tree , yyWr ) ; "); WriteNl (f);
        WriteS (f, "  Thread . Join ( yyThread ) ; "); WriteNl (f);
        WriteS (f, "  RETURN yyClosure . yyNew ; "); WriteNl (f);
        WriteS (f, " END Copy"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('k'), Options) THEN
        WriteS (f, "PROCEDURE Check"); WI (iModule); WriteS (f, " (Tree: "); WI (itTree); WriteS (f, "): BOOLEAN"); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteS (f, "  yyMark (Tree);"); WriteNl (f);
        WriteS (f, "  RETURN yyCheck"); WI (iModule); WriteS (f, " (Tree);"); WriteNl (f);
        WriteS (f, " END Check"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyCheckMessage (yyParent, yyChild: "); WI (itTree); WriteS (f, "; yySelector: TEXT) "); WriteNl (f);
        WriteS (f, "=VAR yyf     := Stdio . stderr ;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, '   Wr . PutText ( yyf , "CheckTree: parent = " ) ;'); WriteNl (f);
        WriteS (f, "   Write"); WI (iModule); WriteS (f, "Node (yyf, yyParent);"); WriteNl (f);
        WriteS (f, "   Wr . PutText  ( yyf , Wr . EOL ) ;"); WriteNl (f);
        WriteS (f, '   Wr . PutText  ( yyf , "selector: " ) ;'); WriteNl (f);
        WriteS (f, "   Wr . PutText  ( yyf , yySelector ) ;"); WriteNl (f);
        WriteS (f, '   Wr . PutText  ( yyf , ", child = ");'); WriteNl (f);
        WriteS (f, "   Write"); WI (iModule); WriteS (f, "Node (yyf, yyChild);"); WriteNl (f);
        WriteS (f, "   Wr . PutText  (yyf, Wr . EOL ) ;"); WriteNl (f);
        WriteS (f, " END yyCheckMessage;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyCheck"); WI (iModule); WriteS (f, " (yyt: "); WI (itTree); WriteS (f, "): BOOLEAN"); WriteNl (f);
        WriteS (f, "=VAR yyResult  : BOOLEAN;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  IF yyt = "); WI (iNoTree); WriteS (f, " THEN RETURN FALSE;"); WriteNl (f);
        WriteS (f, "  ELSIF yyt.yyHead.yyMark = 0 THEN RETURN TRUE;"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, "  yyt.yyHead.yyMark := 0;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  yyResult := TRUE;"); WriteNl (f);
        WriteS (f, "  TYPECASE yyt OF"); WriteNl (f);
        CheckAttributes ( Classes ) ;
        WriteS (f, "  ELSE"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, "  RETURN yyResult;"); WriteNl (f);
        WriteS (f, " END yyCheck"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('q'), Options) THEN
        WriteNl (f);
        WriteS (f, "CONST yyQueryStateWrite = 1 ; yyQueryStateRead = 2 ; yyQueryStateQuit = 3 ;"); WriteNl (f);
        WriteS (f, "VAR yyQueryState    : INTEGER;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE Query"); WI (iModule); WriteS (f, " (Tree: "); WI (itTree); WriteS (f, " )"); WriteNl (f);
        WriteS (f, "=VAR LCommand : TEXT ;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  yyQueryState := yyQueryStateWrite;"); WriteNl (f);
        
        WriteS (f, "  LOOP"); WriteNl (f);
        WriteS (f, "   CASE yyQueryState OF"); WriteNl (f);
        WriteS (f, "   | yyQueryStateQuit => RETURN ;"); WriteNl (f);
        WriteS (f, "   | yyQueryStateWrite => Write"); WI (iModule); WriteS (f, "Node ( Stdio . stdout , Tree); yyQueryState := yyQueryStateRead;"); WriteNl (f);
        WriteS (f, '   | yyQueryStateRead   => Wr . PutText ( Stdio . stdout , "? " ) ;'); WriteNl (f);
        WriteS (f, "      LCommand := Lex . Scan ( Stdio . Stdin , Lex . NonBlanks ) ;"); WriteNl (f);
        WriteS (f, '      IF    Text . Equal ( LCommand , "parent" ) THEN yyQueryState := yyQueryStateWrite; RETURN;'); WriteNl (f);
        WriteS (f, '      ELSIF Text . Equal ( LCommand , "quit" ) THEN yyQueryState := yyQueryStateQuit ; RETURN;'); WriteNl (f);
        WriteS (f, "      ELSIF Tree # "); WI (iNoTree); WriteS (f, " THEN"); WriteNl (f);
        WriteS (f, "       TYPECASE Tree OF"); WriteNl (f);
        QueryAttributes ( Classes ) ; 
        WriteS (f, "       ELSE"); WriteNl (f);
        WriteS (f, "       END;"); WriteNl (f);
        WriteS (f, "      END;"); WriteNl (f);
        WriteS (f, "   END;"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, " END Query"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('='), Options) THEN
        WriteS (f, "PROCEDURE yyIsEqual (yya, yyb: ARRAY OF CHAR ): BOOLEAN"); WriteNl (f);
        WriteS (f, " =BEGIN"); WriteNl (f);
        WriteS (f, "  FOR yyi := 0 TO NUMBER ( yya ) DO"); WriteNl (f);
        WriteS (f, "   IF yya [yyi] # yyb [yyi] THEN RETURN FALSE; END;"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, "  RETURN TRUE;"); WriteNl (f);
        WriteS (f, " END yyIsEqual;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE IsEqual"); WI (iModule); WriteS (f, " (Tree1, Tree2: "); WI (itTree); WriteS (f, "): BOOLEAN"); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteS (f, "  IF Tree1 = Tree2 THEN RETURN TRUE; END;"); WriteNl (f);
        WriteS (f, "  IF (Tree1 = "); WI (iNoTree); WriteS (f, ") OR (Tree2 = "); WI (iNoTree); WriteS (f, ") "); WriteNl (f);
        WriteS (f, "     OR ( TYPECODE ( Tree1 ) # TYPECODE ( Tree2 ) THEN RETURN FALSE; END;"); WriteNl (f);
        WriteS (f, "  TYPECASE Tree1 OF"); WriteNl (f);
        IsEqualAttributes ( Classes ) ;
        WriteS (f, "  ELSE RETURN TRUE;"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, " END IsEqual"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('L'), Options) THEN
        MaxBit := 0;
        ForallClasses (Classes, CompMaxBit);
        WriteS (f, "PROCEDURE Init"); WI (iModule); WriteS (f, " (Tree: "); WI (itTree); WriteS (f, ")"); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteS (f, "   Tree . yyHead . yyIsComp := {} ; "); WriteNl (f);
      IF IsElement (ORD ('5'), Options) THEN
        WriteS (f, "   Tree . yyHead . yyIsDone := {} ; "); WriteNl (f);
      END;
        WriteS (f, "   TYPECASE Tree OF"); WriteNl (f);
        InitAttributes ( Classes ) ;
        WriteS (f, "   ELSE RETURN;"); WriteNl (f);
        WriteS (f, "   END;"); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, " END Init"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
      END;
        WriteS (f, "PROCEDURE Begin"); WI (iModule); WriteS (f, " ( )"); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteLine (TreeCodes^.Codes.BeginLine);
        WriteText (f, TreeCodes^.Codes.Begin);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.BeginLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Begin);
           Node := Node^.Module.Next;
        END;
        WriteS (f, " END Begin"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE Close"); WI (iModule); WriteS (f, " ( ) "); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteLine (TreeCodes^.Codes.CloseLine);
        WriteText (f, TreeCodes^.Codes.Close);
        Node := Modules;
        WHILE Node^.Kind = Tree.Module DO
           WriteLine (Node^.Module.TreeCodes^.Codes.CloseLine);
           WriteText (f, Node^.Module.TreeCodes^.Codes.Close);
           Node := Node^.Module.Next;
        END;
        WriteS (f, " END Close"); WI (iModule); WriteS (f, ";"); WriteNl (f);
        WriteNl (f);
      IF NOT IsElement (ORD ('<'), Options) THEN
        WriteS (f, "PROCEDURE xxExit ( ) "); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteS (f, "  Process.Exit (1);"); WriteNl (f);
        WriteS (f, " END xxExit;"); WriteNl (f);
        WriteNl (f);
      END;
        WriteS (f, "BEGIN"); WriteNl (f);
      IF IsElement (ORD ('r'), Options) THEN
        WriteS (f, " yyIsInitialized := FALSE;"); WriteNl (f);
      END;
      IF NOT IsElement (ORD ('<'), Options) THEN
        WriteS (f, " yyExit        := xxExit;"); WriteNl (f);
        ForallClassesExtensionsFirst (Classes, InitTypeRange);
      END;
      IF IsElement (ORD (';'), Options) THEN
        WriteS (f, " yyRecursionLevel := 0;"); WriteNl (f);
        WriteS (f, " yyTreeStorePtr := NEW ( REF yytTreeStore , yyInitTreeStoreSize ) ;"); WriteNl (f);
      END;
        WriteS (f, " Begin"); WI (iModule); WriteS (f, " ( ) ;"); WriteNl (f);
        TreeIOInit ( t ) ; 
        WriteS (f, "END "); WI (iModule); WriteS (f, " ."); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  END;
 END TreeModule;

PROCEDURE MakeNode (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 721 "" *)
     WITH t^.Class DO
(* line 722 "" *)
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "  | Nk"); WI ( Name ) ; WriteS (f, " => RETURN n"); WI ( Name ) ; WriteS (f, " ( ) ; "); WriteNl (f);
        END;
     ;
      RETURN;
     END (* WITH *) ;

  END;
 END MakeNode;

PROCEDURE IsTypeCases (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 729 "" *)
     WITH t^.Class DO
(* line 730 "" *)
       IF (NoCodeClass * Properties) = {} THEN 
         WriteS (f, "   | Nk"); WI ( Name ) ; WriteS (f, " => RETURN ISTYPE ( Tree , "); WI ( Name ) ; WriteS (f, " ) "); WriteNl (f);
       END 
     ;
      RETURN;
     END (* WITH *) ;

  END;
 END IsTypeCases;

PROCEDURE ProcedureBodyn (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 737 "" *)
     WITH t^.Class DO
(* line 737 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "(* VISIBLE: *)"); WriteNl (f);
           WriteS (f, "PROCEDURE n"); WI (Name); WriteS (f, " ( ) : "); WI ( Name ); WriteNl (f);
           WriteS (f, "=VAR yyt : ");  WI ( Name ); WriteS (f, " ;"); WriteNl (f);
           WriteS (f, " BEGIN"); WriteNl (f);
           WriteS (f, "  yyt := NEW ( "); WI ( Name ); WriteS (f, " ) ;"); WriteNl (f);
           WriteS (f, "  yyt . Kind := Nk"); WI (Name); WriteS (f, " ;"); WriteNl (f);
           iClassName := Name;
           ForallAttributes (t, ProcedureBodyn);
           WriteS (f, "  RETURN yyt;"); WriteNl (f);
           WriteS (f, " END n"); WI (Name); WriteS (f, ";"); WriteNl (f);
           WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 752 "" *)
     WITH t^.Child DO
(* line 752 "" *)
      
        WriteS (f, "  begin"); WI (itTree); WriteS (f, " ( yyt . "); WI (Name); WriteS (f, " )"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 755 "" *)
     WITH t^.Attribute DO
(* line 755 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
           WriteS (f, "  begin"); WI (Type); WriteS (f, " ( yyt . "); WI (Name); WriteS (f, ")"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ProcedureBodyn;

PROCEDURE ProcedureBodym (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 764 "" *)
     WITH t^.Class DO
(* line 764 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "(* VISIBLE: *)"); WriteNl (f);
           ProcedureHeadingm (t); 
           WriteS (f, " VAR yyt    : "); WI ( Name ); WriteS (f, ";"); WriteNl (f);
           WriteS (f, " BEGIN"); WriteNl (f);
           WriteS (f, "  yyt := NEW ( "); WI ( Name ); WriteS (f, " ) ;"); WriteNl (f);
           WriteS (f, "  yyt . Kind := Nk"); WI (Name); WriteS (f, " ;"); WriteNl (f);
           IF ({HasChildren, HasAttributes} * Properties) # {} THEN
              iClassName := Name;
              ForallAttributes (t, ProcedureBodym);
           END;
           WriteS (f, "  RETURN yyt;"); WriteNl (f);
           WriteS (f, " END m"); WI (Name); WriteS (f, ";"); WriteNl (f);
           WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 781 "" *)
     WITH t^.Child DO
(* line 781 "" *)
      
        IF Input IN Properties THEN
           WriteS (f, "  yyt . "); WI (Name); WriteS (f, " := p"); WI (Name); WriteS (f, ";"); WriteNl (f);
        ELSE
           WriteS (f, "  begin"); WI (itTree); WriteS (f, " ( yyt . "); WI (Name); WriteS (f, ")"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 788 "" *)
     WITH t^.Attribute DO
(* line 788 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
           IF Input IN Properties THEN
              WriteS (f, "  yyt . "); WI (Name); WriteS (f, " := p"); WI (Name); WriteS (f, ";"); WriteNl (f);
           ELSE
              WriteS (f, "  begin"); WI (Type); WriteS (f, " ( yyt . "); WI (Name); WriteS (f, ")"); WriteNl (f);
           END;
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ProcedureBodym;

PROCEDURE TraverseTD (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 801 "" *)
     WITH t^.Class DO
(* line 801 "" *)
      
        TraverseTD ( Extensions ) ; 
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           WriteS (f, "      | "); WI (Name); WriteS (f, " ( Node ) => "); WriteNl (f);
           GetIterator (t);
           iClassName := Name;
           ForallAttributes (t, TraverseTD);
           IF Iterator = NoTree THEN
              WriteS (f, "      RETURN;"); WriteNl (f);
           ELSE
              WriteS (f, "      LTree := Node . "); WI (Iterator^.Child.Name); WriteS (f, " ;"); WriteNl (f);
           END;
        END;
        TraverseTD ( Next ) ; 
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 816 "" *)
     WITH t^.Child DO
(* line 816 "" *)
      
        IF t # Iterator THEN
           WriteS (f, "      Recurse ( Node . "); WI (Name); WriteS (f, " ) ;"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END TraverseTD;

PROCEDURE TraverseBU (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 825 "" *)
     WITH t^.Class DO
(* line 825 "" *)
      
        TraverseBU ( Extensions ) ; 
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           WriteS (f, "      | "); WI (Name); WriteS (f, " ( Node ) => "); WriteNl (f);
           GetIterator (t);
           iClassName := Name;
           ForallAttributes (t, TraverseBU);
           IF Iterator = NoTree THEN
              WriteS (f, "      RETURN;"); WriteNl (f);
           ELSE
              WriteS (f, "      Recurse  ( Node . "); WI (Iterator^.Child.Name); WriteS (f, " ) ;"); WriteNl (f);
           END;
        END;
        TraverseBU ( Next ) ; 
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 840 "" *)
     WITH t^.Child DO
(* line 840 "" *)
      
        IF t # Iterator THEN
           WriteS (f, "      Recurse ( Node . "); WI (Name); WriteS (f, " ) ;"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END TraverseBU;

PROCEDURE Reverse1 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 849 "" *)
     WITH t^.Class DO
(* line 849 "" *)
      
        Reverse1 ( Extensions ) ; 
        IF (NoCodeClass * Properties) = {} THEN 
           iClassName := Name;
           ForallAttributes (t, Reverse1);
        END;
        Reverse1 ( Next ) ; 
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 857 "" *)
     WITH t^.Child DO
(* line 857 "" *)
      
        IF Reverse IN Properties THEN 
           WriteS (f, "   | "); WI (iClassName); WriteS (f, " ( yyNode ) => yyNext := yyNode . "); WI (Name); WriteS (f, ";"); WriteNl (f);
           WriteS (f, " yyNode  "); WI (Name); WriteS (f, " := NARROW ( yyNew , "); 
           WI ( Class ^ . Class . Name ) ; WriteS (f, " ) ;"); WriteNl (f);
 
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Reverse1;

PROCEDURE Reverse2 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 869 "" *)
     WITH t^.Class DO
(* line 869 "" *)
      
        Reverse2 ( Extensions ) ; 
        IF (NoCodeClass * Properties) = {} THEN
           iClassName := Name;
           ForallAttributes (t, Reverse2);
        END;
        Reverse2 ( Next ) ; 
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 877 "" *)
     WITH t^.Child DO
(* line 877 "" *)
      
        IF Reverse IN Properties THEN
           WriteS (f, "   | "); WI (iClassName); WriteS (f, " ( yyNode ) => yyNode . "); WI (Name); WriteS (f, " := yyOld;"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Reverse2;

PROCEDURE CheckAttributes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 886 "" *)
     WITH t^.Class DO
(* line 886 "" *)
      
        CheckAttributes ( Extensions ) ; 
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           WriteS (f, "   | "); WI (Name); WriteS (f, " ( TNode ) => "); WriteNl (f);
           iClassName := Name;
           ForallAttributes (t, CheckAttributes);
        END;
        CheckAttributes ( Next ) ; 
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 895 "" *)
     WITH t^.Child DO
(* line 895 "" *)
      
           WriteS (f, "       IF TNode . "); WI ( Name ) ; WriteS (f, " = NIL"); WriteNl (f);
           WriteS (f, "       OR NOT ISTYPE ( TNode . "); WI ( Name ) ; WriteS (f, " , "); 
                                   NodeType ( Class ) ; WriteS (f, " )"); WriteNl (f);
           WriteS (f, '       THEN yyCheckMessage ( yyt , TNode . '); WI ( Name ) ; 
                                       WriteS (f, ' , "'); WI (Name); WriteS (f, '" ) ;'); WriteNl (f);
           WriteS (f, "            yyResult := FALSE ; "); WriteNl (f);
           WriteS (f, "       END (* IF *) ; "); WriteNl (f);
           WriteS (f, "       yyResult := yyCheck"); WI ( iModule ) ; WriteS (f, " ( TNode . "); WI ( Name ) ; WriteS (f, " ) AND yyResult ;"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 907 "" *)
     WITH t^.Attribute DO
(* line 907 "" *)
      
         IF Link IN Properties 
         THEN 
           WriteS (f, "       IF TNode . "); WI ( Name ) ; WriteS (f, " = NIL"); WriteNl (f);
           WriteS (f, "       OR NOT ISTYPE ( TNode . "); WI ( Name ) ; WriteS (f, " , "); 
                                   WI ( Type ) ; WriteS (f, " )"); WriteNl (f);
           WriteS (f, '       THEN yyCheckMessage ( yyt , TNode . '); WI ( Name ) ; 
                                       WriteS (f, ' , "'); WI (Name); WriteS (f, '" ) ;'); WriteNl (f);
           WriteS (f, "            yyResult := FALSE ; "); WriteNl (f);
           WriteS (f, "       END (* IF *) ; "); WriteNl (f);
           WriteS (f, "       yyResult := yyCheck"); WI ( iModule ) ; WriteS (f, " ( TNode . "); WI ( Name ) ; WriteS (f, " ) AND yyResult ;"); WriteNl (f);
         END  ; 
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END CheckAttributes;

PROCEDURE InitTypeRange (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 924 "" *)
     WITH t^.Class DO
(* line 924 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           iRange := Name;
           ForallClasses (Extensions, InitTypeRange2);
           WriteS (f, " yyTypeRange [ Nk"); WI (Name); WriteS (f, " ] := Nk"); WI (iRange); WriteS (f, " ;"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END InitTypeRange;

PROCEDURE InitTypeRange2 (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 935 "" *)
     WITH t^.Class DO
(* line 935 "" *)
      
        iRange := Name;
;
      RETURN;
     END (* WITH *) ;

  END;
 END InitTypeRange2;

PROCEDURE QueryAttributes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 942 "" *)
     WITH t^.Class DO
(* line 942 "" *)
      
        QueryAttributes ( Extensions ) ; 
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           WriteS (f, "       | "); WI (Name); WriteS (f, " ( TNode ) =>  IF FALSE THEN"); WriteNl (f);
           iClassName := Name;
           ForallAttributes (t, QueryAttributes);
           WriteS (f, "           END;"); WriteNl (f);
        END;
        QueryAttributes ( Next ) ; 
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 952 "" *)
     WITH t^.Child DO
(* line 952 "" *)
      
        WriteS (f, '           ELSIF Text . Equal ( LCommand , "'); WI (Name); WriteS (f, '" ) THEN Query'); WI (iModule);
        WriteS (f, " ( TNode . "); WI (Name); WriteS (f, ");"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 956 "" *)
     WITH t^.Attribute DO
(* line 956 "" *)
      
     IF Link IN Properties 
     THEN 
        WriteS (f, '           ELSIF Text . Equal ( LCommand , "'); WI (Name); WriteS (f, '" ) THEN Query'); WI (iModule);
        WriteS (f, " ( TNode . "); WI (Name); WriteS (f, ");"); WriteNl (f);
     END  ; 
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END QueryAttributes;

PROCEDURE IsEqualAttributes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 967 "" *)
     WITH t^.Class DO
(* line 967 "" *)
      
        IsEqualAttributes ( Extensions ) ; 
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           WriteS (f, "   | "); WI (Name); WriteS (f, " ( TNode ) => RETURN TRUE"); WriteNl (f);
           iClassName := Name;
           ForallAttributes (t, IsEqualAttributes);
        END;
        IsEqualAttributes ( Next ) ; 
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 977 "" *)
     WITH t^.Child DO
(* line 977 "" *)
      
        WriteS (f, "AND equal"); WI (itTree); WriteS (f, " ( TNode . "); WI (Name);
        WriteS (f, "    , NARROW ( Tree2 , "); WI ( iClassName ) ; WriteS (f, " ) . "); WI (Name); WriteS (f, " )"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 981 "" *)
     WITH t^.Attribute DO
(* line 981 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
           WriteS (f, "AND ( equal"); WI (Type); WriteS (f, " (TNode . "); WI (Name);
           WriteS (f, "      , NARROW ( Tree2 , "); WI ( iClassName ) ; WriteS (f, " ) . "); WI (Name); WriteS (f, " ) )"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END IsEqualAttributes;

PROCEDURE InitAttributes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 991 "" *)
   LOOP
     WITH t^.Class DO
(* line 992 "" *)
      InitAttributes (Extensions);
(* line 993 "" *)
      IF NOT (((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties)) THEN EXIT; END;
(* line 994 "" *)
      WriteS (f, "  | ");
(* line 994 "" *)
      WI (Name);
(* line 994 "" *)
      WriteS (f, " ( TNode ) => ");
(* line 994 "" *)
      WriteNl (f);
(* line 995 "" *)
      GetIterator (t);
(* line 996 "" *)
      iClassName := Name;
(* line 997 "" *)
      gBitCount := BitCount;
(* line 998 "" *)
      ForallAttributes (t, InitAttributes);
(* line 999 "" *)
             IF (Iterator = NoTree) OR NOT (Input IN Iterator^.Child.Properties) THEN
           WriteS (f, "RETURN;"); WriteNl (f);
        ELSE
           WriteS (f, "Tree := TNode . "); WI (Iterator^.Child.Name); WriteS (f, " ;"); WriteNl (f);
        END;
;
(* line 1005 "" *)
      InitAttributes (Extensions);
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.Child:
(* line 1007 "" *)
   LOOP
     WITH t^.Child DO
(* line 1008 "" *)
      IF NOT (Input IN Properties) THEN EXIT; END;
(* line 1009 "" *)
      WriteS (f, "WITH WChildHead = TNode . ");
(* line 1009 "" *)
      WI (Name);
(* line 1009 "" *)
      WriteS (f, " . yyHead DO ");
(* line 1009 "" *)
      WriteNl (f);
(* line 1010 "" *)
      WriteS (f, "     WChildHead . yyOffset := ");
(* line 1011 "" *)
      WN (gBitCount + BitOffset);
(* line 1011 "" *)
      WriteS (f, " ; ");
(* line 1011 "" *)
      WriteNl (f);
(* line 1012 "" *)
      WriteS (f, "     WChildHead . yyParent := Tree ; END;");
(* line 1012 "" *)
      WriteNl (f);
(* line 1013 "" *)
      IF NOT (t # Iterator) THEN EXIT; END;
(* line 1014 "" *)
      WriteS (f, "Init");
(* line 1014 "" *)
      WI (iModule);
(* line 1014 "" *)
      WriteS (f, " ( TNode . ");
(* line 1014 "" *)
      WI (Name);
(* line 1014 "" *)
      WriteS (f, " ) ;");
(* line 1014 "" *)
      WriteNl (f);
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  ELSE END;

 END InitAttributes;

PROCEDURE ImportList (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Ag:
(* line 1019 "" *)
     WITH t^.Ag DO
(* line 1019 "" *)
      
        WriteS (f, "FROM "); WI (iMain); WriteS (f, " IMPORT"); WriteNl (f);
      IF NOT IsElement (ORD ('<'), Options) THEN
        WI (iNoTree); WriteS (f, ", "); WI (itTree); WriteS (f, ", "); WI (iMain); WriteS (f, "Root, Make"); WI (iMain); WriteS (f, ", IsType,"); WriteNl (f);
      END;
        ForallClassesExtensionsFirst (Classes, ImportList);
      IF IsElement (ORD ('o'), Options) THEN
        WriteS (f, "Write"); WI (iModule); WriteS (f, "Node,"); WriteNl (f);
      END;
      IF IsElement (ORD ('w'), Options) THEN
        WriteS (f, "Write"); WI (iModule); WriteS (f, ","); WriteNl (f);
      END;
      IF IsElement (ORD ('^'), Options) THEN
        WriteS (f, "Write"); WI (iModule); WriteS (f, "Html,"); WriteNl (f);
      END;
      IF IsElement (ORD ('r'), Options) THEN
        WriteS (f, "Read"); WI (iModule); WriteS (f, ","); WriteNl (f);
      END;
      IF IsElement (ORD ('p'), Options) THEN
        WriteS (f, "Put"); WI (iModule); WriteS (f, ","); WriteNl (f);
      END;
      IF IsElement (ORD ('g'), Options) THEN
        WriteS (f, "Get"); WI (iModule); WriteS (f, ","); WriteNl (f);
      END;
      IF IsElement (ORD ('t'), Options) THEN
        WriteS (f, "Traverse"); WI (iModule); WriteS (f, "TD,"); WriteNl (f);
      END;
      IF IsElement (ORD ('b'), Options) THEN
        WriteS (f, "Traverse"); WI (iModule); WriteS (f, "BU,"); WriteNl (f);
      END;
      IF IsElement (ORD ('R'), Options) THEN
        WriteS (f, "Reverse"); WI (iModule); WriteS (f, ","); WriteNl (f);
      END;
      IF IsElement (ORD ('y'), Options) THEN
        WriteS (f, "Copy"); WI (iModule); WriteS (f, ","); WriteNl (f);
      END;
      IF IsElement (ORD ('k'), Options) THEN
        WriteS (f, "Check"); WI (iModule); WriteS (f, ","); WriteNl (f);
      END;
      IF IsElement (ORD ('q'), Options) THEN
        WriteS (f, "Query"); WI (iModule); WriteS (f, ","); WriteNl (f);
      END;
      IF IsElement (ORD ('='), Options) THEN
        WriteS (f, "IsEqual"); WI (iModule); WriteS (f, ","); WriteNl (f);
      END;
      IF IsElement (ORD ('L'), Options) THEN
        WriteS (f, "Init"); WI (iModule); WriteS (f, ","); WriteNl (f);
      END;
        WriteS (f, "Begin"); WI (iModule); WriteS (f, ","); WriteNl (f);
        WriteS (f, "Close"); WI (iModule); WriteS (f, ";"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Class:
(* line 1070 "" *)
     WITH t^.Class DO
(* line 1070 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
          WI (Name); WriteS (f, ", "); 
          WriteS (f, "Nk"); WI (Name); WriteS (f, ", "); 
          IF IsElement (ORD ('n'), Options) THEN
               WriteS (f, "n"); WI (Name); WriteS (f, ", "); 
          END;
          IF IsElement (ORD ('m'), Options) THEN
               WriteS (f, "m"); WI (Name); WriteS (f, ","); WriteNl (f);
          END;
          
          IF IsElement (ORD ('+'), Options) THEN
               WriteS (f, "Nk"); WI (Name); WriteS (f, "Max,"); WriteNl (f);
          END;
          
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END ImportList;

PROCEDURE ImportConst (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 1091 "" *)
     WITH t^.Class DO
(* line 1091 "" *)
      
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, ","); WriteNl (f);
           WI (Name);
        END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END ImportConst;

PROCEDURE CompMaxBit (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 1100 "" *)
     WITH t^.Class DO
(* line 1101 "" *)
      i := 1;
(* line 1102 "" *)
      ForallAttributes (t, CompMaxBit);
(* line 1103 "" *)
      MaxBit := Max (i, MaxBit);
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 1105 "" *)
   LOOP
     WITH t^.Child DO
(* line 1107 "" *)
      IF NOT (({Input, Test, Dummy} * Properties = {})) THEN EXIT; END;
(* line 1108 "" *)
      INC (i);
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  | Tree.Attribute:
(* line 1105 "" *)
   LOOP
     WITH t^.Attribute DO
(* line 1107 "" *)
      IF NOT (({Input, Test, Dummy} * Properties = {})) THEN EXIT; END;
(* line 1108 "" *)
      INC (i);
      RETURN;
     END (* WITH *) ;
   END (* LOOP *) ;

  ELSE END;

 END CompMaxBit;

PROCEDURE BeginTreeMThree1;
 BEGIN
(* line 66 "" *)
 ConstCount := 0; 

 END BeginTreeMThree1;

PROCEDURE CloseTreeMThree1;
 BEGIN

 END CloseTreeMThree1;

PROCEDURE yyExit;
 BEGIN
  IO.CloseIO; System.Exit (1);
 END yyExit;

BEGIN
 yyf   := IO.StdOutput;
 Exit  := yyExit;
 BeginTreeMThree1;
END TreeMThree1.

