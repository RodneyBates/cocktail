
(* This file was mechanically generated by puma. *)

IMPLEMENTATION MODULE TreeMThree2;








IMPORT SYSTEM, System, IO, Tree;
(* line 36 "" *)


IMPORT Idents , Strings ; 
FROM IO         IMPORT WriteS, WriteNl;
FROM Sets       IMPORT IsElement;
FROM Idents     IMPORT tIdent;
FROM Positions  IMPORT tPosition;

FROM Tree       IMPORT
   NoTree       , tTree         , Options       , ClassCount    ,
   f            , WI    , WN    , iInteger      , itTree        ,
   iNoTree      , iModule       , iMain         , HasChildren   ,
   HasAttributes, NoCodeAttr    , NoCodeClass   , Link          , 
   ForallClassesExtensionsFirst, ForallAttributes, Reverse      ;

VAR
   iClassName   : Idents . tIdent;
   sBOOLEAN     : Strings . tString;
   iBOOLEAN     : Idents . tIdent;
   RevChild     : tTree;

PROCEDURE WriteLine (Line: tPosition);
   BEGIN
      IF Line.Line # 0 THEN
         WriteS (f, "(* line "); WN (Line.Line); WriteS (f, ' "'); WI (Line.File); WriteS (f, '" *)'); WriteNl (f);
         IF IsElement (ORD ('#'), Options) THEN 
           WriteS (f, "<*LINE "); WN (Line.Line); WriteS (f, ' "'); WI (Line.File); WriteS (f, '" *>'); WriteNl (f);
         END; 
      END;
   END WriteLine;






































































































PROCEDURE yyAbort (yyFunction: ARRAY OF CHAR);
 BEGIN
  IO.WriteS (IO.StdError, 'Error: module TreeMThree2, routine ');
  IO.WriteS (IO.StdError, yyFunction);
  IO.WriteS (IO.StdError, ' failed');
  IO.WriteNl (IO.StdError);
  Exit;
 END yyAbort;

PROCEDURE yyIsEqual (yya, yyb: ARRAY OF SYSTEM.BYTE): BOOLEAN;
 VAR yyi       : INTEGER;
 BEGIN
  FOR yyi := 0 TO INTEGER (HIGH (yya)) DO
   IF yya [yyi] # yyb [yyi] THEN RETURN FALSE; END;
  END;
  RETURN TRUE;
 END yyIsEqual;

PROCEDURE TreeIO (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Ag) THEN
(* line 77 "" *)
     WITH t^.Ag DO
(* line 77 "" *)
      
        WriteNl (f);
      IF IsElement (ORD ('w'), Options) 
         OR IsElement (ORD ('o'), Options) 
         OR IsElement (ORD ( '^' ), Options) THEN
        WriteS (f, "VAR yyf        : Wr . T ;"); WriteNl (f);
      END; 
      IF IsElement (ORD ('r'), Options) THEN 

      END;  
        WriteNl (f);
      IF IsElement (ORD (','), Options) THEN
        WriteS (f, "PROCEDURE yyMark  (yyt : "); WI (itTree); WriteS (f, " )"); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteS (f, "  LOOP"); WriteNl (f);
        WriteS (f, "   IF yyt = "); WI (iNoTree); WriteS (f, " THEN RETURN; END;"); WriteNl (f);
        WriteS (f, "   INC ( yyt . yyHead . yyMark ) ;"); WriteNl (f);
        WriteS (f, "   IF yyt . yyHead . yyMark > 1 THEN RETURN; END;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "   TYPECASE yyt OF"); WriteNl (f);
        Mark ( Classes ) ; 
        WriteS (f, "   ELSE RETURN ;"); WriteNl (f);
        WriteS (f, "   END ;"); WriteNl (f);
        WriteS (f, "  END ;"); WriteNl (f);
        WriteS (f, " END yyMark ;"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD (';'), Options) THEN
        WriteS (f, "CONST yyInitTreeStoreSize      = 32 ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "TYPE yytTreeStore = ARRAY OF "); WI (itTree); WriteS (f, " ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "VAR yyTreeStorePtr     : REF yytTreeStore ;"); WriteNl (f);
        WriteS (f, "VAR yyLabelCount       : CARDINAL ;"); WriteNl (f);
        WriteS (f, "VAR yyRecursionLevel   : CARDINAL ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyMapToLabel ( yyTree : "); WI (itTree); WriteS (f, " ) : CARDINAL"); WriteNl (f);
        WriteS (f, "=VAR yyi       : CARDINAL ;"); WriteNl (f);
        WriteS (f, " VAR LNewTreeStorePtr : REF yytTreeStore ;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  FOR yyi := 0 TO yyLabelCount - 1 DO"); WriteNl (f);
        WriteS (f, "   IF yyTreeStorePtr ^ [ yyi ] = yyTree THEN RETURN yyi ; END ;"); WriteNl (f);
        WriteS (f, "  END ;"); WriteNl (f);
        WriteS (f, "  IF yyLabelCount = NUMBER ( yyTreeStorePtr ^ ) THEN"); WriteNl (f);
        WriteS (f, "     LNewTreeStorePtr := NEW ( REF yytTreeStore , NUMBER ( yyTreeStorePtr ^ ) * 2 ) ;"); WriteNl (f);
        WriteS (f, "     SUBARRAY ( LNewTreeStorePtr ^ , 0 , NUMBER ( yyTreeStorePtr ^ ) ) := yyTreeStorePtr ^ ; "); WriteNl (f);
        WriteS (f, "     yyTreeStorePtr := LNewTreeStorePtr ; "); WriteNl (f);
        WriteS (f, "  END;"); WriteNl (f);
        WriteS (f, "  yyi := yyLabelCount ;"); WriteNl (f);
        WriteS (f, "  yyTreeStorePtr ^ [ yyi ] := yyTree ;"); WriteNl (f);
        WriteS (f, "  INC ( yyLabelCount ) ;"); WriteNl (f);
        WriteS (f, "  RETURN yyi ;"); WriteNl (f);
        WriteS (f, " END yyMapToLabel;"); WriteNl (f);
        WriteNl (f);
       IF IsElement (ORD ('r'), Options) THEN 
 
       END;
      END;
      IF IsElement (ORD ('w'), Options) OR
         IsElement (ORD ('^'), Options) OR
         IsElement (ORD ('o'), Options) THEN
        WriteS (f, "PROCEDURE yyWriteNl ( ) = BEGIN Wr . PutText ( yyf , Wr . EOL ) ; END yyWriteNl ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyWriteSelector ( yys : TEXT ) "); WriteNl (f);
        WriteS (f, "=BEGIN Wr . PutText  ( yyf , yys ) ; "); WriteNl (f);
        WriteS (f, '   Wr . PutText ( yyf , Fmt . Pad ( "" , MAX ( 0 , 16 - Text . Length ( yys ) ) ) ) ;'); WriteNl (f);
        WriteS (f, '   Wr . PutText (yyf, " = " ) ;'); WriteNl (f);
        WriteS (f, " END yyWriteSelector ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "VAR LittleEndian := TRUE ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyWriteHex ( VAR yyx : ARRAY OF CHAR ) "); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteS (f, "  IF LittleEndian"); WriteNl (f);
        WriteS (f, "  THEN"); WriteNl (f);
        WriteS (f, "   FOR yyi := NUMBER ( yyx ) - 1 TO 0 BY - 1 DO"); WriteNl (f);
        WriteS (f, "    Wr . PutText ( yyf , Fmt . Pad ( Fmt . Int ( ORD ( yyx [ yyi ] ) , 16 ) , 2 , '0' ) ) ;"); WriteNl (f);
         
        WriteS (f, "   END ;"); WriteNl (f);
        WriteS (f, "  ELSE"); WriteNl (f);
        WriteS (f, "   FOR yyi := 0 TO NUMBER ( yyx ) - 1 DO"); WriteNl (f);
        WriteS (f, "    Wr . PutText ( yyf , Fmt . Pad ( Fmt . Int ( ORD ( yyx [ yyi ] ) , 16 ) , 2 , '0' ) ) ;"); WriteNl (f);
         
        WriteS (f, "   END ;"); WriteNl (f);
        WriteS (f, "  END"); WriteNl (f);
        WriteS (f, " END yyWriteHex ;"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('o'), Options) THEN
        WriteS (f, "PROCEDURE yyWriteAdr ( yyt : "); WI (itTree); WriteS (f, " )"); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteS (f, "  IF yyt = "); WI (iNoTree); WriteS (f, " THEN"); WriteNl (f);
        WriteS (f, '   Wr . PutText ( yyf , "'); WI (iNoTree); WriteS (f, '" ) ;'); WriteNl (f);
        WriteS (f, "  ELSE"); WriteNl (f);
        WriteS (f, "   yyWriteHex ( LOOPHOLE ( yyt , ARRAY [ 0 .. 3 ] OF CHAR ) ) ;"); WriteNl (f);
 
        WriteS (f, "  END ;"); WriteNl (f);
        WriteS (f, "  yyWriteNl ( ) ;"); WriteNl (f);
        WriteS (f, " END yyWriteAdr;"); WriteNl (f);
        WriteNl (f);
        ForallClassesExtensionsFirst (Classes, WriteNode);
        WriteS (f, "PROCEDURE Write"); WI (iModule); WriteS (f, "Node ( f : Wr . T ; Tree : "); WI (itTree); WriteS (f, " ) "); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteS (f, "  yyf := f ;"); WriteNl (f);
        WriteS (f, "  IF Tree = "); WI (iNoTree); WriteS (f, " THEN"); WriteNl (f);
        WriteS (f, '   Wr . PutText ( yyf , "'); WI (iNoTree); WriteS (f, '" ) ; yyWriteNl ( ) ; RETURN ;'); WriteNl (f);
        WriteS (f, "  END ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "  TYPECASE Tree OF"); WriteNl (f);
        WriteNodeName ( Classes ) ;
        WriteS (f, "  ELSE"); WriteNl (f);
        WriteS (f, "  END ;"); WriteNl (f);
        WriteS (f, " END Write"); WI (iModule); WriteS (f, "Node ;"); WriteNl (f);
        WriteNl (f);
      END;
       
      IF IsElement (ORD ('w'), Options) THEN
        WriteS (f, "VAR yyIndentLevel      : INTEGER ;"); WriteNl (f);
        WriteS (f, "VAR yyActualIndent , yyIndentQuotient , yyIndentRemainder : INTEGER ;"); WriteNl (f);
        WriteS (f, "CONST yyIndentFactor = 20 ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yySetIndentInfo ( ) "); WriteNl (f);
        WriteS (f, " =BEGIN "); WriteNl (f);
        WriteS (f, "   yyIndentQuotient := yyIndentLevel DIV yyIndentFactor ; "); WriteNl (f);
        WriteS (f, "   yyIndentRemainder := yyIndentLevel MOD yyIndentFactor ; "); WriteNl (f);
        WriteS (f, "   yyActualIndent "); WriteNl (f);
        WriteS (f, "     := 10 * ORD ( yyIndentQuotient > 0 ) "); WriteNl (f);
        WriteS (f, "        + yyIndentRemainder "); WriteNl (f);
        WriteS (f, "  END yySetIndentInfo ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE Write"); WI (iModule); WriteS (f, " ( f : Wr . T ; Tree : "); WI (itTree); WriteS (f, " ) "); WriteNl (f);
        WriteS (f, "=VAR yySaveLevel : INTEGER ;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  yyf := f ;"); WriteNl (f);
        WriteS (f, "  IF yyRecursionLevel = 0 THEN yyLabelCount := 0 END ;"); WriteNl (f);
        WriteS (f, "  INC ( yyRecursionLevel ) ;"); WriteNl (f);
        WriteS (f, "  yyMark ( Tree ) ;"); WriteNl (f);
        WriteS (f, "  yySaveLevel := yyIndentLevel ;"); WriteNl (f);
        WriteS (f, "  yyIndentLevel := 0 ;"); WriteNl (f);
        WriteS (f, "  yySetIndentInfo ( ) ; "); WriteNl (f);
        WriteS (f, "  yyWrite"); WI (iModule); WriteS (f, " ( Tree );"); WriteNl (f);
        WriteS (f, "  yyIndentLevel := yySaveLevel ;"); WriteNl (f);
        WriteS (f, "  yySetIndentInfo ( ) ; "); WriteNl (f);
        WriteS (f, "  DEC ( yyRecursionLevel ) ;"); WriteNl (f);
        WriteS (f, " END Write"); WI (iModule); WriteS (f, " ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyIndentSelector ( yys : TEXT )"); WriteNl (f);
        WriteS (f, "=BEGIN "); WriteNl (f);
        WriteS (f, "   IF yyIndentQuotient > 0 "); WriteNl (f);
        WriteS (f, "   THEN Wr . PutChar ( yyf , '(' ) ; Wr . PutChar ( yyf , '*' ) ;"); WriteNl (f);
        WriteS (f, "     Wr . PutText ( yyf , Fmt . Pad ( Fmt . Int ( yyIndentQuotient * yyIndentFactor ) , 6 ) ) ; "); WriteNl (f);
        WriteS (f, "     Wr . PutChar ( yyf , '*' ) ; Wr . PutChar ( yyf , ')' ) ;"); WriteNl (f);
        WriteS (f, "   END ; "); WriteNl (f);
        WriteS (f, '   Wr . PutText ( yyf , Fmt . Pad ( "" , yyIndentRemainder ) ) ;'); WriteNl (f);
        WriteS (f, "   yyWriteSelector ( yys ) ; "); WriteNl (f);
        WriteS (f, " END yyIndentSelector ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE yyIndentSelectorTree ( yys : TEXT ; yyt : "); WI (itTree); WriteS (f, " )"); WriteNl (f);
        WriteS (f, "=BEGIN yyIndentSelector  ( yys ) ; write"); WI (itTree); WriteS (f, " (yyt) END yyIndentSelectorTree ;"); WriteNl (f);
        WriteNl (f);
        ForallClassesExtensionsFirst (Classes, WriteAttributes);
        WriteS (f, "PROCEDURE yyWrite"); WI (iModule); WriteS (f, " ( yyt : "); WI (itTree); WriteS (f, " )"); WriteNl (f);
        WriteS (f, "=VAR yyLevel : CARDINAL ;"); WriteNl (f);
        WriteS (f, " BEGIN"); WriteNl (f);
        WriteS (f, "  yyLevel := yyIndentLevel ;"); WriteNl (f);
        WriteS (f, "  LOOP"); WriteNl (f);
        WriteS (f, "   IF yyt = "); WI (iNoTree); WriteS (f, " THEN"); WriteNl (f);
        WriteS (f, '    Wr . PutText ( yyf , " '); WI (iNoTree); WriteS (f, '" ) ; yyWriteNl ( ) ; EXIT ; '); WriteNl (f);
        WriteS (f, "   ELSIF yyt . yyHead . yyMark = 0 THEN"); WriteNl (f);
        WriteS (f, "    Wr . PutChar ( yyf, '^') ;"); WriteNl (f);
        WriteS (f, "    Wr . PutText  ( yyf , Fmt . Int ( yyMapToLabel ( yyt ) ) ) ; yyWriteNl ( ) ; EXIT ;"); WriteNl (f);
        WriteS (f, "   ELSIF yyt . yyHead . yyMark > 1 THEN"); WriteNl (f);
        WriteS (f, "    yyWriteNl ( ) ;"); WriteNl (f);
        WriteS (f, "    Wr . PutText ( yyf , Fmt . Pad ( Fmt . Int ( yyMapToLabel ( yyt ) ) , 6 ) ) ;"); WriteNl (f);
        WriteS (f, "    Wr . PutChar ( yyf , ':') ;"); WriteNl (f);
        WriteS (f, '    Wr . PutText ( yyf , Fmt . Pad ( "" , MAX ( 0 , yyActualIndent - 7 ) ) ) ;'); WriteNl (f);
        WriteS (f, "   ELSE"); WriteNl (f);
        WriteS (f, "    Wr . PutChar ( yyf , ' ' ) ;"); WriteNl (f);
        WriteS (f, "   END ;"); WriteNl (f);
        WriteS (f, "   yyt . yyHead . yyMark := 0 ;"); WriteNl (f);
        WriteS (f, "   INC ( yyIndentLevel , 2 ) ;"); WriteNl (f);
        WriteS (f, "   yySetIndentInfo ( ) ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "   TYPECASE yyt OF"); WriteNl (f);
        WriteClassName ( Classes );
        WriteS (f, "   ELSE EXIT ;"); WriteNl (f);
        WriteS (f, "   END ;"); WriteNl (f);
        WriteS (f, "  END ;"); WriteNl (f);
        WriteS (f, "  yyIndentLevel := yyLevel ;"); WriteNl (f);
        WriteS (f, "  yySetIndentInfo ( ) ; "); WriteNl (f);
        WriteS (f, " END yyWrite"); WI (iModule); WriteS (f, " ;"); WriteNl (f);
        WriteNl (f);
      END;
       
      IF IsElement (ORD ('^'), Options) THEN
        WriteS (f, "PROCEDURE yyNodeTag ( yyt : "); WI ( itTree ) ; WriteS (f, " ) : TEXT "); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteS (f, '   RETURN "Node" & Fmt . Int ( yyMapToLabel ( yyt ) ) '); WriteNl (f);
        WriteS (f, " END yyNodeTag ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, " PROCEDURE yyNodeKind ( yyt : "); WI ( itTree ) ; WriteS (f, " ) : TEXT "); WriteNl (f);
        WriteS (f, " =BEGIN"); WriteNl (f);
        WriteS (f, "   IF yyt = "); WI (iNoTree); WriteNl (f);
        WriteS (f, "   THEN"); WriteNl (f);
        WriteS (f, '    RETURN "NIL" '); WriteNl (f);
        WriteS (f, "   ELSE"); WriteNl (f);
        WriteS (f, "    TYPECASE yyt OF"); WriteNl (f);
        NodeKinds ( Classes ) ; 
        WriteS (f, "    ELSE "); 
        WriteS (f, '     RETURN "<Unknown>" '); WriteNl (f);
        WriteS (f, "    END (* TYPECASE *) "); WriteNl (f);
        WriteS (f, "   END (* IF *) "); WriteNl (f);
        WriteS (f, "  END yyNodeKind ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE Write"); WI (iModule); WriteS (f, "Html "); WriteNl (f);
        WriteS (f, '  ( f : Wr . T ; Tree : '); WI (itTree); WriteS (f, ' ; Title : TEXT := "" '); WriteNl (f);
        WriteS (f, "  ; SuppressNullFields : BOOLEAN := FALSE ) "); WriteNl (f);
        WriteNl (f);
        WriteS (f, '=CONST IndentString = "  " ; '); 
        WriteNl (f);
        WriteS (f, " PROCEDURE WriteChildOrLink "); WriteNl (f);
        WriteS (f, "   ( Name , Type : TEXT ; Value : "); WI ( itTree ) ; WriteS (f, " ; IsLink : BOOLEAN := FALSE ) "); WriteNl (f);
        WriteS (f, " =VAR LNodeTag : TEXT ; "); WriteNl (f);
        WriteS (f, "  BEGIN "); WriteNl (f);
        WriteS (f, "   IF Value # NIL OR NOT SuppressNullFields "); 
        WriteS (f, "   THEN "); WriteNl (f);
        WriteS (f, "    Wr . PutText ( yyf , IndentString ) ; "); WriteNl (f);
        WriteS (f, "    Wr . PutText ( yyf , Name ) ; "); WriteNl (f);
        WriteS (f, '    Wr . PutText ( yyf , " : " ) ; '); WriteNl (f);
        WriteS (f, "    Wr . PutText ( yyf , Type ) ; "); WriteNl (f);
        WriteS (f, "    IF IsLink  "); WriteNl (f);
        WriteS (f, "    THEN "); WriteNl (f);
        WriteS (f, '      Wr . PutText ( yyf , " LINK" ) ; '); WriteNl (f);
        WriteS (f, "    END (* IF *) ; "); WriteNl (f);
        WriteS (f, '    Wr . PutText ( yyf , " = " ) ; '); WriteNl (f);
        WriteS (f, "    LNodeTag := yyNodeTag ( Value ) ; "); WriteNl (f);
        WriteS (f, '    Wr . PutText ( yyf , "<a href=\"#" ) ; '); WriteNl (f);
        WriteS (f, "    Wr . PutText ( yyf , LNodeTag ) ; "); WriteNl (f);
        WriteS (f, '    Wr . PutText ( yyf , "\">REF " ) ; '); WriteNl (f);
        WriteS (f, "    Wr . PutText ( yyf , LNodeTag ) ; "); WriteNl (f);
        WriteS (f, '    Wr . PutText ( yyf , "(" ) ; '); WriteNl (f);
        WriteS (f, "    yyWriteHex ( LOOPHOLE ( Value , ARRAY [ 0 .. 3 ] OF CHAR ) ) ; "); WriteNl (f);
        WriteS (f, '    Wr . PutText ( yyf , ")" ) ; '); WriteNl (f);
        WriteS (f, "    Wr . PutText ( yyf , yyNodeKind ( Value ) ) ; "); WriteNl (f);
        WriteS (f, '    Wr . PutText ( yyf , "</a>" ) ; '); WriteNl (f);
        WriteS (f, "    yyWriteNl ( ) ; "); WriteNl (f);
        WriteS (f, "   END (* IF *) "); 
        WriteS (f, "  END WriteChildOrLink ; "); WriteNl (f);
        WriteNl (f);
        WriteS (f, " PROCEDURE WriteBOOLEANAttribute "); WriteNl (f);
        WriteS (f, "   ( Name : TEXT ; Value : BOOLEAN ) "); WriteNl (f);
        WriteS (f, " =BEGIN "); WriteNl (f);
        WriteS (f, "   IF Value OR NOT SuppressNullFields "); 
        WriteS (f, "   THEN "); WriteNl (f);
        WriteS (f, "    Wr . PutText ( yyf , IndentString ) ; "); WriteNl (f);
        WriteS (f, "    Wr . PutText ( yyf , Name ) ; "); WriteNl (f);
        WriteS (f, '    Wr . PutText ( yyf , " : " ) ; '); WriteNl (f);
        WriteS (f, '    Wr . PutText ( yyf , "BOOLEAN = " ) ; '); 
        WriteS (f, "    writeBOOLEAN ( Value ) "); 
        WriteS (f, "    yyWriteNl ( ) ; "); WriteNl (f);
        WriteS (f, "   END (* IF *) "); 
        WriteS (f, "  END WriteBOOLEANAttribute ; "); WriteNl (f);
        WriteNl (f);
      
        ForallClassesExtensionsFirst ( Classes , WriteHtmlNodes ) ;
        WriteS (f, " PROCEDURE WriteHtmlRecurse ( yyt : "); WI ( itTree ) ; WriteS (f, " )"); WriteNl (f);
        WriteS (f, " =BEGIN"); WriteNl (f);
        WriteS (f, "   LOOP"); WriteNl (f);
        WriteS (f, "    IF yyt = "); WI (iNoTree); WriteS (f, " OR yyt . yyHead . yyMark = 0"); WriteNl (f);
        WriteS (f, "    THEN"); WriteNl (f);
        WriteS (f, "     EXIT"); WriteNl (f);
        WriteS (f, "    ELSE"); WriteNl (f);
        WriteS (f, "     yyt . yyHead . yyMark := 0 ;"); WriteNl (f);
        WriteS (f, "     TYPECASE yyt OF"); WriteNl (f);
        WriteHtmlCases ( Classes );
        WriteS (f, "     ELSE EXIT"); 
        WriteS (f, "     END (* TYPECASE *)"); WriteNl (f);
        WriteS (f, "    END (* IF *)"); WriteNl (f);
        WriteS (f, "   END (* LOOP *)"); WriteNl (f);
        WriteS (f, "  END WriteHtmlRecurse ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, " BEGIN (* Write"); WI (iModule); WriteS (f, "Html *)"); WriteNl (f);
        WriteS (f, "  yyf := f ;"); WriteNl (f);
        WriteS (f, "  IF yyRecursionLevel = 0 THEN yyLabelCount := 0 END ;"); WriteNl (f);
        WriteS (f, "  INC ( yyRecursionLevel ) ;"); WriteNl (f);
        WriteS (f, "  yyMark ( Tree ) ;"); WriteNl (f);
        WriteS (f, '  Wr . PutText ( yyf , "<html> " ) ; yyWriteNl ( ) ; '); 
        WriteS (f, '  Wr . PutText ( yyf , "<head>" ) ; yyWriteNl ( ) ; '); 
        WriteS (f, '  Wr . PutText ( yyf , "<title>" ) ; '); 
        WriteS (f, '  Wr . PutText ( yyf , "Tree \"" ) ; '); 
        WriteS (f, '  Wr . PutText ( yyf , Title ) ; '); 
        WriteS (f, '  Wr . PutText ( yyf , "\"</title>" ) ; yyWriteNl ( ) ; '); 
        WriteS (f, '  Wr . PutText ( yyf , "</head>" ) ; yyWriteNl ( ) ; '); 
        WriteS (f, '  Wr . PutText ( yyf , "<body>" ) ; yyWriteNl ( ) ; '); 
        WriteS (f, '  Wr . PutText ( yyf , "<pre>" ) ; yyWriteNl ( ) ; '); 
        WriteS (f, "  yyWriteNl ( ) ; "); WriteNl (f);
        WriteS (f, "  WriteHtmlRecurse ( Tree );"); WriteNl (f);
        WriteS (f, '  Wr . PutText ( yyf , "</pre>" ) ; yyWriteNl ( ) ; '); 
        WriteS (f, '  Wr . PutText ( yyf , "</body>" ) ; yyWriteNl ( ) ; '); 
        WriteS (f, '  Wr . PutText ( yyf , "</html>" ) ; yyWriteNl ( ) ; '); 
        WriteS (f, "  DEC ( yyRecursionLevel ) ;"); WriteNl (f);
        WriteS (f, " END Write"); WI (iModule); WriteS (f, "Html ;"); WriteNl (f);
        WriteNl (f);
      END;
 
      IF IsElement (ORD ('p'), Options) 
         OR IsElement (ORD ('g'), Options) THEN
        WriteS (f, "TYPE AtomSpecialTyp = Pickle . Special OBJECT"); WriteNl (f);
        WriteS (f, "  OVERRIDES"); WriteNl (f);
        WriteS (f, "    write := WriteAtom"); WriteNl (f);
        WriteS (f, "  ; read := ReadAtom"); WriteNl (f);
        WriteS (f, "  END ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE WriteAtom ( Self : AtomSpecialTyp ; r : REFANY ; wr : Pickle . Writer )"); WriteNl (f);
        WriteS (f, "  RAISES { Pickle . Error , Wr . Failure , Thread . Alerted }"); WriteNl (f);
        WriteS (f, "= VAR LText : TEXT := Atom . ToText ( NARROW ( r , Atom . T ) )"); WriteNl (f);
        WriteS (f, "      (* Why does M3 accept this without the NARROW? *) "); WriteNl (f);
        WriteS (f, "; VAR LLength : INTEGER := Text . Length ( LText )"); WriteNl (f);
        WriteS (f, "; BEGIN"); WriteNl (f);
        WriteS (f, "    wr . writeInt ( LLength ) "); WriteNl (f);
        WriteS (f, "  ; FOR i := 0 TO LLength "); WriteNl (f);
        WriteS (f, "    DO"); WriteNl (f);
        WriteS (f, "      Wr . PutChar ( wr . wr , Text . GetChar ( LText , i ) )"); WriteNl (f);
        WriteS (f, "    END (* FOR *) "); WriteNl (f);
        WriteS (f, "  END WriteAtom ;"); WriteNl (f);
        WriteNl (f);
        WriteS (f, "PROCEDURE ReadAtom "); WriteNl (f);
        WriteS (f, "  ( Self : AtomSpecialTyp ; rd : Pickle . Reader ; id : Pickle . RefID ) "); WriteNl (f);
        WriteS (f, "  : REFANY"); WriteNl (f);
        WriteS (f, "  RAISES { Pickle . Error , Rd . EndOfFile , Rd . Failure , Thread . Alerted }"); WriteNl (f);
        WriteS (f, "= VAR LLength : INTEGER := rd . readInt ( ) "); WriteNl (f);
        WriteS (f, "; VAR LChars : REF ARRAY OF CHAR := NEW ( REF ARRAY OF CHAR , LLength ) "); WriteNl (f);
        WriteS (f, "; BEGIN"); WriteNl (f);
        WriteS (f, "    FOR i := 0 TO LLength "); WriteNl (f);
        WriteS (f, "    DO "); WriteNl (f);
        WriteS (f, "      LChars ^ [ i ] := Rd . GetChar ( rd . rd )"); WriteNl (f);
        WriteS (f, "    END (* FOR *) "); WriteNl (f);
        WriteS (f, "  ; RETURN Atom . FromText ( Text . FromChars ( LChars ^ ) )"); WriteNl (f);
        WriteS (f, "  END ReadAtom ;"); WriteNl (f);
        WriteNl (f);
      END; 
      IF IsElement (ORD ('p'), Options) THEN
        WriteS (f, "PROCEDURE Put"); WI (iModule); WriteS (f, " ( f : Wr . T ; Tree : "); WI (itTree); WriteS (f, " )"); WriteNl (f);
        WriteS (f, "=BEGIN"); WriteNl (f);
        WriteS (f, "   Pickle . Write ( f , Tree )"); WriteNl (f);
        WriteS (f, " END Put"); WI (iModule); WriteS (f, " ;"); WriteNl (f);
        WriteNl (f);
      END;
      IF IsElement (ORD ('g'), Options) THEN
        WriteS (f, "PROCEDURE Get"); WI (iModule); WriteS (f, " ( f : Rd . T ) : "); WI (itTree); 
        WriteS (f, "= BEGIN"); WriteNl (f);
        WriteS (f, "    RETURN NARROW ( Pickle . Read ( f ) , "); WI ( itTree ) ; WriteS (f, " )"); WriteNl (f);
        WriteS (f, "  END Get"); WI (iModule); WriteS (f, " ;"); WriteNl (f);
        WriteNl (f);
      END;
;
      RETURN;
     END (* WITH *) ;

  END;
 END TreeIO;

PROCEDURE TreeIOInit (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Ag) THEN
(* line 546 "" *)
     WITH t^.Ag DO
(* line 546 "" *)
      
      IF IsElement (ORD ('p'), Options) 
         OR IsElement (ORD ('g'), Options) THEN
        WriteS (f, "Pickle . RegisterSpecial ( NEW ( AtomSpecialTyp , sc := TYPECODE ( Atom . T ) ) ) ;"); WriteNl (f);
      END; 
;
      RETURN;
     END (* WITH *) ;

  END;
 END TreeIOInit;

PROCEDURE WriteNodeName (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 556 "" *)
     WITH t^.Class DO
(* line 556 "" *)
      
        WriteNodeName ( Extensions ) ; 
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "   | "); WI (Name); WriteS (f, " ( TNode ) =>"); WriteNl (f);
           WriteS (f, '        Wr . PutText ( yyf , "'); WI (Name); WriteS (f, '" ) ; yyWriteNl ( ) ;'); 
           IF ({HasChildren, HasAttributes} * Properties) # {} THEN
             WriteS (f, "        yyyWriteNode"); WI (Name); WriteS (f, " ( TNode ) ;"); WriteNl (f);
           END;
           WriteNl (f);
        END;
        WriteNodeName ( Next ) ; 
;
      RETURN;
     END (* WITH *) ;

  END;
 END WriteNodeName;

PROCEDURE WriteNode (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 572 "" *)
     WITH t^.Class DO
(* line 572 "" *)
      
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           WriteS (f, "PROCEDURE yyyWriteNode"); WI (Name); WriteS (f, " ( yyt : "); WI ( Name ); WriteS (f, " )"); WriteNl (f);
           WriteS (f, "=BEGIN"); WriteNl (f);
           IF (BaseClass^.Kind = Tree.Class) AND                
              (({HasChildren, HasAttributes} * BaseClass^.Class.Properties) # {}) THEN
           WriteS (f, "  yyyWriteNode"); WI (BaseClass^.Class.Name); WriteS (f, " (yyt); "); WriteNl (f);
           END;
           iClassName := Name;  
           ForallAttributes (Attributes, WriteNode);
           WriteS (f, " END yyyWriteNode"); WI (Name); WriteS (f, ";"); WriteNl (f);
           WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 587 "" *)
     WITH t^.Child DO
(* line 587 "" *)
      
        WriteS (f, '  yyWriteSelector ( "'); WI (Name); WriteS (f, '" ) ;'); 
        WriteS (f, " yyWriteAdr ( yyt . "); WI (Name); WriteS (f, " ) ;"); WriteNl (f);
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 591 "" *)
     WITH t^.Attribute DO
(* line 591 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN
         IF Link IN Properties 
         THEN
           WriteS (f, '  yyWriteSelector ( "'); WI (Name); WriteS (f, '" ) ;'); 
           WriteS (f, " yyWriteAdr ( yyt . "); WI (Name); WriteS (f, " ) ;"); WriteNl (f);
         ELSE  
           WriteS (f, '  yyWriteSelector ( "'); WI (Name); WriteS (f, '" ) ; write'); WI (Type);
           WriteS (f, " ( yyt . "); WI (Name) ; WriteS (f, " ) yyWriteNl ( ) ;"); WriteNl (f);
         END; 
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END WriteNode;

PROCEDURE Mark (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 607 "" *)
     WITH t^.Class DO
(* line 607 "" *)
      
        Mark ( Extensions ) ; 
        IF ((NoCodeClass * Properties) = {}) AND (HasChildren IN Properties) THEN
           WriteS (f, "    | "); WI (Name); WriteS (f, " ( TNode ) => "); WriteNl (f);
           GetIterator (t);
           iClassName := Name;  
           ForallAttributes (t, Mark);
           IF Iterator = NoTree THEN
              WriteS (f, "RETURN ;"); WriteNl (f);
           ELSE
              WriteS (f, "yyt := TNode . "); WI (Iterator^.Child.Name); WriteS (f, " ;"); WriteNl (f);
           END;
        END;
        Mark ( Next ) ; 
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 623 "" *)
     WITH t^.Child DO
(* line 623 "" *)
      
        IF t # Iterator THEN
           WriteS (f, "yyMark ( TNode . "); WI (Name); WriteS (f, ");"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 629 "" *)
     WITH t^.Attribute DO
(* line 629 "" *)
      
        IF Link IN Properties THEN
           WriteS (f, "yyMark ( TNode . "); WI (Name); WriteS (f, ");"); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END Mark;

PROCEDURE WriteClassName (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 638 "" *)
     WITH t^.Class DO
(* line 638 "" *)
      
        WriteClassName ( Extensions ) ; 
        IF (NoCodeClass * Properties) = {} THEN
           WriteS (f, "   | "); WI (Name); WriteS (f, " ( TNode ) => "); WriteNl (f);
           IF ({HasChildren, HasAttributes} * Properties) # {} THEN
              WriteS (f, "       yWrite"); WI (Name); WriteS (f, " ( TNode ) ; "); WriteNl (f);
              GetIterator (t);
              IF Iterator = NoTree THEN
                WriteS (f, "       EXIT ;"); WriteNl (f);
              ELSE
                 WriteS (f, '       yyIndentSelector ( "'); WI (Iterator^.Child.Name); WriteS (f, '" ) ;'); 
                 WriteS (f, "       yyt := TNode . "); WI (Iterator^.Child.Name); WriteS (f, " ;"); WriteNl (f);
              END ;
           ELSE
              WriteS (f, '       Wr . PutText ( yyf , "'); WI (Name); WriteS (f, '" ) ; yyWriteNl ( ) ; EXIT ;'); WriteNl (f);
           END;
        END;
        WriteClassName ( Next ) ; 
;
      RETURN;
     END (* WITH *) ;

  END;
 END WriteClassName;

PROCEDURE WriteAttributes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 661 "" *)
     WITH t^.Class DO
(* line 661 "" *)
      
        IF ((NoCodeClass * Properties) = {}) AND
           (({HasChildren, HasAttributes} * Properties) # {}) THEN
           WriteS (f, "PROCEDURE yWrite"); WI (Name); WriteS (f, " ( yyt : "); WI ( Name ); WriteS (f, " )"); WriteNl (f);
           WriteS (f, "=BEGIN"); WriteNl (f);
           WriteS (f, '  Wr . PutText ( yyf , "'); WI (Name); WriteS (f, '" ) ; yyWriteNl ( ) ;'); WriteNl (f);
           GetIterator (t);
           iClassName := Name;  
           ForallAttributes (t, WriteAttributes);
           WriteS (f, " END yWrite"); WI (Name); WriteS (f, " ;"); WriteNl (f);
           WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 674 "" *)
     WITH t^.Child DO
(* line 674 "" *)
      
        IF t # Iterator THEN
           WriteS (f, '  yyIndentSelectorTree ( "'); WI (Name); WriteS (f, '" , yyt . '); WI (Name); WriteS (f, ' ) ;'); WriteNl (f);
        END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 679 "" *)
     WITH t^.Attribute DO
(* line 679 "" *)
      
        IF (NoCodeAttr * Properties) = {} THEN 
         IF Link IN Properties 
         THEN
           WriteS (f, '  yyIndentSelectorTree ( "'); WI (Name); WriteS (f, '" , yyt . '); WI (Name); WriteS (f, ' ) ;'); WriteNl (f);
         ELSE 
           WriteS (f, '  yyIndentSelector ( "'); WI (Name); WriteS (f, '" ) ; '); 
           WriteS (f, "write"); WI (Type); WriteS (f, " ( yyt . "); WI (Name); WriteS (f, " ) yyWriteNl ( ) ;"); WriteNl (f);
         END  ; 
        END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END WriteAttributes;

PROCEDURE NodeKinds (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;
  IF (t^.Kind = Tree.Class) THEN
(* line 695 "" *)
     WITH t^.Class DO
(* line 696 "" *)
       NodeKinds ( Extensions ) ; 
     IF ( NoCodeClass * Properties = { } ) 
     THEN
       WriteS (f, "     | "); WI ( Name ) ; WriteS (f, " => "); 
       WriteS (f, '         RETURN "'); WI ( Name ) ; WriteS (f, '" ; '); WriteNl (f);
     END  ; 
     NodeKinds ( Next ) 
   ;
      RETURN;
     END (* WITH *) ;

  END;
 END NodeKinds;

PROCEDURE WriteHtmlNodes (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 707 "" *)
     WITH t^.Class DO
(* line 708 "" *)
       
     IF ( NoCodeClass * Properties = { } ) 
     THEN
       WriteS (f, " PROCEDURE Write"); WI ( Name ) ; WriteS (f, "Html ( TNode : "); WI ( Name ) ; WriteS (f, " ) "); 
       WriteS (f, " =VAR LNodeTag : TEXT ; "); WriteNl (f);
       WriteS (f, "  BEGIN "); WriteNl (f);
       WriteS (f, "    LNodeTag := yyNodeTag ( TNode ) ; "); WriteNl (f);
       WriteS (f, '    Wr . PutText ( yyf , "<a name=\"" ) ; '); WriteNl (f);
       WriteS (f, "    Wr . PutText ( yyf , LNodeTag ) ; "); WriteNl (f);
       WriteS (f, '    Wr . PutText ( yyf , "\">DEF " ) ; '); WriteNl (f);
       WriteS (f, "    Wr . PutText ( yyf , LNodeTag ) ; "); WriteNl (f);
       WriteS (f, '    Wr . PutText ( yyf , "(" ) ; '); WriteNl (f);
       WriteS (f, "    yyWriteHex ( LOOPHOLE ( TNode , ARRAY [ 0 .. 3 ] OF CHAR ) ) ; "); WriteNl (f);
       WriteS (f, '    Wr . PutText ( yyf , ")'); WI ( Name ) ; WriteS (f, '</a>" ) ; '); WriteNl (f);
       WriteS (f, "    yyWriteNl ( ) ; "); WriteNl (f);
       IF ( { HasChildren , HasAttributes } * Properties # { } ) 
       THEN 
         ForallAttributes ( t , WriteHtmlNodes ) ; 
       END  ; 
       WriteS (f, "    yyWriteNl ( ) ; "); WriteNl (f);
       WriteS (f, "  END Write"); WI ( Name ) ; WriteS (f, "Html ; "); WriteNl (f);
       WriteNl (f);
     END  ; 
   ;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 733 "" *)
     WITH t^.Child DO
(* line 734 "" *)
       WriteS (f, '    WriteChildOrLink ( "'); WI ( Name ) ; WriteS (f, '" , "'); WI ( Type ) ; 
     WriteS (f, '" , TNode . '); WI ( Name ) ; WriteS (f, ' ) ; '); WriteNl (f);
   ;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 738 "" *)
     WITH t^.Attribute DO
(* line 739 "" *)
       IF (NoCodeAttr * Properties) = {} 
     THEN 
       IF Link IN Properties 
       THEN 
         WriteS (f, '    WriteChildOrLink ( "'); WI ( Name ) ; WriteS (f, '" , "'); WI ( Type ) ; 
         WriteS (f, '" , TNode . '); WI ( Name ) ; WriteS (f, ' , TRUE ) ; '); WriteNl (f);
       ELSIF Type = iBOOLEAN 
       THEN 
         WriteS (f, '    WriteBOOLEANAttribute ( "'); WI ( Name ) ; WriteS (f, '" , TNode . '); WI ( Name ) ; WriteS (f, ' ) ; '); WriteNl (f);
       ELSE
         WriteS (f, '    Wr . PutText ( yyf , IndentString & "'); WI ( Name ) ; WriteS (f, ' : '); WI ( Type ) ; WriteS (f, ' = " ) ; '); WriteNl (f);
         WriteS (f, "    write"); WI ( Type ) ; WriteS (f, " ( TNode . "); WI ( Name ) ; WriteS (f, " ) "); WriteNl (f);
          
         WriteS (f, "    yyWriteNl ( ) ; "); WriteNl (f);
       END  ; 
     END  ; 
   ;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END WriteHtmlNodes;

PROCEDURE WriteHtmlCases (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 759 "" *)
     WITH t^.Class DO
(* line 760 "" *)
       WriteHtmlCases ( Extensions ) ; 
     IF ( NoCodeClass * Properties = { } ) 
     THEN
       WriteS (f, "     | "); WI ( Name ) ; WriteS (f, " ( TNode ) => "); WriteNl (f);
       WriteS (f, "         Write"); WI ( Name ) ; WriteS (f, "Html ( TNode ) ; "); WriteNl (f);
       IF ( { HasChildren , HasAttributes } * Properties # { } ) 
       THEN 
         GetIterator ( t ) ; 
         ForallAttributes ( t , WriteHtmlCases ) ;  
         IF Iterator = NoTree THEN
           WriteS (f, "         EXIT ;"); WriteNl (f);
         ELSE
           WriteS (f, "         yyt := TNode . "); WI ( Iterator ^ . Child . Name ) ; WriteS (f, " ; "); WriteNl (f);
         END;
       END  
     END  ;  
     WriteHtmlCases ( Next ) ;  
   ;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 779 "" *)
     WITH t^.Child DO
(* line 780 "" *)
       IF t # Iterator 
     THEN
         WriteS (f, "         WriteHtmlRecurse ( TNode . "); WI ( Name ) ; WriteS (f, " ) ;"); WriteNl (f);
     END  ; 
   ;
      RETURN;
     END (* WITH *) ;

  | Tree.Attribute:
(* line 786 "" *)
     WITH t^.Attribute DO
(* line 787 "" *)
       IF Link IN Properties  
     THEN
         WriteS (f, "         WriteHtmlRecurse ( TNode . "); WI ( Name ) ; WriteS (f, " ) ;"); WriteNl (f);
     END  ; 
   ;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END WriteHtmlCases;

PROCEDURE GetIterator (t: Tree.tTree);

 VAR yyTempo: RECORD CASE : INTEGER OF
 END; END;
 BEGIN
  IF t = Tree.NoTree THEN RETURN; END;

  CASE t^.Kind OF
  | Tree.Class:
(* line 836 "" *)
     WITH t^.Class DO
(* line 836 "" *)
      
        Iterator := NoTree;
        RevChild := NoTree;
        ForallAttributes (t, GetIterator);
        IF RevChild # NoTree THEN Iterator := RevChild; END;
;
      RETURN;
     END (* WITH *) ;

  | Tree.Child:
(* line 842 "" *)
     WITH t^.Child DO
(* line 842 "" *)
      
        Iterator := t;
        IF Reverse IN Properties THEN RevChild := t; END;
;
      RETURN;
     END (* WITH *) ;

  ELSE END;

 END GetIterator;

PROCEDURE BeginTreeMThree2;
 BEGIN
(* line 68 "" *)
 

  Strings . ArrayToString ( "BOOLEAN" , sBOOLEAN ) ; 
  iBOOLEAN := Idents . MakeIdent ( sBOOLEAN ) ; 



 END BeginTreeMThree2;

PROCEDURE CloseTreeMThree2;
 BEGIN

 END CloseTreeMThree2;

PROCEDURE yyExit;
 BEGIN
  IO.CloseIO; System.Exit (1);
 END yyExit;

BEGIN
 yyf   := IO.StdOutput;
 Exit  := yyExit;
 BeginTreeMThree2;
END TreeMThree2.

