(* File Scanner.m30. *) 

$@ UNSAFE MODULE @ 

; FROM SYSTEM IMPORT SHORTCARD , M2LONGINT , M2LONGCARD

; IMPORT OSError 
; IMPORT Process

; IMPORT Checks 
  , System 
  , General 
  , Positions 
  , ReuseIO 
  , DynArray 
  , Strings
; IMPORT RexErrors

$@ ; IMPORT $Source 
(* Global user declarations ($G): *) 
$G (*global user declarations*) 
(* End of global user declarations ($G). *) 

; CONST yyTabSpace = 8 
; CONST yyDNoState = 0 
; CONST yyFileStackSize = 32 
; CONST yyInitBufferSize = ( 1024 * 8 ) + 256 
(* User constant declarations ($C): *) 
$C (*constant declarations*) 
(* End of user constant declarations ($C). *) 

; TYPE yyTableElmt = SHORTCARD 
; TYPE yyStateRange (*yyTableElmt*) = [ 0 .. yyDStateCount ] 
; TYPE yyStateRangePacked = BITS BITSIZE ( yyTableElmt ) FOR yyStateRange 
; TYPE yyTableRange (*yyTableElmt*) = [ 0 .. yyTableSize ] 
; TYPE yyCombType = RECORD Check , Next : BITS 16 FOR yyStateRange END (* RECORD *) 
; TYPE yyCombTypePtr = UNTRACED BRANDED REF yyCombType 
; TYPE yytChBufferPtr = UNTRACED BRANDED REF ARRAY [ 0 .. 1000000 ] OF CHAR 
; TYPE yyChRange = [ yyFirstCh .. yyLastCh ] 
; TYPE yyFileStackPtrTyp = SHORTCARD 
; TYPE yyFileStackSubscript (*yyFileStackPtrTyp*) = [ 1 .. yyFileStackSize ] 

; VAR yyBasePtr : ARRAY yyStateRange OF M2LONGCARD 
; VAR yyDefault : ARRAY yyStateRange OF yyStateRangePacked
; VAR yyComb : ARRAY yyTableRange OF yyCombType 
; VAR yyEobTrans : ARRAY yyStateRange OF yyStateRangePacked
(* Only for ReduceCaseSize, #1 ($M): *)
$M ; yyAction : ARRAY yyStateRange OF yyTableElmt 
(* End of only for ReduceCaseSize, #1 ($M): *)
; VAR yyToLower , yyToUpper : ARRAY yyChRange OF CHAR 

; VAR yyStateStack 
    : UNTRACED BRANDED REF ARRAY [ 0 .. 1000000 ] OF yyStateRange 
; VAR yyStateStackSize : M2LONGINT 
; VAR yyStartState : yyStateRange 
; VAR yyPreviousStart : yyStateRange 

; VAR yySourceFile : System . tFile 
; VAR yyEof : BOOLEAN 
; VAR yyChBufferPtr : yytChBufferPtr 
; VAR yyChBufferStart : INTEGER 
; VAR yyChBufferSize : M2LONGINT 
; VAR yyChBufferIndex : INTEGER 
; VAR yyBytesRead : INTEGER 
; VAR yyLineCount : SHORTCARD (* Number of the current line, 
                                        of the current file. *) 
; VAR yyTotalLineCount : Word . T    (* Number of lines already read, 
                                        of all files. *) 
; VAR yyLineStart : INTEGER 

; VAR yyFileStackPtr : yyFileStackPtrTyp 
; VAR yyFileStack 
    : ARRAY yyFileStackSubscript 
      OF RECORD 
           SourceFile : System . tFile 
         ; Eof : BOOLEAN 
         ; ChBufferPtr : yytChBufferPtr 
         ; ChBufferStart : INTEGER 
         ; ChBufferSize : M2LONGINT 
         ; ChBufferIndex : INTEGER 
         ; BytesRead : INTEGER 
         ; LineCount : SHORTCARD 
         ; LineStart : INTEGER 
         END (* RECORD *) 

; PROCEDURE GetToken ( ) : INTEGER 

  = VAR yyState : yyStateRange 
  ; VAR yyTablePtr : yyCombTypePtr 
  ; VAR yyRestartFlag : BOOLEAN 
  ; VAR yyi , yySource , yyTarget : INTEGER 
  ; VAR yyChBufferFree : M2LONGINT 

(* User local declarations ($L): *) 
$L (*local user declarations*) 
(* End of user local declarations ($L). *)

  ; BEGIN (* GetToken *) 
      LOOP 
        yyState := yyStartState 
      ; TokenLength := 0 
(* Only for LeftJustUsed ($J): *)
$J    ; IF yyChBufferPtr ^ [ yyChBufferIndex - 1 ] = yyEolCh 
$J      THEN INC ( yyState ) 
$J      END (* IF *) 
(* End of only for LeftJustUsed ($J): *)

      (* ASSERT yyChBuffer [ yyChBufferIndex] = first character *) 

      ; LOOP (* eventually restart after sentinel *) 
          LOOP (* execute as many state transitions as possible *) 
            (* determine next state *) 
            yyTablePtr 
              := LOOPHOLE 
                   ( yyBasePtr [ yyState ] 
                     + ( VAL 
                           ( ORD ( yyChBufferPtr ^ [ yyChBufferIndex ] ) 
                           , M2LONGCARD 
                           ) 
                         * VAL ( BYTESIZE ( yyCombType ) , M2LONGCARD ) 
                       ) 
                   , yyCombTypePtr 
                   ) 
          ; IF yyTablePtr ^ . Check # yyState 
            THEN 
              yyState := yyDefault [ yyState ] 
            ; IF yyState = yyDNoState THEN EXIT END (* IF *) 
            ELSE 
              yyState := yyTablePtr ^ . Next 
            ; INC ( TokenLength ) 
            ; yyStateStack ^ [ TokenLength ] := yyState (* push state *) 
            ; INC ( yyChBufferIndex ) (* get next character *) 
            END (* IF *) 
          END (* LOOP *) 

        ; LOOP  (* search for last final state *)
(* Generated actions ($A): *)
$A (*case header and user actions*)
(* End of generated actions ($A): *)
(* Non final states ($N): *)  
$N (*non final states*) 
(* End of non final states ($N). *)  

            DEC ( yyChBufferIndex ) (* return character *) 
          ; DEC ( TokenLength ) (* pop state *) 

(* Only for ReduceCaseSize, #2 ($P): *)
$P (* NOT copied anywhere:         | yyDefaultState *) 
(* End of only for ReduceCaseSize, #2 ($P): *)
              Attribute . Position . Line := yyLineCount 
            ; Attribute . Position . Column 
                := VAL ( yyChBufferIndex - yyLineStart , SHORTCARD ) 
            ; INC ( yyChBufferIndex ) 
            ; TokenLength := 1
(* Only for default line ($D): *)            
$D (*default action*) 
(* End of only for default line ($D). *)            
            ; yyRestartFlag := FALSE 
            ; EXIT 

            | yyDNoState 
            => (* automatic initialization *) 
               yyGetTables ( ) 
            ; yyStateStack ^ [ 0 ] := yyDefaultState (* stack underflow sentinel *) 
            ; IF yyFileStackPtr = 0 
              THEN 
                yyInitialize ( ) 
              ; yySourceFile := System . StdInput 
              END (* IF *) 
            ; yyRestartFlag := FALSE 
            ; EXIT 

(* Only for ReduceCaseSize, #3 ($O): *)
$O (* NOT coplied anywhere:         | yyEobState *) 
(* End only for ReduceCaseSize, #3 ($O): *)
               DEC ( yyChBufferIndex ) (* undo last state transition *) 
            ; DEC ( TokenLength ) (* get previous state *) 
            ; IF TokenLength = 0 
              THEN 
                yyState := yyStartState 
(* Only for LeftJustUsed ($J): *)
$J            ; IF yyChBufferPtr ^ [ yyChBufferIndex - 1 ] = yyEolCh 
$J              THEN INC ( yyState ) 
$J              END (* IF *) 
(* End of only for LeftJustUsed ($J): *)
              ELSE 
                yyState := yyStateStack ^ [ TokenLength ] 
              END (* IF *) 

            ; IF yyChBufferIndex # ( yyChBufferStart + yyBytesRead ) 
              THEN 
                yyState := yyEobTrans [ yyState ] (* end of buffer sentinel in buffer *) 
              ; IF yyState # yyDNoState 
                THEN 
                  INC ( yyChBufferIndex ) 
                ; INC ( TokenLength ) 
                ; yyStateStack ^ [ TokenLength ] := yyState 
                ; yyRestartFlag := TRUE 
                ; EXIT 
                END (* IF *) 
              ELSE (* end of buffer reached *) 

                (* copy initial part of token in front of input buffer *) 
                yySource := yyChBufferIndex - TokenLength - 1 
              ; yyTarget 
                  := General . MaxAlign 
                     - ( TokenLength MOD General . MaxAlign ) 
                     - 1 
              ; IF yySource # yyTarget 
                THEN 
                  FOR yyi := 1 TO TokenLength 
                  DO yyChBufferPtr ^ [ yyTarget + yyi ] 
                       := yyChBufferPtr ^ [ yySource + yyi ] 
                  END (* FOR *) 
                ; DEC ( yyLineStart , yySource - yyTarget ) 
                ; yyChBufferStart := yyTarget + TokenLength + 1 
                ELSE 
                  yyChBufferStart := yyChBufferIndex 
                END (* IF *) 

              ; IF NOT yyEof 
                THEN (* read buffer and restart *) 
                  yyChBufferFree 
                    := VAL 
                         ( General . Exp2 
                             ( General . Log2 
                                 ( yyChBufferSize 
                                   - 4 
                                   - VAL ( General . MaxAlign , M2LONGINT ) 
                                   - VAL ( TokenLength , M2LONGINT ) 
                                 ) 
                             ) 
                         , M2LONGINT 
                         ) 
                ; IF yyChBufferFree < ( yyChBufferSize DIV 8 ) 
                  THEN 
                    DynArray . ExtendArray 
                      ( LOOPHOLE ( yyChBufferPtr , ADDRESS ) 
                      , yyChBufferSize 
                      , BYTESIZE ( CHAR ) 
                      ) 
                  ; IF yyChBufferPtr = NIL 
                    THEN 
                      yyErrorMessage ( 1 ) 
                    END (* IF *) 
                  ; yyChBufferFree 
                      := VAL 
                           ( General . Exp2 
                               ( General . Log2 
                                   ( yyChBufferSize 
                                     - 4 
                                     - VAL ( General . MaxAlign , M2LONGINT ) 
                                     - VAL ( TokenLength , M2LONGINT ) 
                                   ) 
                               ) 
                           , M2LONGINT 
                           ) 
                  ; IF yyStateStackSize < yyChBufferSize 
                    THEN 
                      DynArray . ExtendArray 
                        ( LOOPHOLE ( yyStateStack , ADDRESS )  
                        , yyStateStackSize 
                        , BYTESIZE ( yyStateRange ) 
                        ) 
                    ; IF yyStateStack = NIL 
                      THEN 
                        yyErrorMessage ( 1 ) 
                      END (* IF *) 
                    END (* IF *) 
                  END (* IF *) 
                ; yyChBufferIndex := yyChBufferStart 
                ; yyBytesRead 
$@                := $Source . GetLine 
                         ( yySourceFile 
                         , ADR ( yyChBufferPtr ^ [ yyChBufferIndex ] ) 
                         , yyChBufferFree  
                         ) 
                ; IF yyBytesRead <= 0 
                  THEN 
                    yyBytesRead := 0 
                  ; yyEof := TRUE 
                  END (* IF *) 
                ; yyChBufferPtr ^ [ yyChBufferStart + yyBytesRead ] 
                    := yyEobCh 
                ; yyChBufferPtr ^ [ yyChBufferStart + yyBytesRead + 1 ] 
                    := '\000' 
                ; yyRestartFlag := TRUE 
                ; EXIT 
                END (* IF *) 

              ; IF TokenLength = 0 
                THEN (* end of file reached *) 
                  Attribute . Position . Line := yyLineCount 
                ; Attribute . Position . Column 
                    := VAL ( yyChBufferIndex - yyLineStart , SHORTCARD ) 
                ; CloseFile ( ) 
                ; IF yyFileStackPtr = 0 
                  THEN
(* Eof action ($E): *)
$E (* NOT copied: (* eof action *) *) 
(* End of Eof action ($E): *)
                  END (* IF *) 
                ; IF yyFileStackPtr = 0 THEN RETURN EofToken END (* IF *) 
                ; yyRestartFlag := FALSE 
                ; EXIT 
                END (* IF *) 
              END (* IF *) 
            ELSE 
              yyErrorMessage ( 0 ) 
            END (* CASE *) 
          END (* LOOP *) 
        ; IF yyRestartFlag THEN ELSE EXIT END (* IF *) 
        END (* LOOP *) 
      END (* LOOP *) 
    END GetToken 

; PROCEDURE BeginFile ( FileName : TEXT )  

  = BEGIN (* BeginFile *) 
      IF yyStateStack ^ [ 0 ] = yyDNoState 
      THEN (* have tables been read in ? *) 
        yyGetTables ( ) 
      ; yyStateStack ^ [ 0 ] := yyDefaultState (* stack underflow sentinel *) 
      END (* IF *) 
    ; yyInitialize ( ) 
$@  ; yySourceFile := $Source . BeginSource ( FileName ) 
    ; IF yySourceFile < 0 THEN yyErrorMessage ( 5 ) END (* IF *) 
    END BeginFile 

; PROCEDURE yyInitialize ( ) 

  = BEGIN (* yyInitialize *) 
      IF yyFileStackPtr >= yyFileStackSize 
      THEN 
        yyErrorMessage ( 3 ) 
      END (* IF *) 
      (* push file *) 
    ; INC ( yyFileStackPtr ) 
    ; WITH m2tom3_with_1 = yyFileStack [ yyFileStackPtr ] 
      DO m2tom3_with_1 . SourceFile := yySourceFile 
      ; m2tom3_with_1 . Eof := yyEof 
      ; m2tom3_with_1 . ChBufferPtr := yyChBufferPtr 
      ; m2tom3_with_1 . ChBufferStart := yyChBufferStart 
      ; m2tom3_with_1 . ChBufferSize := yyChBufferSize 
      ; m2tom3_with_1 . ChBufferIndex := yyChBufferIndex 
      ; m2tom3_with_1 . BytesRead := yyBytesRead 
      ; m2tom3_with_1 . LineCount := yyLineCount 
      ; m2tom3_with_1 . LineStart := yyLineStart 
      END (* WITH *) 
      (* initialize file state *) 
    ; yyChBufferSize := yyInitBufferSize 
    ; DynArray . MakeArray
        ( LOOPHOLE ( yyChBufferPtr , ADDRESS ) 
        , yyChBufferSize 
        , BYTESIZE ( CHAR ) 
        ) 
    ; IF yyChBufferPtr = NIL THEN yyErrorMessage ( 1 ) END (* IF *) 
    ; yyChBufferStart := General . MaxAlign 
    ; yyChBufferPtr ^ [ yyChBufferStart - 1 ] := yyEolCh (* begin of line indicator *) 
    ; yyChBufferPtr ^ [ yyChBufferStart ] := yyEobCh (* end of buffer sentinel *) 
    ; yyChBufferPtr ^ [ yyChBufferStart + 1 ] := '\000' 
    ; yyChBufferIndex := yyChBufferStart 
    ; yyEof := FALSE 
    ; yyBytesRead := 0 
    ; yyLineCount := 1 
    ; yyTotalLineCount := 0 
    ; yyLineStart := yyChBufferStart - 1 
    END yyInitialize 

; PROCEDURE CloseFile ( ) 

  = BEGIN (* CloseFile *) 
      IF yyFileStackPtr = 0 THEN yyErrorMessage ( 4 ) END (* IF *) 
$@  ; $Source . CloseSource ( yySourceFile ) 
    ; DynArray . ReleaseArray 
        ( yyChBufferPtr , yyChBufferSize , BYTESIZE ( CHAR ) ) 

      (* pop file *)
      ; WITH m2tom3_with_2 = yyFileStack [ yyFileStackPtr ] 
      DO 
        yySourceFile := m2tom3_with_2 . SourceFile 
      ; yyEof := m2tom3_with_2 . Eof 
      ; yyChBufferPtr := m2tom3_with_2 . ChBufferPtr 
      ; yyChBufferStart := m2tom3_with_2 . ChBufferStart 
      ; yyChBufferSize := m2tom3_with_2 . ChBufferSize 
      ; yyChBufferIndex := m2tom3_with_2 . ChBufferIndex 
      ; yyBytesRead := m2tom3_with_2 . BytesRead 
      ; yyLineCount := m2tom3_with_2 . LineCount 
      ; yyLineStart := m2tom3_with_2 . LineStart 
      END (* WITH *) 
    ; DEC ( yyFileStackPtr ) 
    END CloseFile 

; PROCEDURE GetWord ( VAR Word : Strings . tString ) 

  = VAR i , WordStart : INTEGER 

  ; BEGIN (* GetWord *) 
      WordStart := yyChBufferIndex - TokenLength - 1 
    ; FOR i := 1 TO TokenLength 
      DO Word . Chars [ VAL ( i , Strings . tStringIndex ) ] 
           := yyChBufferPtr ^ [ WordStart + i ] 
      END (* FOR *) 
    ; Word . Length := VAL ( TokenLength , SHORTCARD ) 
    END GetWord 

; PROCEDURE GetLower ( VAR Word : Strings . tString ) 

  = VAR i , WordStart : INTEGER 

  ; BEGIN (* GetLower *) 
      WordStart := yyChBufferIndex - TokenLength - 1 
    ; FOR i := 1 TO TokenLength 
      DO Word . Chars [ VAL ( i , Strings . tStringIndex ) ] 
           := yyToLower [ yyChBufferPtr ^ [ WordStart + i ] ] 
      END (* FOR *) 
    ; Word . Length := VAL ( TokenLength , SHORTCARD ) 
    END GetLower 

; PROCEDURE GetUpper ( VAR Word : Strings . tString ) 

  = VAR i , WordStart : INTEGER 

  ; BEGIN (* GetUpper *) 
      WordStart := yyChBufferIndex - TokenLength - 1 
    ; FOR i := 1 TO TokenLength 
      DO Word . Chars [ VAL ( i , Strings . tStringIndex ) ] 
           := yyToUpper [ yyChBufferPtr ^ [ WordStart + i ] ] 
      END (* FOR *) 
    ; Word . Length := VAL ( TokenLength , SHORTCARD ) 
    END GetUpper 

; PROCEDURE yyStart ( State : yyStateRange ) 

  = BEGIN (* yyStart *) 
      yyPreviousStart := yyStartState 
    ; yyStartState := State 
    END yyStart 

; PROCEDURE yyPrevious ( ) 

  = VAR s : yyStateRange 

  ; BEGIN (* yyPrevious *) 
      s := yyStartState 
    ; yyStartState := yyPreviousStart 
    ; yyPreviousStart := s 
    END yyPrevious 

; PROCEDURE yyEcho ( ) 

  = VAR i : INTEGER 

  ; BEGIN (* yyEcho *) 
      FOR i := yyChBufferIndex - TokenLength TO yyChBufferIndex - 1 
      DO ReuseIO . WriteC ( ReuseIO . StdOutput , yyChBufferPtr ^ [ i ] ) 
      END (* FOR *) 
    END yyEcho 

; PROCEDURE yyLess ( n : INTEGER ) 

  = BEGIN (* yyLess *) 
      DEC ( yyChBufferIndex , TokenLength - n )
    ; TokenLength := n 
    END yyLess 

; PROCEDURE yyTab ( ) 

  = BEGIN (* yyTab *) 
      DEC 
        ( yyLineStart 
        , yyTabSpace 
          - 1 
          - ( ( yyChBufferIndex - yyLineStart - 2 ) MOD yyTabSpace ) 
        ) 
    END yyTab 

; PROCEDURE yyTab1 ( a : INTEGER ) 

  = BEGIN (* yyTab1 *) 
      DEC 
        ( yyLineStart 
        , yyTabSpace 
          - 1 
          - ( ( yyChBufferIndex - yyLineStart - TokenLength + a - 1 ) 
              MOD yyTabSpace 
            ) 
        ) 
    END yyTab1 

; PROCEDURE yyTab2 ( a , b : INTEGER ) 

  = BEGIN (* yyTab2 *) 
      DEC 
        ( yyLineStart 
        , yyTabSpace 
          - 1 
          - ( ( yyChBufferIndex - yyLineStart - TokenLength + a - 1 ) 
              MOD yyTabSpace 
            ) 
        ) 
    END yyTab2 

; PROCEDURE yyEol ( Column : INTEGER ) 

  = BEGIN (* yyEol *) 
      INC ( yyLineCount ) 
    ; INC ( yyTotalLineCount ) 
    ; yyLineStart := yyChBufferIndex - 1 - Column 
    END yyEol 

; PROCEDURE output ( c : CHAR ) 

  = BEGIN (* output *) 
      ReuseIO . WriteC ( ReuseIO . StdOutput , c ) 
    END output 

; PROCEDURE unput ( c : CHAR ) 

  = BEGIN (* unput *) 
      DEC ( yyChBufferIndex ) 
    ; yyChBufferPtr ^ [ yyChBufferIndex ] := c 
    END unput 

; PROCEDURE input ( ) : CHAR 

  = BEGIN (* input *) 
      IF yyChBufferIndex = ( yyChBufferStart + yyBytesRead ) 
      THEN 
        IF NOT yyEof 
        THEN 
          DEC ( yyLineStart , yyBytesRead ) 
        ; DEC ( yyLineStart , yyChBufferStart ) (* RMB *) 
        ; yyChBufferIndex := 0 
        ; yyChBufferStart := 0 
        ; yyBytesRead 
$@            := $Source . GetLine 
                 ( yySourceFile 
                 , yyChBufferPtr 
                 , General . Exp2 ( General . Log2 ( yyChBufferSize ) ) 
                 ) 
        ; IF yyBytesRead <= 0 
          THEN 
            yyBytesRead := 0 
          ; yyEof := TRUE 
          END (* IF *) 
        ; yyChBufferPtr ^ [ yyBytesRead ] := yyEobCh 
        ; yyChBufferPtr ^ [ yyBytesRead + 1 ] := '\000' 
        END (* IF *) 
      END (* IF *) 
    ; IF yyChBufferIndex = ( yyChBufferStart + yyBytesRead ) 
      THEN 
        RETURN '\000' 
      ELSE 
        INC ( yyChBufferIndex ) 
      ; RETURN yyChBufferPtr ^ [ yyChBufferIndex - 1 ] 
      END (* IF *) 
    END input 

(* VISIBLE: *) 
; PROCEDURE UpperCase ( Ch : CHAR ) : CHAR 

  = BEGIN (* UpperCase *) 
      RETURN yyToUpper [ Ch ] 
    END UpperCase 

(* VISIBLE: *) 
; PROCEDURE LowerCase ( Ch : CHAR ) : CHAR 

  = BEGIN (* LowerCase *) 
      RETURN yyToLower [ Ch ] 
    END LowerCase 

(* VISIBLE *) 
; PROCEDURE TotalLineCount ( ) : CARDINAL  

  = BEGIN (* TotalLineCount *) 
      RETURN yyTotalLineCount 
    END TotalLineCount 

; PROCEDURE BeginScanner ( ) 

  = BEGIN (* BeginScanner *)
(* User initialization code ($I): *)
$I (*user initialization code*) 
(* End of user initialization code ($I): *)
    END BeginScanner 

; PROCEDURE CloseScanner ( ) 

  = BEGIN (* CloseScanner *) 
(* User finalization code ($F): *)
$F (*user finalization code*) 
(* End of user finalization code ($F): *)
    END CloseScanner

(* From hand edited version, with $M lines inserted: *)
; PROCEDURE yyGetTables ( ) 

  = VAR BlockSize , j , n : Word . T 
    ; TableFile : System . tFile 
    ; Base : ARRAY yyStateRange OF yyTableRange 

  ; BEGIN (* yyGetTables *) 
      BlockSize := 64000 DIV BYTESIZE ( yyCombType )
    ; TRY 
        TableFile := System . OpenInputT ( ScanTabName ) 
      EXCEPT 
        OSError . E ( code ) 
        => RexErrors . ErrLine
             ( "Unable to open scanner table file " & ScanTabName ) 
        ; Process . Exit ( RexErrors . AbnormalTermination )  
      END (* EXCEPT *) 
    ; Checks . ErrorCheckT ( "Unable to open " & ScanTabName , TableFile ) 
    ; IF ( ( yyGetTable ( TableFile , ADR ( Base [ FIRST ( Base ) ] ) ) 
             DIV BYTESIZE ( yyTableElmt ) 
             - 1 
           ) 
           # yyDStateCount 
         ) 
         OR ( ( yyGetTable 
                  ( TableFile , ADR ( yyDefault [ FIRST ( yyDefault ) ] ) ) 
                DIV BYTESIZE ( yyTableElmt ) 
                - 1 
              ) 
              # yyDStateCount 
            ) 
         OR ( ( yyGetTable 
                  ( TableFile , ADR ( yyEobTrans [ FIRST ( yyEobTrans ) ] ) ) 
                DIV BYTESIZE ( yyTableElmt ) 
                - 1 
              ) 
              # yyDStateCount 
            ) 
(* Only for ReduceCaseSize ($M): *)
$M       OR ( ( yyGetTable 
$M                ( TableFile 
$M                , ADR ( yyAction [ FIRST ( yyAction ) ] ) 
$M                ) 
$M              DIV BYTESIZE ( yyTableElmt ) 
$M              - 1 
$M            ) 
$M            # yyDStateCount 
$M          ) 
(* End of only for ReduceCaseSize ($M): *)
      THEN 
        yyErrorMessage ( 2 ) 
      END (* IF *) 
    ; n := 0 
    ; j := 0 

    ; WHILE j <= yyTableSize 
      DO INC 
           ( n 
           , yyGetTable 
               ( TableFile , ADR ( yyComb [ VAL ( j , SHORTCARD ) ] ) ) 
             DIV BYTESIZE ( yyCombType ) 
           ) 
      ; INC ( j , BlockSize ) 
      END (* WHILE *) 
    ; IF n # ( yyTableSize + 1 ) THEN yyErrorMessage ( 2 ) END (* IF *) 
    ; System . Close ( TableFile ) 

    ; FOR i := 0 TO yyDStateCount 
      DO yyBasePtr [ i ] 
           := LOOPHOLE ( ADR ( yyComb [ Base [ i ] ] ) , M2LONGCARD ) 
      END (* FOR *) 
    END yyGetTables 

(* Directly converted version: lacks manual fixes: 
; PROCEDURE yyGetTables ( ) 

  = VAR BlockSize , j , n : Word . T 
    ; TableFile : System . tFile 
    ; i : yyStateRange 
    ; Base : ARRAY yyStateRange OF yyTableRange 

  ; BEGIN (* yyGetTables *) 
      BlockSize := 64000 DIV BYTESIZE ( yyCombType ) 
    ; TableFile := System . OpenInputT ( ScanTabName ) 
    ; Checks . ErrorCheckT
        ( "Unable to open scanner table file " & ScanTabName, TableFile ) 
    ; IF ( ( yyGetTable 
               ( TableFile , ADR ( Base [ FIRST ( Base ) ] ) ) 
             DIV BYTESIZE ( yyTableElmt ) 
             - 1 
           ) 
           # yyDStateCount 
         ) 
         OR ( ( yyGetTable 
                  ( TableFile 
                  , ADR ( yyDefault [ FIRST ( yyDefault ) ] ) 
                  ) 
                DIV BYTESIZE ( yyTableElmt ) 
                - 1 
              ) 
              # yyDStateCount 
            ) 
         OR ( ( yyGetTable 
                  ( TableFile 
                  , ADR ( yyEobTrans [ FIRST ( yyEobTrans ) ] ) 
                  ) 
                DIV BYTESIZE ( yyTableElmt ) 
                - 1 
              ) 
              # yyDStateCount 
            ) 
(* Only for ReduceCaseSize ($M): *)
$M       OR ( ( yyGetTable 
$M                ( TableFile 
$M                , ADR ( yyAction [ FIRST ( yyAction ) ] ) 
$M                ) 
$M              DIV BYTESIZE ( yyTableElmt ) 
$M              - 1 
$M            ) 
$M            # yyDStateCount 
$M          ) 
(* End of only for ReduceCaseSize ($M): *)
      THEN 
        yyErrorMessage ( 2 ) 
      END (* IF *) 
    ; n := 0 
    ; j := 0 
    ; WHILE j <= yyTableSize 
      DO INC 
           ( n 
           , yyGetTable 
               ( TableFile 
               , ADR ( yyComb [ VAL ( j , SHORTCARD ) ] ) 
               ) 
             DIV BYTESIZE ( yyCombType ) 
           ) 
      ; INC ( j , BlockSize ) 
      END (* WHILE *) 
    ; IF n # ( yyTableSize + 1 ) THEN yyErrorMessage ( 2 ) END (* IF *) 
    ; System . Close ( TableFile ) 

    ; FOR i := 0 TO yyDStateCount 
      DO yyBasePtr [ i ] 
           := LOOPHOLE ( ADR ( yyComb [ Base [ i ] ] ) , M2LONGCARD ) 
      END (* FOR *) 
    END yyGetTables
  End of directly converted version. *)

; PROCEDURE yyGetTable 
    ( TableFile : System . tFile ; Address : ADDRESS ) : Word . T 

  = VAR N : INTEGER 
    ; Length : yyTableElmt 
    ; LongLength : Word . T 

  ; BEGIN (* yyGetTable *) 
      N := System . Read 
             ( TableFile , ADR ( Length ) , BYTESIZE ( yyTableElmt ) ) 
    ; Checks . ErrorCheckT
        ( "Unable to read size in scanner table file " & ScanTabName , N )  
    ; IF N < 0 
      THEN 
        Process . Exit ( RexErrors . AbnormalTermination ) 
      END (* IF *) 
    ; LongLength := Length 
    ; N := System . Read ( TableFile , Address , LongLength ) 
    ; Checks . ErrorCheckT
        ( "Unable to read data in scanner table file " & ScanTabName , N )  
    ; IF N < 0 
      THEN 
        Process . Exit ( RexErrors . AbnormalTermination ) 
      END (* IF *) 
    ; RETURN LongLength 
    END yyGetTable 

; PROCEDURE yyErrorMessage ( ErrorCode : SHORTCARD ) 

  = BEGIN (* yyErrorMessage *) 
      Positions . WritePosition ( ReuseIO . StdError , Attribute . Position ) 
    ; CASE ErrorCode 
      OF 0 
      => ReuseIO . WriteT 
$@         ( ReuseIO . StdError , ": " & "@" & ": internal error" ) 
      | 1 
      => ReuseIO . WriteT 
$@         ( ReuseIO . StdError , ": " & "@" & ": out of memory" ) 
      | 2 
      => ReuseIO . WriteT 
$@         ( ReuseIO . StdError , ": " & "@" & ": table mismatch" ) 
      | 3 
      => ReuseIO . WriteT 
           ( ReuseIO . StdError 
$@         , ": " & "@" & ": too many nested include files"
           ) 
      | 4 
      => ReuseIO . WriteT 
           ( ReuseIO . StdError 
$@         , ": " & "@" & ": file stack underflow (too many calls of CloseFile)"
           ) 
      | 5 
      => ReuseIO . WriteT 
           ( ReuseIO . StdError 
$@         , ": " & "@" & ": unable to open input file. "
           ) 
      END (* CASE *) 
    ; ReuseIO . WriteNl ( ReuseIO . StdError ) 
    ; Exit ( ) 
    END yyErrorMessage 

; PROCEDURE yyExit ( ) 

  = BEGIN (* yyExit *) 
      ReuseIO . CloseIO ( ) 
    ; System . Exit ( 1 ) 
    END yyExit 

; BEGIN (* Name *)
    ScanTabName := "Scanner.Tab" 
  ; Exit := yyExit 
  ; yyFileStackPtr := 0 
  ; yyStartState := 1 (* set up for auto init *) 
  ; yyPreviousStart := 1 
  ; yyBasePtr [ yyStartState ] 
      := LOOPHOLE ( ADR ( yyComb [ 0 ] ) , M2LONGCARD ) 
  ; yyDefault [ yyStartState ] := yyDNoState 
  ; yyComb [ 0 ] . Check := yyDNoState 
  ; yyChBufferPtr := LOOPHOLE ( ADR ( yyComb [ 0 ] ) , yytChBufferPtr ) 
  ; yyChBufferIndex := 1 (* dirty trick *) 
  ; yyStateStackSize := yyInitBufferSize 
  ; DynArray . MakeArray 
      ( LOOPHOLE ( yyStateStack , ADDRESS ) 
      , yyStateStackSize 
      , BYTESIZE ( yyStateRange ) 
      ) 
(* FIXME:              ^ *) 
  ; yyStateStack ^ [ 0 ] := yyDNoState 

  ; FOR yyCh := yyFirstCh TO yyLastCh 
    DO yyToLower [ yyCh ] := yyCh 
    END (* FOR *) 
  ; yyToUpper := yyToLower 
  ; FOR yyCh := 'A' TO 'Z' 
    DO yyToLower [ yyCh ] 
         := VAL ( ORD ( yyCh ) - ORD ( 'A' ) + ORD ( 'a' ) , CHAR ) 
    END (* FOR *) 
  ; FOR yyCh := 'a' TO 'z' 
    DO yyToUpper [ yyCh ] 
         := VAL ( ORD ( yyCh ) - ORD ( 'a' ) + ORD ( 'A' ) , CHAR ) 
    END (* FOR *) 
$@ END @ 
. 

