(* RMB 93/10/11 
   This module was missing from the distribution.  I suppose it
   might have been builtin to Mocka and Sun Modula-2, but it is
   apparently not builtin to mtc.  mtc Won't translate General,
   which is a client of this module, without it.  So how did this ever compile
   without it?  Reconstruction done by looking at clients and the
   C version, which appears to be generated by mtc.
*)

(* This is the mtc syntax version. *)

(*FOREIGN *) MODULE Arguments
; TYPE ArgTable = POINTER TO ARRAY [0 .. 999 ] 
                             OF POINTER TO ARRAY [ 0 .. 999 ] OF CHAR

; PROCEDURE GetArgs ( VAR argc : INTEGER ; VAR argv : ArgTable )
; PROCEDURE GetEnv ( VAR env : ArgTable )

; END Arguments
(* $Id: Checks.md,v 1.1 1991/11/21 14:33:17 grosch rel $ *)

(* $Log: Checks.md,v $
 * Revision 1.1  1991/11/21  14:33:17  grosch
 * new version of RCS on SPARC
 *
 * Revision 1.0  88/10/04  11:46:49  grosch
 * Initial revision
 * 
 *)

(* Ich, Doktor Josef Grosch, Informatiker, Sept. 1987 *)

DEFINITION MODULE Checks;

PROCEDURE ErrorCheck (s: ARRAY OF CHAR; n: INTEGER);

END Checks.
(* $Id: DynArray.md,v 1.1 1991/11/21 14:33:17 grosch rel $ *)

(* $Log: DynArray.md,v $
 * Revision 1.1  1991/11/21  14:33:17  grosch
 * new version of RCS on SPARC
 *
 * Revision 1.0  88/10/04  11:46:52  grosch
 * Initial revision
 * 
 *)

(* Ich, Doktor Josef Grosch, Informatiker, Sept. 1987 *)

DEFINITION MODULE DynArray;

FROM SYSTEM	IMPORT ADDRESS;

PROCEDURE MakeArray    (VAR ArrayPtr	: ADDRESS	;
			VAR ElmtCount	: LONGINT	;
			    ElmtSize	: LONGINT)	;

PROCEDURE ExtendArray  (VAR ArrayPtr	: ADDRESS	;
			VAR ElmtCount	: LONGINT	;
			    ElmtSize	: LONGINT)	;

PROCEDURE ReleaseArray (VAR ArrayPtr	: ADDRESS	;
			VAR ElmtCount	: LONGINT	;
			    ElmtSize	: LONGINT)	;

END DynArray.
(* $Id: Errors.md,v 1.0 1992/08/07 14:41:58 grosch rel $ *)

(* $Log: Errors.md,v $
# Revision 1.0  1992/08/07  14:41:58  grosch
# Initial revision
#
 *)

(* Ich, Doktor Josef Grosch, Informatiker, Juli 1992 *)

DEFINITION MODULE Errors;

FROM SYSTEM	IMPORT ADDRESS;
FROM Positions	IMPORT tPosition;
FROM IO		IMPORT tFile;

CONST
   NoText		= 0	;
   SyntaxError		= 1	;	(* error codes		*)
   ExpectedTokens	= 2	;
   RestartPoint		= 3	;
   TokenInserted	= 4	;
   WrongParseTable	= 5	;
   OpenParseTable	= 6	;
   ReadParseTable	= 7	;
   TooManyErrors	= 8	;

   Fatal		= 1	;	(* error classes	*)
   Restriction		= 2	;
   Error		= 3	;
   Warning		= 4	;
   Repair		= 5	;
   Note			= 6	;
   Information		= 7	;

   None			= 0	;
   Integer		= 1	;	(* info classes		*)
   Short		= 2	;
   Long			= 3	;
   Real			= 4	;
   Boolean		= 5	;
   Character		= 6	;
   String		= 7	;
   Array		= 8	;
   Set			= 9	;
   Ident		= 10	;

VAR	  Exit		: PROC;
			(* Refers to a procedure that specifies		*)
			(* what to do if 'ErrorClass' = Fatal.		*)
			(* Default: terminate program execution.	*)

PROCEDURE StoreMessages (Store: BOOLEAN);
			(* Messages are stored if 'Store' = TRUE	*)
			(* for printing with the routine 'WriteMessages'*)
			(* otherwise they are printed immediately.	*)
			(* If 'Store'=TRUE the message store is cleared.*)

PROCEDURE ErrorMessage	(ErrorCode, ErrorClass: CARDINAL; Position: tPosition);
			(* Report a message represented by an integer	*)
			(* 'ErrorCode' and classified by 'ErrorClass'.	*)

PROCEDURE ErrorMessageI	(ErrorCode, ErrorClass: CARDINAL; Position: tPosition;
			 InfoClass: CARDINAL; Info: ADDRESS);
			(* Like the previous routine with additional	*)
			(* information of type 'InfoClass' at the	*)
			(* address 'Info'.				*)

PROCEDURE Message  (ErrorText: ARRAY OF CHAR; ErrorClass: CARDINAL; Position: tPosition);
			(* Report a message represented by a string	*)
			(* 'ErrorText' and classified by 'ErrorClass'.	*)

PROCEDURE MessageI (ErrorText: ARRAY OF CHAR; ErrorClass: CARDINAL; Position: tPosition;
			 InfoClass: CARDINAL; Info: ADDRESS);
			(* Like the previous routine with additional	*)
			(* information of type 'InfoClass' at the	*)
			(* address 'Info'.				*)

PROCEDURE WriteMessages	(File: tFile);
			(* The stored messages are sorted by their	*)
			(* source position and printed on 'File'.	*)

END Errors.
(* $Id: General.md,v 1.3 1992/01/30 13:23:29 grosch rel $ *)

(* $Log: General.md,v $

 * RMB 93/10/13 Added MinSHORTCARD and MaxSHORTCARD

 * Revision 1.3  1992/01/30  13:23:29  grosch
 * redesign of interface to operating system
 *
 * Revision 1.2  1991/11/21  14:33:17  grosch
 * new version of RCS on SPARC
 *
 * Revision 1.1  90/03/02  17:36:05  grosch
 * automized handling of machine independent alignment
 * 
 * Revision 1.0  88/10/04  11:46:53  grosch
 * Initial revision
 * 
 *)

(* Ich, Doktor Josef Grosch, Informatiker, Sept. 1987 *)

(* General Subroutines: minimum, maximum, binary logarithm, and power of 2 *)

DEFINITION MODULE General;

VAR	  MaxAlign	: INTEGER;
VAR	  AlignMasks	: ARRAY [0..8] OF BITSET;

PROCEDURE Min		(a, b: INTEGER)			: INTEGER;
			(* Returns the minimum of 'a' and 'b'.		*)

PROCEDURE Max		(a, b: INTEGER)			: INTEGER;
			(* Returns the maximum of 'a' and 'b'.		*)

PROCEDURE MinSHORTCARD	(a, b: SHORTCARD)		: SHORTCARD;
			(* Returns the minimum of 'a' and 'b'.		*)

PROCEDURE MaxSHORTCARD	(a, b: SHORTCARD)		: SHORTCARD;
			(* Returns the maximum of 'a' and 'b'.		*)

PROCEDURE Log2		(x: LONGINT)			: CARDINAL;
			(* Returns the logarithm to the base 2 of 'x'.	*)

PROCEDURE Exp2		(x: CARDINAL)			: LONGINT;
			(* Returns 2 to the power of 'x'.		*)

PROCEDURE AntiLog	(x: LONGINT)			: CARDINAL;
			(* Returns the number of the lowest bit set in 'x'. *)

PROCEDURE Exp10		(x: INTEGER)			: REAL;
			(* Returns 10 to the power of 'x'.		*)

END General.




(* $Id: Heap.md,v 1.2 1992/08/07 14:45:41 grosch rel $ *)

(* $Log: Heap.md,v $
 * Revision 1.2  1992/08/07  14:45:41  grosch
 * added comments
 *
 * Revision 1.1  1991/11/21  14:33:17  grosch
 * new version of RCS on SPARC
 *
 * Revision 1.0  88/10/04  11:46:55  grosch
 * Initial revision
 * 
 *)

(* Ich, Doktor Josef Grosch, Informatiker, 2.9.1988 *)

DEFINITION MODULE Heap;

FROM SYSTEM IMPORT ADDRESS;

VAR	  HeapUsed	: LONGCARD;
			(* Holds the total amount of memory managed by	*)
			(* this module.					*)

PROCEDURE Alloc		(ByteCount: LONGINT) : ADDRESS;
			(* Returns a pointer to dynamically allocated	*)
			(* space of size 'ByteCount' bytes.		*)

PROCEDURE Free		;
			(* The complete space allocated for the heap	*)
			(* is released.					*)

(* PROCEDURE WriteHeap; *)

END Heap.
(* $Id: IO.md,v 1.5 1992/01/30 13:23:29 grosch rel $ *)

(* $Log: IO.md,v $

 * RMB: 93/10/11
        Changed param s of WriteS and Filename of ReadOpen and WriteOpen
        not to be VAR, so many calls thereon, in this package and 
        elsewhere, which pass a string literal, are legal in
        WRL Modula-2. 

 * Revision 1.5  1992/01/30  13:23:29  grosch
 * redesign of interface to operating system
 *
 * Revision 1.4  1991/11/21  14:33:17  grosch
 * new version of RCS on SPARC
 *
 * Revision 1.3  89/08/18  11:11:28  grosch
 * make Write work for Size = 0
 * 
 * Revision 1.2  89/07/14  16:26:27  grosch
 * made WriteN work for numbers with MSBit set
 * 
 * Revision 1.1  89/01/24  19:04:20  grosch
 * added procedure UnRead
 * 
 * Revision 1.0  88/10/04  11:46:57  grosch
 * Initial revision
 * 
 *)

(* Ich, Doktor Josef Grosch, Informatiker, Sept. 1987 *)

DEFINITION MODULE IO;				(* buffered IO		*)

FROM SYSTEM	IMPORT ADDRESS;

IMPORT System;

CONST
   StdInput	= System.StdInput;
   StdOutput	= System.StdOutput;
   StdError	= System.StdError;

TYPE
   tFile	= System.tFile;

PROCEDURE ReadOpen	((*VAR*) FileName: ARRAY OF CHAR): tFile;
						(* open  input file	*)
PROCEDURE ReadClose	(f: tFile);		(* close input file	*)
PROCEDURE Read		(f: tFile; Buffer: ADDRESS; Size: CARDINAL): INTEGER;
						(* binary		*)
PROCEDURE ReadC		(f: tFile): CHAR    ;	(* character		*)
PROCEDURE ReadI		(f: tFile): INTEGER ;	(* integer  number	*)
PROCEDURE ReadR		(f: tFile): REAL    ;	(* real     number	*)
PROCEDURE ReadB		(f: tFile): BOOLEAN ;	(* boolean		*)
PROCEDURE ReadN		(f: tFile; Base: INTEGER): INTEGER;
						(* number of base 'Base'*)
PROCEDURE ReadS		(f: tFile; VAR s: ARRAY OF CHAR);
						(* string		*)
PROCEDURE ReadShort	(f: tFile): SHORTINT;	(* shortint number ?	*)
PROCEDURE ReadLong	(f: tFile): LONGINT ;	(* longint  number ?	*)
PROCEDURE ReadCard	(f: tFile): CARDINAL;	(* cardinal number ?	*)
PROCEDURE ReadNl	(f: tFile);		(* new line		*)
PROCEDURE UnRead	(f: tFile);		(* backspace 1 char.	*)

PROCEDURE EndOfLine	(f: tFile): BOOLEAN ;	(* end of line ?	*)
PROCEDURE EndOfFile	(f: tFile): BOOLEAN ;	(* end of file ?	*)


PROCEDURE WriteOpen	((*VAR*) FileName: ARRAY OF CHAR): tFile;
						(* open  output file	*)
PROCEDURE WriteClose	(f: tFile);		(* close output file	*)
PROCEDURE WriteFlush	(f: tFile);		(* flush output buffer	*)
PROCEDURE Write		(f: tFile; Buffer: ADDRESS; Size: INTEGER): INTEGER;
						(* binary		*)
PROCEDURE WriteC	(f: tFile; c: CHAR);	(* character		*)
PROCEDURE WriteI	(f: tFile; n: INTEGER ; FieldWidth: CARDINAL);
						(* integer  number	*)
PROCEDURE WriteR	(f: tFile; n: REAL; Before, After, Exp: CARDINAL);
						(* real     number	*)
PROCEDURE WriteB	(f: tFile; b: BOOLEAN);	(* boolean		*)
PROCEDURE WriteN	(f: tFile; n: LONGCARD; FieldWidth, Base: CARDINAL);
						(* number of base 'Base'*)
PROCEDURE WriteS	(f: tFile; (*VAR*) s: ARRAY OF CHAR); 
						(* string		*)
PROCEDURE WriteShort	(f: tFile; n: SHORTINT; FieldWidth: CARDINAL);
						(* shortint number ?	*)
PROCEDURE WriteLong	(f: tFile; n: LONGINT ; FieldWidth: CARDINAL);
						(* longint  number ?	*)
PROCEDURE WriteCard	(f: tFile; n: CARDINAL; FieldWidth: CARDINAL);
						(* cardinal number ?	*)
PROCEDURE WriteNl	(f: tFile);		(* new line		*)


PROCEDURE CloseIO;				(* close all files	*)

END IO.
(* $Id: Idents.md,v 1.6 1992/08/07 14:45:41 grosch rel $ *)

(* $Log: Idents.md,v $
 * RMB 94/02/04 Added LookupIdent.

 * Revision 1.6  1992/08/07  14:45:41  grosch
 * added comments
 *
 * Revision 1.5  1991/11/21  14:33:17  grosch
 * new version of RCS on SPARC
 *
 * Revision 1.4  89/06/06  10:07:56  grosch
 * changed tIdent to SHORTCARD
 * 
 * Revision 1.3  89/06/01  18:20:22  grosch
 * added predefined identifier NoIdent
 * 
 * Revision 1.2  89/01/25  12:05:29  grosch
 * added function MaxIdent
 * 
 * Revision 1.1  89/01/21  23:03:08  grosch
 * added file parameter to procedure WriteIdent
 * 
 * Revision 1.0  88/10/04  11:47:00  grosch
 * Initial revision
 * 
 *)

(* Ich, Doktor Josef Grosch, Informatiker, Sept. 1987 *)

DEFINITION MODULE Idents;

FROM IO		IMPORT tFile		;
FROM Strings	IMPORT tString		;
FROM StringMem	IMPORT tStringRef	;

TYPE	  tIdent	= SHORTCARD;

CONST
          cNoIdent      = 0;
                        (* A null value. *)

VAR	  NoIdent	: tIdent;
			(* A default identifer (empty string).		*)

PROCEDURE MakeIdent	(VAR s: tString)		: tIdent;
			(* The string 's' is mapped to a unique number	*)
			(* (an integer) which is returned.		*)

PROCEDURE LookupIdent	(VAR s: tString)		: tIdent;
                        (* If s has previously been  mapped by a call to*)
                        (* MakeIdent, return its tIdent value.  Else    *)
                        (* return cNoIdent.                             *)

PROCEDURE GetString	(i: tIdent; VAR s: tString);
			(* Returns the string 's' whose number is 'i'.	*)

PROCEDURE GetStringRef	(i: tIdent)			: tStringRef;
			(* Returns a reference to the string whose	*)
			(* number is 'i'.				*)

PROCEDURE MaxIdent	()				: tIdent;
			(* Returns the current maximal value of the	*)
			(* type 'tIdent'.				*)

PROCEDURE WriteIdent	(f: tFile; i: tIdent);
			(* The string encoded by the ident 'i' is	*)
			(* printed on file 'f'.				*)

PROCEDURE WriteIdents	;
			(* The contents of the identifier table is	*)
			(* printed on the terminal.			*)

PROCEDURE InitIdents	;
			(* The identifier table	is initialized.		*)

PROCEDURE WriteHashTable;

END Idents.
(* $Id: Layout.md,v 1.2 1991/11/21 14:33:17 grosch rel $ *)

(* $Log: Layout.md,v $
 * Revision 1.2  1991/11/21  14:33:17  grosch
 * new version of RCS on SPARC
 *
 * Revision 1.1  89/01/24  19:04:46  grosch
 * added procedure SkipSpaces
 * 
 * Revision 1.0  88/10/04  11:47:02  grosch
 * Initial revision
 * 
 *)

(* Ich, Doktor Josef Grosch, Informatiker, Sept. 1987 *)

DEFINITION MODULE Layout;

FROM IO	IMPORT tFile;

PROCEDURE WriteChar	(f: tFile; Ch: CHAR);
PROCEDURE WriteSpace	(f: tFile);
PROCEDURE WriteSpaces	(f: tFile; Count: INTEGER);

PROCEDURE ReadSpace	(f: tFile);
PROCEDURE ReadSpaces	(f: tFile; Count: INTEGER);
PROCEDURE SkipSpaces	(f: tFile);

END Layout.
(* $Id: Lists.md,v 1.1 1991/11/21 14:33:17 grosch rel $ *)

(* $Log: Lists.md,v $
 * Revision 1.1  1991/11/21  14:33:17  grosch
 * new version of RCS on SPARC
 *
 * Revision 1.0  88/10/04  11:47:03  grosch
 * Initial revision
 * 
 *)

(* Ich, Doktor Josef Grosch, Informatiker, Sept. 1987 *)

DEFINITION MODULE Lists;

FROM SYSTEM	IMPORT ADDRESS;
FROM IO		IMPORT tFile;

TYPE
   tElmt		= ADDRESS;
   tListElmtPtr		= POINTER TO tListElmt;

   tListElmt		= RECORD
	 Succ		: tListElmtPtr;
	 Elmt		: tElmt;
      END;

   tList		= RECORD
	 FirstElmt	,
	 LastElmt	: tListElmtPtr;
      END;

   tProcOfFileAddress	= PROCEDURE (tFile, tElmt);

PROCEDURE MakeList	(VAR List: tList);
PROCEDURE Insert	(VAR List: tList; Elmt: tElmt);
PROCEDURE Append	(VAR List: tList; Elmt: tElmt);
PROCEDURE Head		(    List: tList): tElmt;
PROCEDURE Tail		(VAR List: tList);
PROCEDURE Last		(    List: tList): tElmt;
PROCEDURE Front		(VAR List: tList);		(* not implemented *)
PROCEDURE IsEmpty	(    List: tList): BOOLEAN;
PROCEDURE Length	(    List: tList): CARDINAL;
PROCEDURE WriteList	(f: tFile; List: tList; Proc: tProcOfFileAddress);

END Lists.
(* $Id: Memory.md,v 1.2 1992/08/07 14:45:41 grosch rel $ *)

(* $Log: Memory.md,v $
 * Revision 1.2  1992/08/07  14:45:41  grosch
 * added comments
 *
 * Revision 1.1  1991/11/21  14:33:17  grosch
 * new version of RCS on SPARC
 *
 * Revision 1.0  88/10/04  11:47:10  grosch
 * Initial revision
 * 
 *)

(* Ich, Doktor Josef Grosch, Informatiker, Juli 1986 *)

DEFINITION MODULE Memory;

FROM SYSTEM IMPORT ADDRESS;

VAR	  MemoryUsed	: LONGCARD;
			(* Holds the total amount of memory managed by	*)
			(* this module.					*)

PROCEDURE Alloc		(ByteCount: LONGINT) : ADDRESS;
			(* Returns a pointer to dynamically allocated	*)
			(* space of size 'ByteCount' bytes.		*)
			(* Returns NIL if space is exhausted.           *)


PROCEDURE Free		(ByteCount: LONGINT; a: ADDRESS);
			(* The dynamically allocated space starting at	*)
			(* address 'a' of size 'ByteCount' bytes is	*)
			(* released.					*)

(* PROCEDURE WriteMemory; *)

END Memory.



(* $Id: Positions.md,v 1.0 1992/08/07 14:41:59 grosch rel $ *)

(* $Log: Positions.md,v $
# Revision 1.0  1992/08/07  14:41:59  grosch
# Initial revision
#
 *)

(* Ich, Doktor Josef Grosch, Informatiker, Juli 1992 *)

DEFINITION MODULE Positions;

FROM IO		IMPORT tFile;

TYPE	  tPosition	= RECORD Line, Column: SHORTCARD; END;

VAR	  NoPosition	: tPosition;
			(* A default position (0, 0).			*)

PROCEDURE Compare	(Position1, Position2: tPosition): INTEGER;
			(* Returns -1 if Position1 < Position2.		*)
			(* Returns  0 if Position1 = Position2.		*)
			(* Returns  1 if Position1 > Position2.		*)

PROCEDURE WritePosition	(File: tFile; Position: tPosition);
			(* The 'Position' is printed on the 'File'.	*)

END Positions.
(* $Id: Relations.md,v 1.4 1991/11/21 14:33:17 grosch rel $ *)

(* $Log: Relations.md,v $

RMB 93/10/12 Type changes.

Revision 1.4  1991/11/21  14:33:17  grosch
new version of RCS on SPARC

Revision 1.3  91/06/07  12:19:55  grosch
decreased bounds of flexible arrays

Revision 1.2  91/06/07  11:37:46  grosch
increased bounds of flexible arrays

Revision 1.1  90/06/11  10:40:58  grosch
added procedure GetCyclics

Revision 1.0  89/11/02  18:24:47  grosch
Initial revision

 *)

(* Ich, Doktor Josef Grosch, Informatiker, 8.1.1988 *)

DEFINITION MODULE Relations;

FROM IO		IMPORT tFile;
FROM Sets	IMPORT tSet;
CONST Bound = 10000000 ; 
      (* ^mtc and/or cc get crabby if you make this too large. *)

TYPE
   Bounds = INTEGER [ 0 .. Bound ];
   ArrayOfSet	= ARRAY Bounds OF tSet;
   ProcOfIntInt		= PROCEDURE (INTEGER, INTEGER);
   ProcOfIntIntToBool	= PROCEDURE (INTEGER, INTEGER): BOOLEAN;

   tRelation = RECORD
      ArrayPtr	: POINTER TO ArrayOfSet;
      Size1	,
      Size2	: INTEGER;
   END;

PROCEDURE MakeRelation	(VAR Rel: tRelation; Size1, Size2: INTEGER);
PROCEDURE ReleaseRelation (VAR Rel: tRelation);
PROCEDURE Include	(VAR Rel: tRelation; e1, e2: INTEGER);
PROCEDURE Exclude	(VAR Rel: tRelation; e1, e2: INTEGER);
PROCEDURE IsElement	(e1, e2: INTEGER; Rel: tRelation): BOOLEAN;
PROCEDURE IsRelated	(e1, e2: INTEGER; Rel: tRelation): BOOLEAN;
PROCEDURE IsReflexive1	(e1: INTEGER; Rel: tRelation): BOOLEAN;
PROCEDURE IsSymmetric1	(e1, e2: INTEGER; Rel: tRelation): BOOLEAN;
PROCEDURE IsTransitive1	(e1, e2, e3: INTEGER; Rel: tRelation): BOOLEAN;
PROCEDURE IsReflexive	(Rel: tRelation): BOOLEAN;
PROCEDURE IsSymmetric	(Rel: tRelation): BOOLEAN;
PROCEDURE IsTransitive	(Rel: tRelation): BOOLEAN;
PROCEDURE IsEquivalence	(Rel: tRelation): BOOLEAN;
PROCEDURE HasReflexive	(Rel: tRelation): BOOLEAN;
PROCEDURE IsCyclic	(Rel: tRelation): BOOLEAN;
PROCEDURE GetCyclics	(Rel: tRelation; VAR Set: tSet);
PROCEDURE Closure	(VAR Rel: tRelation);
PROCEDURE AssignEmpty	(VAR Rel: tRelation);
PROCEDURE AssignElmt	(VAR Rel: tRelation; e1, e2: INTEGER);
PROCEDURE Assign	(VAR Rel1: tRelation; Rel2: tRelation);
PROCEDURE Union		(VAR Rel1: tRelation; Rel2: tRelation);
PROCEDURE Difference	(VAR Rel1: tRelation; Rel2: tRelation);
PROCEDURE Intersection	(VAR Rel1: tRelation; Rel2: tRelation);
PROCEDURE SymDiff	(VAR Rel1: tRelation; Rel2: tRelation);
PROCEDURE Complement	(VAR Rel: tRelation);
PROCEDURE IsSubset	(Rel1, Rel2: tRelation): BOOLEAN;
PROCEDURE IsStrictSubset (Rel1, Rel2: tRelation): BOOLEAN;
PROCEDURE IsEqual	(VAR Rel1, Rel2: tRelation): BOOLEAN;
PROCEDURE IsNotEqual	(Rel1, Rel2: tRelation): BOOLEAN;
PROCEDURE IsEmpty	(Rel: tRelation): BOOLEAN;
PROCEDURE Card		(VAR Rel: tRelation): INTEGER;
PROCEDURE Select	(VAR Rel: tRelation; VAR e1, e2: INTEGER);
PROCEDURE Extract	(VAR Rel: tRelation; VAR e1, e2: INTEGER);
PROCEDURE Forall	(Rel: tRelation; Proc: ProcOfIntIntToBool): BOOLEAN;
PROCEDURE Exists	(Rel: tRelation; Proc: ProcOfIntIntToBool): BOOLEAN;
PROCEDURE Exists1	(Rel: tRelation; Proc: ProcOfIntIntToBool): BOOLEAN;
PROCEDURE ForallDo	(Rel: tRelation; Proc: ProcOfIntInt);
PROCEDURE ReadRelation	(f: tFile; VAR Rel: tRelation);
PROCEDURE WriteRelation	(f: tFile;     Rel: tRelation);

END Relations.
(* $Id: Sets.md,v 1.4 1991/11/21 14:33:17 grosch rel $ *)

(* $Log: Sets.md,v $

 * RMB 93/10/12 Regularized types to compile with WRL.

 * Revision 1.4  1991/11/21  14:33:17  grosch
 * new version of RCS on SPARC
 *
 * Revision 1.3  91/09/18  15:09:49  grosch
 * reduced size of set type
 * 
 * Revision 1.2  91/06/07  11:37:49  grosch
 * increased bounds of flexible arrays
 * 
 * Revision 1.1  89/01/09  17:13:03  grosch
 * added functions Size, Minimum, and Maximum
 * 
 * Revision 1.0  88/10/04  11:47:12  grosch
 * Initial revision
 * 
 *)

(* Ich, Doktor Josef Grosch, Informatiker, Sept. 1987 *)

DEFINITION MODULE Sets;

FROM IO IMPORT tFile;

TYPE
   tInternalElmt        = SHORTCARD;
   (* ^ Change this only, for different range of elements. *)
   tElement             = CARDINAL [ 0 .. MAX ( tInternalElmt ) - 1 ];
   ArrayOfBitset	= ARRAY SHORTCARD [0 .. MAX ( SHORTCARD ) ] OF BITSET;
   ProcOftElement		= PROCEDURE (tElement);
   ProcOftElementToBool	= PROCEDURE (tElement): BOOLEAN;

   tSet = RECORD
      BitsetPtr		: POINTER TO ArrayOfBitset;
      LastBitset	: SHORTCARD;
      MaxElmt		: tInternalElmt;
      Card		: tInternalElmt;
      FirstElmt		: tInternalElmt;
      LastElmt		: tInternalElmt;
   END;

PROCEDURE MakeSet	(VAR Set: tSet; MaxSize: tElement);
PROCEDURE ReleaseSet	(VAR Set: tSet);
PROCEDURE Union		(VAR Set1: tSet; Set2: tSet);
PROCEDURE Difference	(VAR Set1: tSet; Set2: tSet);
PROCEDURE Intersection	(VAR Set1: tSet; Set2: tSet);
PROCEDURE SymDiff	(VAR Set1: tSet; Set2: tSet);
PROCEDURE Complement	(VAR Set: tSet);
PROCEDURE Include	(VAR Set: tSet; Elmt: tElement);
PROCEDURE Exclude	(VAR Set: tSet; Elmt: tElement);
PROCEDURE Card		(VAR Set: tSet): tElement;
PROCEDURE Size		(VAR Set: tSet): tElement;
PROCEDURE Minimum	(VAR Set: tSet): tElement;
PROCEDURE Maximum	(VAR Set: tSet): tElement;
PROCEDURE Select	(VAR Set: tSet): tElement;
PROCEDURE Extract	(VAR Set: tSet): tElement;
PROCEDURE IsSubset	(Set1, Set2: tSet): BOOLEAN;
PROCEDURE IsStrictSubset (Set1, Set2: tSet): BOOLEAN;
PROCEDURE IsEqual	(VAR Set1, Set2: tSet): BOOLEAN;
PROCEDURE IsNotEqual	(Set1, Set2: tSet): BOOLEAN;
PROCEDURE IsElement	(Elmt: tElement; VAR Set: tSet): BOOLEAN;
PROCEDURE IsEmpty	(Set: tSet): BOOLEAN;
PROCEDURE Forall	(Set: tSet; Proc: ProcOftElementToBool): BOOLEAN;
PROCEDURE Exists	(Set: tSet; Proc: ProcOftElementToBool): BOOLEAN;
PROCEDURE Exists1	(Set: tSet; Proc: ProcOftElementToBool): BOOLEAN;
PROCEDURE Assign	(VAR Set1: tSet; Set2: tSet);
PROCEDURE AssignElmt	(VAR Set: tSet; Elmt: tElement); (* Singleton *)
PROCEDURE AssignEmpty	(VAR Set: tSet);
PROCEDURE ForallDo	(Set: tSet; Proc: ProcOftElement);
PROCEDURE ReadSet	(f: tFile; VAR Set: tSet);
PROCEDURE WriteSet	(f: tFile;     Set: tSet);

END Sets.


(* $Id: SetsC.md,v 1.2 1991/11/21 14:33:17 grosch rel $ *)

(* $Log: SetsC.md,v $
Revision 1.2  1991/11/21  14:33:17  grosch
new version of RCS on SPARC

Revision 1.1  89/02/23  16:02:11  grosch
Initial revision

 *)

(* Ich, Doktor Josef Grosch, Informatiker, Feb. 1989 *)

DEFINITION MODULE SetsC;

FROM IO IMPORT tFile;

IMPORT Sets;

TYPE
   ProcOftElement		= Sets.ProcOftElement;
   ProcOftElementToBool	= Sets.ProcOftElementToBool;
   tSet			= Sets.tSet;

PROCEDURE MakeSet	(VAR Set: tSet; MaxSize: CARDINAL);
PROCEDURE ReleaseSet	(VAR Set: tSet);
PROCEDURE Union		(VAR Set1: tSet; Set2: tSet);
PROCEDURE Difference	(VAR Set1: tSet; Set2: tSet);
PROCEDURE Intersection	(VAR Set1: tSet; Set2: tSet);
PROCEDURE SymDiff	(VAR Set1: tSet; Set2: tSet);
PROCEDURE Complement	(VAR Set: tSet);
PROCEDURE Include	(VAR Set: tSet; Elmt: CARDINAL);
PROCEDURE Exclude	(VAR Set: tSet; Elmt: CARDINAL);
PROCEDURE Card		(VAR Set: tSet): CARDINAL;
PROCEDURE Size		(VAR Set: tSet): CARDINAL;
PROCEDURE Minimum	(VAR Set: tSet): CARDINAL;
PROCEDURE Maximum	(VAR Set: tSet): CARDINAL;
PROCEDURE Select	(VAR Set: tSet): CARDINAL;
PROCEDURE Extract	(VAR Set: tSet): CARDINAL;
PROCEDURE IsSubset	(Set1, Set2: tSet): BOOLEAN;
PROCEDURE IsStrictSubset (Set1, Set2: tSet): BOOLEAN;
PROCEDURE IsEqual	(VAR Set1, Set2: tSet): BOOLEAN;
PROCEDURE IsNotEqual	(Set1, Set2: tSet): BOOLEAN;
PROCEDURE IsElement	(Elmt: CARDINAL; VAR Set: tSet): BOOLEAN;
PROCEDURE IsEmpty	(Set: tSet): BOOLEAN;
PROCEDURE Forall	(Set: tSet; Proc: ProcOftElementToBool): BOOLEAN;
PROCEDURE Exists	(Set: tSet; Proc: ProcOftElementToBool): BOOLEAN;
PROCEDURE Exists1	(Set: tSet; Proc: ProcOftElementToBool): BOOLEAN;
PROCEDURE Assign	(VAR Set1: tSet; Set2: tSet);
PROCEDURE AssignElmt	(VAR Set: tSet; Elmt: CARDINAL);
PROCEDURE AssignEmpty	(VAR Set: tSet);
PROCEDURE ForallDo	(Set: tSet; Proc: ProcOftElement);
PROCEDURE ReadSet	(f: tFile; VAR Set: tSet);
PROCEDURE WriteSet	(f: tFile;     Set: tSet);

END SetsC.
(* $Id: Sort.md,v 1.0 1992/08/07 14:42:01 grosch rel $ *)

(* $Log: Sort.md,v $
# Revision 1.0  1992/08/07  14:42:01  grosch
# Initial revision
#
 *)

(* Ich, Doktor Josef Grosch, Informatiker, Juli 1992 *)

DEFINITION MODULE Sort;

TYPE tProcIntIntBool	= PROCEDURE (INTEGER, INTEGER): BOOLEAN;
TYPE tProcIntInt	= PROCEDURE (INTEGER, INTEGER);

PROCEDURE Sort (Lwb, Upb: INTEGER; IsLess: tProcIntIntBool; Swap: tProcIntInt);

	(* Sort data from the indices 'Lwb' to 'Upb' using quicksort.	*)
	(* The procedures 'IsLess' and 'Swap' are used to compare and	*)
	(* exchange two data elements.					*)

END Sort.
(* $Id: Source.md,v 1.0 1992/08/07 14:42:02 grosch rel $ *)

(* $Log: Source.md,v $
# Revision 1.0  1992/08/07  14:42:02  grosch
# Initial revision
#
 *)

(* Ich, Doktor Josef Grosch, Informatiker, Juli 1992 *)

DEFINITION MODULE Source;

FROM SYSTEM	IMPORT ADDRESS;
FROM System	IMPORT tFile;

PROCEDURE BeginSource (FileName: ARRAY OF CHAR): tFile;

   (*
      BeginSource is called from the scanner to open files.
      If not called then input is read form standard input.
   *)

PROCEDURE GetLine (File: tFile; Buffer: ADDRESS; Size: CARDINAL): INTEGER;

   (*
      GetLine is called to fill a buffer starting at address 'Buffer'
      with a block of maximal 'Size' characters. Lines are terminated
      by newline characters (ASCII = 0xa). GetLine returns the number
      of characters transferred. Reasonable block sizes are between 128
      and 2048 or the length of a line. Smaller block sizes -
      especially block size 1 - will drastically slow down the scanner.
   *)

PROCEDURE CloseSource (File: tFile);

   (*
      CloseSource is called from the scanner at end of file or
      at end of input, respectively. It can be used to close files.
   *)

END Source.
(* $Id: StdIO.md,v 1.3 1991/11/21 14:33:17 grosch rel $ *)

(* $Log: StdIO.md,v $
 * Revision 1.3  1991/11/21  14:33:17  grosch
 * new version of RCS on SPARC
 *
 * Revision 1.2  89/07/14  16:27:20  grosch
 * made WriteN work for numbers with MSBit set
 * 
 * Revision 1.1  89/01/24  19:04:40  grosch
 * added procedure UnRead
 * 
 * Revision 1.0  88/10/04  11:47:15  grosch
 * Initial revision
 * 
 *)

(* Ich, Doktor Josef Grosch, Informatiker, Sept. 1987 *)

DEFINITION MODULE StdIO;			(* buffered standard IO	*)

FROM SYSTEM IMPORT ADDRESS;

PROCEDURE ReadClose	;			(* close input file	*)
PROCEDURE Read		(Buffer: ADDRESS; Size: CARDINAL): INTEGER;
						(* binary		*)
PROCEDURE ReadC		(): CHAR    ;		(* character		*)
PROCEDURE ReadI		(): INTEGER ;		(* integer  number	*)
PROCEDURE ReadR		(): REAL    ;		(* real     number	*)
PROCEDURE ReadB		(): BOOLEAN ;		(* boolean		*)
PROCEDURE ReadN		(Base: INTEGER): INTEGER;
						(* number of base 'Base'*)
PROCEDURE ReadS		(VAR s: ARRAY OF CHAR);	(* string		*)
PROCEDURE ReadShort	(): SHORTINT;		(* shortint number ?	*)
PROCEDURE ReadLong	(): LONGINT ;		(* longint  number ?	*)
PROCEDURE ReadCard	(): CARDINAL;		(* cardinal number ?	*)
PROCEDURE ReadNl	;			(* new line		*)
PROCEDURE UnRead	;			(* backspace 1 char.	*)

PROCEDURE EndOfLine	(): BOOLEAN ;		(* end of line ?	*)
PROCEDURE EndOfFile	(): BOOLEAN ;		(* end of file ?	*)


PROCEDURE WriteClose	;			(* close output file	*)
PROCEDURE WriteFlush	;			(* flush output buffer	*)
PROCEDURE Write		(Buffer: ADDRESS; Size: CARDINAL): INTEGER;
						(* binary		*)
PROCEDURE WriteC	(c: CHAR);		(* character		*)
PROCEDURE WriteI	(n: INTEGER ; FieldWidth: CARDINAL);
						(* integer  number	*)
PROCEDURE WriteR	(n: REAL; Before, After, Exp: CARDINAL);
						(* real     number	*)
PROCEDURE WriteB	(b: BOOLEAN);		(* boolean		*)
PROCEDURE WriteN	(n: LONGCARD; FieldWidth, Base: CARDINAL);
						(* number of base 'Base'*)
PROCEDURE WriteS	(s: ARRAY OF CHAR);	(* string		*)
PROCEDURE WriteShort	(n: SHORTINT; FieldWidth: CARDINAL);
						(* shortint number ?	*)
PROCEDURE WriteLong	(n: LONGINT ; FieldWidth: CARDINAL);
						(* longint  number ?	*)
PROCEDURE WriteCard	(n: CARDINAL; FieldWidth: CARDINAL);
						(* cardinal number ?	*)
PROCEDURE WriteNl	;			(* new line		*)


PROCEDURE CloseIO;				(* close all files	*)

END StdIO.
(* $Id: StringMem.md,v 1.3 1992/08/07 14:45:41 grosch rel $ *)

(* $Log: StringMem.md,v $
 * Revision 1.3  1992/08/07  14:45:41  grosch
 * added comments
 *
 * Revision 1.2  1991/11/21  14:33:17  grosch
 * new version of RCS on SPARC
 *
 * Revision 1.1  89/01/21  23:02:41  grosch
 * added file parameter to procedure WriteString
 * 
 * Revision 1.0  88/10/04  11:47:17  grosch
 * Initial revision
 * 
 *)

(* Ich, Doktor Josef Grosch, Informatiker, Sept. 1987 *)

DEFINITION MODULE StringMem;

FROM IO		IMPORT tFile	;
FROM Strings	IMPORT tString	;

TYPE tStringRef = LONGINT	;

PROCEDURE PutString	(VAR s: tString)			: tStringRef;
			(* Stores string 's' in the string memory and	*)
			(* returns a reference to the stored string.	*)

PROCEDURE GetString	(r: tStringRef; 		   VAR s: tString);
			(* Returns the string 's' from the string	*)
			(* memory which is referenced by 'r'.		*)

PROCEDURE Length	(r: tStringRef)				: CARDINAL;
			(* Returns the length of the string 's'		*)
			(* which is referenced by 'r'.			*)

PROCEDURE IsEqual	(r: tStringRef; VAR s: tString)		: BOOLEAN;
			(* Compares the string referenced by 'r' and	*)
			(* the string 's'.				*)
			(* Returns TRUE if both are equal.		*)

PROCEDURE WriteString	(f: tFile; r: tStringRef);
			(* The string referenced by 'r' is printed on	*)
			(* file 'f'.					*)

PROCEDURE WriteStringMemory;
			(* The contents of the string memory is printed	*)
			(* on the terminal.				*)

PROCEDURE InitStringMemory;
			(* The string memory is initialized.		*)

END StringMem.
(* $Id: Strings.md,v 1.3 1991/11/21 14:33:17 grosch rel $ *)

(* $Log: Strings.md,v $
 * Revision 1.3  1991/11/21  14:33:17  grosch
 * new version of RCS on SPARC
 *
 * Revision 1.2  89/06/06  10:06:58  grosch
 * changed tStringIndex to SHORTCARD
 * 
 * Revision 1.1  89/05/22  10:45:34  grosch
 * added procedure IntToString
 * 
 * Revision 1.0  88/10/04  11:47:20  grosch
 * Initial revision
 * 
 *)

(* Ich, Doktor Josef Grosch, Informatiker, Sept. 1987 *)

DEFINITION MODULE Strings;

FROM IO IMPORT tFile;

CONST	cMaxStrLength	= 255;

TYPE	tStringIndex	= SHORTCARD [0 .. cMaxStrLength];

TYPE	tString		= RECORD
		     	     Chars  : ARRAY tStringIndex OF CHAR;
		     	     Length : tStringIndex;
		  	  END;

PROCEDURE Assign	(VAR s1, s2: tString);

			(* Assigns the string 's2' to the string 's1'.	*)

PROCEDURE AssignEmpty	(VAR s: tString);

			(* Returns an empty string 's'.			*)

PROCEDURE Concatenate	(VAR s1, s2: tString);

			(* Returns in parameter 's1' the concatenation	*)
			(* of the strings 's1' and 's2'.		*)

PROCEDURE Append	(VAR s: tString; c: CHAR);

			(* The character 'c' is concatenated at the end	*)
			(* of the string 's'.				*)

PROCEDURE Length	(VAR s: tString)			: CARDINAL;

			(* Returns the length of the string 's'.	*)

PROCEDURE IsEqual	(VAR s1, s2: tString)			: BOOLEAN;

			(* Returns TRUE if the strings 's1' and 's2'	*)
			(* are equal.					*)

PROCEDURE IsInOrder	(VAR s1, s2: tString)			: BOOLEAN;

			(* Returns TRUE if the string 's1' is lexico-	*)
			(* graphically less or equal to the string 's2'.*)

PROCEDURE Exchange	(VAR s1, s2: tString);

			(* Exchanges the strings 's1' and 's2'.		*)

PROCEDURE SubString	(VAR s1: tString; from, to: tStringIndex; VAR s2: tString);

			(* Returns in 's2' the substring from 's1' com-	*)
			(* prising the characters between 'from' and 'to'. *)
			(* PRE	1 <= from <= Length (s1)		*)
			(* PRE	1 <=  to  <= Length (s1)		*)

PROCEDURE Char		(VAR s: tString; i: tStringIndex)	: CHAR;

			(* Returns the 'i'-th character of the string 's'. *)
			(* The characters are counted from 1 to Length (s). *)
			(* PRE	1 <= index <= Length (s)		*)

PROCEDURE ArrayToString	(a: ARRAY OF CHAR; VAR s: tString);

			(* An array 'a' of characters representing a	*)
			(* MODULA string is converted to a string 's'	*)
			(* of type tString.				*)

PROCEDURE StringToArray	(VAR s: tString; VAR a: ARRAY OF CHAR);

			(* A string 's' of type tString is converted to *)
			(* an array 'a' of characters representing a	*)
			(* MODULA string.				*)

PROCEDURE StringToInt	(VAR s: tString)			: INTEGER;

			(* Returns the integer value represented by 's'. *)

PROCEDURE StringToNumber(VAR s: tString; Base: CARDINAL)	: CARDINAL;

			(* Returns the integer value represented by 's'	*)
			(* to the base 'Base'.				*)

PROCEDURE StringToReal	(VAR s: tString)			: REAL;

			(* Returns the real value represented by 's'.	*)

PROCEDURE IntToString	(n: INTEGER; VAR s: tString);

			(* Returns in 's' the string representation of 'n'. *)

PROCEDURE ReadS		(f: tFile; VAR s: tString; FieldWidth: tStringIndex);

			(* Read 'FieldWidth' characters as string 's' 	*)
			(* from file 'f'.				*)

PROCEDURE ReadL		(f: tFile; VAR s: tString);

			(* Read rest of line as string 's' from file	*)
			(* 'f'.	Skip to next line.			*)

PROCEDURE WriteS	(f: tFile; VAR s: tString);

			(* Write string 's' to file 'f'.		*)

PROCEDURE WriteL	(f: tFile; VAR s: tString);

			(* Write string 's' as complete line.		*)

END Strings.
(* $Id: System.md,v 1.8 1992/09/24 13:06:53 grosch rel $ *)

(* $Log: System.md,v $
 * Revision 1.8  1992/09/24  13:06:53  grosch
 * adaption to MS-DOS
 *
 * Revision 1.7  1992/02/04  08:38:39  grosch
 * correction of new system interface
 *
 * Revision 1.6  1992/01/30  13:23:29  grosch
 * redesign of interface to operating system
 *
 * Revision 1.5  1992/01/28  16:59:23  grosch
 * revision of the Makefile
 *
 * Revision 1.4  1991/11/21  14:35:51  grosch
 * new version of RCS on SPARC
 *
 * Revision 1.3  91/03/20  09:29:48  grosch
 * added malloc as alternative to sbrk
 * 
 * Revision 1.2  89/08/09  12:00:48  grosch
 * added return value to svc-call system
 * 
 * Revision 1.1  89/03/02  17:32:24  grosch
 * added system call named 'system'
 * 
 * Revision 1.0  88/10/04  11:47:33  grosch
 * Initial revision
 * 
 *)

(* Ich, Doktor Josef Grosch, Informatiker, Jan. 1992 *)

FOREIGN MODULE System;			(* interface for machine dependencies	*)

FROM SYSTEM	IMPORT ADDRESS;

CONST
   cMaxFile	= 32;
   StdInput	= 0;
   StdOutput	= 1;
   StdError	= 2;

TYPE tFile	= INTEGER [-1 .. cMaxFile];

			(* binary IO		*)

PROCEDURE OpenInput	(VAR FileName: ARRAY OF CHAR): tFile;
PROCEDURE OpenOutput	(VAR FileName: ARRAY OF CHAR): tFile;
PROCEDURE Read		(File: tFile; Buffer: ADDRESS; Size: INTEGER): INTEGER;
PROCEDURE Write		(File: tFile; Buffer: ADDRESS; Size: INTEGER): INTEGER;
PROCEDURE Close		(File: tFile);
PROCEDURE IsCharacterSpecial (File: tFile): BOOLEAN;

			(* calls other than IO	*)

PROCEDURE SysAlloc	(ByteCount: LONGINT): ADDRESS;
PROCEDURE Time		(): LONGINT;
PROCEDURE GetArgCount	(): CARDINAL;
PROCEDURE GetArgument	(ArgNum: INTEGER; VAR Argument: ARRAY OF CHAR);
PROCEDURE PutArgs	(Argc: INTEGER; Argv: ADDRESS);
PROCEDURE ErrNum	(): INTEGER;
PROCEDURE System	(VAR String: ARRAY OF CHAR): INTEGER;
PROCEDURE Exit		(Status: INTEGER);

END System.
(* $Id: Texts.md,v 1.2 1992/08/07 14:43:04 grosch rel $ *)

(* $Log: Texts.md,v $
 * Revision 1.2  1992/08/07  14:43:04  grosch
 * added procedure IsEmpty
 *
 * Revision 1.1  1991/11/21  14:33:17  grosch
 * new version of RCS on SPARC
 *
 * Revision 1.0  88/10/04  11:47:36  grosch
 * Initial revision
 * 
 *)

(* Ich, Doktor Josef Grosch, Informatiker, 31.8.1988 *)

DEFINITION MODULE Texts;

FROM IO		IMPORT tFile	;
FROM Lists	IMPORT tList	;
FROM Strings	IMPORT tString	;

TYPE tText	= tList;

PROCEDURE MakeText	(VAR Text: tText);
			(* Create an empty text.			*)

PROCEDURE Append	(VAR Text: tText; VAR String: tString);
			(* Add a line at the beginning of text 'Text'.	*)

PROCEDURE Insert	(VAR Text: tText; VAR String: tString);
			(* Add a line at the end of the text 'Text'.	*)

PROCEDURE IsEmpty	(VAR Text: tText): BOOLEAN;
			(* Test whether a text 'Text' is empty.		*)

PROCEDURE WriteText	(f: tFile; Text: tText);
			(* Print the text 'Text' on the file 'f'.	*)

END Texts.
(* $Id: Times.md,v 1.1 1991/11/21 14:33:17 grosch rel $ *)

(* $Log: Times.md,v $
 * Revision 1.1  1991/11/21  14:33:17  grosch
 * new version of RCS on SPARC
 *
 * Revision 1.0  88/10/04  11:47:38  grosch
 * Initial revision
 * 
 *)

(* Ich, Doktor Josef Grosch, Informatiker, Sept. 1987 *)

DEFINITION MODULE Times;

PROCEDURE CpuTime	(): LONGINT;
PROCEDURE StepTime	(): LONGINT;
PROCEDURE WriteStepTime	(Text: ARRAY OF CHAR);

END Times.
